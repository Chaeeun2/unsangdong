{"ast":null,"code":"import { Geometry } from './p5.Geometry.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { a as request } from '../rendering-CvUVN-Vb.js';\nimport '../constants-BRcElHU3.js';\nimport './p5.DataArray.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\n\n/**\n * @module Shape\n * @submodule 3D Models\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\nasync function fileExists(url) {\n  try {\n    const response = await fetch(url, {\n      method: 'HEAD'\n    });\n    return response.ok;\n  } catch (error) {\n    return false;\n  }\n}\nfunction loading(p5, fn) {\n  /**\n   * Loads a 3D model to create a\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   *\n   * `loadModel()` can load 3D models from OBJ and STL files. Once the model is\n   * loaded, it can be displayed with the\n   * <a href=\"#/p5/model\">model()</a> function, as in `model(shape)`.\n   *\n   * There are three ways to call `loadModel()` with optional parameters to help\n   * process the model.\n   *\n   * The first parameter, `path`, is a `String` with the path to the file. Paths\n   * to local files should be relative, as in `loadModel('assets/model.obj')`.\n   * URLs such as `'https://example.com/model.obj'` may be blocked due to browser\n   * security. The `path` parameter can also be defined as a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n   * object for more advanced usage.\n   * Note: When loading a `.obj` file that references materials stored in\n   * `.mtl` files, p5.js will attempt to load and apply those materials.\n   * To ensure that the `.obj` file reads the `.mtl` file correctly include the\n   * `.mtl` file alongside it.\n   *\n   * The first way to call `loadModel()` has three optional parameters after the\n   * file path. The first optional parameter, `successCallback`, is a function\n   * to call once the model loads. For example,\n   * `loadModel('assets/model.obj', handleModel)` will call the `handleModel()`\n   * function once the model loads. The second optional parameter,\n   * `failureCallback`, is a function to call if the model fails to load. For\n   * example, `loadModel('assets/model.obj', handleModel, handleFailure)` will\n   * call the `handleFailure()` function if an error occurs while loading. The\n   * third optional parameter, `fileType`, is the model’s file extension as a\n   * string. For example,\n   * `loadModel('assets/model', handleModel, handleFailure, '.obj')` will try to\n   * load the file model as a `.obj` file.\n   *\n   * The second way to call `loadModel()` has four optional parameters after the\n   * file path. The first optional parameter is a `Boolean` value. If `true` is\n   * passed, as in `loadModel('assets/model.obj', true)`, then the model will be\n   * resized to ensure it fits the canvas. The next three parameters are\n   * `successCallback`, `failureCallback`, and `fileType` as described above.\n   *\n   * The third way to call `loadModel()` has one optional parameter after the\n   * file path. The optional parameter, `options`, is an `Object` with options,\n   * as in `loadModel('assets/model.obj', options)`. The `options` object can\n   * have the following properties:\n   *\n   * ```js\n   * let options = {\n   *   // Enables standardized size scaling during loading if set to true.\n   *   normalize: true,\n   *\n   *   // Function to call once the model loads.\n   *   successCallback: handleModel,\n   *\n   *   // Function to call if an error occurs while loading.\n   *   failureCallback: handleError,\n   *\n   *   // Model's file extension.\n   *   fileType: '.stl',\n   *\n   *   // Flips the U texture coordinates of the model.\n   *   flipU: false,\n   *\n   *   // Flips the V texture coordinates of the model.\n   *   flipV: false\n   * };\n   *\n   * // Pass the options object to loadModel().\n   * loadModel('assets/model.obj', options);\n   * ```\n   *\n   * This function returns a `Promise` and should be used in an `async` setup with\n   * `await`. See the examples for the usage syntax.\n   *\n   * Note: There’s no support for colored STL files. STL files with color will\n   * be rendered without color.\n   *\n   * @method loadModel\n   * @param  {String|Request} path      path of the model to be loaded.\n   * @param  {String} [fileType]          model’s file extension. Either `'.obj'` or `'.stl'`.\n   * @param  {Boolean} normalize        if `true`, scale the model to fit the canvas.\n   * @param  {function(p5.Geometry)} [successCallback] function to call once the model is loaded. Will be passed\n   *                                                   the <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   * @param  {function(Event)} [failureCallback] function to call if the model fails to load. Will be passed an `Error` event object.\n   * @return {Promise<p5.Geometry>} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * // Normalize the geometry's size to fit the canvas.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj', true);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and log the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div class='notest'>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', '.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   * let options = {\n   *   fileType: '.obj',\n   *   normalize: true,\n   *   successCallback: handleModel,\n   *   failureCallback: handleError\n   * };\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', options);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {Object} [options] loading options.\n   * @param  {String} [options.fileType]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {Boolean} [options.normalize]\n   * @param  {Boolean} [options.flipU]\n   * @param  {Boolean} [options.flipV]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  fn.loadModel = async function (path, fileType, normalize, successCallback, failureCallback) {\n    // p5._validateParameters('loadModel', arguments);\n\n    let flipU = false;\n    let flipV = false;\n    if (typeof fileType === 'object') {\n      // Passing in options object\n      normalize = fileType.normalize || false;\n      successCallback = fileType.successCallback;\n      failureCallback = fileType.failureCallback;\n      fileType = fileType.fileType || fileType;\n      flipU = fileType.flipU || false;\n      flipV = fileType.flipV || false;\n    } else {\n      // Passing in individual parameters\n      if (typeof arguments[arguments.length - 1] === 'function') {\n        if (typeof arguments[arguments.length - 2] === 'function') {\n          successCallback = arguments[arguments.length - 2];\n          failureCallback = arguments[arguments.length - 1];\n        } else {\n          successCallback = arguments[arguments.length - 1];\n        }\n      }\n      if (typeof fileType === 'string') {\n        if (typeof normalize !== 'boolean') normalize = false;\n      } else if (typeof fileType === 'boolean') {\n        normalize = fileType;\n        fileType = path.slice(-4);\n      } else {\n        fileType = path.slice(-4);\n        normalize = false;\n      }\n    }\n    if (fileType.toLowerCase() !== '.obj' && fileType.toLowerCase() !== '.stl') {\n      fileType = '.obj';\n    }\n    const model = new Geometry(undefined, undefined, undefined, this._renderer);\n    model.gid = `${path}|${normalize}`;\n    async function getMaterials(lines) {\n      const parsedMaterialPromises = [];\n      for (let line of lines) {\n        const mtllibMatch = line.match(/^mtllib (.+)/);\n        if (mtllibMatch) {\n          // Object has material\n          let mtlPath = '';\n          const mtlFilename = mtllibMatch[1];\n          const objPathParts = path.split('/');\n          if (objPathParts.length > 1) {\n            objPathParts.pop();\n            const objFolderPath = objPathParts.join('/');\n            mtlPath = objFolderPath + '/' + mtlFilename;\n          } else {\n            mtlPath = mtlFilename;\n          }\n          parsedMaterialPromises.push(fileExists(mtlPath).then(exists => {\n            if (exists) {\n              return parseMtl(mtlPath);\n            } else {\n              console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);\n              return {};\n            }\n          }).catch(error => {\n            console.warn(`Error loading MTL file: ${mtlPath}`, error);\n            return {};\n          }));\n        }\n      }\n      try {\n        const parsedMaterials = await Promise.all(parsedMaterialPromises);\n        const materials = Object.assign({}, ...parsedMaterials);\n        return materials;\n      } catch (error) {\n        return {};\n      }\n    }\n    try {\n      if (fileType.match(/\\.stl$/i)) {\n        const {\n          data\n        } = await request(path, 'arrayBuffer');\n        parseSTL(model, data);\n        if (normalize) {\n          model.normalize();\n        }\n        if (flipU) {\n          model.flipU();\n        }\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n      } else if (fileType.match(/\\.obj$/i)) {\n        const {\n          data\n        } = await request(path, 'text');\n        const lines = data.split('\\n');\n        const parsedMaterials = await getMaterials(lines);\n        parseObj(model, lines, parsedMaterials);\n        if (normalize) {\n          model.normalize();\n        }\n        if (flipU) {\n          model.flipU();\n        }\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n      }\n    } catch (err) {\n      p5._friendlyFileLoadError(3, path);\n      if (failureCallback) {\n        return failureCallback(err);\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  async function parseMtl(mtlPath) {\n    let currentMaterial = null;\n    let materials = {};\n    const {\n      data\n    } = await request(mtlPath, \"text\");\n    const lines = data.split('\\n');\n    for (let line = 0; line < lines.length; ++line) {\n      const tokens = lines[line].trim().split(/\\s+/);\n      if (tokens[0] === 'newmtl') {\n        const materialName = tokens[1];\n        currentMaterial = materialName;\n        materials[currentMaterial] = {};\n      } else if (tokens[0] === 'Kd') {\n        //Diffuse color\n        materials[currentMaterial].diffuseColor = [parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])];\n      } else if (tokens[0] === 'Ka') {\n        //Ambient Color\n        materials[currentMaterial].ambientColor = [parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])];\n      } else if (tokens[0] === 'Ks') {\n        //Specular color\n        materials[currentMaterial].specularColor = [parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3])];\n      } else if (tokens[0] === 'map_Kd') {\n        //Texture path\n        materials[currentMaterial].texturePath = tokens[1];\n      }\n    }\n    return materials;\n  }\n\n  /**\n   * @private\n   * Parse OBJ lines into model. For reference, this is what a simple model of a\n   * square might look like:\n   *\n   * v -0.5 -0.5 0.5\n   * v -0.5 -0.5 -0.5\n   * v -0.5 0.5 -0.5\n   * v -0.5 0.5 0.5\n   *\n   * f 4 3 2 1\n   */\n  function parseObj(model, lines, materials = {}) {\n    // OBJ allows a face to specify an index for a vertex (in the above example),\n    // but it also allows you to specify a custom combination of vertex, UV\n    // coordinate, and vertex normal. So, \"3/4/3\" would mean, \"use vertex 3 with\n    // UV coordinate 4 and vertex normal 3\". In WebGL, every vertex with different\n    // parameters must be a different vertex, so loadedVerts is used to\n    // temporarily store the parsed vertices, normals, etc., and indexedVerts is\n    // used to map a specific combination (keyed on, for example, the string\n    // \"3/4/3\"), to the actual index of the newly created vertex in the final\n    // object.\n    const loadedVerts = {\n      v: [],\n      vt: [],\n      vn: []\n    };\n\n    // Map from source index → Map of material → destination index\n    const usedVerts = {}; // Track colored vertices\n    let currentMaterial = null;\n    let hasColoredVertices = false;\n    let hasColorlessVertices = false;\n    for (let line = 0; line < lines.length; ++line) {\n      // Each line is a separate object (vertex, face, vertex normal, etc)\n      // For each line, split it into tokens on whitespace. The first token\n      // describes the type.\n      const tokens = lines[line].trim().split(/\\b\\s+/);\n      if (tokens.length > 0) {\n        if (tokens[0] === 'usemtl') {\n          // Switch to a new material\n          currentMaterial = tokens[1];\n        } else if (tokens[0] === 'v' || tokens[0] === 'vn') {\n          // Check if this line describes a vertex or vertex normal.\n          // It will have three numeric parameters.\n          const vertex = new Vector(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n          loadedVerts[tokens[0]].push(vertex);\n        } else if (tokens[0] === 'vt') {\n          // Check if this line describes a texture coordinate.\n          // It will have two numeric parameters U and V (W is omitted).\n          // Because of WebGL texture coordinates rendering behaviour, the V\n          // coordinate is inversed.\n          const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];\n          loadedVerts[tokens[0]].push(texVertex);\n        } else if (tokens[0] === 'f') {\n          // Check if this line describes a face.\n          // OBJ faces can have more than three points. Triangulate points.\n          for (let tri = 3; tri < tokens.length; ++tri) {\n            const face = [];\n            const vertexTokens = [1, tri - 1, tri];\n            for (let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd) {\n              // Now, convert the given token into an index\n              const vertString = tokens[vertexTokens[tokenInd]];\n              let vertParts = vertString.split('/');\n\n              // TODO: Faces can technically use negative numbers to refer to the\n              // previous nth vertex. I haven't seen this used in practice, but\n              // it might be good to implement this in the future.\n\n              for (let i = 0; i < vertParts.length; i++) {\n                vertParts[i] = parseInt(vertParts[i]) - 1;\n              }\n              if (!usedVerts[vertString]) {\n                usedVerts[vertString] = {};\n              }\n              if (usedVerts[vertString][currentMaterial] === undefined) {\n                const vertIndex = model.vertices.length;\n                model.vertices.push(loadedVerts.v[vertParts[0]].copy());\n                model.uvs.push(loadedVerts.vt[vertParts[1]] ? loadedVerts.vt[vertParts[1]].slice() : [0, 0]);\n                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ? loadedVerts.vn[vertParts[2]].copy() : new Vector());\n                usedVerts[vertString][currentMaterial] = vertIndex;\n                face.push(vertIndex);\n                if (currentMaterial && materials[currentMaterial] && materials[currentMaterial].diffuseColor) {\n                  hasColoredVertices = true;\n                  const materialDiffuseColor = materials[currentMaterial].diffuseColor;\n                  model.vertexColors.push(materialDiffuseColor[0]);\n                  model.vertexColors.push(materialDiffuseColor[1]);\n                  model.vertexColors.push(materialDiffuseColor[2]);\n                  model.vertexColors.push(1);\n                } else {\n                  hasColorlessVertices = true;\n                }\n              } else {\n                face.push(usedVerts[vertString][currentMaterial]);\n              }\n            }\n            if (face[0] !== face[1] && face[0] !== face[2] && face[1] !== face[2]) {\n              model.faces.push(face);\n            }\n          }\n        }\n      }\n    }\n    // If the model doesn't have normals, compute the normals\n    if (model.vertexNormals.length === 0) {\n      model.computeNormals();\n    }\n    if (hasColoredVertices === hasColorlessVertices) {\n      // If both are true or both are false, throw an error because the model is inconsistent\n      throw new Error('Model coloring is inconsistent. Either all vertices should have colors or none should.');\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * STL files can be of two types, ASCII and Binary,\n   *\n   * We need to convert the arrayBuffer to an array of strings,\n   * to parse it as an ASCII file.\n   */\n  function parseSTL(model, buffer) {\n    if (isBinary(buffer)) {\n      parseBinarySTL(model, buffer);\n    } else {\n      const reader = new DataView(buffer);\n      if (!('TextDecoder' in window)) {\n        console.warn('Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)');\n        return model;\n      }\n      const decoder = new TextDecoder('utf-8');\n      const lines = decoder.decode(reader);\n      const lineArray = lines.split('\\n');\n      parseASCIISTL(model, lineArray);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * This function checks if the file is in ASCII format or in Binary format\n   *\n   * It is done by searching keyword `solid` at the start of the file.\n   *\n   * An ASCII STL data must begin with `solid` as the first six bytes.\n   * However, ASCII STLs lacking the SPACE after the `d` are known to be\n   * plentiful. So, check the first 5 bytes for `solid`.\n   *\n   * Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n   * https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n   * Search for `solid` to start anywhere after those prefixes.\n   */\n  function isBinary(data) {\n    const reader = new DataView(data);\n\n    // US-ASCII ordinal values for `s`, `o`, `l`, `i`, `d`\n    const solid = [115, 111, 108, 105, 100];\n    for (let off = 0; off < 5; off++) {\n      // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n      if (matchDataViewAt(solid, reader, off)) return false;\n    }\n\n    // Couldn't find \"solid\" text at the beginning; it is binary STL.\n    return true;\n  }\n\n  /**\n   * @private\n   * This function matches the `query` at the provided `offset`\n   */\n  function matchDataViewAt(query, reader, offset) {\n    // Check if each byte in query matches the corresponding byte from the current offset\n    for (let i = 0, il = query.length; i < il; i++) {\n      if (query[i] !== reader.getUint8(offset + i, false)) return false;\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * This function parses the Binary STL files.\n   * https://en.wikipedia.org/wiki/STL_%28file_format%29#Binary_STL\n   *\n   * Currently there is no support for the colors provided in STL files.\n   */\n  function parseBinarySTL(model, buffer) {\n    const reader = new DataView(buffer);\n\n    // Number of faces is present following the header\n    const faces = reader.getUint32(80, true);\n    let r,\n      g,\n      b,\n      hasColors = false,\n      colors;\n    let defaultR, defaultG, defaultB;\n\n    // Binary files contain 80-byte header, which is generally ignored.\n    for (let index = 0; index < 80 - 10; index++) {\n      // Check for `COLOR=`\n      if (reader.getUint32(index, false) === 0x434f4c4f /*COLO*/ && reader.getUint8(index + 4) === 0x52 /*'R'*/ && reader.getUint8(index + 5) === 0x3d /*'='*/) {\n        hasColors = true;\n        colors = [];\n        defaultR = reader.getUint8(index + 6) / 255;\n        defaultG = reader.getUint8(index + 7) / 255;\n        defaultB = reader.getUint8(index + 8) / 255;\n        // To be used when color support is added\n        // alpha = reader.getUint8(index + 9) / 255;\n      }\n    }\n    const dataOffset = 84;\n    const faceLength = 12 * 4 + 2;\n\n    // Iterate the faces\n    for (let face = 0; face < faces; face++) {\n      const start = dataOffset + face * faceLength;\n      const normalX = reader.getFloat32(start, true);\n      const normalY = reader.getFloat32(start + 4, true);\n      const normalZ = reader.getFloat32(start + 8, true);\n      if (hasColors) {\n        const packedColor = reader.getUint16(start + 48, true);\n        if ((packedColor & 0x8000) === 0) {\n          // facet has its own unique color\n          r = (packedColor & 0x1f) / 31;\n          g = (packedColor >> 5 & 0x1f) / 31;\n          b = (packedColor >> 10 & 0x1f) / 31;\n        } else {\n          r = defaultR;\n          g = defaultG;\n          b = defaultB;\n        }\n      }\n      const newNormal = new Vector(normalX, normalY, normalZ);\n      for (let i = 1; i <= 3; i++) {\n        const vertexstart = start + i * 12;\n        const newVertex = new Vector(reader.getFloat32(vertexstart, true), reader.getFloat32(vertexstart + 4, true), reader.getFloat32(vertexstart + 8, true));\n        model.vertices.push(newVertex);\n        model.vertexNormals.push(newNormal);\n        if (hasColors) {\n          colors.push(r, g, b);\n        }\n      }\n      model.faces.push([3 * face, 3 * face + 1, 3 * face + 2]);\n      model.uvs.push([0, 0], [0, 0], [0, 0]);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * ASCII STL file starts with `solid 'nameOfFile'`\n   * Then contain the normal of the face, starting with `facet normal`\n   * Next contain a keyword indicating the start of face vertex, `outer loop`\n   * Next comes the three vertex, starting with `vertex x y z`\n   * Vertices ends with `endloop`\n   * Face ends with `endfacet`\n   * Next face starts with `facet normal`\n   * The end of the file is indicated by `endsolid`\n   */\n  function parseASCIISTL(model, lines) {\n    let state = '';\n    let curVertexIndex = [];\n    let newNormal, newVertex;\n    for (let iterator = 0; iterator < lines.length; ++iterator) {\n      const line = lines[iterator].trim();\n      const parts = line.split(' ');\n      for (let partsiterator = 0; partsiterator < parts.length; ++partsiterator) {\n        if (parts[partsiterator] === '') {\n          // Ignoring multiple whitespaces\n          parts.splice(partsiterator, 1);\n        }\n      }\n      if (parts.length === 0) {\n        // Remove newline\n        continue;\n      }\n      switch (state) {\n        case '':\n          // First run\n          if (parts[0] !== 'solid') {\n            // Invalid state\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"solid\"`);\n            return;\n          } else {\n            state = 'solid';\n          }\n          break;\n        case 'solid':\n          // First face\n          if (parts[0] !== 'facet' || parts[1] !== 'normal') {\n            // Invalid state\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"facet normal\"`);\n            return;\n          } else {\n            // Push normal for first face\n            newNormal = new Vector(parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          }\n          break;\n        case 'facet normal':\n          // After normal is defined\n          if (parts[0] !== 'outer' || parts[1] !== 'loop') {\n            // Invalid State\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"outer loop\"`);\n            return;\n          } else {\n            // Next should be vertices\n            state = 'vertex';\n          }\n          break;\n        case 'vertex':\n          if (parts[0] === 'vertex') {\n            //Vertex of triangle\n            newVertex = new Vector(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));\n            model.vertices.push(newVertex);\n            model.uvs.push([0, 0]);\n            curVertexIndex.push(model.vertices.indexOf(newVertex));\n          } else if (parts[0] === 'endloop') {\n            // End of vertices\n            model.faces.push(curVertexIndex);\n            curVertexIndex = [];\n            state = 'endloop';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"vertex\" or \"endloop\"`);\n            return;\n          }\n          break;\n        case 'endloop':\n          if (parts[0] !== 'endfacet') {\n            // End of face\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"endfacet\"`);\n            return;\n          } else {\n            state = 'endfacet';\n          }\n          break;\n        case 'endfacet':\n          if (parts[0] === 'endsolid') ;else if (parts[0] === 'facet' && parts[1] === 'normal') {\n            // Next face\n            newNormal = new Vector(parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"endsolid\" or \"facet normal\"`);\n            return;\n          }\n          break;\n        default:\n          console.error(`Invalid state \"${state}\"`);\n          break;\n      }\n    }\n    return model;\n  }\n\n  /**\n   * Draws a <a href=\"#/p5.Geometry\">p5.Geometry</a> object to the canvas.\n   *\n   * The parameter, `model`, is the\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object to draw.\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> objects can be built with\n   * <a href=\"#/p5/buildGeometry\">buildGeometry()</a>, or\n   * <a href=\"#/p5/beginGeometry\">beginGeometry()</a> and\n   * <a href=\"#/p5/endGeometry\">endGeometry()</a>. They can also be loaded from\n   * a file with <a href=\"#/p5/loadGeometry\">loadGeometry()</a>.\n   *\n   * Note: `model()` can only be used in WebGL mode.\n   *\n   * @method model\n   * @param  {p5.Geometry} model 3D shape to be drawn.\n   *\n   * @param {Number} [count=1] number of instances to draw.\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createShape);\n   *\n   *   describe('A white cone drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   * }\n   *\n   * // Create p5.Geometry object from a single cone.\n   * function createShape() {\n   *   cone();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createArrow);\n   *\n   *   describe('Two white arrows drawn on a gray background. The arrow on the right rotates slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the arrows.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   *\n   *   // Translate and rotate the coordinate system.\n   *   translate(30, 0, 0);\n   *   rotateZ(frameCount * 0.01);\n   *\n   *   // Draw the p5.Geometry object again.\n   *   model(shape);\n   * }\n   *\n   * function createArrow() {\n   *   // Add shapes to the p5.Geometry object.\n   *   push();\n   *   rotateX(PI);\n   *   cone(10);\n   *   translate(0, -10, 0);\n   *   cylinder(3, 20);\n   *   pop();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * async function setup() {\n   *   shape = await loadModel('assets/octahedron.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white octahedron drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.model = function (model, count = 1) {\n    this._assert3d('model');\n    // p5._validateParameters('model', arguments);\n    this._renderer.model(model, count);\n  };\n\n  /**\n   * Load a 3d model from an OBJ or STL string.\n   *\n   * OBJ and STL files lack a built-in sense of scale, causing models exported from different programs to vary in size.\n   * If your model doesn't display correctly, consider using `loadModel()` with `normalize` set to `true` to standardize its size.\n   * Further adjustments can be made using the `scale()` function.\n   *\n   * Also, the support for colored STL files is not present. STL files with color will be\n   * rendered without color properties.\n   *\n   * * Options can include:\n   * - `modelString`: Specifies the plain text string of either an stl or obj file to be loaded.\n   * - `fileType`: Defines the file extension of the model.\n   * - `normalize`: Enables standardized size scaling during loading if set to true.\n   * - `successCallback`: Callback for post-loading actions with the 3D model object.\n   * - `failureCallback`: Handles errors if model loading fails, receiving an event error.\n   * - `flipU`: Flips the U texture coordinates of the model.\n   * - `flipV`: Flips the V texture coordinates of the model.\n   *\n   *\n   * @method createModel\n   * @param  {String} modelString         String of the object to be loaded\n   * @param  {String} [fileType]          The file extension of the model\n   *                                      (<code>.stl</code>, <code>.obj</code>).\n   * @param  {Boolean} normalize        If true, scale the model to a\n   *                                      standardized size when loading\n   * @param  {function(p5.Geometry)} [successCallback] Function to be called\n   *                                     once the model is loaded. Will be passed\n   *                                     the 3D model object.\n   * @param  {function(Event)} [failureCallback] called with event error if\n   *                                         the model fails to load.\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * const octahedron_model = `\n   * v 0.000000E+00 0.000000E+00 40.0000\n   * v 22.5000 22.5000 0.000000E+00\n   * v 22.5000 -22.5000 0.000000E+00\n   * v -22.5000 -22.5000 0.000000E+00\n   * v -22.5000 22.5000 0.000000E+00\n   * v 0.000000E+00 0.000000E+00 -40.0000\n   * f     1 2 3\n   * f     1 3 4\n   * f     1 4 5\n   * f     1 5 2\n   * f     6 5 4\n   * f     6 4 3\n   * f     6 3 2\n   * f     6 2 5\n   * `;\n   * //draw a spinning octahedron\n   * let octahedron;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *   octahedron = createModel(octahedron_model, '.obj');\n   *   describe('Vertically rotating 3D octahedron.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   rotateX(frameCount * 0.01);\n   *   rotateY(frameCount * 0.01);\n   *   model(octahedron);\n   *}\n   * </code>\n   * </div>\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {Object} [options]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {boolean} [options.normalize]\n   * @param  {boolean} [options.flipU]\n   * @param  {boolean} [options.flipV]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  let modelCounter = 0;\n  fn.createModel = function (modelString, fileType = ' ', options) {\n    // p5._validateParameters('createModel', arguments);\n    let normalize = false;\n    let successCallback;\n    let failureCallback;\n    let flipU = false;\n    let flipV = false;\n    if (options && typeof options === 'object') {\n      normalize = options.normalize || false;\n      successCallback = options.successCallback;\n      failureCallback = options.failureCallback;\n      flipU = options.flipU || false;\n      flipV = options.flipV || false;\n    } else if (typeof options === 'boolean') {\n      normalize = options;\n      successCallback = arguments[3];\n      failureCallback = arguments[4];\n    } else {\n      successCallback = typeof arguments[2] === 'function' ? arguments[2] : undefined;\n      failureCallback = arguments[3];\n    }\n    const model = new p5.Geometry();\n    model.gid = `${fileType}|${normalize}|${modelCounter++}`;\n    if (fileType.match(/\\.stl$/i)) {\n      try {\n        let uint8array = new TextEncoder().encode(modelString);\n        let arrayBuffer = uint8array.buffer;\n        parseSTL(model, arrayBuffer);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else if (fileType.match(/\\.obj$/i)) {\n      try {\n        const lines = modelString.split('\\n');\n        parseObj(model, lines);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else {\n      p5._friendlyFileLoadError(3, modelString);\n      if (failureCallback) {\n        failureCallback();\n      } else {\n        p5._friendlyError('Sorry, the file type is invalid. Only OBJ and STL files are supported.');\n      }\n    }\n    if (normalize) {\n      model.normalize();\n    }\n    if (flipU) {\n      model.flipU();\n    }\n    if (flipV) {\n      model.flipV();\n    }\n    model._makeTriangleEdges();\n    if (typeof successCallback === 'function') {\n      successCallback(model);\n    }\n    return model;\n  };\n}\nif (typeof p5 !== 'undefined') {\n  loading(p5, p5.prototype);\n}\nexport { loading as default };","map":{"version":3,"names":["Geometry","Vector","a","request","fileExists","url","response","fetch","method","ok","error","loading","p5","fn","loadModel","path","fileType","normalize","successCallback","failureCallback","flipU","flipV","arguments","length","slice","toLowerCase","model","undefined","_renderer","gid","getMaterials","lines","parsedMaterialPromises","line","mtllibMatch","match","mtlPath","mtlFilename","objPathParts","split","pop","objFolderPath","join","push","then","exists","parseMtl","console","warn","catch","parsedMaterials","Promise","all","materials","Object","assign","data","parseSTL","_makeTriangleEdges","parseObj","err","_friendlyFileLoadError","currentMaterial","tokens","trim","materialName","diffuseColor","parseFloat","ambientColor","specularColor","texturePath","loadedVerts","v","vt","vn","usedVerts","hasColoredVertices","hasColorlessVertices","vertex","texVertex","tri","face","vertexTokens","tokenInd","vertString","vertParts","i","parseInt","vertIndex","vertices","copy","uvs","vertexNormals","materialDiffuseColor","vertexColors","faces","computeNormals","Error","buffer","isBinary","parseBinarySTL","reader","DataView","window","decoder","TextDecoder","decode","lineArray","parseASCIISTL","solid","off","matchDataViewAt","query","offset","il","getUint8","getUint32","r","g","b","hasColors","colors","defaultR","defaultG","defaultB","index","dataOffset","faceLength","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","newNormal","vertexstart","newVertex","state","curVertexIndex","iterator","parts","partsiterator","splice","indexOf","count","_assert3d","modelCounter","createModel","modelString","options","uint8array","TextEncoder","encode","arrayBuffer","_friendlyError","message","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/webgl/loading.js"],"sourcesContent":["import { Geometry } from './p5.Geometry.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { a as request } from '../rendering-CvUVN-Vb.js';\nimport '../constants-BRcElHU3.js';\nimport './p5.DataArray.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\n\n/**\n * @module Shape\n * @submodule 3D Models\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\n\nasync function fileExists(url) {\n  try {\n    const response = await fetch(url, { method: 'HEAD' });\n    return response.ok;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction loading(p5, fn){\n  /**\n   * Loads a 3D model to create a\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   *\n   * `loadModel()` can load 3D models from OBJ and STL files. Once the model is\n   * loaded, it can be displayed with the\n   * <a href=\"#/p5/model\">model()</a> function, as in `model(shape)`.\n   *\n   * There are three ways to call `loadModel()` with optional parameters to help\n   * process the model.\n   *\n   * The first parameter, `path`, is a `String` with the path to the file. Paths\n   * to local files should be relative, as in `loadModel('assets/model.obj')`.\n   * URLs such as `'https://example.com/model.obj'` may be blocked due to browser\n   * security. The `path` parameter can also be defined as a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n   * object for more advanced usage.\n   * Note: When loading a `.obj` file that references materials stored in\n   * `.mtl` files, p5.js will attempt to load and apply those materials.\n   * To ensure that the `.obj` file reads the `.mtl` file correctly include the\n   * `.mtl` file alongside it.\n   *\n   * The first way to call `loadModel()` has three optional parameters after the\n   * file path. The first optional parameter, `successCallback`, is a function\n   * to call once the model loads. For example,\n   * `loadModel('assets/model.obj', handleModel)` will call the `handleModel()`\n   * function once the model loads. The second optional parameter,\n   * `failureCallback`, is a function to call if the model fails to load. For\n   * example, `loadModel('assets/model.obj', handleModel, handleFailure)` will\n   * call the `handleFailure()` function if an error occurs while loading. The\n   * third optional parameter, `fileType`, is the model’s file extension as a\n   * string. For example,\n   * `loadModel('assets/model', handleModel, handleFailure, '.obj')` will try to\n   * load the file model as a `.obj` file.\n   *\n   * The second way to call `loadModel()` has four optional parameters after the\n   * file path. The first optional parameter is a `Boolean` value. If `true` is\n   * passed, as in `loadModel('assets/model.obj', true)`, then the model will be\n   * resized to ensure it fits the canvas. The next three parameters are\n   * `successCallback`, `failureCallback`, and `fileType` as described above.\n   *\n   * The third way to call `loadModel()` has one optional parameter after the\n   * file path. The optional parameter, `options`, is an `Object` with options,\n   * as in `loadModel('assets/model.obj', options)`. The `options` object can\n   * have the following properties:\n   *\n   * ```js\n   * let options = {\n   *   // Enables standardized size scaling during loading if set to true.\n   *   normalize: true,\n   *\n   *   // Function to call once the model loads.\n   *   successCallback: handleModel,\n   *\n   *   // Function to call if an error occurs while loading.\n   *   failureCallback: handleError,\n   *\n   *   // Model's file extension.\n   *   fileType: '.stl',\n   *\n   *   // Flips the U texture coordinates of the model.\n   *   flipU: false,\n   *\n   *   // Flips the V texture coordinates of the model.\n   *   flipV: false\n   * };\n   *\n   * // Pass the options object to loadModel().\n   * loadModel('assets/model.obj', options);\n   * ```\n   *\n   * This function returns a `Promise` and should be used in an `async` setup with\n   * `await`. See the examples for the usage syntax.\n   *\n   * Note: There’s no support for colored STL files. STL files with color will\n   * be rendered without color.\n   *\n   * @method loadModel\n   * @param  {String|Request} path      path of the model to be loaded.\n   * @param  {String} [fileType]          model’s file extension. Either `'.obj'` or `'.stl'`.\n   * @param  {Boolean} normalize        if `true`, scale the model to fit the canvas.\n   * @param  {function(p5.Geometry)} [successCallback] function to call once the model is loaded. Will be passed\n   *                                                   the <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   * @param  {function(Event)} [failureCallback] function to call if the model fails to load. Will be passed an `Error` event object.\n   * @return {Promise<p5.Geometry>} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * // Normalize the geometry's size to fit the canvas.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj', true);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and log the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div class='notest'>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', '.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   * let options = {\n   *   fileType: '.obj',\n   *   normalize: true,\n   *   successCallback: handleModel,\n   *   failureCallback: handleError\n   * };\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', options);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {Object} [options] loading options.\n   * @param  {String} [options.fileType]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {Boolean} [options.normalize]\n   * @param  {Boolean} [options.flipU]\n   * @param  {Boolean} [options.flipV]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  fn.loadModel = async function (path, fileType, normalize, successCallback, failureCallback) {\n    // p5._validateParameters('loadModel', arguments);\n\n    let flipU = false;\n    let flipV = false;\n\n    if (typeof fileType === 'object') {\n      // Passing in options object\n      normalize = fileType.normalize || false;\n      successCallback = fileType.successCallback;\n      failureCallback = fileType.failureCallback;\n      fileType = fileType.fileType || fileType;\n      flipU = fileType.flipU || false;\n      flipV = fileType.flipV || false;\n\n    } else {\n      // Passing in individual parameters\n      if(typeof arguments[arguments.length-1] === 'function'){\n        if(typeof arguments[arguments.length-2] === 'function'){\n          successCallback = arguments[arguments.length-2];\n          failureCallback = arguments[arguments.length-1];\n        }else {\n          successCallback = arguments[arguments.length-1];\n        }\n      }\n\n      if (typeof fileType === 'string') {\n        if(typeof normalize !== 'boolean') normalize = false;\n\n      } else if (typeof fileType === 'boolean') {\n        normalize = fileType;\n        fileType = path.slice(-4);\n\n      } else {\n        fileType = path.slice(-4);\n        normalize = false;\n      }\n    }\n\n    if (fileType.toLowerCase() !== '.obj' && fileType.toLowerCase() !== '.stl') {\n      fileType = '.obj';\n    }\n\n    const model = new Geometry(undefined, undefined, undefined, this._renderer);\n    model.gid = `${path}|${normalize}`;\n\n    async function getMaterials(lines) {\n      const parsedMaterialPromises = [];\n\n      for (let line of lines) {\n        const mtllibMatch = line.match(/^mtllib (.+)/);\n\n        if (mtllibMatch) {\n          // Object has material\n          let mtlPath = '';\n          const mtlFilename = mtllibMatch[1];\n          const objPathParts = path.split('/');\n          if (objPathParts.length > 1) {\n            objPathParts.pop();\n            const objFolderPath = objPathParts.join('/');\n            mtlPath = objFolderPath + '/' + mtlFilename;\n          } else {\n            mtlPath = mtlFilename;\n          }\n\n          parsedMaterialPromises.push(\n            fileExists(mtlPath).then(exists => {\n              if (exists) {\n                return parseMtl(mtlPath);\n              } else {\n                console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);\n                return {};\n\n              }\n            }).catch(error => {\n              console.warn(`Error loading MTL file: ${mtlPath}`, error);\n              return {};\n            })\n          );\n        }\n      }\n\n      try {\n        const parsedMaterials = await Promise.all(parsedMaterialPromises);\n        const materials = Object.assign({}, ...parsedMaterials);\n        return materials;\n      } catch (error) {\n        return {};\n      }\n    }\n\n    try{\n      if (fileType.match(/\\.stl$/i)) {\n        const { data } = await request(path, 'arrayBuffer');\n        parseSTL(model, data);\n\n        if (normalize) {\n          model.normalize();\n        }\n\n        if (flipU) {\n          model.flipU();\n        }\n\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n\n      } else if (fileType.match(/\\.obj$/i)) {\n        const { data } = await request(path, 'text');\n        const lines = data.split('\\n');\n\n        const parsedMaterials = await getMaterials(lines);\n        parseObj(model, lines, parsedMaterials);\n\n        if (normalize) {\n          model.normalize();\n        }\n        if (flipU) {\n          model.flipU();\n        }\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n      }\n    } catch(err) {\n      p5._friendlyFileLoadError(3, path);\n      if(failureCallback) {\n        return failureCallback(err);\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  async function parseMtl(mtlPath) {\n    let currentMaterial = null;\n    let materials = {};\n\n    const { data } = await request(mtlPath, \"text\");\n    const lines = data.split('\\n');\n\n    for (let line = 0; line < lines.length; ++line) {\n      const tokens = lines[line].trim().split(/\\s+/);\n      if (tokens[0] === 'newmtl') {\n        const materialName = tokens[1];\n        currentMaterial = materialName;\n        materials[currentMaterial] = {};\n      } else if (tokens[0] === 'Kd') {\n        //Diffuse color\n        materials[currentMaterial].diffuseColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n      } else if (tokens[0] === 'Ka') {\n        //Ambient Color\n        materials[currentMaterial].ambientColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n      } else if (tokens[0] === 'Ks') {\n        //Specular color\n        materials[currentMaterial].specularColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n\n      } else if (tokens[0] === 'map_Kd') {\n        //Texture path\n        materials[currentMaterial].texturePath = tokens[1];\n      }\n    }\n\n    return materials;\n  }\n\n  /**\n   * @private\n   * Parse OBJ lines into model. For reference, this is what a simple model of a\n   * square might look like:\n   *\n   * v -0.5 -0.5 0.5\n   * v -0.5 -0.5 -0.5\n   * v -0.5 0.5 -0.5\n   * v -0.5 0.5 0.5\n   *\n   * f 4 3 2 1\n   */\n  function parseObj(model, lines, materials = {}) {\n    // OBJ allows a face to specify an index for a vertex (in the above example),\n    // but it also allows you to specify a custom combination of vertex, UV\n    // coordinate, and vertex normal. So, \"3/4/3\" would mean, \"use vertex 3 with\n    // UV coordinate 4 and vertex normal 3\". In WebGL, every vertex with different\n    // parameters must be a different vertex, so loadedVerts is used to\n    // temporarily store the parsed vertices, normals, etc., and indexedVerts is\n    // used to map a specific combination (keyed on, for example, the string\n    // \"3/4/3\"), to the actual index of the newly created vertex in the final\n    // object.\n    const loadedVerts = {\n      v: [],\n      vt: [],\n      vn: []\n    };\n\n\n    // Map from source index → Map of material → destination index\n    const usedVerts = {}; // Track colored vertices\n    let currentMaterial = null;\n    let hasColoredVertices = false;\n    let hasColorlessVertices = false;\n    for (let line = 0; line < lines.length; ++line) {\n      // Each line is a separate object (vertex, face, vertex normal, etc)\n      // For each line, split it into tokens on whitespace. The first token\n      // describes the type.\n      const tokens = lines[line].trim().split(/\\b\\s+/);\n\n      if (tokens.length > 0) {\n        if (tokens[0] === 'usemtl') {\n          // Switch to a new material\n          currentMaterial = tokens[1];\n        } else if (tokens[0] === 'v' || tokens[0] === 'vn') {\n          // Check if this line describes a vertex or vertex normal.\n          // It will have three numeric parameters.\n          const vertex = new Vector(\n            parseFloat(tokens[1]),\n            parseFloat(tokens[2]),\n            parseFloat(tokens[3])\n          );\n          loadedVerts[tokens[0]].push(vertex);\n        } else if (tokens[0] === 'vt') {\n          // Check if this line describes a texture coordinate.\n          // It will have two numeric parameters U and V (W is omitted).\n          // Because of WebGL texture coordinates rendering behaviour, the V\n          // coordinate is inversed.\n          const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];\n          loadedVerts[tokens[0]].push(texVertex);\n        } else if (tokens[0] === 'f') {\n          // Check if this line describes a face.\n          // OBJ faces can have more than three points. Triangulate points.\n          for (let tri = 3; tri < tokens.length; ++tri) {\n            const face = [];\n            const vertexTokens = [1, tri - 1, tri];\n\n            for (let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd) {\n              // Now, convert the given token into an index\n              const vertString = tokens[vertexTokens[tokenInd]];\n              let vertParts = vertString.split('/');\n\n              // TODO: Faces can technically use negative numbers to refer to the\n              // previous nth vertex. I haven't seen this used in practice, but\n              // it might be good to implement this in the future.\n\n              for (let i = 0; i < vertParts.length; i++) {\n                vertParts[i] = parseInt(vertParts[i]) - 1;\n              }\n\n              if (!usedVerts[vertString]) {\n                usedVerts[vertString] = {};\n              }\n\n              if (usedVerts[vertString][currentMaterial] === undefined) {\n                const vertIndex = model.vertices.length;\n                model.vertices.push(loadedVerts.v[vertParts[0]].copy());\n                model.uvs.push(loadedVerts.vt[vertParts[1]] ?\n                  loadedVerts.vt[vertParts[1]].slice() : [0, 0]);\n                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ?\n                  loadedVerts.vn[vertParts[2]].copy() : new Vector());\n\n                usedVerts[vertString][currentMaterial] = vertIndex;\n                face.push(vertIndex);\n                if (currentMaterial\n                  && materials[currentMaterial]\n                  && materials[currentMaterial].diffuseColor) {\n                  hasColoredVertices = true;\n                  const materialDiffuseColor =\n                    materials[currentMaterial].diffuseColor;\n                  model.vertexColors.push(materialDiffuseColor[0]);\n                  model.vertexColors.push(materialDiffuseColor[1]);\n                  model.vertexColors.push(materialDiffuseColor[2]);\n                  model.vertexColors.push(1);\n                } else {\n                  hasColorlessVertices = true;\n                }\n              } else {\n                face.push(usedVerts[vertString][currentMaterial]);\n              }\n            }\n\n            if (\n              face[0] !== face[1] &&\n              face[0] !== face[2] &&\n              face[1] !== face[2]\n            ) {\n              model.faces.push(face);\n            }\n          }\n        }\n      }\n    }\n    // If the model doesn't have normals, compute the normals\n    if (model.vertexNormals.length === 0) {\n      model.computeNormals();\n    }\n    if (hasColoredVertices === hasColorlessVertices) {\n      // If both are true or both are false, throw an error because the model is inconsistent\n      throw new Error('Model coloring is inconsistent. Either all vertices should have colors or none should.');\n    }\n\n    return model;\n  }\n\n  /**\n   * @private\n   * STL files can be of two types, ASCII and Binary,\n   *\n   * We need to convert the arrayBuffer to an array of strings,\n   * to parse it as an ASCII file.\n   */\n  function parseSTL(model, buffer) {\n    if (isBinary(buffer)) {\n      parseBinarySTL(model, buffer);\n    } else {\n      const reader = new DataView(buffer);\n\n      if (!('TextDecoder' in window)) {\n        console.warn(\n          'Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)'\n        );\n        return model;\n      }\n\n      const decoder = new TextDecoder('utf-8');\n      const lines = decoder.decode(reader);\n      const lineArray = lines.split('\\n');\n      parseASCIISTL(model, lineArray);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * This function checks if the file is in ASCII format or in Binary format\n   *\n   * It is done by searching keyword `solid` at the start of the file.\n   *\n   * An ASCII STL data must begin with `solid` as the first six bytes.\n   * However, ASCII STLs lacking the SPACE after the `d` are known to be\n   * plentiful. So, check the first 5 bytes for `solid`.\n   *\n   * Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n   * https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n   * Search for `solid` to start anywhere after those prefixes.\n   */\n  function isBinary(data) {\n    const reader = new DataView(data);\n\n    // US-ASCII ordinal values for `s`, `o`, `l`, `i`, `d`\n    const solid = [115, 111, 108, 105, 100];\n    for (let off = 0; off < 5; off++) {\n      // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n      if (matchDataViewAt(solid, reader, off)) return false;\n    }\n\n    // Couldn't find \"solid\" text at the beginning; it is binary STL.\n    return true;\n  }\n\n  /**\n   * @private\n   * This function matches the `query` at the provided `offset`\n   */\n  function matchDataViewAt(query, reader, offset) {\n    // Check if each byte in query matches the corresponding byte from the current offset\n    for (let i = 0, il = query.length; i < il; i++) {\n      if (query[i] !== reader.getUint8(offset + i, false)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @private\n   * This function parses the Binary STL files.\n   * https://en.wikipedia.org/wiki/STL_%28file_format%29#Binary_STL\n   *\n   * Currently there is no support for the colors provided in STL files.\n   */\n  function parseBinarySTL(model, buffer) {\n    const reader = new DataView(buffer);\n\n    // Number of faces is present following the header\n    const faces = reader.getUint32(80, true);\n    let r,\n      g,\n      b,\n      hasColors = false,\n      colors;\n    let defaultR, defaultG, defaultB;\n\n    // Binary files contain 80-byte header, which is generally ignored.\n    for (let index = 0; index < 80 - 10; index++) {\n      // Check for `COLOR=`\n      if (\n        reader.getUint32(index, false) === 0x434f4c4f /*COLO*/ &&\n        reader.getUint8(index + 4) === 0x52 /*'R'*/ &&\n        reader.getUint8(index + 5) === 0x3d /*'='*/\n      ) {\n        hasColors = true;\n        colors = [];\n\n        defaultR = reader.getUint8(index + 6) / 255;\n        defaultG = reader.getUint8(index + 7) / 255;\n        defaultB = reader.getUint8(index + 8) / 255;\n        // To be used when color support is added\n        // alpha = reader.getUint8(index + 9) / 255;\n      }\n    }\n    const dataOffset = 84;\n    const faceLength = 12 * 4 + 2;\n\n    // Iterate the faces\n    for (let face = 0; face < faces; face++) {\n      const start = dataOffset + face * faceLength;\n      const normalX = reader.getFloat32(start, true);\n      const normalY = reader.getFloat32(start + 4, true);\n      const normalZ = reader.getFloat32(start + 8, true);\n\n      if (hasColors) {\n        const packedColor = reader.getUint16(start + 48, true);\n\n        if ((packedColor & 0x8000) === 0) {\n          // facet has its own unique color\n          r = (packedColor & 0x1f) / 31;\n          g = ((packedColor >> 5) & 0x1f) / 31;\n          b = ((packedColor >> 10) & 0x1f) / 31;\n        } else {\n          r = defaultR;\n          g = defaultG;\n          b = defaultB;\n        }\n      }\n      const newNormal = new Vector(normalX, normalY, normalZ);\n\n      for (let i = 1; i <= 3; i++) {\n        const vertexstart = start + i * 12;\n\n        const newVertex = new Vector(\n          reader.getFloat32(vertexstart, true),\n          reader.getFloat32(vertexstart + 4, true),\n          reader.getFloat32(vertexstart + 8, true)\n        );\n\n        model.vertices.push(newVertex);\n        model.vertexNormals.push(newNormal);\n\n        if (hasColors) {\n          colors.push(r, g, b);\n        }\n      }\n\n      model.faces.push([3 * face, 3 * face + 1, 3 * face + 2]);\n      model.uvs.push([0, 0], [0, 0], [0, 0]);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * ASCII STL file starts with `solid 'nameOfFile'`\n   * Then contain the normal of the face, starting with `facet normal`\n   * Next contain a keyword indicating the start of face vertex, `outer loop`\n   * Next comes the three vertex, starting with `vertex x y z`\n   * Vertices ends with `endloop`\n   * Face ends with `endfacet`\n   * Next face starts with `facet normal`\n   * The end of the file is indicated by `endsolid`\n   */\n  function parseASCIISTL(model, lines) {\n    let state = '';\n    let curVertexIndex = [];\n    let newNormal, newVertex;\n\n    for (let iterator = 0; iterator < lines.length; ++iterator) {\n      const line = lines[iterator].trim();\n      const parts = line.split(' ');\n\n      for (let partsiterator = 0; partsiterator < parts.length; ++partsiterator) {\n        if (parts[partsiterator] === '') {\n          // Ignoring multiple whitespaces\n          parts.splice(partsiterator, 1);\n        }\n      }\n\n      if (parts.length === 0) {\n        // Remove newline\n        continue;\n      }\n\n      switch (state) {\n        case '': // First run\n          if (parts[0] !== 'solid') {\n            // Invalid state\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"solid\"`);\n            return;\n          } else {\n            state = 'solid';\n          }\n          break;\n\n        case 'solid': // First face\n          if (parts[0] !== 'facet' || parts[1] !== 'normal') {\n            // Invalid state\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]}\", should be \"facet normal\"`\n            );\n            return;\n          } else {\n            // Push normal for first face\n            newNormal = new Vector(\n              parseFloat(parts[2]),\n              parseFloat(parts[3]),\n              parseFloat(parts[4])\n            );\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          }\n          break;\n\n        case 'facet normal': // After normal is defined\n          if (parts[0] !== 'outer' || parts[1] !== 'loop') {\n            // Invalid State\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"outer loop\"`);\n            return;\n          } else {\n            // Next should be vertices\n            state = 'vertex';\n          }\n          break;\n\n        case 'vertex':\n          if (parts[0] === 'vertex') {\n            //Vertex of triangle\n            newVertex = new Vector(\n              parseFloat(parts[1]),\n              parseFloat(parts[2]),\n              parseFloat(parts[3])\n            );\n            model.vertices.push(newVertex);\n            model.uvs.push([0, 0]);\n            curVertexIndex.push(model.vertices.indexOf(newVertex));\n          } else if (parts[0] === 'endloop') {\n            // End of vertices\n            model.faces.push(curVertexIndex);\n            curVertexIndex = [];\n            state = 'endloop';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]}\", should be \"vertex\" or \"endloop\"`\n            );\n            return;\n          }\n          break;\n\n        case 'endloop':\n          if (parts[0] !== 'endfacet') {\n            // End of face\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"endfacet\"`);\n            return;\n          } else {\n            state = 'endfacet';\n          }\n          break;\n\n        case 'endfacet':\n          if (parts[0] === 'endsolid') ; else if (parts[0] === 'facet' && parts[1] === 'normal') {\n            // Next face\n            newNormal = new Vector(\n              parseFloat(parts[2]),\n              parseFloat(parts[3]),\n              parseFloat(parts[4])\n            );\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]\n              }\", should be \"endsolid\" or \"facet normal\"`\n            );\n            return;\n          }\n          break;\n\n        default:\n          console.error(`Invalid state \"${state}\"`);\n          break;\n      }\n    }\n    return model;\n  }\n\n  /**\n   * Draws a <a href=\"#/p5.Geometry\">p5.Geometry</a> object to the canvas.\n   *\n   * The parameter, `model`, is the\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object to draw.\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> objects can be built with\n   * <a href=\"#/p5/buildGeometry\">buildGeometry()</a>, or\n   * <a href=\"#/p5/beginGeometry\">beginGeometry()</a> and\n   * <a href=\"#/p5/endGeometry\">endGeometry()</a>. They can also be loaded from\n   * a file with <a href=\"#/p5/loadGeometry\">loadGeometry()</a>.\n   *\n   * Note: `model()` can only be used in WebGL mode.\n   *\n   * @method model\n   * @param  {p5.Geometry} model 3D shape to be drawn.\n   *\n   * @param {Number} [count=1] number of instances to draw.\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createShape);\n   *\n   *   describe('A white cone drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   * }\n   *\n   * // Create p5.Geometry object from a single cone.\n   * function createShape() {\n   *   cone();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createArrow);\n   *\n   *   describe('Two white arrows drawn on a gray background. The arrow on the right rotates slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the arrows.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   *\n   *   // Translate and rotate the coordinate system.\n   *   translate(30, 0, 0);\n   *   rotateZ(frameCount * 0.01);\n   *\n   *   // Draw the p5.Geometry object again.\n   *   model(shape);\n   * }\n   *\n   * function createArrow() {\n   *   // Add shapes to the p5.Geometry object.\n   *   push();\n   *   rotateX(PI);\n   *   cone(10);\n   *   translate(0, -10, 0);\n   *   cylinder(3, 20);\n   *   pop();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * async function setup() {\n   *   shape = await loadModel('assets/octahedron.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white octahedron drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.model = function (model, count = 1) {\n    this._assert3d('model');\n    // p5._validateParameters('model', arguments);\n    this._renderer.model(model, count);\n  };\n\n  /**\n   * Load a 3d model from an OBJ or STL string.\n   *\n   * OBJ and STL files lack a built-in sense of scale, causing models exported from different programs to vary in size.\n   * If your model doesn't display correctly, consider using `loadModel()` with `normalize` set to `true` to standardize its size.\n   * Further adjustments can be made using the `scale()` function.\n   *\n   * Also, the support for colored STL files is not present. STL files with color will be\n   * rendered without color properties.\n   *\n   * * Options can include:\n   * - `modelString`: Specifies the plain text string of either an stl or obj file to be loaded.\n   * - `fileType`: Defines the file extension of the model.\n   * - `normalize`: Enables standardized size scaling during loading if set to true.\n   * - `successCallback`: Callback for post-loading actions with the 3D model object.\n   * - `failureCallback`: Handles errors if model loading fails, receiving an event error.\n   * - `flipU`: Flips the U texture coordinates of the model.\n   * - `flipV`: Flips the V texture coordinates of the model.\n   *\n   *\n   * @method createModel\n   * @param  {String} modelString         String of the object to be loaded\n   * @param  {String} [fileType]          The file extension of the model\n   *                                      (<code>.stl</code>, <code>.obj</code>).\n   * @param  {Boolean} normalize        If true, scale the model to a\n   *                                      standardized size when loading\n   * @param  {function(p5.Geometry)} [successCallback] Function to be called\n   *                                     once the model is loaded. Will be passed\n   *                                     the 3D model object.\n   * @param  {function(Event)} [failureCallback] called with event error if\n   *                                         the model fails to load.\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * const octahedron_model = `\n   * v 0.000000E+00 0.000000E+00 40.0000\n   * v 22.5000 22.5000 0.000000E+00\n   * v 22.5000 -22.5000 0.000000E+00\n   * v -22.5000 -22.5000 0.000000E+00\n   * v -22.5000 22.5000 0.000000E+00\n   * v 0.000000E+00 0.000000E+00 -40.0000\n   * f     1 2 3\n   * f     1 3 4\n   * f     1 4 5\n   * f     1 5 2\n   * f     6 5 4\n   * f     6 4 3\n   * f     6 3 2\n   * f     6 2 5\n   * `;\n   * //draw a spinning octahedron\n   * let octahedron;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *   octahedron = createModel(octahedron_model, '.obj');\n   *   describe('Vertically rotating 3D octahedron.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   rotateX(frameCount * 0.01);\n   *   rotateY(frameCount * 0.01);\n   *   model(octahedron);\n   *}\n   * </code>\n   * </div>\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {Object} [options]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {boolean} [options.normalize]\n   * @param  {boolean} [options.flipU]\n   * @param  {boolean} [options.flipV]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  let modelCounter = 0;\n  fn.createModel = function(modelString, fileType=' ', options) {\n    // p5._validateParameters('createModel', arguments);\n    let normalize= false;\n    let successCallback;\n    let failureCallback;\n    let flipU = false;\n    let flipV = false;\n    if (options && typeof options === 'object') {\n      normalize = options.normalize || false;\n      successCallback = options.successCallback;\n      failureCallback = options.failureCallback;\n      flipU = options.flipU || false;\n      flipV = options.flipV || false;\n    } else if (typeof options === 'boolean') {\n      normalize = options;\n      successCallback = arguments[3];\n      failureCallback = arguments[4];\n    } else {\n      successCallback = typeof arguments[2] === 'function' ? arguments[2] : undefined;\n      failureCallback = arguments[3];\n    }\n    const model = new p5.Geometry();\n    model.gid = `${fileType}|${normalize}|${modelCounter++}`;\n\n    if (fileType.match(/\\.stl$/i)) {\n      try {\n        let uint8array = new TextEncoder().encode(modelString);\n        let arrayBuffer = uint8array.buffer;\n        parseSTL(model, arrayBuffer);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else if (fileType.match(/\\.obj$/i)) {\n      try {\n        const lines = modelString.split('\\n');\n        parseObj(model, lines);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else {\n      p5._friendlyFileLoadError(3, modelString);\n      if (failureCallback) {\n        failureCallback();\n      } else {\n        p5._friendlyError(\n          'Sorry, the file type is invalid. Only OBJ and STL files are supported.'\n        );\n      }\n    }\n    if (normalize) {\n      model.normalize();\n    }\n\n    if (flipU) {\n      model.flipU();\n    }\n\n    if (flipV) {\n      model.flipV();\n    }\n\n    model._makeTriangleEdges();\n\n    if (typeof successCallback === 'function') {\n      successCallback(model);\n    }\n\n    return model;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  loading(p5, p5.prototype);\n}\n\nexport { loading as default };\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,kBAAkB;AAC3C,SAASC,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,CAAC,IAAIC,OAAO,QAAQ,0BAA0B;AACvD,OAAO,0BAA0B;AACjC,OAAO,mBAAmB;AAC1B,OAAO,iCAAiC;AACxC,OAAO,eAAe;AACtB,OAAO,8BAA8B;AACrC,OAAO,sBAAsB;AAC7B,OAAO,mBAAmB;AAC1B,OAAO,iBAAiB;AACxB,OAAO,4BAA4B;AACnC,OAAO,qBAAqB;AAC5B,OAAO,2BAA2B;AAClC,OAAO,mBAAmB;AAC1B,OAAO,oBAAoB;AAC3B,OAAO,YAAY;AACnB,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,oBAAoB;AAC3B,OAAO,wBAAwB;AAC/B,OAAO,oBAAoB;AAC3B,OAAO,oBAAoB;AAC3B,OAAO,qBAAqB;AAC5B,OAAO,QAAQ;AACf,OAAO,cAAc;AACrB,OAAO,QAAQ;AACf,OAAO,oBAAoB;AAC3B,OAAO,sBAAsB;AAC7B,OAAO,sBAAsB;AAC7B,OAAO,sBAAsB;AAC7B,OAAO,4BAA4B;AACnC,OAAO,qCAAqC;AAC5C,OAAO,cAAc;AACrB,OAAO,sBAAsB;AAC7B,OAAO,mBAAmB;AAC1B,OAAO,SAAS;AAChB,OAAO,0BAA0B;AACjC,OAAO,mBAAmB;AAC1B,OAAO,yBAAyB;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,eAAeC,UAAUA,CAACC,GAAG,EAAE;EAC7B,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACF,GAAG,EAAE;MAAEG,MAAM,EAAE;IAAO,CAAC,CAAC;IACrD,OAAOF,QAAQ,CAACG,EAAE;EACpB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd,OAAO,KAAK;EACd;AACF;AAEA,SAASC,OAAOA,CAACC,EAAE,EAAEC,EAAE,EAAC;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEb,EAAE,CAACa,KAAK,GAAG,UAAUA,KAAK,EAAEuH,KAAK,GAAG,CAAC,EAAE;IACrC,IAAI,CAACC,SAAS,CAAC,OAAO,CAAC;IACvB;IACA,IAAI,CAACtH,SAAS,CAACF,KAAK,CAACA,KAAK,EAAEuH,KAAK,CAAC;EACpC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIE,YAAY,GAAG,CAAC;EACpBtI,EAAE,CAACuI,WAAW,GAAG,UAASC,WAAW,EAAErI,QAAQ,GAAC,GAAG,EAAEsI,OAAO,EAAE;IAC5D;IACA,IAAIrI,SAAS,GAAE,KAAK;IACpB,IAAIC,eAAe;IACnB,IAAIC,eAAe;IACnB,IAAIC,KAAK,GAAG,KAAK;IACjB,IAAIC,KAAK,GAAG,KAAK;IACjB,IAAIiI,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC1CrI,SAAS,GAAGqI,OAAO,CAACrI,SAAS,IAAI,KAAK;MACtCC,eAAe,GAAGoI,OAAO,CAACpI,eAAe;MACzCC,eAAe,GAAGmI,OAAO,CAACnI,eAAe;MACzCC,KAAK,GAAGkI,OAAO,CAAClI,KAAK,IAAI,KAAK;MAC9BC,KAAK,GAAGiI,OAAO,CAACjI,KAAK,IAAI,KAAK;IAChC,CAAC,MAAM,IAAI,OAAOiI,OAAO,KAAK,SAAS,EAAE;MACvCrI,SAAS,GAAGqI,OAAO;MACnBpI,eAAe,GAAGI,SAAS,CAAC,CAAC,CAAC;MAC9BH,eAAe,GAAGG,SAAS,CAAC,CAAC,CAAC;IAChC,CAAC,MAAM;MACLJ,eAAe,GAAG,OAAOI,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,GAAGA,SAAS,CAAC,CAAC,CAAC,GAAGK,SAAS;MAC/ER,eAAe,GAAGG,SAAS,CAAC,CAAC,CAAC;IAChC;IACA,MAAMI,KAAK,GAAG,IAAId,EAAE,CAACZ,QAAQ,CAAC,CAAC;IAC/B0B,KAAK,CAACG,GAAG,GAAG,GAAGb,QAAQ,IAAIC,SAAS,IAAIkI,YAAY,EAAE,EAAE;IAExD,IAAInI,QAAQ,CAACmB,KAAK,CAAC,SAAS,CAAC,EAAE;MAC7B,IAAI;QACF,IAAIoH,UAAU,GAAG,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACJ,WAAW,CAAC;QACtD,IAAIK,WAAW,GAAGH,UAAU,CAACrD,MAAM;QACnCzC,QAAQ,CAAC/B,KAAK,EAAEgI,WAAW,CAAC;MAC9B,CAAC,CAAC,OAAOhJ,KAAK,EAAE;QACd,IAAIS,eAAe,EAAE;UACnBA,eAAe,CAACT,KAAK,CAAC;QACxB,CAAC,MAAM;UACLE,EAAE,CAAC+I,cAAc,CAAC,wBAAwB,GAAGjJ,KAAK,CAACkJ,OAAO,CAAC;QAC7D;QACA;MACF;IACF,CAAC,MAAM,IAAI5I,QAAQ,CAACmB,KAAK,CAAC,SAAS,CAAC,EAAE;MACpC,IAAI;QACF,MAAMJ,KAAK,GAAGsH,WAAW,CAAC9G,KAAK,CAAC,IAAI,CAAC;QACrCoB,QAAQ,CAACjC,KAAK,EAAEK,KAAK,CAAC;MACxB,CAAC,CAAC,OAAOrB,KAAK,EAAE;QACd,IAAIS,eAAe,EAAE;UACnBA,eAAe,CAACT,KAAK,CAAC;QACxB,CAAC,MAAM;UACLE,EAAE,CAAC+I,cAAc,CAAC,wBAAwB,GAAGjJ,KAAK,CAACkJ,OAAO,CAAC;QAC7D;QACA;MACF;IACF,CAAC,MAAM;MACLhJ,EAAE,CAACiD,sBAAsB,CAAC,CAAC,EAAEwF,WAAW,CAAC;MACzC,IAAIlI,eAAe,EAAE;QACnBA,eAAe,CAAC,CAAC;MACnB,CAAC,MAAM;QACLP,EAAE,CAAC+I,cAAc,CACf,wEACF,CAAC;MACH;IACF;IACA,IAAI1I,SAAS,EAAE;MACbS,KAAK,CAACT,SAAS,CAAC,CAAC;IACnB;IAEA,IAAIG,KAAK,EAAE;MACTM,KAAK,CAACN,KAAK,CAAC,CAAC;IACf;IAEA,IAAIC,KAAK,EAAE;MACTK,KAAK,CAACL,KAAK,CAAC,CAAC;IACf;IAEAK,KAAK,CAACgC,kBAAkB,CAAC,CAAC;IAE1B,IAAI,OAAOxC,eAAe,KAAK,UAAU,EAAE;MACzCA,eAAe,CAACQ,KAAK,CAAC;IACxB;IAEA,OAAOA,KAAK;EACd,CAAC;AACH;AAEA,IAAG,OAAOd,EAAE,KAAK,WAAW,EAAC;EAC3BD,OAAO,CAACC,EAAE,EAAEA,EAAE,CAACiJ,SAAS,CAAC;AAC3B;AAEA,SAASlJ,OAAO,IAAImJ,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}