{"ast":null,"code":"class DataArray {\n  constructor(initialLength = 128) {\n    this.length = 0;\n    this.data = new Float32Array(initialLength);\n    this.initialLength = initialLength;\n  }\n\n  /**\n   * Returns a Float32Array window sized to the exact length of the data\n   */\n  dataArray() {\n    return this.subArray(0, this.length);\n  }\n\n  /**\n   * A \"soft\" clear, which keeps the underlying storage size the same, but\n   * empties the contents of its dataArray()\n   */\n  clear() {\n    this.length = 0;\n  }\n\n  /**\n   * Can be used to scale a DataArray back down to fit its contents.\n   */\n  rescale() {\n    if (this.length < this.data.length / 2) {\n      // Find the power of 2 size that fits the data\n      const targetLength = 1 << Math.ceil(Math.log2(this.length));\n      const newData = new Float32Array(targetLength);\n      newData.set(this.data.subarray(0, this.length), 0);\n      this.data = newData;\n    }\n  }\n\n  /**\n   * A full reset, which allocates a new underlying Float32Array at its initial\n   * length\n   */\n  reset() {\n    this.clear();\n    this.data = new Float32Array(this.initialLength);\n  }\n\n  /**\n   * Adds values to the DataArray, expanding its internal storage to\n   * accommodate the new items.\n   */\n  push(...values) {\n    this.ensureLength(this.length + values.length);\n    this.data.set(values, this.length);\n    this.length += values.length;\n  }\n\n  /**\n   * Returns a copy of the data from the index `from`, inclusive, to the index\n   * `to`, exclusive\n   */\n  slice(from, to) {\n    return this.data.slice(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Returns a mutable Float32Array window from the index `from`, inclusive, to\n   * the index `to`, exclusive\n   */\n  subArray(from, to) {\n    return this.data.subarray(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Expand capacity of the internal storage until it can fit a target size\n   */\n  ensureLength(target) {\n    while (this.data.length < target) {\n      const newData = new Float32Array(this.data.length * 2);\n      newData.set(this.data, 0);\n      this.data = newData;\n    }\n  }\n}\nfunction dataArray(p5, fn) {\n  /**\n   * An internal class to store data that will be sent to a p5.RenderBuffer.\n   * Those need to eventually go into a Float32Array, so this class provides a\n   * variable-length array container backed by a Float32Array so that it can be\n   * sent to the GPU without allocating a new array each frame.\n   *\n   * Like a C++ vector, its fixed-length Float32Array backing its contents will\n   * double in size when it goes over its capacity.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Initialize storage with a capacity of 4\n   * const storage = new DataArray(4);\n   * console.log(storage.data.length); // 4\n   * console.log(storage.length); // 0\n   * console.log(storage.dataArray()); // Empty Float32Array\n   *\n   * storage.push(1, 2, 3, 4, 5, 6);\n   * console.log(storage.data.length); // 8\n   * console.log(storage.length); // 6\n   * console.log(storage.dataArray()); // Float32Array{1, 2, 3, 4, 5, 6}\n   * </code>\n   * </div>\n   */\n  p5.DataArray = DataArray;\n}\nif (typeof p5 !== 'undefined') {\n  dataArray(p5, p5.prototype);\n}\nexport { DataArray, dataArray as default };","map":{"version":3,"names":["DataArray","constructor","initialLength","length","data","Float32Array","dataArray","subArray","clear","rescale","targetLength","Math","ceil","log2","newData","set","subarray","reset","push","values","ensureLength","slice","from","to","min","target","p5","fn","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/webgl/p5.DataArray.js"],"sourcesContent":["class DataArray {\n  constructor(initialLength = 128) {\n    this.length = 0;\n    this.data = new Float32Array(initialLength);\n    this.initialLength = initialLength;\n  }\n\n  /**\n   * Returns a Float32Array window sized to the exact length of the data\n   */\n  dataArray() {\n    return this.subArray(0, this.length);\n  }\n\n  /**\n   * A \"soft\" clear, which keeps the underlying storage size the same, but\n   * empties the contents of its dataArray()\n   */\n  clear() {\n    this.length = 0;\n  }\n\n  /**\n   * Can be used to scale a DataArray back down to fit its contents.\n   */\n  rescale() {\n    if (this.length < this.data.length / 2) {\n      // Find the power of 2 size that fits the data\n      const targetLength = 1 << Math.ceil(Math.log2(this.length));\n      const newData = new Float32Array(targetLength);\n      newData.set(this.data.subarray(0, this.length), 0);\n      this.data = newData;\n    }\n  }\n\n  /**\n   * A full reset, which allocates a new underlying Float32Array at its initial\n   * length\n   */\n  reset() {\n    this.clear();\n    this.data = new Float32Array(this.initialLength);\n  }\n\n  /**\n   * Adds values to the DataArray, expanding its internal storage to\n   * accommodate the new items.\n   */\n  push(...values) {\n    this.ensureLength(this.length + values.length);\n    this.data.set(values, this.length);\n    this.length += values.length;\n  }\n\n  /**\n   * Returns a copy of the data from the index `from`, inclusive, to the index\n   * `to`, exclusive\n   */\n  slice(from, to) {\n    return this.data.slice(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Returns a mutable Float32Array window from the index `from`, inclusive, to\n   * the index `to`, exclusive\n   */\n  subArray(from, to) {\n    return this.data.subarray(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Expand capacity of the internal storage until it can fit a target size\n   */\n  ensureLength(target) {\n    while (this.data.length < target) {\n      const newData = new Float32Array(this.data.length * 2);\n      newData.set(this.data, 0);\n      this.data = newData;\n    }\n  }\n}\nfunction dataArray(p5, fn){\n  /**\n   * An internal class to store data that will be sent to a p5.RenderBuffer.\n   * Those need to eventually go into a Float32Array, so this class provides a\n   * variable-length array container backed by a Float32Array so that it can be\n   * sent to the GPU without allocating a new array each frame.\n   *\n   * Like a C++ vector, its fixed-length Float32Array backing its contents will\n   * double in size when it goes over its capacity.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Initialize storage with a capacity of 4\n   * const storage = new DataArray(4);\n   * console.log(storage.data.length); // 4\n   * console.log(storage.length); // 0\n   * console.log(storage.dataArray()); // Empty Float32Array\n   *\n   * storage.push(1, 2, 3, 4, 5, 6);\n   * console.log(storage.data.length); // 8\n   * console.log(storage.length); // 6\n   * console.log(storage.dataArray()); // Float32Array{1, 2, 3, 4, 5, 6}\n   * </code>\n   * </div>\n   */\n  p5.DataArray = DataArray;\n}\n\nif(typeof p5 !== 'undefined'){\n  dataArray(p5, p5.prototype);\n}\n\nexport { DataArray, dataArray as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}