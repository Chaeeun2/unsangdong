{"ast":null,"code":"import { R as Renderer } from '../p5.Renderer-R23xoC7s.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../constants-BRcElHU3.js';\nimport '../image/filters.js';\nimport '../math/p5.Vector.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\n\n/**\n * @module Typography\n * @requires core\n */\n\nconst textCoreConstants = {\n  IDEOGRAPHIC: 'ideographic',\n  RIGHT_TO_LEFT: 'rtl',\n  LEFT_TO_RIGHT: 'ltr',\n  _CTX_MIDDLE: 'middle',\n  _TEXT_BOUNDS: '_textBoundsSingle',\n  _FONT_BOUNDS: '_fontBoundsSingle',\n  HANGING: 'hanging',\n  START: 'start',\n  END: 'end'\n};\nfunction textCore(p5, fn) {\n  const LeadingScale = 1.275;\n  const DefaultFill = '#000000';\n  const LinebreakRe = /\\r?\\n/g;\n  const CommaDelimRe = /,\\s+/;\n  const QuotedRe = /^\".*\"$/;\n  const TabsRe = /\\t/g;\n  const FontVariationSettings = 'fontVariationSettings';\n  const VariableAxes = ['wght', 'wdth', 'ital', 'slnt', 'opsz'];\n  const VariableAxesRe = new RegExp(`(?:${VariableAxes.join('|')})`);\n  const textFunctions = ['text', 'textAlign', 'textAscent', 'textDescent', 'textLeading', 'textMode', 'textFont', 'textSize', 'textStyle', 'textWidth', 'textWrap', 'textBounds', 'textDirection', 'textProperty', 'textProperties', 'fontBounds', 'fontWidth', 'fontAscent', 'fontDescent', 'textWeight'];\n\n  /**\n   * Draws text to the canvas.\n   *\n   * The first parameter, `str`, is the text to be drawn. The second and third\n   * parameters, `x` and `y`, set the coordinates of the text's bottom-left\n   * corner. See <a href=\"#/p5/textAlign\">textAlign()</a> for other ways to\n   * align text.\n   *\n   * The fourth and fifth parameters, `maxWidth` and `maxHeight`, are optional.\n   * They set the dimensions of the invisible rectangle containing the text. By\n   * default, they set its  maximum width and height. See\n   * <a href=\"#/p5/rectMode\">rectMode()</a> for other ways to define the\n   * rectangular text box. Text will wrap to fit within the text box. Text\n   * outside of the box won't be drawn.\n   *\n   * Text can be styled a few ways. Call the <a href=\"#/p5/fill\">fill()</a>\n   * function to set the text's fill color. Call\n   * <a href=\"#/p5/stroke\">stroke()</a> and\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> to set the text's outline.\n   * Call <a href=\"#/p5/textSize\">textSize()</a> and\n   * <a href=\"#/p5/textFont\">textFont()</a> to set the text's size and font,\n   * respectively.\n   *\n   * Note: `WEBGL` mode only supports fonts loaded with\n   * <a href=\"#/p5/loadFont\">loadFont()</a>. Calling\n   * <a href=\"#/p5/stroke\">stroke()</a> has no effect in `WEBGL` mode.\n   *\n   * @method text\n   * @param {String|Object|Array|Number|Boolean} str text to be displayed.\n   * @param {Number} x          x-coordinate of the text box.\n   * @param {Number} y          y-coordinate of the text box.\n   * @param {Number} [maxWidth] maximum width of the text box. See\n   *                            <a href=\"#/p5/rectMode\">rectMode()</a> for\n   *                            other options.\n   * @param {Number} [maxHeight] maximum height of the text box. See\n   *                            <a href=\"#/p5/rectMode\">rectMode()</a> for\n   *                            other options.\n   *\n   * @for p5\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   text('hi', 50, 50);\n   *\n   *   describe('The text \"hi\" written in black in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background('skyblue');\n   *   textSize(100);\n   *   text('üåà', 0, 100);\n   *\n   *   describe('A rainbow in a blue sky.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   textSize(32);\n   *   fill(255);\n   *   stroke(0);\n   *   strokeWeight(4);\n   *   text('hi', 50, 50);\n   *\n   *   describe('The text \"hi\" written in white with a black outline.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background('black');\n   *   textSize(22);\n   *   fill('yellow');\n   *   text('rainbows', 6, 20);\n   *   fill('cornflowerblue');\n   *   text('rainbows', 6, 45);\n   *   fill('tomato');\n   *   text('rainbows', 6, 70);\n   *   fill('limegreen');\n   *   text('rainbows', 6, 95);\n   *\n   *   describe('The text \"rainbows\" written on several lines, each in a different color.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   let s = 'The quick brown fox jumps over the lazy dog.';\n   *   text(s, 10, 10, 70, 80);\n   *\n   *   describe('The sample text \"The quick brown fox...\" written in black across several lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   rectMode(CENTER);\n   *   let s = 'The quick brown fox jumps over the lazy dog.';\n   *   text(s, 50, 50, 70, 80);\n   *\n   *   describe('The sample text \"The quick brown fox...\" written in black across several lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div modernizr='webgl'>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *   font = await loadFont('assets/inconsolata.otf');\n   *   textFont(font);\n   *   textSize(32);\n   *   textAlign(CENTER, CENTER);\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   rotateY(frameCount / 30);\n   *   text('p5*js', 0, 0);\n   *\n   *   describe('The text \"p5*js\" written in white and spinning in 3D.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets the way text is aligned when <a href=\"#/p5/text\">text()</a> is called.\n   *\n   * By default, calling `text('hi', 10, 20)` places the bottom-left corner of\n   * the text's bounding box at (10, 20).\n   *\n   * The first parameter, `horizAlign`, changes the way\n   * <a href=\"#/p5/text\">text()</a> interprets x-coordinates. By default, the\n   * x-coordinate sets the left edge of the bounding box. `textAlign()` accepts\n   * the following values for `horizAlign`: `LEFT`, `CENTER`, or `RIGHT`.\n   *\n   * The second parameter, `vertAlign`, is optional. It changes the way\n   * <a href=\"#/p5/text\">text()</a> interprets y-coordinates. By default, the\n   * y-coordinate sets the bottom edge of the bounding box. `textAlign()`\n   * accepts the following values for `vertAlign`: `TOP`, `BOTTOM`, `CENTER`,\n   * or `BASELINE`.\n   *\n   * @method textAlign\n   * @for p5\n   * @param {LEFT|CENTER|RIGHT} horizAlign horizontal alignment\n   * @param {TOP|BOTTOM|CENTER|BASELINE} [vertAlign] vertical alignment\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Draw a vertical line.\n   *   strokeWeight(0.5);\n   *   line(50, 0, 50, 100);\n   *\n   *   // Top line.\n   *   textSize(16);\n   *   textAlign(RIGHT);\n   *   text('ABCD', 50, 30);\n   *\n   *   // Middle line.\n   *   textAlign(CENTER);\n   *   text('EFGH', 50, 50);\n   *\n   *   // Bottom line.\n   *   textAlign(LEFT);\n   *   text('IJKL', 50, 70);\n   *\n   *   describe('The letters ABCD displayed at top-left, EFGH at center, and IJKL at bottom-right. A vertical line divides the canvas in half.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   strokeWeight(0.5);\n   *\n   *   // First line.\n   *   line(0, 12, width, 12);\n   *   textAlign(CENTER, TOP);\n   *   text('TOP', 50, 12);\n   *\n   *   // Second line.\n   *   line(0, 37, width, 37);\n   *   textAlign(CENTER, CENTER);\n   *   text('CENTER', 50, 37);\n   *\n   *   // Third line.\n   *   line(0, 62, width, 62);\n   *   textAlign(CENTER, BASELINE);\n   *   text('BASELINE', 50, 62);\n   *\n   *   // Fourth line.\n   *   line(0, 97, width, 97);\n   *   textAlign(CENTER, BOTTOM);\n   *   text('BOTTOM', 50, 97);\n   *\n   *   describe('The words \"TOP\", \"CENTER\", \"BASELINE\", and \"BOTTOM\" each drawn relative to a horizontal line. Their positions demonstrate different vertical alignments.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Returns the ascent of the text.\n   *\n   * The `textAscent()` function calculates the distance from the baseline to the\n   * highest point of the current font. This value represents the ascent, which is essential\n   * for determining the overall height of the text along with `textDescent()`. If\n   * a text string is provided as an argument, the ascent is calculated based on that specific\n   * string; otherwise, the ascent of the current font is returned.\n   *\n   * @method textAscent\n   * @for p5\n   *\n   * @param {String} [txt] - (Optional) The text string for which to calculate the ascent.\n   *                         If omitted, the function returns the ascent for the current font.\n   * @returns {Number} The ascent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(400, 300);\n   *   background(220);\n   *\n   *   textSize(48);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the ascent of the current font\n   *   let asc = textAscent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the ascent position\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y - asc, x + 200, y - asc); // Ascent (top of text)\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"textAscent: \" + asc.toFixed(2) + \" pixels\", x, y - asc - 10);\n   * }\n   * </code>\n   * </div>\n   *\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup()  {\n   *   font = await loadFont('assets/inconsolata.otf');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textFont(font);\n   *\n   *   // Different for each font.\n   *   let fontScale = 0.8;\n   *\n   *   let baseY = 75;\n   *   strokeWeight(0.5);\n   *\n   *   // Draw small text.\n   *   textSize(24);\n   *   text('dp', 0, baseY);\n   *\n   *   // Draw baseline and ascent.\n   *   let a = textAscent() * fontScale;\n   *   line(0, baseY, 23, baseY);\n   *   line(23, baseY - a, 23, baseY);\n   *\n   *   // Draw large text.\n   *   textSize(48);\n   *   text('dp', 45, baseY);\n   *\n   *   // Draw baseline and ascent.\n   *   a = textAscent() * fontScale;\n   *   line(45, baseY, 91, baseY);\n   *   line(91, baseY - a, 91, baseY);\n   *\n   *   describe('The letters \"dp\" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends upward from each baseline to the top of the \"d\".');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Returns the descent of the text.\n   *\n   * The `textDescent()` function calculates the distance from the baseline to the\n   * lowest point of the current font. This value represents the descent, which, when combined\n   * with the ascent (from `textAscent()`), determines the overall vertical span of the text.\n   * If a text string is provided as an argument, the descent is calculated based on that specific string;\n   * otherwise, the descent of the current font is returned.\n   *\n   * @method textDescent\n   * @for p5\n   *\n   * @param {String} [txt] - (Optional) The text string for which to calculate the descent.\n   *                         If omitted, the function returns the descent for the current font.\n   * @returns {Number} The descent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(400, 300);\n   *   background(220);\n   *\n   *   textSize(48);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the descent of the current font\n   *   let desc = textDescent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the bottom of the text\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y + desc, x + 200, y + desc); // Descent (bottom of text)\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"textDescent: \" + desc.toFixed(2) + \" pixels\", x, y + desc + 20);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup()  {\n   *   font = await loadFont('assets/inconsolata.otf');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the font.\n   *   textFont(font);\n   *\n   *   // Different for each font.\n   *   let fontScale = 0.9;\n   *\n   *   let baseY = 75;\n   *   strokeWeight(0.5);\n   *\n   *   // Draw small text.\n   *   textSize(24);\n   *   text('dp', 0, baseY);\n   *\n   *   // Draw baseline and descent.\n   *   let d = textDescent() * fontScale;\n   *   line(0, baseY, 23, baseY);\n   *   line(23, baseY, 23, baseY + d);\n   *\n   *   // Draw large text.\n   *   textSize(48);\n   *   text('dp', 45, baseY);\n   *\n   *   // Draw baseline and descent.\n   *   d = textDescent() * fontScale;\n   *   line(45, baseY, 91, baseY);\n   *   line(91, baseY, 91, baseY + d);\n   *\n   *   describe('The letters \"dp\" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends downward from each baseline to the bottom of the \"p\".');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets the spacing between lines of text when\n   * <a href=\"#/p5/text\">text()</a> is called.\n   *\n   * Note: Spacing is measured in pixels.\n   *\n   * Calling `textLeading()` without an argument returns the current spacing.\n   *\n   * @method textLeading\n   * @for p5\n   * @param {Number} leading The new text leading to apply, in pixels\n   * @returns {Number} If no arguments are provided, the current text leading\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // \"\\n\" starts a new line of text.\n   *   let lines = 'one\\ntwo';\n   *\n   *   // Left.\n   *   text(lines, 10, 25);\n   *\n   *   // Right.\n   *   textLeading(30);\n   *   text(lines, 70, 25);\n   *\n   *   describe('The words \"one\" and \"two\" written on separate lines twice. The words on the left have less vertical spacing than the words on the right.');\n   * }\n   * </code>\n   * </div>\n   */\n  /*\n   * @method textLeading\n   * @for p5\n   */\n\n  /**\n   * Sets the font used by the <a href=\"#/p5/text\">text()</a> function.\n   *\n   * The first parameter, `font`, sets the font. `textFont()` recognizes either\n   * a <a href=\"#/p5.Font\">p5.Font</a> object or a string with the name of a\n   * system font. For example, `'Courier New'`.\n   *\n   * The second parameter, `size`, is optional. It sets the font size in pixels.\n   * This has the same effect as calling <a href=\"#/p5/textSize\">textSize()</a>.\n   *\n   * Note: `WEBGL` mode only supports fonts loaded with\n   * <a href=\"#/p5/loadFont\">loadFont()</a>.\n   *\n   * @method textFont\n   * @param {p5.Font|String|Object} font The font to apply\n   * @param {Number} [size] An optional text size to apply.\n   * @for p5\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   textFont('Courier New');\n   *   textSize(24);\n   *   text('hi', 35, 55);\n   *\n   *   describe('The text \"hi\" written in a black, monospace font on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background('black');\n   *   fill('palegreen');\n   *   textFont('Courier New', 10);\n   *   text('You turn to the left and see a door. Do you enter?', 5, 5, 90, 90);\n   *   text('>', 5, 70);\n   *\n   *   describe('A text prompt from a game is written in a green, monospace font on a black background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   textFont('Verdana');\n   *   let currentFont = textFont();\n   *   text(currentFont, 25, 50);\n   *\n   *   describe('The text \"Verdana\" written in a black, sans-serif font on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * let fontRegular;\n   * let fontItalic;\n   * let fontBold;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   fontRegular = await loadFont('assets/Regular.otf');\n   *   fontItalic = await loadFont('assets/Italic.ttf');\n   *   fontBold = await loadFont('assets/Bold.ttf');\n   *\n   *   background(200);\n   *   textFont(fontRegular);\n   *   text('I am Normal', 10, 30);\n   *   textFont(fontItalic);\n   *   text('I am Italic', 10, 50);\n   *   textFont(fontBold);\n   *   text('I am Bold', 10, 70);\n   *\n   *   describe('The statements \"I am Normal\", \"I am Italic\", and \"I am Bold\" written in black on separate lines. The statements have normal, italic, and bold fonts, respectively.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets or gets the current text size.\n   *\n   * The `textSize()` function is used to specify the size of the text\n   * that will be rendered on the canvas. When called with an argument, it sets the\n   * text size to the specified value (which can be a number representing pixels or a\n   * CSS-style string, e.g., '32px', '2em'). When called without an argument, it\n   * returns the current text size in pixels.\n   *\n   * @method textSize\n   * @for p5\n   *\n   * @param {Number} size - The size to set for the text.\n   * @returns {Number} If no arguments are provided, the current text size in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(600, 200);\n   *   background(240);\n   *\n   *   // Set the text size to 48 pixels\n   *   textSize(48);\n   *   textAlign(CENTER, CENTER);\n   *   textFont(\"Georgia\");\n   *\n   *   // Draw text using the current text size\n   *   fill(0);\n   *   text(\"Hello, p5.js!\", width / 2, height / 2);\n   *\n   *   // Retrieve and display the current text size\n   *   let currentSize = textSize();\n   *   fill(50);\n   *   textSize(16);\n   *   text(\"Current text size: \" + currentSize, width / 2, height - 20);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top.\n   *   textSize(12);\n   *   text('Font Size 12', 10, 30);\n   *\n   *   // Middle.\n   *   textSize(14);\n   *   text('Font Size 14', 10, 60);\n   *\n   *   // Bottom.\n   *   textSize(16);\n   *   text('Font Size 16', 10, 90);\n   *\n   *   describe('The text \"Font Size 12\" drawn small, \"Font Size 14\" drawn medium, and \"Font Size 16\" drawn large.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textSize\n   * @for p5\n   * @returns {Number} The current text size in pixels.\n   */\n\n  /**\n   * Sets the style for system fonts when\n   * <a href=\"#/p5/text\">text()</a> is called.\n   *\n   * The parameter, `style`, can be either `NORMAL`, `ITALIC`, `BOLD`, or\n   * `BOLDITALIC`.\n   *\n   * `textStyle()` may be overridden by CSS styling. This function doesn't\n   * affect fonts loaded with <a href=\"#/p5/loadFont\">loadFont()</a>.\n   *\n   * @method textStyle\n   * @for p5\n   * @param {NORMAL|ITALIC|BOLD|BOLDITALIC} style The style to use\n   * @returns {NORMAL|ITALIC|BOLD|BOLDITALIC} If no arguments are provided, the current style\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(12);\n   *   textAlign(CENTER);\n   *\n   *   // First row.\n   *   textStyle(NORMAL);\n   *   text('Normal', 50, 15);\n   *\n   *   // Second row.\n   *   textStyle(ITALIC);\n   *   text('Italic', 50, 40);\n   *\n   *   // Third row.\n   *   textStyle(BOLD);\n   *   text('Bold', 50, 65);\n   *\n   *   // Fourth row.\n   *   textStyle(BOLDITALIC);\n   *   text('Bold Italic', 50, 90);\n   *\n   *   describe('The words \"Normal\" displayed normally, \"Italic\" in italic, \"Bold\" in bold, and \"Bold Italic\" in bold italics.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textStyle\n   * @for p5\n   * @returns {NORMAL|BOLD|ITALIC|BOLDITALIC}\n   */\n\n  /**\n   * Calculates the width of the given text string in pixels.\n   *\n   * The `textWidth()` function processes the provided text string to determine its tight bounding box\n   * based on the current text properties such as font, textSize, and textStyle. Internally, it splits\n   * the text into individual lines (if line breaks are present) and computes the bounding box for each\n   * line using the renderer‚Äôs measurement functions. The final width is determined as the maximum width\n   * among all these lines.\n   *\n   * For example, if the text contains multiple lines due to wrapping or explicit line breaks, textWidth()\n   * will return the width of the longest line.\n   *\n   * @method textWidth\n   * @for p5\n   * @param {String} text The text to measure\n   * @returns {Number} The width of the text\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(200, 200);\n   *   background(220);\n   *\n   *   // Set text size and alignment\n   *   textSize(48);\n   *   textAlign(LEFT, TOP);\n   *\n   *   let myText = \"Hello\";\n   *\n   *   // Calculate the width of the text\n   *   let tw = textWidth(myText);\n   *\n   *   // Draw the text on the canvas\n   *   fill(0);\n   *   text(myText, 50, 50);\n   *\n   *   // Display the text width below\n   *   noStroke();\n   *   fill(0);\n   *   textSize(20);\n   *   text(\"Text width: \" + tw, 10, 150);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(28);\n   *   strokeWeight(0.5);\n   *\n   *   // Calculate the text width.\n   *   let s = 'yoyo';\n   *   let w = textWidth(s);\n   *\n   *   // Display the text.\n   *   text(s, 22, 55);\n   *\n   *   // Underline the text.\n   *   line(22, 55, 22 + w, 55);\n   *\n   *   describe('The word \"yoyo\" underlined.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(28);\n   *   strokeWeight(0.5);\n   *\n   *   // Calculate the text width.\n   *   // \"\\n\" starts a new line.\n   *   let s = 'yo\\nyo';\n   *   let w = textWidth(s);\n   *\n   *   // Display the text.\n   *   text(s, 22, 55);\n   *\n   *   // Underline the text.\n   *   line(22, 55, 22 + w, 55);\n   *\n   *   describe('The word \"yo\" written twice, one copy beneath the other. The words are divided by a horizontal line.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets the style for wrapping text when\n   * <a href=\"#/p5/text\">text()</a> is called.\n   *\n   * The parameter, `style`, can be one of the following values:\n   *\n   * `WORD` starts new lines of text at spaces. If a string of text doesn't\n   * have spaces, it may overflow the text box and the canvas. This is the\n   * default style.\n   *\n   * `CHAR` starts new lines as needed to stay within the text box.\n   *\n   * `textWrap()` only works when the maximum width is set for a text box. For\n   * example, calling `text('Have a wonderful day', 0, 10, 100)` sets the\n   * maximum width to 100 pixels.\n   *\n   * Calling `textWrap()` without an argument returns the current style.\n   *\n   * @method textWrap\n   * @for p5\n   *\n   * @param {WORD|CHAR} style The wrapping style to use\n   * @returns {CHAR|WORD} If no arguments are provided, the current wrapping style\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(20);\n   *   textWrap(WORD);\n   *\n   *   // Display the text.\n   *   text('Have a wonderful day', 0, 10, 100);\n   *\n   *   describe('The text \"Have a wonderful day\" written across three lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(20);\n   *   textWrap(CHAR);\n   *\n   *   // Display the text.\n   *   text('Have a wonderful day', 0, 10, 100);\n   *\n   *   describe('The text \"Have a wonderful day\" written across two lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(20);\n   *   textWrap(CHAR);\n   *\n   *   // Display the text.\n   *   text('Á•ù‰Ω†ÊúâÁæéÂ•ΩÁöÑ‰∏ÄÂ§©', 0, 10, 100);\n   *\n   *   describe('The text \"Á•ù‰Ω†ÊúâÁæéÂ•ΩÁöÑ‰∏ÄÂ§©\" written across two lines.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textWrap\n   * @for p5\n   * @returns {CHAR|WORD} The current wrapping style\n   */\n\n  /**\n   * Computes the tight bounding box for a block of text.\n   *\n   * The `textBounds()` function calculates the precise pixel boundaries that enclose\n   * the rendered text based on the current text properties (such as font, textSize, textStyle, and\n   * alignment). If the text spans multiple lines (due to line breaks or wrapping), the function\n   * measures each line individually and then aggregates these measurements into a single bounding box.\n   * The resulting object contains the x and y coordinates along with the width (w) and height (h)\n   * of the text block.\n   *\n   * @method textBounds\n   * @for p5\n   *\n   * @param {String} str - The text string to measure.\n   * @param {Number} x - The x-coordinate where the text is drawn.\n   * @param {Number} y - The y-coordinate where the text is drawn.\n   * @param {Number} [width] - (Optional) The maximum width available for the text block.\n   *                           When specified, the text may be wrapped to fit within this width.\n   * @param {Number} [height] - (Optional) The maximum height available for the text block.\n   *                            Any lines exceeding this height will be truncated.\n   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` that represent the tight\n   *                   bounding box of the rendered text.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(220);\n   *\n   *   // Set up text properties for clarity\n   *   textSize(32);\n   *   textAlign(LEFT, TOP);\n   *\n   *   let txt = \"Hello, World!\";\n   *   // Compute the bounding box for the text starting at (50, 50)\n   *   let bounds = textBounds(txt, 50, 50);\n   *\n   *   // Draw the text\n   *   fill(0);\n   *   text(txt, 50, 50);\n   *\n   *   // Draw the computed bounding box in red to visualize the measured area\n   *   noFill();\n   *   stroke('red');\n   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets or gets the text drawing direction.\n   *\n   * The <code>textDirection()</code> function allows you to specify the direction in which text is\n   * rendered on the canvas. When provided with a <code>direction</code> parameter (such as \"ltr\" for\n   * left-to-right, \"rtl\" for right-to-left, or \"inherit\"), it updates the renderer's state with that\n   * value and applies the new setting. When called without any arguments, it returns the current text\n   * direction. This function is particularly useful for rendering text in languages with different\n   * writing directions.\n   *\n   * @method textDirection\n   * @for p5\n   *\n   * @param {String} direction - The text direction to set (\"ltr\", \"rtl\", or \"inherit\").\n   * @returns {String} If no arguments are provided, the current text direction, either \"ltr\", \"rtl\", or \"inherit\"\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(240);\n   *\n   *   textSize(32);\n   *   textFont(\"Georgia\");\n   *   textAlign(LEFT, TOP);\n   *\n   *   // Set text direction to right-to-left and draw Arabic text.\n   *   textDirection(\"rtl\");\n   *   fill(0);\n   *   text(\"ŸÖÿ±ÿ≠ÿ®Ÿãÿß!\", 50, 50);\n   *\n   *   // Set text direction to left-to-right and draw English text.\n   *   textDirection(\"ltr\");\n   *   text(\"Hello, p5.js!\", 50, 150);\n   *\n   *   // Display the current text direction.\n   *   textSize(16);\n   *   fill(50);\n   *   textAlign(LEFT, TOP);\n   *   text(\"Current textDirection: \" + textDirection(), 50, 250);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textDirection\n   * @for p5\n   * @returns {String} The current text direction, either \"ltr\", \"rtl\", or \"inherit\"\n   */\n\n  /**\n   * Sets or gets a single text property for the renderer.\n   *\n   * The `textProperty()` function allows you to set or retrieve a single text-related property,\n   * such as `textAlign`, `textBaseline`, `fontStyle`, or any other property\n   * that may be part of the renderer's state, its drawing context, or the canvas style.\n   *\n   * When called with a `prop` and a `value`, the function sets the property by checking\n   * for its existence in the renderer's state, the drawing context, or the canvas style. If the property is\n   * successfully modified, the function applies the updated text properties. If called with only the\n   * `prop` parameter, the function returns the current value of that property.\n   *\n   * @method textProperty\n   * @for p5\n   *\n   * @param {String} prop - The name of the text property to set or get.\n   * @param value - The value to set for the specified text property. If omitted, the current\n   *                      value of the property is returned\n   * @returns If no arguments are provided, the current value of the specified text property\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(240);\n   *\n   *   // Set the text alignment to CENTER and the baseline to TOP using textProperty.\n   *   textProperty(\"textAlign\", CENTER);\n   *   textProperty(\"textBaseline\", TOP);\n   *\n   *   // Set additional text properties and draw the text.\n   *   textSize(32);\n   *   textFont(\"Georgia\");\n   *   fill(0);\n   *   text(\"Hello, World!\", width / 2, 50);\n   *\n   *   // Retrieve and display the current text properties.\n   *   let currentAlign = textProperty(\"textAlign\");\n   *   let currentBaseline = textProperty(\"textBaseline\");\n   *\n   *   textSize(16);\n   *   textAlign(LEFT, TOP);\n   *   fill(50);\n   *   text(\"Current textAlign: \" + currentAlign, 50, 150);\n   *   text(\"Current textBaseline: \" + currentBaseline, 50, 170);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textProperty\n   * @for p5\n   * @param {String} prop - The name of the text property to set or get.\n   * @returns The current value of the specified text property\n   */\n\n  /**\n   * Gets or sets text properties in batch, similar to calling `textProperty()`\n   * multiple times.\n   *\n   * If an object is passed in, `textProperty(key, value)` will be called for you\n   * on every key/value pair in the object.\n   *\n   * If no arguments are passed in, an object will be returned with all the current\n   * properties.\n   *\n   * @method textProperties\n   * @for p5\n   * @param {Object} properties An object whose keys are properties to set, and whose\n   *                            values are what they should be set to.\n   */\n  /**\n   * @method textProperties\n   * @for p5\n   * @returns {Object} An object with all the possible properties and their current values.\n   */\n\n  /**\n   * Computes a generic (non-tight) bounding box for a block of text.\n   *\n   * The `fontBounds()` function calculates the bounding box for the text based on the\n   * font's intrinsic metrics (such as `fontBoundingBoxAscent` and\n   * `fontBoundingBoxDescent`). Unlike `textBounds()`, which measures the exact\n   * pixel boundaries of the rendered text, `fontBounds()` provides a looser measurement\n   * derived from the font‚Äôs default spacing. This measurement is useful for layout purposes where\n   * a consistent approximation of the text's dimensions is desired.\n   *\n   * @method fontBounds\n   * @for p5\n   *\n   * @param {String} str - The text string to measure.\n   * @param {Number} x - The x-coordinate where the text is drawn.\n   * @param {Number} y - The y-coordinate where the text is drawn.\n   * @param {Number} [width] - (Optional) The maximum width available for the text block.\n   *                           When specified, the text may be wrapped to fit within this width.\n   * @param {Number} [height] - (Optional) The maximum height available for the text block.\n   *                            Any lines exceeding this height will be truncated.\n   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` representing the loose\n   *                   bounding box of the text based on the font's intrinsic metrics.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(240);\n   *\n   *   textSize(32);\n   *   textAlign(LEFT, TOP);\n   *   textFont('Georgia');\n   *\n   *   let txt = \"Hello, World!\";\n   *   // Compute the bounding box based on the font's intrinsic metrics\n   *   let bounds = fontBounds(txt, 50, 50);\n   *\n   *   fill(0);\n   *   text(txt, 50, 50);\n   *\n   *   noFill();\n   *   stroke('green');\n   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);\n   *\n   *   noStroke();\n   *   fill(50);\n   *   textSize(15);\n   *   text(\"Font Bounds: x=\" + bounds.x.toFixed(1) + \", y=\" + bounds.y.toFixed(1) +\n   *        \", w=\" + bounds.w.toFixed(1) + \", h=\" + bounds.h.toFixed(1), 8, 100);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Returns the loose width of a text string based on the current font.\n   *\n   * The `fontWidth()` function measures the width of the provided text string using\n   * the font's default measurement (i.e., the width property from the text metrics returned by\n   * the browser). Unlike `textWidth()`, which calculates the tight pixel boundaries\n   * of the text glyphs, `fontWidth()` uses the font's intrinsic spacing, which may include\n   * additional space for character spacing and kerning. This makes it useful for scenarios where\n   * an approximate width is sufficient for layout and positioning.\n   *\n   * @method fontWidth\n   * @for p5\n   *\n   * @param {String} theText - The text string to measure.\n   * @returns {Number} The loose width of the text in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(240);\n   *\n   *   textSize(32);\n   *   textAlign(LEFT, TOP);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, World!\";\n   *   let fw = fontWidth(s);\n   *\n   *   fill(0);\n   *   text(s, 50, 50);\n   *\n   *   stroke('blue');\n   *   line(50, 90, 50 + fw, 90);\n   *\n   *   noStroke();\n   *   fill(50);\n   *   textSize(16);\n   *   text(\"Font width: \" + fw.toFixed(2) + \" pixels\", 50, 100);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Returns the loose ascent of the text based on the font's intrinsic metrics.\n   *\n   * The `fontAscent()` function calculates the ascent of the text using the font's\n   * intrinsic metrics (e.g., `fontBoundingBoxAscent`). This value represents the space\n   * above the baseline that the font inherently occupies, and is useful for layout purposes when\n   * an approximate vertical measurement is required.\n   *\n   * @method fontAscent\n   * @for p5\n   *\n   * @returns {Number} The loose ascent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(220);\n   *\n   *   textSize(35);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the font descent of the current font\n   *   let fasc = fontAscent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the ascent position\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y - fasc, x + 200, y - fasc); // Font ascent position\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"fontAscent: \" + fasc.toFixed(2) + \" pixels\", x, y + fdesc + 20);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Returns the loose descent of the text based on the font's intrinsic metrics.\n   *\n   * The `fontDescent()` function calculates the descent of the text using the font's\n   * intrinsic metrics (e.g., `fontBoundingBoxDescent`). This value represents the space\n   * below the baseline that the font inherently occupies, and is useful for layout purposes when\n   * an approximate vertical measurement is required.\n   *\n   * @method fontDescent\n   * @for p5\n   *\n   * @returns {Number} The loose descent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(220);\n   *\n   *   textSize(48);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the font descent of the current font\n   *   let fdesc = fontDescent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the descent position\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y + fdesc, x + 200, y + fdesc); // Font descent position\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"fontDescent: \" + fdesc.toFixed(2) + \" pixels\", x, y + fdesc + 20);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   *\n   * Sets or gets the current font weight.\n   *\n   * The <code>textWeight()</code> function is used to specify the weight (thickness) of the text.\n   * When a numeric value is provided, it sets the font weight to that value and updates the\n   * rendering properties accordingly (including the \"font-variation-settings\" on the canvas style).\n   * When called without an argument, it returns the current font weight setting.\n   *\n   * @method textWeight\n   * @for p5\n   *\n   * @param {Number} weight - The numeric weight value to set for the text.\n   * @returns {Number} If no arguments are provided, the current font weight\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(240);\n   *\n   *   // Set text alignment, size, and font\n   *   textAlign(LEFT, TOP);\n   *   textSize(20);\n   *   textFont(\"Georgia\");\n   *\n   *   // Draw text with a normal weight (lighter appearance)\n   *   push();\n   *   textWeight(400);  // Set font weight to 400\n   *   fill(0);\n   *   text(\"Normal\", 50, 50);\n   *   let normalWeight = textWeight();  // Should return 400\n   *   pop();\n   *\n   *   // Draw text with a bold weight (heavier appearance)\n   *   push();\n   *   textWeight(900);  // Set font weight to 900\n   *   fill(0);\n   *   text(\"Bold\", 50, 100);\n   *   let boldWeight = textWeight();  // Should return 900\n   *   pop();\n   *\n   *   // Display the current font weight values on the canvas\n   *   textSize(16);\n   *   fill(50);\n   *   text(\"Normal Weight: \" + normalWeight, 150, 52);\n   *   text(\"Bold Weight: \" + boldWeight, 150, 100);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont(\n   *     'https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *   textFont(font);\n   *   textAlign(LEFT, TOP);\n   *   textSize(35);\n   *   textWeight(sin(millis() * 0.002) * 200 + 400);\n   *   text('p5*js', 0, 10);\n   *   describe('The text p5*js pulsing its weight over time');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textWeight\n   * @for p5\n   * @returns {Number} The current font weight\n   */\n\n  // attach each text func to p5, delegating to the renderer\n  textFunctions.forEach(func => {\n    fn[func] = function (...args) {\n      if (!(func in Renderer.prototype)) {\n        throw Error(`Renderer2D.prototype.${func} is not defined.`);\n      }\n      return this._renderer[func](...args);\n    };\n    // attach also to p5.Graphics.prototype\n    p5.Graphics.prototype[func] = function (...args) {\n      return this._renderer[func](...args);\n    };\n  });\n  const RendererTextProps = {\n    textAlign: {\n      default: fn.LEFT,\n      type: 'Context2d'\n    },\n    textBaseline: {\n      default: fn.BASELINE,\n      type: 'Context2d'\n    },\n    textFont: {\n      default: {\n        family: 'sans-serif'\n      }\n    },\n    textLeading: {\n      default: 15\n    },\n    textSize: {\n      default: 12\n    },\n    textWrap: {\n      default: fn.WORD\n    },\n    fontStretch: {\n      default: fn.NORMAL,\n      isShorthand: true\n    },\n    // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }\n    fontWeight: {\n      default: fn.NORMAL,\n      isShorthand: true\n    },\n    // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }\n    lineHeight: {\n      default: fn.NORMAL,\n      isShorthand: true\n    },\n    // line-height: { default:  normal | number | length | percentage }\n    fontVariant: {\n      default: fn.NORMAL,\n      isShorthand: true\n    },\n    // font-variant: { default:  normal | small-caps }\n    fontStyle: {\n      default: fn.NORMAL,\n      isShorthand: true\n    },\n    // font-style: { default:  normal | italic | oblique } [was 'textStyle' in v1]\n    direction: {\n      default: 'inherit'\n    } // direction: { default: inherit | ltr | rtl }\n  };\n\n  // note: font must be first here otherwise it may reset other properties\n  const ContextTextProps = ['font', 'direction', 'fontKerning', 'fontStretch', 'fontVariantCaps', 'letterSpacing', 'textAlign', 'textBaseline', 'textRendering', 'wordSpacing'];\n\n  // shorthand font properties that can be set with context2d.font\n  const ShorthandFontProps = Object.keys(RendererTextProps).filter(p => RendererTextProps[p].isShorthand);\n\n  // allowable values for font-stretch property for context2d.font\n  const FontStretchKeys = [\"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"normal\", \"semi-expanded\", \"expanded\", \"extra-expanded\", \"ultra-expanded\"];\n  let contextQueue, cachedDiv; // lazy\n\n  ////////////////////////////// start API ///////////////////////////////\n\n  Renderer.prototype.text = function (str, x, y, width, height) {\n    let setBaseline = this.textDrawingContext().textBaseline; // store baseline\n\n    // adjust {x,y,w,h} properties based on rectMode\n    ({\n      x,\n      y,\n      width,\n      height\n    } = this._handleRectMode(x, y, width, height));\n\n    // parse the lines according to width, height & linebreaks\n    let lines = this._processLines(str, width, height);\n\n    // add the adjusted positions [x,y] to each line\n    lines = this._positionLines(x, y, width, height, lines);\n\n    // render each line at the adjusted position\n    lines.forEach(line => this._renderText(line.text, line.x, line.y));\n    this.textDrawingContext().textBaseline = setBaseline; // restore baseline\n  };\n\n  /**\n   * Computes the precise (tight) bounding box for a block of text\n   * @param {String} str - the text to measure\n   * @param {Number} x - the x-coordinate of the text\n   * @param {Number} y - the y-coordinate of the text\n   * @param {Number} width - the max width of the text block\n   * @param {Number} height - the max height of the text block\n   * @returns - a bounding box object for the text block: {x,y,w,h}\n   * @private\n   */\n  Renderer.prototype.textBounds = function (str, x, y, width, height) {\n    // delegate to _textBoundsSingle for measuring\n    return this._computeBounds(textCoreConstants._TEXT_BOUNDS, str, x, y, width, height).bounds;\n  };\n\n  /**\n   * Computes a generic (non-tight) bounding box for a block of text\n   * @param {String} str - the text to measure\n   * @param {Number} x - the x-coordinate of the text\n   * @param {Number} y - the y-coordinate of the text\n   * @param {Number} width - the max width of the text block\n   * @param {Number} height - the max height of the text block\n   * @returns - a bounding box object for the text block: {x,y,w,h}\n   * @private\n   */\n  Renderer.prototype.fontBounds = function (str, x, y, width, height) {\n    // delegate to _fontBoundsSingle for measuring\n    return this._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height).bounds;\n  };\n\n  /**\n   * Get the width of a text string in pixels (tight bounds)\n   * @param {String} theText\n   * @returns - the width of the text in pixels\n   * @private\n   */\n  Renderer.prototype.textWidth = function (theText) {\n    let lines = this._processLines(theText);\n    // return the max width of the lines (using tight bounds)\n    return Math.max(...lines.map(l => this._textWidthSingle(l)));\n  };\n\n  /**\n   * Get the width of a text string in pixels (loose bounds)\n   * @param {String} theText\n   * @returns - the width of the text in pixels\n   * @private\n   */\n  Renderer.prototype.fontWidth = function (theText) {\n    // return the max width of the lines (using loose bounds)\n    let lines = this._processLines(theText);\n    return Math.max(...lines.map(l => this._fontWidthSingle(l)));\n  };\n\n  /**\n   * @param {*} txt - optional text to measure, if provided will be\n   * used to compute the ascent, otherwise the font's ascent will be used\n   * @returns - the ascent of the text\n   * @private\n   */\n  Renderer.prototype.textAscent = function (txt = '') {\n    if (!txt.length) return this.fontAscent();\n    return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;\n  };\n\n  /**\n   * @returns - returns the ascent for the current font\n   * @private\n   */\n  Renderer.prototype.fontAscent = function () {\n    return this.textDrawingContext().measureText('_').fontBoundingBoxAscent;\n  };\n\n  /**\n   * @param {*} txt - optional text to measure, if provided will\n   * be used to compute the descent, otherwise the font's descent will be used\n   * @returns - the descent of the text\n   * @private\n   */\n  Renderer.prototype.textDescent = function (txt = '') {\n    if (!txt.length) return this.fontDescent();\n    return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;\n  };\n  Renderer.prototype.fontDescent = function () {\n    return this.textDrawingContext().measureText('_').fontBoundingBoxDescent;\n  };\n\n  // setters/getters for text properties //////////////////////////\n\n  Renderer.prototype.textAlign = function (h, v) {\n    // the setter\n    if (typeof h !== 'undefined') {\n      this.states.setValue('textAlign', h);\n      if (typeof v !== 'undefined') {\n        if (v === fn.CENTER) {\n          v = textCoreConstants._CTX_MIDDLE;\n        }\n        this.states.setValue('textBaseline', v);\n      }\n      return this._applyTextProperties();\n    }\n    // the getter\n    return {\n      horizontal: this.states.textAlign,\n      vertical: this.states.textBaseline\n    };\n  };\n  Renderer.prototype._currentTextFont = function () {\n    return this.states.textFont.font || this.states.textFont.family;\n  };\n\n  /**\n   * Set the font and [size] and [options] for rendering text\n   * @param {p5.Font | string} font - the font to use for rendering text\n   * @param {Number} size - the size of the text, can be a number or a css-style string\n   * @param {Object} options - additional options for rendering text, see FontProps\n   * @private\n   */\n  Renderer.prototype.textFont = function (font, size, options) {\n    if (arguments.length === 0) {\n      return this._currentTextFont();\n    }\n    let family = font;\n\n    // do we have a custon loaded font ?\n    if (font instanceof p5.Font) {\n      family = font.face.family;\n    } else if (font.data instanceof Uint8Array) {\n      family = font.name.fontFamily;\n      if (font.name?.fontSubfamily) {\n        family += '-' + font.name.fontSubfamily;\n      }\n    } else if (typeof font === 'string') {\n      // direct set the font-string if it contains size\n      if (typeof size === 'undefined' && /[.0-9]+(%|em|p[xt])/.test(family)) {\n        //console.log('direct set font-string: ', family);\n        ({\n          family,\n          size\n        } = this._directSetFontString(family));\n      }\n    }\n    if (typeof family !== 'string') throw Error('null font in textFont()');\n\n    // handle two-arg case: textFont(font, options)\n    if (arguments.length === 2 && typeof size === 'object') {\n      options = size;\n      size = undefined;\n    }\n\n    // update font properties in this.states\n    this.states.setValue('textFont', {\n      font,\n      family,\n      size\n    });\n\n    // convert/update the size in this.states\n    if (typeof size !== 'undefined') {\n      this._setTextSize(size);\n    }\n\n    // apply any options to this.states\n    if (typeof options === 'object') {\n      this.textProperties(options);\n    }\n    return this._applyTextProperties();\n  };\n  Renderer.prototype._directSetFontString = function (font, debug = 0) {\n    if (debug) console.log('_directSetFontString\"' + font + '\"');\n    let defaults = ShorthandFontProps.reduce((props, p) => {\n      props[p] = RendererTextProps[p].default;\n      return props;\n    }, {});\n    let el = this._cachedDiv(defaults);\n    el.style.font = font;\n    let style = getComputedStyle(el);\n    ShorthandFontProps.forEach(prop => {\n      this.states[prop] = style[prop];\n      if (debug) console.log('  this.states.' + prop + '=\"' + style[prop] + '\"');\n    });\n    return {\n      family: style.fontFamily,\n      size: style.fontSize\n    };\n  };\n  Renderer.prototype.textLeading = function (leading) {\n    // the setter\n    if (typeof leading === 'number') {\n      this.states.setValue('leadingSet', true);\n      this.states.setValue('textLeading', leading);\n      return this._applyTextProperties();\n    }\n    // the getter\n    return this.states.textLeading;\n  };\n  Renderer.prototype.textWeight = function (weight) {\n    // the setter\n    if (typeof weight === 'number') {\n      this.states.setValue('fontWeight', weight);\n      this._applyTextProperties();\n\n      // Safari works without weight set in the canvas style attribute, and actually\n      // has buggy behavior if it is present, using the wrong weight when drawing\n      // multiple times with different weights\n      if (!p5.prototype._isSafari()) {\n        this._setCanvasStyleProperty('font-variation-settings', `\"wght\" ${weight}`);\n      }\n      return;\n    }\n    // the getter\n    return this.states.fontWeight;\n  };\n\n  /**\n   * @param {*} size - the size of the text, can be a number or a css-style string\n   * @private\n   */\n  Renderer.prototype.textSize = function (size) {\n    // the setter\n    if (typeof size !== 'undefined') {\n      this._setTextSize(size);\n      return this._applyTextProperties();\n    }\n    // the getter\n    return this.states.textSize;\n  };\n  Renderer.prototype.textStyle = function (style) {\n    // the setter\n    if (typeof style !== 'undefined') {\n      this.states.setValue('fontStyle', style);\n      return this._applyTextProperties();\n    }\n    // the getter\n    return this.states.fontStyle;\n  };\n  Renderer.prototype.textWrap = function (wrapStyle) {\n    if (wrapStyle === fn.WORD || wrapStyle === fn.CHAR) {\n      this.states.setValue('textWrap', wrapStyle);\n      // no need to apply text properties here as not a context property\n      return this._pInst;\n    }\n    return this.states.textWrap;\n  };\n  Renderer.prototype.textDirection = function (direction) {\n    if (typeof direction !== 'undefined') {\n      this.states.setValue('direction', direction);\n      return this._applyTextProperties();\n    }\n    return this.states.direction;\n  };\n\n  /**\n   * Sets/gets a single text property for the renderer (eg. fontStyle, fontStretch, etc.)\n   * The property to be set can be a mapped or unmapped property on `this.states` or a property\n   * on `this.textDrawingContext()` or on `this.canvas.style`\n   * The property to get can exist in `this.states` or `this.textDrawingContext()` or `this.canvas.style`\n   * @private\n   */\n  Renderer.prototype.textProperty = function (prop, value, opts) {\n    let modified = false,\n      debug = opts?.debug || false;\n\n    // getter: return option from this.states or this.textDrawingContext()\n    if (typeof value === 'undefined') {\n      let props = this.textProperties();\n      if (prop in props) return props[prop];\n      throw Error('Unknown text option \"' + prop + '\"'); // FES?\n    }\n\n    // set the option in this.states if it exists\n    if (prop in this.states && this.states[prop] !== value) {\n      this.states[prop] = value;\n      modified = true;\n      if (debug) {\n        console.log('this.states.' + prop + '=\"' + options[prop] + '\"');\n      }\n    }\n    // does it exist in CanvasRenderingContext2D ?\n    else if (prop in this.textDrawingContext()) {\n      this._setContextProperty(prop, value, debug);\n      modified = true;\n    }\n    // does it exist in the canvas.style ?\n    else if (prop in this.textCanvas().style) {\n      this._setCanvasStyleProperty(prop, value, debug);\n      modified = true;\n    } else {\n      console.warn('Ignoring unknown text option: \"' + prop + '\"\\n'); // FES?\n    }\n    return modified ? this._applyTextProperties() : this._pInst;\n  };\n\n  /**\n   * Batch set/get text properties for the renderer.\n   * The properties can be either on `states` or `drawingContext`\n   * @private\n   */\n  Renderer.prototype.textProperties = function (properties) {\n    // setter\n    if (typeof properties !== 'undefined') {\n      Object.keys(properties).forEach(opt => {\n        this.textProperty(opt, properties[opt]);\n      });\n      return this._pInst;\n    }\n\n    // getter: get props from drawingContext\n    let context = this.textDrawingContext();\n    properties = ContextTextProps.reduce((props, p) => {\n      props[p] = context[p];\n      return props;\n    }, {});\n\n    // add renderer props\n    Object.keys(RendererTextProps).forEach(p => {\n      if (RendererTextProps[p]?.type === 'Context2d') {\n        properties[p] = context[p];\n      } else {\n        // a renderer.states property\n        if (p === 'textFont') {\n          // avoid circular ref. inside textFont\n          let current = this._currentTextFont();\n          if (typeof current === 'object' && '_pInst' in current) {\n            current = Object.assign({}, current);\n            delete current._pInst;\n          }\n          properties[p] = current;\n        } else {\n          properties[p] = this.states[p];\n        }\n      }\n    });\n    return properties;\n  };\n  Renderer.prototype.textMode = function () {/* no-op for processing api */};\n\n  /////////////////////////////// end API ////////////////////////////////\n\n  Renderer.prototype._currentTextFont = function () {\n    return this.states.textFont.font || this.states.textFont.family;\n  };\n\n  /*\n    Compute the bounds for a block of text based on the specified\n    measure function, either _textBoundsSingle or _fontBoundsSingle\n   * @private\n  */\n  Renderer.prototype._computeBounds = function (type, str, x, y, width, height, opts) {\n    let context = this.textDrawingContext();\n    let setBaseline = context.textBaseline;\n    let {\n      textLeading,\n      textAlign\n    } = this.states;\n\n    // adjust width, height based on current rectMode\n    ({\n      width,\n      height\n    } = this._rectModeAdjust(x, y, width, height));\n\n    // parse the lines according to the width & linebreaks\n    let lines = this._processLines(str, width, height);\n\n    // get the adjusted positions [x,y] for each line\n    let boxes = lines.map((line, i) => this[type].bind(this)(line, x, y + i * textLeading));\n\n    // adjust the bounding boxes based on horiz. text alignment\n    if (lines.length > 1) {\n      // Call the 2D mode version: the WebGL mode version does additional\n      // alignment adjustments to account for how WebGL renders text.\n      boxes.forEach(bb => bb.x += p5.Renderer2D.prototype._xAlignOffset.call(this, textAlign, width));\n    }\n\n    // adjust the bounding boxes based on vert. text alignment\n    if (typeof height !== 'undefined') {\n      // Call the 2D mode version: the WebGL mode version does additional\n      // alignment adjustments to account for how WebGL renders text.\n      p5.Renderer2D.prototype._yAlignOffset.call(this, boxes, height);\n    }\n\n    // get the bounds for the text block\n    let bounds = boxes[0];\n    if (lines.length > 1) {\n      // get the bounds for the multi-line text block\n      bounds = this._aggregateBounds(boxes);\n\n      // align the multi-line bounds\n      if (!opts?.ignoreRectMode) {\n        this._rectModeAlign(bounds, width || 0, height || 0);\n      }\n    }\n    context.textBaseline = setBaseline; // restore baseline\n\n    return {\n      bounds,\n      lines\n    };\n  };\n\n  /*\n    Adjust width, height of bounds based on current rectMode\n   * @private\n  */\n  Renderer.prototype._rectModeAdjust = function (x, y, width, height) {\n    if (typeof width !== 'undefined') {\n      switch (this.states.rectMode) {\n        case fn.CENTER:\n          break;\n        case fn.CORNERS:\n          width -= x;\n          height -= y;\n          break;\n        case fn.RADIUS:\n          width *= 2;\n          height *= 2;\n          break;\n      }\n    }\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  };\n\n  /*\n    Attempts to set a property directly on the canvas.style object\n   * @private\n  */\n  Renderer.prototype._setCanvasStyleProperty = function (opt, val, debug) {\n    let value = val.toString(); // ensure its a string\n\n    if (debug) console.log('canvas.style.' + opt + '=\"' + value + '\"');\n\n    // handle variable fonts options\n    if (opt === FontVariationSettings) {\n      this._handleFontVariationSettings(value);\n    }\n\n    // lets try to set it on the canvas style\n    this.textCanvas().style[opt] = value;\n\n    // check if the value was set successfully\n    if (this.textCanvas().style[opt] !== value) ;\n  };\n\n  /*\n    Parses the fontVariationSettings string and sets the font properties, only font-weight\n    working consistently across browsers at present\n   * @private\n  */\n  Renderer.prototype._handleFontVariationSettings = function (value, debug = false) {\n    // check if the value is a string or an object\n    if (typeof value === 'object') {\n      value = Object.keys(value).map(k => k + ' ' + value[k]).join(', ');\n    }\n    let values = value.split(CommaDelimRe);\n    values.forEach(v => {\n      v = v.replace(/[\"']/g, ''); // remove quotes\n      let matches = VariableAxesRe.exec(v);\n      //console.log('matches: ', matches);\n      if (matches && matches.length) {\n        let axis = matches[0];\n        // get the value to 3 digits of precision with no trailing zeros\n        let val = parseFloat(parseFloat(v.replace(axis, '').trim()).toFixed(3));\n        switch (axis) {\n          case 'wght':\n            if (debug) console.log('setting font-weight=' + val);\n            // manually set the font-weight via the font string\n            if (this.states.fontWeight !== val) this.textWeight(val);\n            return val;\n          case 'wdth':\n            break;\n          case 'ital':\n            if (debug) console.log('setting font-style=' + (val ? 'italic' : 'normal'));\n            break;\n          case 'slnt':\n            if (debug) console.log('setting font-style=' + (val ? 'oblique' : 'normal'));\n            break;\n          case 'opsz':\n            if (debug) console.log('setting font-optical-size=' + val);\n            break;\n        }\n      }\n    });\n  };\n\n  /*\n    For properties not directly managed by the renderer in this.states\n      we check if it has a mapping to a property in this.states\n    Otherwise, add the property to the context-queue for later application\n  */\n  Renderer.prototype._setContextProperty = function (prop, val, debug = false) {\n    // check if the value is actually different, else short-circuit\n    if (this.textDrawingContext()[prop] === val) {\n      return this._pInst;\n    }\n\n    // otherwise, we will set the property directly on the `this.textDrawingContext()`\n    // by adding [property, value] to context-queue for later application\n    (contextQueue ??= []).push([prop, val]);\n    if (debug) console.log('queued context2d.' + prop + '=\"' + val + '\"');\n  };\n\n  /*\n     Adjust parameters (x,y,w,h) based on current rectMode\n  */\n  Renderer.prototype._handleRectMode = function (x, y, width, height) {\n    let rectMode = this.states.rectMode;\n    if (typeof width !== 'undefined') {\n      switch (rectMode) {\n        case fn.RADIUS:\n          width *= 2;\n          x -= width / 2;\n          if (typeof height !== 'undefined') {\n            height *= 2;\n            y -= height / 2;\n          }\n          break;\n        case fn.CENTER:\n          x -= width / 2;\n          if (typeof height !== 'undefined') {\n            y -= height / 2;\n          }\n          break;\n        case fn.CORNERS:\n          width -= x;\n          if (typeof height !== 'undefined') {\n            height -= y;\n          }\n          break;\n      }\n    }\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  };\n\n  /*\n    Get the computed font-size in pixels for a given size string\n    @param {String} size - the font-size string to compute\n    @returns {number} - the computed font-size in pixels\n   * @private\n   */\n  Renderer.prototype._fontSizePx = function (theSize, {\n    family\n  } = this.states.textFont) {\n    const isNumString = num => !isNaN(num) && num.trim() !== '';\n\n    // check for a number in a string, eg '12'\n    if (isNumString(theSize)) {\n      return parseFloat(theSize);\n    }\n    let ele = this._cachedDiv({\n      fontSize: theSize\n    });\n    ele.style.fontSize = theSize;\n    ele.style.fontFamily = family;\n    let fontSizeStr = getComputedStyle(ele).fontSize;\n    let fontSize = parseFloat(fontSizeStr);\n    if (typeof fontSize !== 'number') {\n      throw Error('textSize: invalid font-size');\n    }\n    return fontSize;\n  };\n  Renderer.prototype._cachedDiv = function (props) {\n    if (typeof cachedDiv === 'undefined') {\n      let ele = document.createElement('div');\n      ele.ariaHidden = 'true';\n      ele.style.display = 'none';\n      Object.entries(props).forEach(([prop, val]) => {\n        ele.style[prop] = val;\n      });\n      this.textCanvas().appendChild(ele);\n      cachedDiv = ele;\n    }\n    return cachedDiv;\n  };\n\n  /*\n    Aggregate the bounding boxes of multiple lines of text\n    @param {Array} bboxes - the bounding boxes to aggregate\n    @returns {object} - the aggregated bounding box\n   * @private\n  */\n  Renderer.prototype._aggregateBounds = function (bboxes) {\n    // loop over the bounding boxes to get the min/max x/y values\n    let minX = Math.min(...bboxes.map(b => b.x));\n    let minY = Math.min(...bboxes.map(b => b.y));\n    let maxY = Math.max(...bboxes.map(b => b.y + b.h));\n    let maxX = Math.max(...bboxes.map(b => b.x + b.w));\n    return {\n      x: minX,\n      y: minY,\n      w: maxX - minX,\n      h: maxY - minY\n    };\n  };\n\n  // Renderer.prototype._aggregateBounds = function (tx, ty, bboxes) {\n  //   let x = Math.min(...bboxes.map(b => b.x));\n  //   let y = Math.min(...bboxes.map(b => b.y));\n  //   // the width is the max of the x-offset + the box width\n  //   let w = Math.max(...bboxes.map(b => (b.x - tx) + b.w));\n  //   let h = bboxes[bboxes.length - 1].y - bboxes[0].y + bboxes[bboxes.length - 1].h;\n\n  //   return { x, y, w, h };\n  // };\n\n  /*\n    Process the text string to handle line-breaks and text wrapping\n    @param {String} str - the text to process\n    @param {Number} width - the width to wrap the text to\n    @returns {array} - the processed lines of text\n   * @private\n  */\n  Renderer.prototype._processLines = function (str, width, height) {\n    if (typeof width !== 'undefined') {\n      // only for text with bounds\n      let drawingContext = this.textDrawingContext();\n      if (drawingContext.textBaseline === fn.BASELINE) {\n        this.drawingContext.textBaseline = fn.TOP;\n      }\n    }\n    let lines = this._splitOnBreaks(str.toString());\n    let hasLineBreaks = lines.length > 1;\n    let hasWidth = typeof width !== 'undefined';\n    let exceedsWidth = hasWidth && lines.some(l => this._textWidthSingle(l) > width);\n    let {\n      textLeading: leading,\n      textWrap\n    } = this.states;\n\n    //if (!hasLineBreaks && !exceedsWidth) return lines; // a single-line\n    if (hasLineBreaks || exceedsWidth) {\n      if (hasWidth) lines = this._lineate(textWrap, lines, width);\n    }\n\n    // handle height truncation\n    if (hasWidth && typeof height !== 'undefined') {\n      if (typeof leading === 'undefined') {\n        throw Error('leading is required if height is specified');\n      }\n\n      // truncate lines that exceed the height\n      for (let i = 0; i < lines.length; i++) {\n        let lh = leading * (i + 1);\n        if (lh > height) {\n          //console.log('TRUNCATING: ', i, '-', lines.length, '\"' + lines.slice(i) + '\"');\n          lines = lines.slice(0, i);\n          break;\n        }\n      }\n    }\n    return lines;\n  };\n\n  /*\n    Get the x-offset for text given the width and textAlign property\n  */\n  Renderer.prototype._xAlignOffset = function (textAlign, width) {\n    switch (textAlign) {\n      case fn.LEFT:\n        return 0;\n      case fn.CENTER:\n        return width / 2;\n      case fn.RIGHT:\n        return width;\n      case textCoreConstants.START:\n        return 0;\n      case textCoreConstants.END:\n        throw new Error('textBounds: END not yet supported for textAlign');\n      default:\n        return 0;\n    }\n  };\n\n  /*\n    Align the bounding box based on the current rectMode setting\n  */\n  Renderer.prototype._rectModeAlign = function (bb, width, height) {\n    if (typeof width !== 'undefined') {\n      switch (this.states.rectMode) {\n        case fn.CENTER:\n          bb.x -= (width - bb.w) / 2;\n          bb.y -= (height - bb.h) / 2;\n          break;\n        case fn.CORNERS:\n          bb.w += bb.x;\n          bb.h += bb.y;\n          break;\n        case fn.RADIUS:\n          bb.x -= (width - bb.w) / 2;\n          bb.y -= (height - bb.h) / 2;\n          bb.w /= 2;\n          bb.h /= 2;\n          break;\n      }\n      return bb;\n    }\n  };\n  Renderer.prototype._rectModeAlignRevert = function (bb, width, height) {\n    if (typeof width !== 'undefined') {\n      switch (this.states.rectMode) {\n        case fn.CENTER:\n          bb.x += (width - bb.w) / 2;\n          bb.y += (height - bb.h) / 2;\n          break;\n        case fn.CORNERS:\n          bb.w -= bb.x;\n          bb.h -= bb.y;\n          break;\n        case fn.RADIUS:\n          bb.x += (width - bb.w) / 2;\n          bb.y += (height - bb.h) / 2;\n          bb.w *= 2;\n          bb.h *= 2;\n          break;\n      }\n      return bb;\n    }\n  };\n\n  /*\n    Get the (tight) width of a single line of text\n  */\n  Renderer.prototype._textWidthSingle = function (s) {\n    let metrics = this.textDrawingContext().measureText(s);\n    let abl = metrics.actualBoundingBoxLeft;\n    let abr = metrics.actualBoundingBoxRight;\n    return abr + abl;\n  };\n\n  /*\n    Get the (loose) width of a single line of text as specified by the font\n  */\n  Renderer.prototype._fontWidthSingle = function (s) {\n    return this.textDrawingContext().measureText(s).width;\n  };\n\n  /*\n    Get the (tight) bounds of a single line of text based on its actual bounding box\n  */\n  Renderer.prototype._textBoundsSingle = function (s, x = 0, y = 0) {\n    let metrics = this.textDrawingContext().measureText(s);\n    let asc = metrics.actualBoundingBoxAscent;\n    let desc = metrics.actualBoundingBoxDescent;\n    let abl = metrics.actualBoundingBoxLeft;\n    let abr = metrics.actualBoundingBoxRight;\n    return {\n      x: x - abl,\n      y: y - asc,\n      w: abr + abl,\n      h: asc + desc\n    };\n  };\n\n  /*\n    Get the (loose) bounds of a single line of text based on its font's bounding box\n  */\n  Renderer.prototype._fontBoundsSingle = function (s, x = 0, y = 0) {\n    let metrics = this.textDrawingContext().measureText(s);\n    let asc = metrics.fontBoundingBoxAscent;\n    let desc = metrics.fontBoundingBoxDescent;\n    x -= this._xAlignOffset(this.states.textAlign, metrics.width);\n    return {\n      x,\n      y: y - asc,\n      w: metrics.width,\n      h: asc + desc\n    };\n  };\n\n  /*\n    Set the textSize property in `this.states` if it has changed\n    @param {number | string} theSize - the font-size to set\n    @returns {boolean} - true if the size was changed, false otherwise\n   */\n  Renderer.prototype._setTextSize = function (theSize) {\n    if (typeof theSize === 'string') {\n      // parse the size string via computed style, eg '2em'\n      theSize = this._fontSizePx(theSize);\n    }\n\n    // should be a number now\n    if (typeof theSize === 'number') {\n      // set it in `this.states` if its been changed\n      if (this.states.textSize !== theSize) {\n        this.states.setValue('textSize', theSize);\n\n        // handle leading here, if not set otherwise\n        if (!this.states.leadingSet) {\n          this.states.setValue('textLeading', this.states.textSize * LeadingScale);\n        }\n        return true; // size was changed\n      }\n    } else {\n      console.warn('textSize: invalid size: ' + theSize);\n    }\n    return false;\n  };\n\n  /*\n    Split the lines of text based on the width and the textWrap property\n    @param {Array} lines - the lines of text to split\n    @param {Number} maxWidth - the maximum width of the lines\n    @param {Object} opts - additional options for splitting the lines\n    @returns {array} - the split lines of text\n   * @private\n  */\n  Renderer.prototype._lineate = function (textWrap, lines, maxWidth = Infinity, opts = {}) {\n    let splitter = opts.splitChar ?? (textWrap === fn.WORD ? ' ' : '');\n    let line,\n      testLine,\n      testWidth,\n      words,\n      newLines = [];\n    for (let lidx = 0; lidx < lines.length; lidx++) {\n      line = '';\n      words = lines[lidx].split(splitter);\n      for (let widx = 0; widx < words.length; widx++) {\n        testLine = `${line + words[widx]}` + splitter;\n        testWidth = this._textWidthSingle(testLine);\n        if (line.length > 0 && testWidth > maxWidth) {\n          newLines.push(line.trim());\n          line = `${words[widx]}` + splitter;\n        } else {\n          line = testLine;\n        }\n      }\n      newLines.push(line.trim());\n    }\n    return newLines;\n  };\n\n  /*\n    Split the text into lines based on line-breaks and tabs\n  */\n  Renderer.prototype._splitOnBreaks = function (s) {\n    if (!s || s.length === 0) return [''];\n    return s.replace(TabsRe, '  ').split(LinebreakRe);\n  };\n\n  /*\n    Parse the font-family string to handle complex names, fallbacks, etc.\n  */\n  Renderer.prototype._parseFontFamily = function (familyStr) {\n    let parts = familyStr.split(CommaDelimRe);\n    let family = parts.map(part => {\n      part = part.trim();\n      if (part.indexOf(' ') > -1 && !QuotedRe.test(part)) {\n        part = `\"${part}\"`; // quote font names with spaces\n      }\n      return part;\n    }).join(', ');\n    return family;\n  };\n  Renderer.prototype._applyFontString = function () {\n    /*\n      Create the font-string according to the CSS font-string specification:\n      If font is specified as a shorthand for several font-related properties, then:\n      - it must include values for: <font-size> and <font-family>\n      - it may optionally include values for:\n          [<font-style>, <font-variant>, <font-weight>, <font-stretch>, <line-height>]\n      Format:\n      - font-style, font-variant and font-weight must precede font-size\n      - font-variant may only specify the values defined in CSS 2.1, that is 'normal' and 'small-caps'.\n      - font-stretch may only be a single keyword value.\n      - line-height must immediately follow font-size, preceded by \"/\", eg 16px/3.\n      - font-family must be the last value specified.\n    */\n    let {\n      textFont,\n      textSize,\n      lineHeight,\n      fontStyle,\n      fontWeight,\n      fontVariant\n    } = this.states;\n    let drawingContext = this.textDrawingContext();\n    let family = this._parseFontFamily(textFont.family);\n    let style = fontStyle !== fn.NORMAL ? `${fontStyle} ` : '';\n    let weight = fontWeight !== fn.NORMAL ? `${fontWeight} ` : '';\n    let variant = fontVariant !== fn.NORMAL ? `${fontVariant} ` : '';\n    let fsize = `${textSize}px` + (lineHeight !== fn.NORMAL ? `/${lineHeight} ` : ' ');\n    let fontString = `${style}${variant}${weight}${fsize}${family}`.trim();\n    //console.log('fontString=\"' + fontString + '\"');\n\n    // set the font string on the context\n    drawingContext.font = fontString;\n\n    // verify that it was set successfully\n    if (drawingContext.font !== fontString) {\n      let expected = fontString;\n      let actual = drawingContext.font;\n      if (expected !== actual) {\n        //console.warn(`Unable to set font property on context2d. It may not be supported.`);\n        //console.log('Expected \"' + expected + '\" but got: \"' + actual + '\"'); // TMP\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /*\n    Apply the text properties in `this.states` to the `this.textDrawingContext()`\n    Then apply any properties in the context-queue\n   */\n  Renderer.prototype._applyTextProperties = function (debug = false) {\n    this._applyFontString();\n\n    // set these after the font so they're not overridden\n    let context = this.textDrawingContext();\n    context.direction = this.states.direction;\n    context.textAlign = this.states.textAlign;\n    context.textBaseline = this.states.textBaseline;\n\n    // set manually as (still) not fully supported as part of font-string\n    let stretch = this.states.fontStretch;\n    if (FontStretchKeys.includes(stretch) && context.fontStretch !== stretch) {\n      context.fontStretch = stretch;\n    }\n\n    // apply each property in queue after the font so they're not overridden\n    while (contextQueue?.length) {\n      let [prop, val] = contextQueue.shift();\n      if (debug) console.log('apply context property \"' + prop + '\" = \"' + val + '\"');\n      context[prop] = val;\n\n      // check if the value was set successfully\n      if (context[prop] !== val) {\n        console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`); // FES?\n        console.log('Expected \"' + val + '\" but got: \"' + context[prop] + '\"');\n      }\n    }\n    return this._pInst;\n  };\n  if (p5.Renderer2D) {\n    p5.Renderer2D.prototype.textCanvas = function () {\n      return this.canvas;\n    };\n    p5.Renderer2D.prototype.textDrawingContext = function () {\n      return this.drawingContext;\n    };\n    p5.Renderer2D.prototype._renderText = function (text, x, y, maxY, minY) {\n      let states = this.states;\n      let context = this.textDrawingContext();\n      if (y < minY || y >= maxY) {\n        return; // don't render lines beyond minY/maxY\n      }\n      this.push();\n\n      // no stroke unless specified by user\n      if (states.strokeColor && states.strokeSet) {\n        context.strokeText(text, x, y);\n      }\n      if (!this._clipping && states.fillColor) {\n        // if fill hasn't been set by user, use default text fill\n        if (!states.fillSet) {\n          this._setFill(DefaultFill);\n        }\n        context.fillText(text, x, y);\n      }\n      this.pop();\n    };\n\n    /*\n      Position the lines of text based on their textAlign/textBaseline properties\n    */\n    p5.Renderer2D.prototype._positionLines = function (x, y, width, height, lines) {\n      let {\n        textLeading,\n        textAlign\n      } = this.states;\n      let adjustedX,\n        lineData = new Array(lines.length);\n      let adjustedW = typeof width === 'undefined' ? 0 : width;\n      let adjustedH = typeof height === 'undefined' ? 0 : height;\n      for (let i = 0; i < lines.length; i++) {\n        switch (textAlign) {\n          case textCoreConstants.START:\n            throw new Error('textBounds: START not yet supported for textAlign');\n          // default to LEFT\n          case fn.LEFT:\n            adjustedX = x;\n            break;\n          case fn.CENTER:\n            adjustedX = x + adjustedW / 2;\n            break;\n          case fn.RIGHT:\n            adjustedX = x + adjustedW;\n            break;\n          case textCoreConstants.END:\n            throw new Error('textBounds: END not yet supported for textAlign');\n        }\n        lineData[i] = {\n          text: lines[i],\n          x: adjustedX,\n          y: y + i * textLeading\n        };\n      }\n      return this._yAlignOffset(lineData, adjustedH);\n    };\n\n    /*\n      Get the y-offset for text given the height, leading, line-count and textBaseline property\n    */\n    p5.Renderer2D.prototype._yAlignOffset = function (dataArr, height) {\n      if (typeof height === 'undefined') {\n        throw Error('_yAlignOffset: height is required');\n      }\n      let {\n        textLeading,\n        textBaseline\n      } = this.states;\n      let yOff = 0,\n        numLines = dataArr.length;\n      let ydiff = height - textLeading * (numLines - 1);\n      switch (textBaseline) {\n        // drawingContext ?\n        case fn.TOP:\n          break;\n        // ??\n        case fn.BASELINE:\n          break;\n        case textCoreConstants._CTX_MIDDLE:\n          yOff = ydiff / 2;\n          break;\n        case fn.BOTTOM:\n          yOff = ydiff;\n          break;\n        case textCoreConstants.IDEOGRAPHIC:\n          console.warn('textBounds: IDEOGRAPHIC not yet supported for textBaseline'); // FES?\n          break;\n        case textCoreConstants.HANGING:\n          console.warn('textBounds: HANGING not yet supported for textBaseline'); // FES?\n          break;\n      }\n      dataArr.forEach(ele => ele.y += yOff);\n      return dataArr;\n    };\n  }\n  if (p5.RendererGL) {\n    p5.RendererGL.prototype.textCanvas = function () {\n      if (!this._textCanvas) {\n        this._textCanvas = document.createElement('canvas');\n        this._textCanvas.width = 1;\n        this._textCanvas.height = 1;\n        this._textCanvas.style.display = 'none';\n        // Has to be added to the DOM for measureText to work properly!\n        this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);\n      }\n      return this._textCanvas;\n    };\n    p5.RendererGL.prototype.textDrawingContext = function () {\n      if (!this._textDrawingContext) {\n        const textCanvas = this.textCanvas();\n        this._textDrawingContext = textCanvas.getContext('2d');\n      }\n      return this._textDrawingContext;\n    };\n    const oldRemove = p5.RendererGL.prototype.remove;\n    p5.RendererGL.prototype.remove = function () {\n      if (this._textCanvas) {\n        this._textCanvas.parentElement.removeChild(this._textCanvas);\n      }\n      oldRemove.call(this);\n    };\n    p5.RendererGL.prototype._positionLines = function (x, y, width, height, lines) {\n      let {\n        textLeading,\n        textAlign\n      } = this.states;\n      const widths = lines.map(line => this._fontWidthSingle(line));\n      let adjustedX,\n        lineData = new Array(lines.length);\n      let adjustedW = typeof width === 'undefined' ? Math.max(0, ...widths) : width;\n      let adjustedH = typeof height === 'undefined' ? 0 : height;\n      for (let i = 0; i < lines.length; i++) {\n        switch (textAlign) {\n          case textCoreConstants.START:\n            throw new Error('textBounds: START not yet supported for textAlign');\n          // default to LEFT\n          case fn.LEFT:\n            adjustedX = x;\n            break;\n          case fn.CENTER:\n            adjustedX = x + (adjustedW - widths[i]) / 2 - adjustedW / 2 + (width || 0) / 2;\n            break;\n          case fn.RIGHT:\n            adjustedX = x + adjustedW - widths[i] - adjustedW + (width || 0);\n            break;\n          case textCoreConstants.END:\n            throw new Error('textBounds: END not yet supported for textAlign');\n        }\n        lineData[i] = {\n          text: lines[i],\n          x: adjustedX,\n          y: y + i * textLeading\n        };\n      }\n      return this._yAlignOffset(lineData, adjustedH);\n    };\n    p5.RendererGL.prototype._yAlignOffset = function (dataArr, height) {\n      if (typeof height === 'undefined') {\n        throw Error('_yAlignOffset: height is required');\n      }\n      let {\n        textLeading,\n        textBaseline,\n        textSize,\n        textFont\n      } = this.states;\n      let yOff = 0,\n        numLines = dataArr.length;\n      let totalHeight = textSize * numLines + (textLeading - textSize) * (numLines - 1);\n      switch (textBaseline) {\n        // drawingContext ?\n        case fn.TOP:\n          yOff = textSize;\n          break;\n        case fn.BASELINE:\n          break;\n        case textCoreConstants._CTX_MIDDLE:\n          yOff = -totalHeight / 2 + textSize + (height || 0) / 2;\n          break;\n        case fn.BOTTOM:\n          yOff = -(totalHeight - textSize) + (height || 0);\n          break;\n        default:\n          console.warn(`${textBaseline} is not supported in WebGL mode.`); // FES?\n          break;\n      }\n      yOff += this.states.textFont.font?._verticalAlign(textSize) || 0; // Does this function exist?\n      dataArr.forEach(ele => ele.y += yOff);\n      return dataArr;\n    };\n  }\n}\nif (typeof p5 !== 'undefined') {\n  textCore(p5, p5.prototype);\n}\nexport { textCore as default, textCoreConstants };","map":{"version":3,"names":["R","Renderer","textCoreConstants","IDEOGRAPHIC","RIGHT_TO_LEFT","LEFT_TO_RIGHT","_CTX_MIDDLE","_TEXT_BOUNDS","_FONT_BOUNDS","HANGING","START","END","textCore","p5","fn","LeadingScale","DefaultFill","LinebreakRe","CommaDelimRe","QuotedRe","TabsRe","FontVariationSettings","VariableAxes","VariableAxesRe","RegExp","join","textFunctions","forEach","func","args","prototype","Error","_renderer","Graphics","RendererTextProps","textAlign","default","LEFT","type","textBaseline","BASELINE","textFont","family","textLeading","textSize","textWrap","WORD","fontStretch","NORMAL","isShorthand","fontWeight","lineHeight","fontVariant","fontStyle","direction","ContextTextProps","ShorthandFontProps","Object","keys","filter","p","FontStretchKeys","contextQueue","cachedDiv","text","str","x","y","width","height","setBaseline","textDrawingContext","_handleRectMode","lines","_processLines","_positionLines","line","_renderText","textBounds","_computeBounds","bounds","fontBounds","textWidth","theText","Math","max","map","l","_textWidthSingle","fontWidth","_fontWidthSingle","textAscent","txt","length","fontAscent","measureText","actualBoundingBoxAscent","fontBoundingBoxAscent","textDescent","fontDescent","actualBoundingBoxDescent","fontBoundingBoxDescent","h","v","states","setValue","CENTER","_applyTextProperties","horizontal","vertical","_currentTextFont","font","size","options","arguments","Font","face","data","Uint8Array","name","fontFamily","fontSubfamily","test","_directSetFontString","undefined","_setTextSize","textProperties","debug","console","log","defaults","reduce","props","el","_cachedDiv","style","getComputedStyle","prop","fontSize","leading","textWeight","weight","_isSafari","_setCanvasStyleProperty","textStyle","wrapStyle","CHAR","_pInst","textDirection","textProperty","value","opts","modified","_setContextProperty","textCanvas","warn","properties","opt","context","current","assign","textMode","_rectModeAdjust","boxes","i","bind","bb","Renderer2D","_xAlignOffset","call","_yAlignOffset","_aggregateBounds","ignoreRectMode","_rectModeAlign","rectMode","CORNERS","RADIUS","val","toString","_handleFontVariationSettings","k","values","split","replace","matches","exec","axis","parseFloat","trim","toFixed","push","_fontSizePx","theSize","isNumString","num","isNaN","ele","fontSizeStr","document","createElement","ariaHidden","display","entries","appendChild","bboxes","minX","min","b","minY","maxY","maxX","w","drawingContext","TOP","_splitOnBreaks","hasLineBreaks","hasWidth","exceedsWidth","some","_lineate","lh","slice","RIGHT","_rectModeAlignRevert","s","metrics","abl","actualBoundingBoxLeft","abr","actualBoundingBoxRight","_textBoundsSingle","asc","desc","_fontBoundsSingle","leadingSet","maxWidth","Infinity","splitter","splitChar","testLine","testWidth","words","newLines","lidx","widx","_parseFontFamily","familyStr","parts","part","indexOf","_applyFontString","variant","fsize","fontString","expected","actual","stretch","includes","shift","canvas","strokeColor","strokeSet","strokeText","_clipping","fillColor","fillSet","_setFill","fillText","pop","adjustedX","lineData","Array","adjustedW","adjustedH","dataArr","yOff","numLines","ydiff","BOTTOM","RendererGL","_textCanvas","parentElement","insertBefore","_textDrawingContext","getContext","oldRemove","remove","removeChild","widths","totalHeight","_verticalAlign"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/type/textCore.js"],"sourcesContent":["import { R as Renderer } from '../p5.Renderer-R23xoC7s.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../constants-BRcElHU3.js';\nimport '../image/filters.js';\nimport '../math/p5.Vector.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\n\n/**\n * @module Typography\n * @requires core\n */\n\n\nconst textCoreConstants = {\n  IDEOGRAPHIC: 'ideographic',\n  RIGHT_TO_LEFT: 'rtl',\n  LEFT_TO_RIGHT: 'ltr',\n  _CTX_MIDDLE: 'middle',\n  _TEXT_BOUNDS: '_textBoundsSingle',\n  _FONT_BOUNDS: '_fontBoundsSingle',\n  HANGING: 'hanging',\n  START: 'start',\n  END: 'end',\n};\n\nfunction textCore(p5, fn) {\n  const LeadingScale = 1.275;\n  const DefaultFill = '#000000';\n  const LinebreakRe = /\\r?\\n/g;\n  const CommaDelimRe = /,\\s+/;\n  const QuotedRe = /^\".*\"$/;\n  const TabsRe = /\\t/g;\n\n  const FontVariationSettings = 'fontVariationSettings';\n  const VariableAxes = ['wght', 'wdth', 'ital', 'slnt', 'opsz'];\n  const VariableAxesRe = new RegExp(`(?:${VariableAxes.join('|')})`);\n\n  const textFunctions = [\n    'text',\n    'textAlign',\n    'textAscent',\n    'textDescent',\n    'textLeading',\n    'textMode',\n    'textFont',\n    'textSize',\n    'textStyle',\n    'textWidth',\n    'textWrap',\n    'textBounds',\n    'textDirection',\n    'textProperty',\n    'textProperties',\n    'fontBounds',\n    'fontWidth',\n    'fontAscent',\n    'fontDescent',\n    'textWeight'\n  ];\n\n  /**\n   * Draws text to the canvas.\n   *\n   * The first parameter, `str`, is the text to be drawn. The second and third\n   * parameters, `x` and `y`, set the coordinates of the text's bottom-left\n   * corner. See <a href=\"#/p5/textAlign\">textAlign()</a> for other ways to\n   * align text.\n   *\n   * The fourth and fifth parameters, `maxWidth` and `maxHeight`, are optional.\n   * They set the dimensions of the invisible rectangle containing the text. By\n   * default, they set its  maximum width and height. See\n   * <a href=\"#/p5/rectMode\">rectMode()</a> for other ways to define the\n   * rectangular text box. Text will wrap to fit within the text box. Text\n   * outside of the box won't be drawn.\n   *\n   * Text can be styled a few ways. Call the <a href=\"#/p5/fill\">fill()</a>\n   * function to set the text's fill color. Call\n   * <a href=\"#/p5/stroke\">stroke()</a> and\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> to set the text's outline.\n   * Call <a href=\"#/p5/textSize\">textSize()</a> and\n   * <a href=\"#/p5/textFont\">textFont()</a> to set the text's size and font,\n   * respectively.\n   *\n   * Note: `WEBGL` mode only supports fonts loaded with\n   * <a href=\"#/p5/loadFont\">loadFont()</a>. Calling\n   * <a href=\"#/p5/stroke\">stroke()</a> has no effect in `WEBGL` mode.\n   *\n   * @method text\n   * @param {String|Object|Array|Number|Boolean} str text to be displayed.\n   * @param {Number} x          x-coordinate of the text box.\n   * @param {Number} y          y-coordinate of the text box.\n   * @param {Number} [maxWidth] maximum width of the text box. See\n   *                            <a href=\"#/p5/rectMode\">rectMode()</a> for\n   *                            other options.\n   * @param {Number} [maxHeight] maximum height of the text box. See\n   *                            <a href=\"#/p5/rectMode\">rectMode()</a> for\n   *                            other options.\n   *\n   * @for p5\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   text('hi', 50, 50);\n   *\n   *   describe('The text \"hi\" written in black in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background('skyblue');\n   *   textSize(100);\n   *   text('üåà', 0, 100);\n   *\n   *   describe('A rainbow in a blue sky.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   textSize(32);\n   *   fill(255);\n   *   stroke(0);\n   *   strokeWeight(4);\n   *   text('hi', 50, 50);\n   *\n   *   describe('The text \"hi\" written in white with a black outline.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background('black');\n   *   textSize(22);\n   *   fill('yellow');\n   *   text('rainbows', 6, 20);\n   *   fill('cornflowerblue');\n   *   text('rainbows', 6, 45);\n   *   fill('tomato');\n   *   text('rainbows', 6, 70);\n   *   fill('limegreen');\n   *   text('rainbows', 6, 95);\n   *\n   *   describe('The text \"rainbows\" written on several lines, each in a different color.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   let s = 'The quick brown fox jumps over the lazy dog.';\n   *   text(s, 10, 10, 70, 80);\n   *\n   *   describe('The sample text \"The quick brown fox...\" written in black across several lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   rectMode(CENTER);\n   *   let s = 'The quick brown fox jumps over the lazy dog.';\n   *   text(s, 50, 50, 70, 80);\n   *\n   *   describe('The sample text \"The quick brown fox...\" written in black across several lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div modernizr='webgl'>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *   font = await loadFont('assets/inconsolata.otf');\n   *   textFont(font);\n   *   textSize(32);\n   *   textAlign(CENTER, CENTER);\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   rotateY(frameCount / 30);\n   *   text('p5*js', 0, 0);\n   *\n   *   describe('The text \"p5*js\" written in white and spinning in 3D.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets the way text is aligned when <a href=\"#/p5/text\">text()</a> is called.\n   *\n   * By default, calling `text('hi', 10, 20)` places the bottom-left corner of\n   * the text's bounding box at (10, 20).\n   *\n   * The first parameter, `horizAlign`, changes the way\n   * <a href=\"#/p5/text\">text()</a> interprets x-coordinates. By default, the\n   * x-coordinate sets the left edge of the bounding box. `textAlign()` accepts\n   * the following values for `horizAlign`: `LEFT`, `CENTER`, or `RIGHT`.\n   *\n   * The second parameter, `vertAlign`, is optional. It changes the way\n   * <a href=\"#/p5/text\">text()</a> interprets y-coordinates. By default, the\n   * y-coordinate sets the bottom edge of the bounding box. `textAlign()`\n   * accepts the following values for `vertAlign`: `TOP`, `BOTTOM`, `CENTER`,\n   * or `BASELINE`.\n   *\n   * @method textAlign\n   * @for p5\n   * @param {LEFT|CENTER|RIGHT} horizAlign horizontal alignment\n   * @param {TOP|BOTTOM|CENTER|BASELINE} [vertAlign] vertical alignment\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Draw a vertical line.\n   *   strokeWeight(0.5);\n   *   line(50, 0, 50, 100);\n   *\n   *   // Top line.\n   *   textSize(16);\n   *   textAlign(RIGHT);\n   *   text('ABCD', 50, 30);\n   *\n   *   // Middle line.\n   *   textAlign(CENTER);\n   *   text('EFGH', 50, 50);\n   *\n   *   // Bottom line.\n   *   textAlign(LEFT);\n   *   text('IJKL', 50, 70);\n   *\n   *   describe('The letters ABCD displayed at top-left, EFGH at center, and IJKL at bottom-right. A vertical line divides the canvas in half.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   strokeWeight(0.5);\n   *\n   *   // First line.\n   *   line(0, 12, width, 12);\n   *   textAlign(CENTER, TOP);\n   *   text('TOP', 50, 12);\n   *\n   *   // Second line.\n   *   line(0, 37, width, 37);\n   *   textAlign(CENTER, CENTER);\n   *   text('CENTER', 50, 37);\n   *\n   *   // Third line.\n   *   line(0, 62, width, 62);\n   *   textAlign(CENTER, BASELINE);\n   *   text('BASELINE', 50, 62);\n   *\n   *   // Fourth line.\n   *   line(0, 97, width, 97);\n   *   textAlign(CENTER, BOTTOM);\n   *   text('BOTTOM', 50, 97);\n   *\n   *   describe('The words \"TOP\", \"CENTER\", \"BASELINE\", and \"BOTTOM\" each drawn relative to a horizontal line. Their positions demonstrate different vertical alignments.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Returns the ascent of the text.\n   *\n   * The `textAscent()` function calculates the distance from the baseline to the\n   * highest point of the current font. This value represents the ascent, which is essential\n   * for determining the overall height of the text along with `textDescent()`. If\n   * a text string is provided as an argument, the ascent is calculated based on that specific\n   * string; otherwise, the ascent of the current font is returned.\n   *\n   * @method textAscent\n   * @for p5\n   *\n   * @param {String} [txt] - (Optional) The text string for which to calculate the ascent.\n   *                         If omitted, the function returns the ascent for the current font.\n   * @returns {Number} The ascent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(400, 300);\n   *   background(220);\n   *\n   *   textSize(48);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the ascent of the current font\n   *   let asc = textAscent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the ascent position\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y - asc, x + 200, y - asc); // Ascent (top of text)\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"textAscent: \" + asc.toFixed(2) + \" pixels\", x, y - asc - 10);\n   * }\n   * </code>\n   * </div>\n   *\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup()  {\n   *   font = await loadFont('assets/inconsolata.otf');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textFont(font);\n   *\n   *   // Different for each font.\n   *   let fontScale = 0.8;\n   *\n   *   let baseY = 75;\n   *   strokeWeight(0.5);\n   *\n   *   // Draw small text.\n   *   textSize(24);\n   *   text('dp', 0, baseY);\n   *\n   *   // Draw baseline and ascent.\n   *   let a = textAscent() * fontScale;\n   *   line(0, baseY, 23, baseY);\n   *   line(23, baseY - a, 23, baseY);\n   *\n   *   // Draw large text.\n   *   textSize(48);\n   *   text('dp', 45, baseY);\n   *\n   *   // Draw baseline and ascent.\n   *   a = textAscent() * fontScale;\n   *   line(45, baseY, 91, baseY);\n   *   line(91, baseY - a, 91, baseY);\n   *\n   *   describe('The letters \"dp\" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends upward from each baseline to the top of the \"d\".');\n   * }\n   * </code>\n   * </div>\n   */\n\n\n  /**\n   * Returns the descent of the text.\n   *\n   * The `textDescent()` function calculates the distance from the baseline to the\n   * lowest point of the current font. This value represents the descent, which, when combined\n   * with the ascent (from `textAscent()`), determines the overall vertical span of the text.\n   * If a text string is provided as an argument, the descent is calculated based on that specific string;\n   * otherwise, the descent of the current font is returned.\n   *\n   * @method textDescent\n   * @for p5\n   *\n   * @param {String} [txt] - (Optional) The text string for which to calculate the descent.\n   *                         If omitted, the function returns the descent for the current font.\n   * @returns {Number} The descent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(400, 300);\n   *   background(220);\n   *\n   *   textSize(48);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the descent of the current font\n   *   let desc = textDescent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the bottom of the text\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y + desc, x + 200, y + desc); // Descent (bottom of text)\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"textDescent: \" + desc.toFixed(2) + \" pixels\", x, y + desc + 20);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup()  {\n   *   font = await loadFont('assets/inconsolata.otf');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the font.\n   *   textFont(font);\n   *\n   *   // Different for each font.\n   *   let fontScale = 0.9;\n   *\n   *   let baseY = 75;\n   *   strokeWeight(0.5);\n   *\n   *   // Draw small text.\n   *   textSize(24);\n   *   text('dp', 0, baseY);\n   *\n   *   // Draw baseline and descent.\n   *   let d = textDescent() * fontScale;\n   *   line(0, baseY, 23, baseY);\n   *   line(23, baseY, 23, baseY + d);\n   *\n   *   // Draw large text.\n   *   textSize(48);\n   *   text('dp', 45, baseY);\n   *\n   *   // Draw baseline and descent.\n   *   d = textDescent() * fontScale;\n   *   line(45, baseY, 91, baseY);\n   *   line(91, baseY, 91, baseY + d);\n   *\n   *   describe('The letters \"dp\" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends downward from each baseline to the bottom of the \"p\".');\n   * }\n   * </code>\n   * </div>\n   */\n\n/**\n * Sets the spacing between lines of text when\n * <a href=\"#/p5/text\">text()</a> is called.\n *\n * Note: Spacing is measured in pixels.\n *\n * Calling `textLeading()` without an argument returns the current spacing.\n *\n * @method textLeading\n * @for p5\n * @param {Number} leading The new text leading to apply, in pixels\n * @returns {Number} If no arguments are provided, the current text leading\n *\n * @example\n * <div>\n * <code>\n * function setup() {\n *   createCanvas(100, 100);\n *\n *   background(200);\n *\n *   // \"\\n\" starts a new line of text.\n *   let lines = 'one\\ntwo';\n *\n *   // Left.\n *   text(lines, 10, 25);\n *\n *   // Right.\n *   textLeading(30);\n *   text(lines, 70, 25);\n *\n *   describe('The words \"one\" and \"two\" written on separate lines twice. The words on the left have less vertical spacing than the words on the right.');\n * }\n * </code>\n * </div>\n */\n /*\n  * @method textLeading\n  * @for p5\n  */\n\n  /**\n   * Sets the font used by the <a href=\"#/p5/text\">text()</a> function.\n   *\n   * The first parameter, `font`, sets the font. `textFont()` recognizes either\n   * a <a href=\"#/p5.Font\">p5.Font</a> object or a string with the name of a\n   * system font. For example, `'Courier New'`.\n   *\n   * The second parameter, `size`, is optional. It sets the font size in pixels.\n   * This has the same effect as calling <a href=\"#/p5/textSize\">textSize()</a>.\n   *\n   * Note: `WEBGL` mode only supports fonts loaded with\n   * <a href=\"#/p5/loadFont\">loadFont()</a>.\n   *\n   * @method textFont\n   * @param {p5.Font|String|Object} font The font to apply\n   * @param {Number} [size] An optional text size to apply.\n   * @for p5\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   textFont('Courier New');\n   *   textSize(24);\n   *   text('hi', 35, 55);\n   *\n   *   describe('The text \"hi\" written in a black, monospace font on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background('black');\n   *   fill('palegreen');\n   *   textFont('Courier New', 10);\n   *   text('You turn to the left and see a door. Do you enter?', 5, 5, 90, 90);\n   *   text('>', 5, 70);\n   *\n   *   describe('A text prompt from a game is written in a green, monospace font on a black background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   *   textFont('Verdana');\n   *   let currentFont = textFont();\n   *   text(currentFont, 25, 50);\n   *\n   *   describe('The text \"Verdana\" written in a black, sans-serif font on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * let fontRegular;\n   * let fontItalic;\n   * let fontBold;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   fontRegular = await loadFont('assets/Regular.otf');\n   *   fontItalic = await loadFont('assets/Italic.ttf');\n   *   fontBold = await loadFont('assets/Bold.ttf');\n   *\n   *   background(200);\n   *   textFont(fontRegular);\n   *   text('I am Normal', 10, 30);\n   *   textFont(fontItalic);\n   *   text('I am Italic', 10, 50);\n   *   textFont(fontBold);\n   *   text('I am Bold', 10, 70);\n   *\n   *   describe('The statements \"I am Normal\", \"I am Italic\", and \"I am Bold\" written in black on separate lines. The statements have normal, italic, and bold fonts, respectively.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets or gets the current text size.\n   *\n   * The `textSize()` function is used to specify the size of the text\n   * that will be rendered on the canvas. When called with an argument, it sets the\n   * text size to the specified value (which can be a number representing pixels or a\n   * CSS-style string, e.g., '32px', '2em'). When called without an argument, it\n   * returns the current text size in pixels.\n   *\n   * @method textSize\n   * @for p5\n   *\n   * @param {Number} size - The size to set for the text.\n   * @returns {Number} If no arguments are provided, the current text size in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(600, 200);\n   *   background(240);\n   *\n   *   // Set the text size to 48 pixels\n   *   textSize(48);\n   *   textAlign(CENTER, CENTER);\n   *   textFont(\"Georgia\");\n   *\n   *   // Draw text using the current text size\n   *   fill(0);\n   *   text(\"Hello, p5.js!\", width / 2, height / 2);\n   *\n   *   // Retrieve and display the current text size\n   *   let currentSize = textSize();\n   *   fill(50);\n   *   textSize(16);\n   *   text(\"Current text size: \" + currentSize, width / 2, height - 20);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top.\n   *   textSize(12);\n   *   text('Font Size 12', 10, 30);\n   *\n   *   // Middle.\n   *   textSize(14);\n   *   text('Font Size 14', 10, 60);\n   *\n   *   // Bottom.\n   *   textSize(16);\n   *   text('Font Size 16', 10, 90);\n   *\n   *   describe('The text \"Font Size 12\" drawn small, \"Font Size 14\" drawn medium, and \"Font Size 16\" drawn large.');\n   * }\n   * </code>\n   * </div>\n   */\n   /**\n    * @method textSize\n    * @for p5\n    * @returns {Number} The current text size in pixels.\n    */\n\n  /**\n   * Sets the style for system fonts when\n   * <a href=\"#/p5/text\">text()</a> is called.\n   *\n   * The parameter, `style`, can be either `NORMAL`, `ITALIC`, `BOLD`, or\n   * `BOLDITALIC`.\n   *\n   * `textStyle()` may be overridden by CSS styling. This function doesn't\n   * affect fonts loaded with <a href=\"#/p5/loadFont\">loadFont()</a>.\n   *\n   * @method textStyle\n   * @for p5\n   * @param {NORMAL|ITALIC|BOLD|BOLDITALIC} style The style to use\n   * @returns {NORMAL|ITALIC|BOLD|BOLDITALIC} If no arguments are provided, the current style\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(12);\n   *   textAlign(CENTER);\n   *\n   *   // First row.\n   *   textStyle(NORMAL);\n   *   text('Normal', 50, 15);\n   *\n   *   // Second row.\n   *   textStyle(ITALIC);\n   *   text('Italic', 50, 40);\n   *\n   *   // Third row.\n   *   textStyle(BOLD);\n   *   text('Bold', 50, 65);\n   *\n   *   // Fourth row.\n   *   textStyle(BOLDITALIC);\n   *   text('Bold Italic', 50, 90);\n   *\n   *   describe('The words \"Normal\" displayed normally, \"Italic\" in italic, \"Bold\" in bold, and \"Bold Italic\" in bold italics.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textStyle\n   * @for p5\n   * @returns {NORMAL|BOLD|ITALIC|BOLDITALIC}\n   */\n\n\n  /**\n   * Calculates the width of the given text string in pixels.\n   *\n   * The `textWidth()` function processes the provided text string to determine its tight bounding box\n   * based on the current text properties such as font, textSize, and textStyle. Internally, it splits\n   * the text into individual lines (if line breaks are present) and computes the bounding box for each\n   * line using the renderer‚Äôs measurement functions. The final width is determined as the maximum width\n   * among all these lines.\n   *\n   * For example, if the text contains multiple lines due to wrapping or explicit line breaks, textWidth()\n   * will return the width of the longest line.\n   *\n   * @method textWidth\n   * @for p5\n   * @param {String} text The text to measure\n   * @returns {Number} The width of the text\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(200, 200);\n   *   background(220);\n   *\n   *   // Set text size and alignment\n   *   textSize(48);\n   *   textAlign(LEFT, TOP);\n   *\n   *   let myText = \"Hello\";\n   *\n   *   // Calculate the width of the text\n   *   let tw = textWidth(myText);\n   *\n   *   // Draw the text on the canvas\n   *   fill(0);\n   *   text(myText, 50, 50);\n   *\n   *   // Display the text width below\n   *   noStroke();\n   *   fill(0);\n   *   textSize(20);\n   *   text(\"Text width: \" + tw, 10, 150);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(28);\n   *   strokeWeight(0.5);\n   *\n   *   // Calculate the text width.\n   *   let s = 'yoyo';\n   *   let w = textWidth(s);\n   *\n   *   // Display the text.\n   *   text(s, 22, 55);\n   *\n   *   // Underline the text.\n   *   line(22, 55, 22 + w, 55);\n   *\n   *   describe('The word \"yoyo\" underlined.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(28);\n   *   strokeWeight(0.5);\n   *\n   *   // Calculate the text width.\n   *   // \"\\n\" starts a new line.\n   *   let s = 'yo\\nyo';\n   *   let w = textWidth(s);\n   *\n   *   // Display the text.\n   *   text(s, 22, 55);\n   *\n   *   // Underline the text.\n   *   line(22, 55, 22 + w, 55);\n   *\n   *   describe('The word \"yo\" written twice, one copy beneath the other. The words are divided by a horizontal line.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Sets the style for wrapping text when\n   * <a href=\"#/p5/text\">text()</a> is called.\n   *\n   * The parameter, `style`, can be one of the following values:\n   *\n   * `WORD` starts new lines of text at spaces. If a string of text doesn't\n   * have spaces, it may overflow the text box and the canvas. This is the\n   * default style.\n   *\n   * `CHAR` starts new lines as needed to stay within the text box.\n   *\n   * `textWrap()` only works when the maximum width is set for a text box. For\n   * example, calling `text('Have a wonderful day', 0, 10, 100)` sets the\n   * maximum width to 100 pixels.\n   *\n   * Calling `textWrap()` without an argument returns the current style.\n   *\n   * @method textWrap\n   * @for p5\n   *\n   * @param {WORD|CHAR} style The wrapping style to use\n   * @returns {CHAR|WORD} If no arguments are provided, the current wrapping style\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(20);\n   *   textWrap(WORD);\n   *\n   *   // Display the text.\n   *   text('Have a wonderful day', 0, 10, 100);\n   *\n   *   describe('The text \"Have a wonderful day\" written across three lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(20);\n   *   textWrap(CHAR);\n   *\n   *   // Display the text.\n   *   text('Have a wonderful day', 0, 10, 100);\n   *\n   *   describe('The text \"Have a wonderful day\" written across two lines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the text.\n   *   textSize(20);\n   *   textWrap(CHAR);\n   *\n   *   // Display the text.\n   *   text('Á•ù‰Ω†ÊúâÁæéÂ•ΩÁöÑ‰∏ÄÂ§©', 0, 10, 100);\n   *\n   *   describe('The text \"Á•ù‰Ω†ÊúâÁæéÂ•ΩÁöÑ‰∏ÄÂ§©\" written across two lines.');\n   * }\n   * </code>\n   * </div>\n   */\n   /**\n    * @method textWrap\n    * @for p5\n    * @returns {CHAR|WORD} The current wrapping style\n    */\n\n\n  /**\n   * Computes the tight bounding box for a block of text.\n   *\n   * The `textBounds()` function calculates the precise pixel boundaries that enclose\n   * the rendered text based on the current text properties (such as font, textSize, textStyle, and\n   * alignment). If the text spans multiple lines (due to line breaks or wrapping), the function\n   * measures each line individually and then aggregates these measurements into a single bounding box.\n   * The resulting object contains the x and y coordinates along with the width (w) and height (h)\n   * of the text block.\n   *\n   * @method textBounds\n   * @for p5\n   *\n   * @param {String} str - The text string to measure.\n   * @param {Number} x - The x-coordinate where the text is drawn.\n   * @param {Number} y - The y-coordinate where the text is drawn.\n   * @param {Number} [width] - (Optional) The maximum width available for the text block.\n   *                           When specified, the text may be wrapped to fit within this width.\n   * @param {Number} [height] - (Optional) The maximum height available for the text block.\n   *                            Any lines exceeding this height will be truncated.\n   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` that represent the tight\n   *                   bounding box of the rendered text.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(220);\n   *\n   *   // Set up text properties for clarity\n   *   textSize(32);\n   *   textAlign(LEFT, TOP);\n   *\n   *   let txt = \"Hello, World!\";\n   *   // Compute the bounding box for the text starting at (50, 50)\n   *   let bounds = textBounds(txt, 50, 50);\n   *\n   *   // Draw the text\n   *   fill(0);\n   *   text(txt, 50, 50);\n   *\n   *   // Draw the computed bounding box in red to visualize the measured area\n   *   noFill();\n   *   stroke('red');\n   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);\n   * }\n   * </code>\n   * </div>\n   */\n\n\n  /**\n   * Sets or gets the text drawing direction.\n   *\n   * The <code>textDirection()</code> function allows you to specify the direction in which text is\n   * rendered on the canvas. When provided with a <code>direction</code> parameter (such as \"ltr\" for\n   * left-to-right, \"rtl\" for right-to-left, or \"inherit\"), it updates the renderer's state with that\n   * value and applies the new setting. When called without any arguments, it returns the current text\n   * direction. This function is particularly useful for rendering text in languages with different\n   * writing directions.\n   *\n   * @method textDirection\n   * @for p5\n   *\n   * @param {String} direction - The text direction to set (\"ltr\", \"rtl\", or \"inherit\").\n   * @returns {String} If no arguments are provided, the current text direction, either \"ltr\", \"rtl\", or \"inherit\"\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(240);\n   *\n   *   textSize(32);\n   *   textFont(\"Georgia\");\n   *   textAlign(LEFT, TOP);\n   *\n   *   // Set text direction to right-to-left and draw Arabic text.\n   *   textDirection(\"rtl\");\n   *   fill(0);\n   *   text(\"ŸÖÿ±ÿ≠ÿ®Ÿãÿß!\", 50, 50);\n   *\n   *   // Set text direction to left-to-right and draw English text.\n   *   textDirection(\"ltr\");\n   *   text(\"Hello, p5.js!\", 50, 150);\n   *\n   *   // Display the current text direction.\n   *   textSize(16);\n   *   fill(50);\n   *   textAlign(LEFT, TOP);\n   *   text(\"Current textDirection: \" + textDirection(), 50, 250);\n   * }\n   * </code>\n   * </div>\n   */\n   /**\n    * @method textDirection\n    * @for p5\n    * @returns {String} The current text direction, either \"ltr\", \"rtl\", or \"inherit\"\n    */\n\n  /**\n   * Sets or gets a single text property for the renderer.\n   *\n   * The `textProperty()` function allows you to set or retrieve a single text-related property,\n   * such as `textAlign`, `textBaseline`, `fontStyle`, or any other property\n   * that may be part of the renderer's state, its drawing context, or the canvas style.\n   *\n   * When called with a `prop` and a `value`, the function sets the property by checking\n   * for its existence in the renderer's state, the drawing context, or the canvas style. If the property is\n   * successfully modified, the function applies the updated text properties. If called with only the\n   * `prop` parameter, the function returns the current value of that property.\n   *\n   * @method textProperty\n   * @for p5\n   *\n   * @param {String} prop - The name of the text property to set or get.\n   * @param value - The value to set for the specified text property. If omitted, the current\n   *                      value of the property is returned\n   * @returns If no arguments are provided, the current value of the specified text property\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(240);\n   *\n   *   // Set the text alignment to CENTER and the baseline to TOP using textProperty.\n   *   textProperty(\"textAlign\", CENTER);\n   *   textProperty(\"textBaseline\", TOP);\n   *\n   *   // Set additional text properties and draw the text.\n   *   textSize(32);\n   *   textFont(\"Georgia\");\n   *   fill(0);\n   *   text(\"Hello, World!\", width / 2, 50);\n   *\n   *   // Retrieve and display the current text properties.\n   *   let currentAlign = textProperty(\"textAlign\");\n   *   let currentBaseline = textProperty(\"textBaseline\");\n   *\n   *   textSize(16);\n   *   textAlign(LEFT, TOP);\n   *   fill(50);\n   *   text(\"Current textAlign: \" + currentAlign, 50, 150);\n   *   text(\"Current textBaseline: \" + currentBaseline, 50, 170);\n   * }\n   * </code>\n   * </div>\n   */\n   /**\n    * @method textProperty\n    * @for p5\n    * @param {String} prop - The name of the text property to set or get.\n    * @returns The current value of the specified text property\n    */\n\n  /**\n   * Gets or sets text properties in batch, similar to calling `textProperty()`\n   * multiple times.\n   *\n   * If an object is passed in, `textProperty(key, value)` will be called for you\n   * on every key/value pair in the object.\n   *\n   * If no arguments are passed in, an object will be returned with all the current\n   * properties.\n   *\n   * @method textProperties\n   * @for p5\n   * @param {Object} properties An object whose keys are properties to set, and whose\n   *                            values are what they should be set to.\n   */\n  /**\n   * @method textProperties\n   * @for p5\n   * @returns {Object} An object with all the possible properties and their current values.\n   */\n\n  /**\n   * Computes a generic (non-tight) bounding box for a block of text.\n   *\n   * The `fontBounds()` function calculates the bounding box for the text based on the\n   * font's intrinsic metrics (such as `fontBoundingBoxAscent` and\n   * `fontBoundingBoxDescent`). Unlike `textBounds()`, which measures the exact\n   * pixel boundaries of the rendered text, `fontBounds()` provides a looser measurement\n   * derived from the font‚Äôs default spacing. This measurement is useful for layout purposes where\n   * a consistent approximation of the text's dimensions is desired.\n   *\n   * @method fontBounds\n   * @for p5\n   *\n   * @param {String} str - The text string to measure.\n   * @param {Number} x - The x-coordinate where the text is drawn.\n   * @param {Number} y - The y-coordinate where the text is drawn.\n   * @param {Number} [width] - (Optional) The maximum width available for the text block.\n   *                           When specified, the text may be wrapped to fit within this width.\n   * @param {Number} [height] - (Optional) The maximum height available for the text block.\n   *                            Any lines exceeding this height will be truncated.\n   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` representing the loose\n   *                   bounding box of the text based on the font's intrinsic metrics.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(240);\n   *\n   *   textSize(32);\n   *   textAlign(LEFT, TOP);\n   *   textFont('Georgia');\n   *\n   *   let txt = \"Hello, World!\";\n   *   // Compute the bounding box based on the font's intrinsic metrics\n   *   let bounds = fontBounds(txt, 50, 50);\n   *\n   *   fill(0);\n   *   text(txt, 50, 50);\n   *\n   *   noFill();\n   *   stroke('green');\n   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);\n   *\n   *   noStroke();\n   *   fill(50);\n   *   textSize(15);\n   *   text(\"Font Bounds: x=\" + bounds.x.toFixed(1) + \", y=\" + bounds.y.toFixed(1) +\n   *        \", w=\" + bounds.w.toFixed(1) + \", h=\" + bounds.h.toFixed(1), 8, 100);\n   * }\n   * </code>\n   * </div>\n   */\n\n\n  /**\n   * Returns the loose width of a text string based on the current font.\n   *\n   * The `fontWidth()` function measures the width of the provided text string using\n   * the font's default measurement (i.e., the width property from the text metrics returned by\n   * the browser). Unlike `textWidth()`, which calculates the tight pixel boundaries\n   * of the text glyphs, `fontWidth()` uses the font's intrinsic spacing, which may include\n   * additional space for character spacing and kerning. This makes it useful for scenarios where\n   * an approximate width is sufficient for layout and positioning.\n   *\n   * @method fontWidth\n   * @for p5\n   *\n   * @param {String} theText - The text string to measure.\n   * @returns {Number} The loose width of the text in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(240);\n   *\n   *   textSize(32);\n   *   textAlign(LEFT, TOP);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, World!\";\n   *   let fw = fontWidth(s);\n   *\n   *   fill(0);\n   *   text(s, 50, 50);\n   *\n   *   stroke('blue');\n   *   line(50, 90, 50 + fw, 90);\n   *\n   *   noStroke();\n   *   fill(50);\n   *   textSize(16);\n   *   text(\"Font width: \" + fw.toFixed(2) + \" pixels\", 50, 100);\n   * }\n   * </code>\n   * </div>\n   */\n\n\n  /**\n   * Returns the loose ascent of the text based on the font's intrinsic metrics.\n   *\n   * The `fontAscent()` function calculates the ascent of the text using the font's\n   * intrinsic metrics (e.g., `fontBoundingBoxAscent`). This value represents the space\n   * above the baseline that the font inherently occupies, and is useful for layout purposes when\n   * an approximate vertical measurement is required.\n   *\n   * @method fontAscent\n   * @for p5\n   *\n   * @returns {Number} The loose ascent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(220);\n   *\n   *   textSize(35);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the font descent of the current font\n   *   let fasc = fontAscent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the ascent position\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y - fasc, x + 200, y - fasc); // Font ascent position\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"fontAscent: \" + fasc.toFixed(2) + \" pixels\", x, y + fdesc + 20);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Returns the loose descent of the text based on the font's intrinsic metrics.\n   *\n   * The `fontDescent()` function calculates the descent of the text using the font's\n   * intrinsic metrics (e.g., `fontBoundingBoxDescent`). This value represents the space\n   * below the baseline that the font inherently occupies, and is useful for layout purposes when\n   * an approximate vertical measurement is required.\n   *\n   * @method fontDescent\n   * @for p5\n   *\n   * @returns {Number} The loose descent value in pixels.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 300);\n   *   background(220);\n   *\n   *   textSize(48);\n   *   textAlign(LEFT, BASELINE);\n   *   textFont('Georgia');\n   *\n   *   let s = \"Hello, p5.js!\";\n   *   let x = 50, y = 150;\n   *\n   *   fill(0);\n   *   text(s, x, y);\n   *\n   *   // Get the font descent of the current font\n   *   let fdesc = fontDescent();\n   *\n   *   // Draw a red line at the baseline and a blue line at the descent position\n   *   stroke('red');\n   *   line(x, y, x + 200, y); // Baseline\n   *   stroke('blue');\n   *   line(x, y + fdesc, x + 200, y + fdesc); // Font descent position\n   *\n   *   noStroke();\n   *   fill(0);\n   *   textSize(16);\n   *   text(\"fontDescent: \" + fdesc.toFixed(2) + \" pixels\", x, y + fdesc + 20);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   *\n   * Sets or gets the current font weight.\n   *\n   * The <code>textWeight()</code> function is used to specify the weight (thickness) of the text.\n   * When a numeric value is provided, it sets the font weight to that value and updates the\n   * rendering properties accordingly (including the \"font-variation-settings\" on the canvas style).\n   * When called without an argument, it returns the current font weight setting.\n   *\n   * @method textWeight\n   * @for p5\n   *\n   * @param {Number} weight - The numeric weight value to set for the text.\n   * @returns {Number} If no arguments are provided, the current font weight\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(300, 200);\n   *   background(240);\n   *\n   *   // Set text alignment, size, and font\n   *   textAlign(LEFT, TOP);\n   *   textSize(20);\n   *   textFont(\"Georgia\");\n   *\n   *   // Draw text with a normal weight (lighter appearance)\n   *   push();\n   *   textWeight(400);  // Set font weight to 400\n   *   fill(0);\n   *   text(\"Normal\", 50, 50);\n   *   let normalWeight = textWeight();  // Should return 400\n   *   pop();\n   *\n   *   // Draw text with a bold weight (heavier appearance)\n   *   push();\n   *   textWeight(900);  // Set font weight to 900\n   *   fill(0);\n   *   text(\"Bold\", 50, 100);\n   *   let boldWeight = textWeight();  // Should return 900\n   *   pop();\n   *\n   *   // Display the current font weight values on the canvas\n   *   textSize(16);\n   *   fill(50);\n   *   text(\"Normal Weight: \" + normalWeight, 150, 52);\n   *   text(\"Bold Weight: \" + boldWeight, 150, 100);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont(\n   *     'https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *   textFont(font);\n   *   textAlign(LEFT, TOP);\n   *   textSize(35);\n   *   textWeight(sin(millis() * 0.002) * 200 + 400);\n   *   text('p5*js', 0, 10);\n   *   describe('The text p5*js pulsing its weight over time');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method textWeight\n   * @for p5\n   * @returns {Number} The current font weight\n   */\n\n  // attach each text func to p5, delegating to the renderer\n  textFunctions.forEach(func => {\n    fn[func] = function (...args) {\n      if (!(func in Renderer.prototype)) {\n        throw Error(`Renderer2D.prototype.${func} is not defined.`);\n      }\n      return this._renderer[func](...args);\n    };\n    // attach also to p5.Graphics.prototype\n    p5.Graphics.prototype[func] = function (...args) {\n      return this._renderer[func](...args);\n    };\n  });\n\n  const RendererTextProps = {\n    textAlign: { default: fn.LEFT, type: 'Context2d' },\n    textBaseline: { default: fn.BASELINE, type: 'Context2d' },\n    textFont: { default: { family: 'sans-serif' } },\n    textLeading: { default: 15 },\n    textSize: { default: 12 },\n    textWrap: { default: fn.WORD },\n    fontStretch: { default: fn.NORMAL, isShorthand: true },  // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }\n    fontWeight: { default: fn.NORMAL, isShorthand: true },   // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }\n    lineHeight: { default: fn.NORMAL, isShorthand: true },   // line-height: { default:  normal | number | length | percentage }\n    fontVariant: { default: fn.NORMAL, isShorthand: true },  // font-variant: { default:  normal | small-caps }\n    fontStyle: { default: fn.NORMAL, isShorthand: true },    // font-style: { default:  normal | italic | oblique } [was 'textStyle' in v1]\n    direction: { default: 'inherit' }, // direction: { default: inherit | ltr | rtl }\n  };\n\n  // note: font must be first here otherwise it may reset other properties\n  const ContextTextProps = ['font', 'direction', 'fontKerning', 'fontStretch', 'fontVariantCaps', 'letterSpacing', 'textAlign', 'textBaseline', 'textRendering', 'wordSpacing'];\n\n  // shorthand font properties that can be set with context2d.font\n  const ShorthandFontProps = Object.keys(RendererTextProps).filter(p => RendererTextProps[p].isShorthand);\n\n  // allowable values for font-stretch property for context2d.font\n  const FontStretchKeys = [\"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"normal\", \"semi-expanded\", \"expanded\", \"extra-expanded\", \"ultra-expanded\"];\n\n  let contextQueue, cachedDiv; // lazy\n\n  ////////////////////////////// start API ///////////////////////////////\n\n  Renderer.prototype.text = function (str, x, y, width, height) {\n\n    let setBaseline = this.textDrawingContext().textBaseline; // store baseline\n\n    // adjust {x,y,w,h} properties based on rectMode\n    ({ x, y, width, height } = this._handleRectMode(x, y, width, height));\n\n    // parse the lines according to width, height & linebreaks\n    let lines = this._processLines(str, width, height);\n\n    // add the adjusted positions [x,y] to each line\n    lines = this._positionLines(x, y, width, height, lines);\n\n    // render each line at the adjusted position\n    lines.forEach(line => this._renderText(line.text, line.x, line.y));\n\n    this.textDrawingContext().textBaseline = setBaseline; // restore baseline\n  };\n\n  /**\n   * Computes the precise (tight) bounding box for a block of text\n   * @param {String} str - the text to measure\n   * @param {Number} x - the x-coordinate of the text\n   * @param {Number} y - the y-coordinate of the text\n   * @param {Number} width - the max width of the text block\n   * @param {Number} height - the max height of the text block\n   * @returns - a bounding box object for the text block: {x,y,w,h}\n   * @private\n   */\n  Renderer.prototype.textBounds = function (str, x, y, width, height) {\n    // delegate to _textBoundsSingle for measuring\n    return this._computeBounds(textCoreConstants._TEXT_BOUNDS, str, x, y, width, height).bounds;\n  };\n\n  /**\n   * Computes a generic (non-tight) bounding box for a block of text\n   * @param {String} str - the text to measure\n   * @param {Number} x - the x-coordinate of the text\n   * @param {Number} y - the y-coordinate of the text\n   * @param {Number} width - the max width of the text block\n   * @param {Number} height - the max height of the text block\n   * @returns - a bounding box object for the text block: {x,y,w,h}\n   * @private\n   */\n  Renderer.prototype.fontBounds = function (str, x, y, width, height) {\n    // delegate to _fontBoundsSingle for measuring\n    return this._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height).bounds;\n  };\n\n  /**\n   * Get the width of a text string in pixels (tight bounds)\n   * @param {String} theText\n   * @returns - the width of the text in pixels\n   * @private\n   */\n  Renderer.prototype.textWidth = function (theText) {\n    let lines = this._processLines(theText);\n    // return the max width of the lines (using tight bounds)\n    return Math.max(...lines.map(l => this._textWidthSingle(l)));\n  };\n\n  /**\n   * Get the width of a text string in pixels (loose bounds)\n   * @param {String} theText\n   * @returns - the width of the text in pixels\n   * @private\n   */\n  Renderer.prototype.fontWidth = function (theText) {\n    // return the max width of the lines (using loose bounds)\n    let lines = this._processLines(theText);\n    return Math.max(...lines.map(l => this._fontWidthSingle(l)));\n  };\n\n  /**\n   * @param {*} txt - optional text to measure, if provided will be\n   * used to compute the ascent, otherwise the font's ascent will be used\n   * @returns - the ascent of the text\n   * @private\n   */\n  Renderer.prototype.textAscent = function (txt = '') {\n    if (!txt.length) return this.fontAscent();\n    return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;\n  };\n\n  /**\n   * @returns - returns the ascent for the current font\n   * @private\n   */\n  Renderer.prototype.fontAscent = function () {\n    return this.textDrawingContext().measureText('_').fontBoundingBoxAscent;\n  };\n\n  /**\n   * @param {*} txt - optional text to measure, if provided will\n   * be used to compute the descent, otherwise the font's descent will be used\n   * @returns - the descent of the text\n   * @private\n   */\n  Renderer.prototype.textDescent = function (txt = '') {\n    if (!txt.length) return this.fontDescent();\n    return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;\n  };\n\n  Renderer.prototype.fontDescent = function () {\n    return this.textDrawingContext().measureText('_').fontBoundingBoxDescent;\n  };\n\n\n  // setters/getters for text properties //////////////////////////\n\n  Renderer.prototype.textAlign = function (h, v) {\n\n    // the setter\n    if (typeof h !== 'undefined') {\n      this.states.setValue('textAlign', h);\n      if (typeof v !== 'undefined') {\n        if (v === fn.CENTER) {\n          v = textCoreConstants._CTX_MIDDLE;\n        }\n        this.states.setValue('textBaseline', v);\n      }\n      return this._applyTextProperties();\n    }\n    // the getter\n    return {\n      horizontal: this.states.textAlign,\n      vertical: this.states.textBaseline\n    };\n  };\n\n  Renderer.prototype._currentTextFont = function () {\n    return this.states.textFont.font || this.states.textFont.family;\n  };\n\n  /**\n   * Set the font and [size] and [options] for rendering text\n   * @param {p5.Font | string} font - the font to use for rendering text\n   * @param {Number} size - the size of the text, can be a number or a css-style string\n   * @param {Object} options - additional options for rendering text, see FontProps\n   * @private\n   */\n  Renderer.prototype.textFont = function (font, size, options) {\n\n    if (arguments.length === 0) {\n      return this._currentTextFont();\n    }\n\n    let family = font;\n\n    // do we have a custon loaded font ?\n    if (font instanceof p5.Font) {\n      family = font.face.family;\n    }\n    else if (font.data instanceof Uint8Array) {\n      family = font.name.fontFamily;\n      if (font.name?.fontSubfamily) {\n        family += '-' + font.name.fontSubfamily;\n      }\n    }\n    else if (typeof font === 'string') {\n      // direct set the font-string if it contains size\n      if (typeof size === 'undefined' && /[.0-9]+(%|em|p[xt])/.test(family)) {\n        //console.log('direct set font-string: ', family);\n        ({ family, size } = this._directSetFontString(family));\n      }\n    }\n\n    if (typeof family !== 'string') throw Error('null font in textFont()');\n\n    // handle two-arg case: textFont(font, options)\n    if (arguments.length === 2 && typeof size === 'object') {\n      options = size;\n      size = undefined;\n    }\n\n    // update font properties in this.states\n    this.states.setValue('textFont', { font, family, size });\n\n    // convert/update the size in this.states\n    if (typeof size !== 'undefined') {\n      this._setTextSize(size);\n    }\n\n    // apply any options to this.states\n    if (typeof options === 'object') {\n      this.textProperties(options);\n    }\n\n    return this._applyTextProperties();\n  };\n\n  Renderer.prototype._directSetFontString = function (font, debug = 0) {\n    if (debug) console.log('_directSetFontString\"' + font + '\"');\n\n    let defaults = ShorthandFontProps.reduce((props, p) => {\n      props[p] = RendererTextProps[p].default;\n      return props;\n    }, {});\n\n    let el = this._cachedDiv(defaults);\n    el.style.font = font;\n    let style = getComputedStyle(el);\n    ShorthandFontProps.forEach(prop => {\n      this.states[prop] = style[prop];\n      if (debug) console.log('  this.states.' + prop + '=\"' + style[prop] + '\"');\n    });\n\n    return { family: style.fontFamily, size: style.fontSize };\n  };\n\n  Renderer.prototype.textLeading = function (leading) {\n    // the setter\n    if (typeof leading === 'number') {\n      this.states.setValue('leadingSet', true);\n      this.states.setValue('textLeading', leading);\n      return this._applyTextProperties();\n    }\n    // the getter\n    return this.states.textLeading;\n  };\n\n  Renderer.prototype.textWeight = function (weight) {\n    // the setter\n    if (typeof weight === 'number') {\n      this.states.setValue('fontWeight', weight);\n      this._applyTextProperties();\n\n      // Safari works without weight set in the canvas style attribute, and actually\n      // has buggy behavior if it is present, using the wrong weight when drawing\n      // multiple times with different weights\n      if (!p5.prototype._isSafari()) {\n        this._setCanvasStyleProperty('font-variation-settings', `\"wght\" ${weight}`);\n      }\n      return;\n    }\n    // the getter\n    return this.states.fontWeight;\n  };\n\n  /**\n   * @param {*} size - the size of the text, can be a number or a css-style string\n   * @private\n   */\n  Renderer.prototype.textSize = function (size) {\n\n    // the setter\n    if (typeof size !== 'undefined') {\n      this._setTextSize(size);\n      return this._applyTextProperties();\n    }\n    // the getter\n    return this.states.textSize;\n  };\n\n  Renderer.prototype.textStyle = function (style) {\n\n    // the setter\n    if (typeof style !== 'undefined') {\n      this.states.setValue('fontStyle', style);\n      return this._applyTextProperties();\n    }\n    // the getter\n    return this.states.fontStyle;\n  };\n\n  Renderer.prototype.textWrap = function (wrapStyle) {\n\n    if (wrapStyle === fn.WORD || wrapStyle === fn.CHAR) {\n      this.states.setValue('textWrap', wrapStyle);\n      // no need to apply text properties here as not a context property\n      return this._pInst;\n    }\n    return this.states.textWrap;\n  };\n\n  Renderer.prototype.textDirection = function (direction) {\n\n    if (typeof direction !== 'undefined') {\n      this.states.setValue('direction', direction);\n      return this._applyTextProperties();\n    }\n    return this.states.direction;\n  };\n\n  /**\n   * Sets/gets a single text property for the renderer (eg. fontStyle, fontStretch, etc.)\n   * The property to be set can be a mapped or unmapped property on `this.states` or a property\n   * on `this.textDrawingContext()` or on `this.canvas.style`\n   * The property to get can exist in `this.states` or `this.textDrawingContext()` or `this.canvas.style`\n   * @private\n   */\n  Renderer.prototype.textProperty = function (prop, value, opts) {\n\n    let modified = false, debug = opts?.debug || false;\n\n    // getter: return option from this.states or this.textDrawingContext()\n    if (typeof value === 'undefined') {\n      let props = this.textProperties();\n      if (prop in props) return props[prop];\n      throw Error('Unknown text option \"' + prop + '\"'); // FES?\n    }\n\n    // set the option in this.states if it exists\n    if (prop in this.states && this.states[prop] !== value) {\n      this.states[prop] = value;\n      modified = true;\n      if (debug) {\n        console.log('this.states.' + prop + '=\"' + options[prop] + '\"');\n      }\n    }\n    // does it exist in CanvasRenderingContext2D ?\n    else if (prop in this.textDrawingContext()) {\n      this._setContextProperty(prop, value, debug);\n      modified = true;\n    }\n    // does it exist in the canvas.style ?\n    else if (prop in this.textCanvas().style) {\n      this._setCanvasStyleProperty(prop, value, debug);\n      modified = true;\n    }\n    else {\n      console.warn('Ignoring unknown text option: \"' + prop + '\"\\n'); // FES?\n    }\n\n    return modified ? this._applyTextProperties() : this._pInst;\n  };\n\n  /**\n   * Batch set/get text properties for the renderer.\n   * The properties can be either on `states` or `drawingContext`\n   * @private\n   */\n  Renderer.prototype.textProperties = function (properties) {\n\n    // setter\n    if (typeof properties !== 'undefined') {\n      Object.keys(properties).forEach(opt => {\n        this.textProperty(opt, properties[opt]);\n      });\n      return this._pInst;\n    }\n\n    // getter: get props from drawingContext\n    let context = this.textDrawingContext();\n    properties = ContextTextProps.reduce((props, p) => {\n      props[p] = context[p];\n      return props;\n    }, {});\n\n    // add renderer props\n    Object.keys(RendererTextProps).forEach(p => {\n      if (RendererTextProps[p]?.type === 'Context2d') {\n        properties[p] = context[p];\n      }\n      else { // a renderer.states property\n        if (p === 'textFont') {\n          // avoid circular ref. inside textFont\n          let current = this._currentTextFont();\n          if (typeof current === 'object' && '_pInst' in current) {\n            current = Object.assign({}, current);\n            delete current._pInst;\n          }\n          properties[p] = current;\n        }\n        else {\n          properties[p] = this.states[p];\n        }\n      }\n    });\n\n    return properties;\n  };\n\n  Renderer.prototype.textMode = function () { /* no-op for processing api */ };\n\n  /////////////////////////////// end API ////////////////////////////////\n\n  Renderer.prototype._currentTextFont = function () {\n    return this.states.textFont.font || this.states.textFont.family;\n  };\n\n  /*\n    Compute the bounds for a block of text based on the specified\n    measure function, either _textBoundsSingle or _fontBoundsSingle\n   * @private\n  */\n  Renderer.prototype._computeBounds = function (type, str, x, y, width, height, opts) {\n\n    let context = this.textDrawingContext();\n    let setBaseline = context.textBaseline;\n    let { textLeading, textAlign } = this.states;\n\n    // adjust width, height based on current rectMode\n    ({ width, height } = this._rectModeAdjust(x, y, width, height));\n\n    // parse the lines according to the width & linebreaks\n    let lines = this._processLines(str, width, height);\n\n    // get the adjusted positions [x,y] for each line\n    let boxes = lines.map((line, i) => this[type].bind(this)\n      (line, x, y + i * textLeading));\n\n    // adjust the bounding boxes based on horiz. text alignment\n    if (lines.length > 1) {\n      // Call the 2D mode version: the WebGL mode version does additional\n      // alignment adjustments to account for how WebGL renders text.\n      boxes.forEach(bb => bb.x += p5.Renderer2D.prototype._xAlignOffset.call(this, textAlign, width));\n    }\n\n    // adjust the bounding boxes based on vert. text alignment\n    if (typeof height !== 'undefined') {\n      // Call the 2D mode version: the WebGL mode version does additional\n      // alignment adjustments to account for how WebGL renders text.\n      p5.Renderer2D.prototype._yAlignOffset.call(this, boxes, height);\n    }\n\n    // get the bounds for the text block\n    let bounds = boxes[0];\n    if (lines.length > 1) {\n\n      // get the bounds for the multi-line text block\n      bounds = this._aggregateBounds(boxes);\n\n      // align the multi-line bounds\n      if (!opts?.ignoreRectMode) {\n        this._rectModeAlign(bounds, width || 0, height || 0);\n      }\n    }\n\n    context.textBaseline = setBaseline; // restore baseline\n\n    return { bounds, lines };\n  };\n\n  /*\n    Adjust width, height of bounds based on current rectMode\n   * @private\n  */\n  Renderer.prototype._rectModeAdjust = function (x, y, width, height) {\n\n    if (typeof width !== 'undefined') {\n      switch (this.states.rectMode) {\n        case fn.CENTER:\n          break;\n        case fn.CORNERS:\n          width -= x;\n          height -= y;\n          break;\n        case fn.RADIUS:\n          width *= 2;\n          height *= 2;\n          break;\n      }\n    }\n    return { x, y, width, height };\n  };\n\n  /*\n    Attempts to set a property directly on the canvas.style object\n   * @private\n  */\n  Renderer.prototype._setCanvasStyleProperty = function (opt, val, debug) {\n\n    let value = val.toString(); // ensure its a string\n\n    if (debug) console.log('canvas.style.' + opt + '=\"' + value + '\"');\n\n    // handle variable fonts options\n    if (opt === FontVariationSettings) {\n      this._handleFontVariationSettings(value);\n    }\n\n    // lets try to set it on the canvas style\n    this.textCanvas().style[opt] = value;\n\n    // check if the value was set successfully\n    if (this.textCanvas().style[opt] !== value) ;\n  };\n\n  /*\n    Parses the fontVariationSettings string and sets the font properties, only font-weight\n    working consistently across browsers at present\n   * @private\n  */\n  Renderer.prototype._handleFontVariationSettings = function (value, debug = false) {\n    // check if the value is a string or an object\n    if (typeof value === 'object') {\n      value = Object.keys(value).map(k => k + ' ' + value[k]).join(', ');\n    }\n    let values = value.split(CommaDelimRe);\n    values.forEach(v => {\n      v = v.replace(/[\"']/g, ''); // remove quotes\n      let matches = VariableAxesRe.exec(v);\n      //console.log('matches: ', matches);\n      if (matches && matches.length) {\n        let axis = matches[0];\n        // get the value to 3 digits of precision with no trailing zeros\n        let val = parseFloat(parseFloat(v.replace(axis, '').trim()).toFixed(3));\n        switch (axis) {\n          case 'wght':\n            if (debug) console.log('setting font-weight=' + val);\n            // manually set the font-weight via the font string\n            if (this.states.fontWeight !== val) this.textWeight(val);\n            return val;\n          case 'wdth':\n            break;\n          case 'ital':\n            if (debug) console.log('setting font-style=' + (val ? 'italic' : 'normal'));\n            break;\n          case 'slnt':\n            if (debug) console.log('setting font-style=' + (val ? 'oblique' : 'normal'));\n            break;\n          case 'opsz':\n            if (debug) console.log('setting font-optical-size=' + val);\n            break;\n        }\n      }\n    });\n  };\n\n\n\n\n  /*\n    For properties not directly managed by the renderer in this.states\n      we check if it has a mapping to a property in this.states\n    Otherwise, add the property to the context-queue for later application\n  */\n  Renderer.prototype._setContextProperty = function (prop, val, debug = false) {\n\n    // check if the value is actually different, else short-circuit\n    if (this.textDrawingContext()[prop] === val) {\n      return this._pInst;\n    }\n\n    // otherwise, we will set the property directly on the `this.textDrawingContext()`\n    // by adding [property, value] to context-queue for later application\n    (contextQueue ??= []).push([prop, val]);\n\n    if (debug) console.log('queued context2d.' + prop + '=\"' + val + '\"');\n  };\n\n  /*\n     Adjust parameters (x,y,w,h) based on current rectMode\n  */\n  Renderer.prototype._handleRectMode = function (x, y, width, height) {\n\n    let rectMode = this.states.rectMode;\n\n    if (typeof width !== 'undefined') {\n      switch (rectMode) {\n        case fn.RADIUS:\n          width *= 2;\n          x -= width / 2;\n          if (typeof height !== 'undefined') {\n            height *= 2;\n            y -= height / 2;\n          }\n          break;\n        case fn.CENTER:\n          x -= width / 2;\n          if (typeof height !== 'undefined') {\n            y -= height / 2;\n          }\n          break;\n        case fn.CORNERS:\n          width -= x;\n          if (typeof height !== 'undefined') {\n            height -= y;\n          }\n          break;\n      }\n    }\n    return { x, y, width, height };\n  };\n\n  /*\n    Get the computed font-size in pixels for a given size string\n    @param {String} size - the font-size string to compute\n    @returns {number} - the computed font-size in pixels\n   * @private\n   */\n  Renderer.prototype._fontSizePx = function (theSize, { family } = this.states.textFont) {\n\n    const isNumString = (num) => !isNaN(num) && num.trim() !== '';\n\n    // check for a number in a string, eg '12'\n    if (isNumString(theSize)) {\n      return parseFloat(theSize);\n    }\n    let ele = this._cachedDiv({ fontSize: theSize });\n    ele.style.fontSize = theSize;\n    ele.style.fontFamily = family;\n    let fontSizeStr = getComputedStyle(ele).fontSize;\n    let fontSize = parseFloat(fontSizeStr);\n    if (typeof fontSize !== 'number') {\n      throw Error('textSize: invalid font-size');\n    }\n    return fontSize;\n  };\n\n  Renderer.prototype._cachedDiv = function (props) {\n    if (typeof cachedDiv === 'undefined') {\n      let ele = document.createElement('div');\n      ele.ariaHidden = 'true';\n      ele.style.display = 'none';\n      Object.entries(props).forEach(([prop, val]) => {\n        ele.style[prop] = val;\n      });\n      this.textCanvas().appendChild(ele);\n      cachedDiv = ele;\n    }\n    return cachedDiv;\n  };\n\n\n  /*\n    Aggregate the bounding boxes of multiple lines of text\n    @param {Array} bboxes - the bounding boxes to aggregate\n    @returns {object} - the aggregated bounding box\n   * @private\n  */\n  Renderer.prototype._aggregateBounds = function (bboxes) {\n    // loop over the bounding boxes to get the min/max x/y values\n    let minX = Math.min(...bboxes.map(b => b.x));\n    let minY = Math.min(...bboxes.map(b => b.y));\n    let maxY = Math.max(...bboxes.map(b => b.y + b.h));\n    let maxX = Math.max(...bboxes.map(b => b.x + b.w));\n    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n  };\n\n  // Renderer.prototype._aggregateBounds = function (tx, ty, bboxes) {\n  //   let x = Math.min(...bboxes.map(b => b.x));\n  //   let y = Math.min(...bboxes.map(b => b.y));\n  //   // the width is the max of the x-offset + the box width\n  //   let w = Math.max(...bboxes.map(b => (b.x - tx) + b.w));\n  //   let h = bboxes[bboxes.length - 1].y - bboxes[0].y + bboxes[bboxes.length - 1].h;\n\n\n  //   return { x, y, w, h };\n  // };\n\n  /*\n    Process the text string to handle line-breaks and text wrapping\n    @param {String} str - the text to process\n    @param {Number} width - the width to wrap the text to\n    @returns {array} - the processed lines of text\n   * @private\n  */\n  Renderer.prototype._processLines = function (str, width, height) {\n\n    if (typeof width !== 'undefined') { // only for text with bounds\n      let drawingContext = this.textDrawingContext();\n      if (drawingContext.textBaseline === fn.BASELINE) {\n        this.drawingContext.textBaseline = fn.TOP;\n      }\n    }\n\n    let lines = this._splitOnBreaks(str.toString());\n    let hasLineBreaks = lines.length > 1;\n    let hasWidth = typeof width !== 'undefined';\n    let exceedsWidth = hasWidth && lines.some(l => this._textWidthSingle(l) > width);\n    let { textLeading: leading, textWrap } = this.states;\n\n    //if (!hasLineBreaks && !exceedsWidth) return lines; // a single-line\n    if (hasLineBreaks || exceedsWidth) {\n      if (hasWidth) lines = this._lineate(textWrap, lines, width);\n    }\n\n    // handle height truncation\n    if (hasWidth && typeof height !== 'undefined') {\n\n      if (typeof leading === 'undefined') {\n        throw Error('leading is required if height is specified');\n      }\n\n      // truncate lines that exceed the height\n      for (let i = 0; i < lines.length; i++) {\n        let lh = leading * (i + 1);\n        if (lh > height) {\n          //console.log('TRUNCATING: ', i, '-', lines.length, '\"' + lines.slice(i) + '\"');\n          lines = lines.slice(0, i);\n          break;\n        }\n      }\n    }\n\n    return lines;\n  };\n\n  /*\n    Get the x-offset for text given the width and textAlign property\n  */\n  Renderer.prototype._xAlignOffset = function (textAlign, width) {\n    switch (textAlign) {\n      case fn.LEFT:\n        return 0;\n      case fn.CENTER:\n        return width / 2;\n      case fn.RIGHT:\n        return width;\n      case textCoreConstants.START:\n        return 0;\n      case textCoreConstants.END:\n        throw new Error('textBounds: END not yet supported for textAlign');\n      default:\n        return 0;\n    }\n  };\n\n  /*\n    Align the bounding box based on the current rectMode setting\n  */\n  Renderer.prototype._rectModeAlign = function (bb, width, height) {\n    if (typeof width !== 'undefined') {\n\n      switch (this.states.rectMode) {\n        case fn.CENTER:\n          bb.x -= (width - bb.w) / 2;\n          bb.y -= (height - bb.h) / 2;\n          break;\n        case fn.CORNERS:\n          bb.w += bb.x;\n          bb.h += bb.y;\n          break;\n        case fn.RADIUS:\n          bb.x -= (width - bb.w) / 2;\n          bb.y -= (height - bb.h) / 2;\n          bb.w /= 2;\n          bb.h /= 2;\n          break;\n      }\n      return bb;\n    }\n  };\n\n  Renderer.prototype._rectModeAlignRevert = function (bb, width, height) {\n    if (typeof width !== 'undefined') {\n\n      switch (this.states.rectMode) {\n        case fn.CENTER:\n          bb.x += (width - bb.w) / 2;\n          bb.y += (height - bb.h) / 2;\n          break;\n        case fn.CORNERS:\n          bb.w -= bb.x;\n          bb.h -= bb.y;\n          break;\n        case fn.RADIUS:\n          bb.x += (width - bb.w) / 2;\n          bb.y += (height - bb.h) / 2;\n          bb.w *= 2;\n          bb.h *= 2;\n          break;\n      }\n      return bb;\n    }\n  };\n\n  /*\n    Get the (tight) width of a single line of text\n  */\n  Renderer.prototype._textWidthSingle = function (s) {\n    let metrics = this.textDrawingContext().measureText(s);\n    let abl = metrics.actualBoundingBoxLeft;\n    let abr = metrics.actualBoundingBoxRight;\n    return abr + abl;\n  };\n\n  /*\n    Get the (loose) width of a single line of text as specified by the font\n  */\n  Renderer.prototype._fontWidthSingle = function (s) {\n    return this.textDrawingContext().measureText(s).width;\n  };\n\n  /*\n    Get the (tight) bounds of a single line of text based on its actual bounding box\n  */\n  Renderer.prototype._textBoundsSingle = function (s, x = 0, y = 0) {\n\n    let metrics = this.textDrawingContext().measureText(s);\n    let asc = metrics.actualBoundingBoxAscent;\n    let desc = metrics.actualBoundingBoxDescent;\n    let abl = metrics.actualBoundingBoxLeft;\n    let abr = metrics.actualBoundingBoxRight;\n    return { x: x - abl, y: y - asc, w: abr + abl, h: asc + desc };\n  };\n\n  /*\n    Get the (loose) bounds of a single line of text based on its font's bounding box\n  */\n  Renderer.prototype._fontBoundsSingle = function (s, x = 0, y = 0) {\n\n    let metrics = this.textDrawingContext().measureText(s);\n    let asc = metrics.fontBoundingBoxAscent;\n    let desc = metrics.fontBoundingBoxDescent;\n    x -= this._xAlignOffset(this.states.textAlign, metrics.width);\n    return { x, y: y - asc, w: metrics.width, h: asc + desc };  };\n\n  /*\n    Set the textSize property in `this.states` if it has changed\n    @param {number | string} theSize - the font-size to set\n    @returns {boolean} - true if the size was changed, false otherwise\n   */\n  Renderer.prototype._setTextSize = function (theSize) {\n\n    if (typeof theSize === 'string') {\n      // parse the size string via computed style, eg '2em'\n      theSize = this._fontSizePx(theSize);\n    }\n\n    // should be a number now\n    if (typeof theSize === 'number') {\n\n      // set it in `this.states` if its been changed\n      if (this.states.textSize !== theSize) {\n        this.states.setValue('textSize', theSize);\n\n        // handle leading here, if not set otherwise\n        if (!this.states.leadingSet) {\n          this.states.setValue('textLeading', this.states.textSize * LeadingScale);\n        }\n        return true; // size was changed\n      }\n    }\n    else {\n      console.warn('textSize: invalid size: ' + theSize);\n    }\n\n    return false;\n  };\n\n  /*\n    Split the lines of text based on the width and the textWrap property\n    @param {Array} lines - the lines of text to split\n    @param {Number} maxWidth - the maximum width of the lines\n    @param {Object} opts - additional options for splitting the lines\n    @returns {array} - the split lines of text\n   * @private\n  */\n  Renderer.prototype._lineate = function (textWrap, lines, maxWidth = Infinity, opts = {}) {\n\n    let splitter = opts.splitChar ?? (textWrap === fn.WORD ? ' ' : '');\n    let line, testLine, testWidth, words, newLines = [];\n\n    for (let lidx = 0; lidx < lines.length; lidx++) {\n      line = '';\n      words = lines[lidx].split(splitter);\n      for (let widx = 0; widx < words.length; widx++) {\n        testLine = `${line + words[widx]}` + splitter;\n        testWidth = this._textWidthSingle(testLine);\n        if (line.length > 0 && testWidth > maxWidth) {\n          newLines.push(line.trim());\n          line = `${words[widx]}` + splitter;\n        } else {\n          line = testLine;\n        }\n      }\n      newLines.push(line.trim());\n    }\n    return newLines;\n  };\n\n  /*\n    Split the text into lines based on line-breaks and tabs\n  */\n  Renderer.prototype._splitOnBreaks = function (s) {\n    if (!s || s.length === 0) return [''];\n    return s.replace(TabsRe, '  ').split(LinebreakRe);\n  };\n\n  /*\n    Parse the font-family string to handle complex names, fallbacks, etc.\n  */\n  Renderer.prototype._parseFontFamily = function (familyStr) {\n\n    let parts = familyStr.split(CommaDelimRe);\n    let family = parts.map(part => {\n      part = part.trim();\n      if (part.indexOf(' ') > -1 && !QuotedRe.test(part)) {\n        part = `\"${part}\"`; // quote font names with spaces\n      }\n      return part;\n    }).join(', ');\n\n    return family;\n  };\n\n  Renderer.prototype._applyFontString = function () {\n    /*\n      Create the font-string according to the CSS font-string specification:\n      If font is specified as a shorthand for several font-related properties, then:\n      - it must include values for: <font-size> and <font-family>\n      - it may optionally include values for:\n          [<font-style>, <font-variant>, <font-weight>, <font-stretch>, <line-height>]\n      Format:\n      - font-style, font-variant and font-weight must precede font-size\n      - font-variant may only specify the values defined in CSS 2.1, that is 'normal' and 'small-caps'.\n      - font-stretch may only be a single keyword value.\n      - line-height must immediately follow font-size, preceded by \"/\", eg 16px/3.\n      - font-family must be the last value specified.\n    */\n    let { textFont, textSize, lineHeight, fontStyle, fontWeight, fontVariant } = this.states;\n    let drawingContext = this.textDrawingContext();\n\n    let family = this._parseFontFamily(textFont.family);\n    let style = fontStyle !== fn.NORMAL ? `${fontStyle} ` : '';\n    let weight = fontWeight !== fn.NORMAL ? `${fontWeight} ` : '';\n    let variant = fontVariant !== fn.NORMAL ? `${fontVariant} ` : '';\n    let fsize = `${textSize}px` + (lineHeight !== fn.NORMAL ? `/${lineHeight} ` : ' ');\n    let fontString = `${style}${variant}${weight}${fsize}${family}`.trim();\n    //console.log('fontString=\"' + fontString + '\"');\n\n    // set the font string on the context\n    drawingContext.font = fontString;\n\n    // verify that it was set successfully\n    if (drawingContext.font !== fontString) {\n      let expected = fontString;\n      let actual = drawingContext.font;\n      if (expected !== actual) {\n        //console.warn(`Unable to set font property on context2d. It may not be supported.`);\n        //console.log('Expected \"' + expected + '\" but got: \"' + actual + '\"'); // TMP\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /*\n    Apply the text properties in `this.states` to the `this.textDrawingContext()`\n    Then apply any properties in the context-queue\n   */\n  Renderer.prototype._applyTextProperties = function (debug = false) {\n\n    this._applyFontString();\n\n    // set these after the font so they're not overridden\n    let context = this.textDrawingContext();\n    context.direction = this.states.direction;\n    context.textAlign = this.states.textAlign;\n    context.textBaseline = this.states.textBaseline;\n\n    // set manually as (still) not fully supported as part of font-string\n    let stretch = this.states.fontStretch;\n    if (FontStretchKeys.includes(stretch) && context.fontStretch !== stretch) {\n      context.fontStretch = stretch;\n    }\n\n    // apply each property in queue after the font so they're not overridden\n    while (contextQueue?.length) {\n\n      let [prop, val] = contextQueue.shift();\n      if (debug) console.log('apply context property \"' + prop + '\" = \"' + val + '\"');\n      context[prop] = val;\n\n      // check if the value was set successfully\n      if (context[prop] !== val) {\n        console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`); // FES?\n        console.log('Expected \"' + val + '\" but got: \"' + context[prop] + '\"');\n      }\n    }\n\n    return this._pInst;\n  };\n\n  if (p5.Renderer2D) {\n    p5.Renderer2D.prototype.textCanvas = function () {\n      return this.canvas;\n    };\n    p5.Renderer2D.prototype.textDrawingContext = function () {\n      return this.drawingContext;\n    };\n\n    p5.Renderer2D.prototype._renderText = function (text, x, y, maxY, minY) {\n      let states = this.states;\n      let context = this.textDrawingContext();\n\n      if (y < minY || y >= maxY) {\n        return; // don't render lines beyond minY/maxY\n      }\n\n      this.push();\n\n      // no stroke unless specified by user\n      if (states.strokeColor && states.strokeSet) {\n        context.strokeText(text, x, y);\n      }\n\n      if (!this._clipping && states.fillColor) {\n\n        // if fill hasn't been set by user, use default text fill\n        if (!states.fillSet) {\n          this._setFill(DefaultFill);\n        }\n        context.fillText(text, x, y);\n      }\n\n      this.pop();\n    };\n\n    /*\n      Position the lines of text based on their textAlign/textBaseline properties\n    */\n    p5.Renderer2D.prototype._positionLines = function (x, y, width, height, lines) {\n\n      let { textLeading, textAlign } = this.states;\n      let adjustedX, lineData = new Array(lines.length);\n      let adjustedW = typeof width === 'undefined' ? 0 : width;\n      let adjustedH = typeof height === 'undefined' ? 0 : height;\n\n      for (let i = 0; i < lines.length; i++) {\n        switch (textAlign) {\n          case textCoreConstants.START:\n            throw new Error('textBounds: START not yet supported for textAlign'); // default to LEFT\n          case fn.LEFT:\n            adjustedX = x;\n            break;\n          case fn.CENTER:\n            adjustedX = x + adjustedW / 2;\n            break;\n          case fn.RIGHT:\n            adjustedX = x + adjustedW;\n            break;\n          case textCoreConstants.END:\n            throw new Error('textBounds: END not yet supported for textAlign');\n        }\n        lineData[i] = { text: lines[i], x: adjustedX, y: y + i * textLeading };\n      }\n\n      return this._yAlignOffset(lineData, adjustedH);\n    };\n\n    /*\n      Get the y-offset for text given the height, leading, line-count and textBaseline property\n    */\n    p5.Renderer2D.prototype._yAlignOffset = function (dataArr, height) {\n\n      if (typeof height === 'undefined') {\n        throw Error('_yAlignOffset: height is required');\n      }\n\n      let { textLeading, textBaseline } = this.states;\n      let yOff = 0, numLines = dataArr.length;\n      let ydiff = height - (textLeading * (numLines - 1));\n      switch (textBaseline) { // drawingContext ?\n        case fn.TOP:\n          break; // ??\n        case fn.BASELINE:\n          break;\n        case textCoreConstants._CTX_MIDDLE:\n          yOff = ydiff / 2;\n          break;\n        case fn.BOTTOM:\n          yOff = ydiff;\n          break;\n        case textCoreConstants.IDEOGRAPHIC:\n          console.warn('textBounds: IDEOGRAPHIC not yet supported for textBaseline'); // FES?\n          break;\n        case textCoreConstants.HANGING:\n          console.warn('textBounds: HANGING not yet supported for textBaseline'); // FES?\n          break;\n      }\n      dataArr.forEach(ele => ele.y += yOff);\n      return dataArr;\n    };\n  }\n\n  if (p5.RendererGL) {\n    p5.RendererGL.prototype.textCanvas = function() {\n      if (!this._textCanvas) {\n        this._textCanvas = document.createElement('canvas');\n        this._textCanvas.width = 1;\n        this._textCanvas.height = 1;\n        this._textCanvas.style.display = 'none';\n        // Has to be added to the DOM for measureText to work properly!\n        this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);\n      }\n      return this._textCanvas;\n    };\n    p5.RendererGL.prototype.textDrawingContext = function() {\n      if (!this._textDrawingContext) {\n        const textCanvas = this.textCanvas();\n        this._textDrawingContext = textCanvas.getContext('2d');\n      }\n      return this._textDrawingContext;\n    };\n    const oldRemove = p5.RendererGL.prototype.remove;\n    p5.RendererGL.prototype.remove = function() {\n      if (this._textCanvas) {\n        this._textCanvas.parentElement.removeChild(this._textCanvas);\n      }\n      oldRemove.call(this);\n    };\n\n    p5.RendererGL.prototype._positionLines = function (x, y, width, height, lines) {\n\n      let { textLeading, textAlign } = this.states;\n      const widths = lines.map((line) => this._fontWidthSingle(line));\n      let adjustedX, lineData = new Array(lines.length);\n      let adjustedW = typeof width === 'undefined' ? Math.max(0, ...widths) : width;\n      let adjustedH = typeof height === 'undefined' ? 0 : height;\n\n      for (let i = 0; i < lines.length; i++) {\n        switch (textAlign) {\n          case textCoreConstants.START:\n            throw new Error('textBounds: START not yet supported for textAlign'); // default to LEFT\n          case fn.LEFT:\n            adjustedX = x;\n            break;\n          case fn.CENTER:\n            adjustedX = x + (adjustedW - widths[i]) / 2 - adjustedW / 2 + (width || 0) / 2;\n            break;\n          case fn.RIGHT:\n            adjustedX = x + adjustedW - widths[i] - adjustedW + (width || 0);\n            break;\n          case textCoreConstants.END:\n            throw new Error('textBounds: END not yet supported for textAlign');\n        }\n        lineData[i] = { text: lines[i], x: adjustedX, y: y + i * textLeading };\n      }\n\n      return this._yAlignOffset(lineData, adjustedH);\n    };\n\n    p5.RendererGL.prototype._yAlignOffset = function (dataArr, height) {\n\n      if (typeof height === 'undefined') {\n        throw Error('_yAlignOffset: height is required');\n      }\n\n      let { textLeading, textBaseline, textSize, textFont } = this.states;\n      let yOff = 0, numLines = dataArr.length;\n      let totalHeight = textSize * numLines + ((textLeading - textSize) * (numLines - 1));\n      switch (textBaseline) { // drawingContext ?\n        case fn.TOP:\n          yOff = textSize;\n          break;\n        case fn.BASELINE:\n          break;\n        case textCoreConstants._CTX_MIDDLE:\n          yOff = -totalHeight / 2 + textSize + (height || 0) / 2;\n          break;\n        case fn.BOTTOM:\n          yOff = -(totalHeight - textSize) + (height || 0);\n          break;\n        default:\n          console.warn(`${textBaseline} is not supported in WebGL mode.`); // FES?\n          break;\n      }\n      yOff += this.states.textFont.font?._verticalAlign(textSize) || 0; // Does this function exist?\n      dataArr.forEach(ele => ele.y += yOff);\n      return dataArr;\n    };\n  }\n}\n\nif (typeof p5 !== 'undefined') {\n  textCore(p5, p5.prototype);\n}\n\nexport { textCore as default, textCoreConstants };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,QAAQ,QAAQ,4BAA4B;AAC1D,OAAO,iCAAiC;AACxC,OAAO,eAAe;AACtB,OAAO,8BAA8B;AACrC,OAAO,0BAA0B;AACjC,OAAO,qBAAqB;AAC5B,OAAO,sBAAsB;AAC7B,OAAO,2BAA2B;AAClC,OAAO,mBAAmB;AAC1B,OAAO,oBAAoB;AAC3B,OAAO,YAAY;;AAEnB;AACA;AACA;AACA;;AAGA,MAAMC,iBAAiB,GAAG;EACxBC,WAAW,EAAE,aAAa;EAC1BC,aAAa,EAAE,KAAK;EACpBC,aAAa,EAAE,KAAK;EACpBC,WAAW,EAAE,QAAQ;EACrBC,YAAY,EAAE,mBAAmB;EACjCC,YAAY,EAAE,mBAAmB;EACjCC,OAAO,EAAE,SAAS;EAClBC,KAAK,EAAE,OAAO;EACdC,GAAG,EAAE;AACP,CAAC;AAED,SAASC,QAAQA,CAACC,EAAE,EAAEC,EAAE,EAAE;EACxB,MAAMC,YAAY,GAAG,KAAK;EAC1B,MAAMC,WAAW,GAAG,SAAS;EAC7B,MAAMC,WAAW,GAAG,QAAQ;EAC5B,MAAMC,YAAY,GAAG,MAAM;EAC3B,MAAMC,QAAQ,GAAG,QAAQ;EACzB,MAAMC,MAAM,GAAG,KAAK;EAEpB,MAAMC,qBAAqB,GAAG,uBAAuB;EACrD,MAAMC,YAAY,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC;EAC7D,MAAMC,cAAc,GAAG,IAAIC,MAAM,CAAC,MAAMF,YAAY,CAACG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;EAElE,MAAMC,aAAa,GAAG,CACpB,MAAM,EACN,WAAW,EACX,YAAY,EACZ,aAAa,EACb,aAAa,EACb,UAAU,EACV,UAAU,EACV,UAAU,EACV,WAAW,EACX,WAAW,EACX,UAAU,EACV,YAAY,EACZ,eAAe,EACf,cAAc,EACd,gBAAgB,EAChB,YAAY,EACZ,WAAW,EACX,YAAY,EACZ,aAAa,EACb,YAAY,CACb;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC;AACD;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACG;AACH;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACG;AACH;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACG;AACH;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACG;AACH;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;;EAEE;EACAA,aAAa,CAACC,OAAO,CAACC,IAAI,IAAI;IAC5Bd,EAAE,CAACc,IAAI,CAAC,GAAG,UAAU,GAAGC,IAAI,EAAE;MAC5B,IAAI,EAAED,IAAI,IAAI3B,QAAQ,CAAC6B,SAAS,CAAC,EAAE;QACjC,MAAMC,KAAK,CAAC,wBAAwBH,IAAI,kBAAkB,CAAC;MAC7D;MACA,OAAO,IAAI,CAACI,SAAS,CAACJ,IAAI,CAAC,CAAC,GAAGC,IAAI,CAAC;IACtC,CAAC;IACD;IACAhB,EAAE,CAACoB,QAAQ,CAACH,SAAS,CAACF,IAAI,CAAC,GAAG,UAAU,GAAGC,IAAI,EAAE;MAC/C,OAAO,IAAI,CAACG,SAAS,CAACJ,IAAI,CAAC,CAAC,GAAGC,IAAI,CAAC;IACtC,CAAC;EACH,CAAC,CAAC;EAEF,MAAMK,iBAAiB,GAAG;IACxBC,SAAS,EAAE;MAAEC,OAAO,EAAEtB,EAAE,CAACuB,IAAI;MAAEC,IAAI,EAAE;IAAY,CAAC;IAClDC,YAAY,EAAE;MAAEH,OAAO,EAAEtB,EAAE,CAAC0B,QAAQ;MAAEF,IAAI,EAAE;IAAY,CAAC;IACzDG,QAAQ,EAAE;MAAEL,OAAO,EAAE;QAAEM,MAAM,EAAE;MAAa;IAAE,CAAC;IAC/CC,WAAW,EAAE;MAAEP,OAAO,EAAE;IAAG,CAAC;IAC5BQ,QAAQ,EAAE;MAAER,OAAO,EAAE;IAAG,CAAC;IACzBS,QAAQ,EAAE;MAAET,OAAO,EAAEtB,EAAE,CAACgC;IAAK,CAAC;IAC9BC,WAAW,EAAE;MAAEX,OAAO,EAAEtB,EAAE,CAACkC,MAAM;MAAEC,WAAW,EAAE;IAAK,CAAC;IAAG;IACzDC,UAAU,EAAE;MAAEd,OAAO,EAAEtB,EAAE,CAACkC,MAAM;MAAEC,WAAW,EAAE;IAAK,CAAC;IAAI;IACzDE,UAAU,EAAE;MAAEf,OAAO,EAAEtB,EAAE,CAACkC,MAAM;MAAEC,WAAW,EAAE;IAAK,CAAC;IAAI;IACzDG,WAAW,EAAE;MAAEhB,OAAO,EAAEtB,EAAE,CAACkC,MAAM;MAAEC,WAAW,EAAE;IAAK,CAAC;IAAG;IACzDI,SAAS,EAAE;MAAEjB,OAAO,EAAEtB,EAAE,CAACkC,MAAM;MAAEC,WAAW,EAAE;IAAK,CAAC;IAAK;IACzDK,SAAS,EAAE;MAAElB,OAAO,EAAE;IAAU,CAAC,CAAE;EACrC,CAAC;;EAED;EACA,MAAMmB,gBAAgB,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,aAAa,EAAE,aAAa,EAAE,iBAAiB,EAAE,eAAe,EAAE,WAAW,EAAE,cAAc,EAAE,eAAe,EAAE,aAAa,CAAC;;EAE7K;EACA,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,IAAI,CAACxB,iBAAiB,CAAC,CAACyB,MAAM,CAACC,CAAC,IAAI1B,iBAAiB,CAAC0B,CAAC,CAAC,CAACX,WAAW,CAAC;;EAEvG;EACA,MAAMY,eAAe,GAAG,CAAC,iBAAiB,EAAE,iBAAiB,EAAE,WAAW,EAAE,gBAAgB,EAAE,QAAQ,EAAE,eAAe,EAAE,UAAU,EAAE,gBAAgB,EAAE,gBAAgB,CAAC;EAExK,IAAIC,YAAY,EAAEC,SAAS,CAAC,CAAC;;EAE7B;;EAEA9D,QAAQ,CAAC6B,SAAS,CAACkC,IAAI,GAAG,UAAUC,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAE;IAE5D,IAAIC,WAAW,GAAG,IAAI,CAACC,kBAAkB,CAAC,CAAC,CAAChC,YAAY,CAAC,CAAC;;IAE1D;IACA,CAAC;MAAE2B,CAAC;MAAEC,CAAC;MAAEC,KAAK;MAAEC;IAAO,CAAC,GAAG,IAAI,CAACG,eAAe,CAACN,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC;;IAEpE;IACA,IAAII,KAAK,GAAG,IAAI,CAACC,aAAa,CAACT,GAAG,EAAEG,KAAK,EAAEC,MAAM,CAAC;;IAElD;IACAI,KAAK,GAAG,IAAI,CAACE,cAAc,CAACT,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEI,KAAK,CAAC;;IAEvD;IACAA,KAAK,CAAC9C,OAAO,CAACiD,IAAI,IAAI,IAAI,CAACC,WAAW,CAACD,IAAI,CAACZ,IAAI,EAAEY,IAAI,CAACV,CAAC,EAAEU,IAAI,CAACT,CAAC,CAAC,CAAC;IAElE,IAAI,CAACI,kBAAkB,CAAC,CAAC,CAAChC,YAAY,GAAG+B,WAAW,CAAC,CAAC;EACxD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErE,QAAQ,CAAC6B,SAAS,CAACgD,UAAU,GAAG,UAAUb,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAE;IAClE;IACA,OAAO,IAAI,CAACU,cAAc,CAAC7E,iBAAiB,CAACK,YAAY,EAAE0D,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC,CAACW,MAAM;EAC7F,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE/E,QAAQ,CAAC6B,SAAS,CAACmD,UAAU,GAAG,UAAUhB,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAE;IAClE;IACA,OAAO,IAAI,CAACU,cAAc,CAAC7E,iBAAiB,CAACM,YAAY,EAAEyD,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC,CAACW,MAAM;EAC7F,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE/E,QAAQ,CAAC6B,SAAS,CAACoD,SAAS,GAAG,UAAUC,OAAO,EAAE;IAChD,IAAIV,KAAK,GAAG,IAAI,CAACC,aAAa,CAACS,OAAO,CAAC;IACvC;IACA,OAAOC,IAAI,CAACC,GAAG,CAAC,GAAGZ,KAAK,CAACa,GAAG,CAACC,CAAC,IAAI,IAAI,CAACC,gBAAgB,CAACD,CAAC,CAAC,CAAC,CAAC;EAC9D,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACEtF,QAAQ,CAAC6B,SAAS,CAAC2D,SAAS,GAAG,UAAUN,OAAO,EAAE;IAChD;IACA,IAAIV,KAAK,GAAG,IAAI,CAACC,aAAa,CAACS,OAAO,CAAC;IACvC,OAAOC,IAAI,CAACC,GAAG,CAAC,GAAGZ,KAAK,CAACa,GAAG,CAACC,CAAC,IAAI,IAAI,CAACG,gBAAgB,CAACH,CAAC,CAAC,CAAC,CAAC;EAC9D,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACEtF,QAAQ,CAAC6B,SAAS,CAAC6D,UAAU,GAAG,UAAUC,GAAG,GAAG,EAAE,EAAE;IAClD,IAAI,CAACA,GAAG,CAACC,MAAM,EAAE,OAAO,IAAI,CAACC,UAAU,CAAC,CAAC;IACzC,OAAO,IAAI,CAACvB,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAACH,GAAG,CAAC,CAACI,uBAAuB;EAC3E,CAAC;;EAED;AACF;AACA;AACA;EACE/F,QAAQ,CAAC6B,SAAS,CAACgE,UAAU,GAAG,YAAY;IAC1C,OAAO,IAAI,CAACvB,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAAC,GAAG,CAAC,CAACE,qBAAqB;EACzE,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACEhG,QAAQ,CAAC6B,SAAS,CAACoE,WAAW,GAAG,UAAUN,GAAG,GAAG,EAAE,EAAE;IACnD,IAAI,CAACA,GAAG,CAACC,MAAM,EAAE,OAAO,IAAI,CAACM,WAAW,CAAC,CAAC;IAC1C,OAAO,IAAI,CAAC5B,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAACH,GAAG,CAAC,CAACQ,wBAAwB;EAC5E,CAAC;EAEDnG,QAAQ,CAAC6B,SAAS,CAACqE,WAAW,GAAG,YAAY;IAC3C,OAAO,IAAI,CAAC5B,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAAC,GAAG,CAAC,CAACM,sBAAsB;EAC1E,CAAC;;EAGD;;EAEApG,QAAQ,CAAC6B,SAAS,CAACK,SAAS,GAAG,UAAUmE,CAAC,EAAEC,CAAC,EAAE;IAE7C;IACA,IAAI,OAAOD,CAAC,KAAK,WAAW,EAAE;MAC5B,IAAI,CAACE,MAAM,CAACC,QAAQ,CAAC,WAAW,EAAEH,CAAC,CAAC;MACpC,IAAI,OAAOC,CAAC,KAAK,WAAW,EAAE;QAC5B,IAAIA,CAAC,KAAKzF,EAAE,CAAC4F,MAAM,EAAE;UACnBH,CAAC,GAAGrG,iBAAiB,CAACI,WAAW;QACnC;QACA,IAAI,CAACkG,MAAM,CAACC,QAAQ,CAAC,cAAc,EAAEF,CAAC,CAAC;MACzC;MACA,OAAO,IAAI,CAACI,oBAAoB,CAAC,CAAC;IACpC;IACA;IACA,OAAO;MACLC,UAAU,EAAE,IAAI,CAACJ,MAAM,CAACrE,SAAS;MACjC0E,QAAQ,EAAE,IAAI,CAACL,MAAM,CAACjE;IACxB,CAAC;EACH,CAAC;EAEDtC,QAAQ,CAAC6B,SAAS,CAACgF,gBAAgB,GAAG,YAAY;IAChD,OAAO,IAAI,CAACN,MAAM,CAAC/D,QAAQ,CAACsE,IAAI,IAAI,IAAI,CAACP,MAAM,CAAC/D,QAAQ,CAACC,MAAM;EACjE,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEzC,QAAQ,CAAC6B,SAAS,CAACW,QAAQ,GAAG,UAAUsE,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAE;IAE3D,IAAIC,SAAS,CAACrB,MAAM,KAAK,CAAC,EAAE;MAC1B,OAAO,IAAI,CAACiB,gBAAgB,CAAC,CAAC;IAChC;IAEA,IAAIpE,MAAM,GAAGqE,IAAI;;IAEjB;IACA,IAAIA,IAAI,YAAYlG,EAAE,CAACsG,IAAI,EAAE;MAC3BzE,MAAM,GAAGqE,IAAI,CAACK,IAAI,CAAC1E,MAAM;IAC3B,CAAC,MACI,IAAIqE,IAAI,CAACM,IAAI,YAAYC,UAAU,EAAE;MACxC5E,MAAM,GAAGqE,IAAI,CAACQ,IAAI,CAACC,UAAU;MAC7B,IAAIT,IAAI,CAACQ,IAAI,EAAEE,aAAa,EAAE;QAC5B/E,MAAM,IAAI,GAAG,GAAGqE,IAAI,CAACQ,IAAI,CAACE,aAAa;MACzC;IACF,CAAC,MACI,IAAI,OAAOV,IAAI,KAAK,QAAQ,EAAE;MACjC;MACA,IAAI,OAAOC,IAAI,KAAK,WAAW,IAAI,qBAAqB,CAACU,IAAI,CAAChF,MAAM,CAAC,EAAE;QACrE;QACA,CAAC;UAAEA,MAAM;UAAEsE;QAAK,CAAC,GAAG,IAAI,CAACW,oBAAoB,CAACjF,MAAM,CAAC;MACvD;IACF;IAEA,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE,MAAMX,KAAK,CAAC,yBAAyB,CAAC;;IAEtE;IACA,IAAImF,SAAS,CAACrB,MAAM,KAAK,CAAC,IAAI,OAAOmB,IAAI,KAAK,QAAQ,EAAE;MACtDC,OAAO,GAAGD,IAAI;MACdA,IAAI,GAAGY,SAAS;IAClB;;IAEA;IACA,IAAI,CAACpB,MAAM,CAACC,QAAQ,CAAC,UAAU,EAAE;MAAEM,IAAI;MAAErE,MAAM;MAAEsE;IAAK,CAAC,CAAC;;IAExD;IACA,IAAI,OAAOA,IAAI,KAAK,WAAW,EAAE;MAC/B,IAAI,CAACa,YAAY,CAACb,IAAI,CAAC;IACzB;;IAEA;IACA,IAAI,OAAOC,OAAO,KAAK,QAAQ,EAAE;MAC/B,IAAI,CAACa,cAAc,CAACb,OAAO,CAAC;IAC9B;IAEA,OAAO,IAAI,CAACN,oBAAoB,CAAC,CAAC;EACpC,CAAC;EAED1G,QAAQ,CAAC6B,SAAS,CAAC6F,oBAAoB,GAAG,UAAUZ,IAAI,EAAEgB,KAAK,GAAG,CAAC,EAAE;IACnE,IAAIA,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,uBAAuB,GAAGlB,IAAI,GAAG,GAAG,CAAC;IAE5D,IAAImB,QAAQ,GAAG1E,kBAAkB,CAAC2E,MAAM,CAAC,CAACC,KAAK,EAAExE,CAAC,KAAK;MACrDwE,KAAK,CAACxE,CAAC,CAAC,GAAG1B,iBAAiB,CAAC0B,CAAC,CAAC,CAACxB,OAAO;MACvC,OAAOgG,KAAK;IACd,CAAC,EAAE,CAAC,CAAC,CAAC;IAEN,IAAIC,EAAE,GAAG,IAAI,CAACC,UAAU,CAACJ,QAAQ,CAAC;IAClCG,EAAE,CAACE,KAAK,CAACxB,IAAI,GAAGA,IAAI;IACpB,IAAIwB,KAAK,GAAGC,gBAAgB,CAACH,EAAE,CAAC;IAChC7E,kBAAkB,CAAC7B,OAAO,CAAC8G,IAAI,IAAI;MACjC,IAAI,CAACjC,MAAM,CAACiC,IAAI,CAAC,GAAGF,KAAK,CAACE,IAAI,CAAC;MAC/B,IAAIV,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,gBAAgB,GAAGQ,IAAI,GAAG,IAAI,GAAGF,KAAK,CAACE,IAAI,CAAC,GAAG,GAAG,CAAC;IAC5E,CAAC,CAAC;IAEF,OAAO;MAAE/F,MAAM,EAAE6F,KAAK,CAACf,UAAU;MAAER,IAAI,EAAEuB,KAAK,CAACG;IAAS,CAAC;EAC3D,CAAC;EAEDzI,QAAQ,CAAC6B,SAAS,CAACa,WAAW,GAAG,UAAUgG,OAAO,EAAE;IAClD;IACA,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC/B,IAAI,CAACnC,MAAM,CAACC,QAAQ,CAAC,YAAY,EAAE,IAAI,CAAC;MACxC,IAAI,CAACD,MAAM,CAACC,QAAQ,CAAC,aAAa,EAAEkC,OAAO,CAAC;MAC5C,OAAO,IAAI,CAAChC,oBAAoB,CAAC,CAAC;IACpC;IACA;IACA,OAAO,IAAI,CAACH,MAAM,CAAC7D,WAAW;EAChC,CAAC;EAED1C,QAAQ,CAAC6B,SAAS,CAAC8G,UAAU,GAAG,UAAUC,MAAM,EAAE;IAChD;IACA,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;MAC9B,IAAI,CAACrC,MAAM,CAACC,QAAQ,CAAC,YAAY,EAAEoC,MAAM,CAAC;MAC1C,IAAI,CAAClC,oBAAoB,CAAC,CAAC;;MAE3B;MACA;MACA;MACA,IAAI,CAAC9F,EAAE,CAACiB,SAAS,CAACgH,SAAS,CAAC,CAAC,EAAE;QAC7B,IAAI,CAACC,uBAAuB,CAAC,yBAAyB,EAAE,UAAUF,MAAM,EAAE,CAAC;MAC7E;MACA;IACF;IACA;IACA,OAAO,IAAI,CAACrC,MAAM,CAACtD,UAAU;EAC/B,CAAC;;EAED;AACF;AACA;AACA;EACEjD,QAAQ,CAAC6B,SAAS,CAACc,QAAQ,GAAG,UAAUoE,IAAI,EAAE;IAE5C;IACA,IAAI,OAAOA,IAAI,KAAK,WAAW,EAAE;MAC/B,IAAI,CAACa,YAAY,CAACb,IAAI,CAAC;MACvB,OAAO,IAAI,CAACL,oBAAoB,CAAC,CAAC;IACpC;IACA;IACA,OAAO,IAAI,CAACH,MAAM,CAAC5D,QAAQ;EAC7B,CAAC;EAED3C,QAAQ,CAAC6B,SAAS,CAACkH,SAAS,GAAG,UAAUT,KAAK,EAAE;IAE9C;IACA,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;MAChC,IAAI,CAAC/B,MAAM,CAACC,QAAQ,CAAC,WAAW,EAAE8B,KAAK,CAAC;MACxC,OAAO,IAAI,CAAC5B,oBAAoB,CAAC,CAAC;IACpC;IACA;IACA,OAAO,IAAI,CAACH,MAAM,CAACnD,SAAS;EAC9B,CAAC;EAEDpD,QAAQ,CAAC6B,SAAS,CAACe,QAAQ,GAAG,UAAUoG,SAAS,EAAE;IAEjD,IAAIA,SAAS,KAAKnI,EAAE,CAACgC,IAAI,IAAImG,SAAS,KAAKnI,EAAE,CAACoI,IAAI,EAAE;MAClD,IAAI,CAAC1C,MAAM,CAACC,QAAQ,CAAC,UAAU,EAAEwC,SAAS,CAAC;MAC3C;MACA,OAAO,IAAI,CAACE,MAAM;IACpB;IACA,OAAO,IAAI,CAAC3C,MAAM,CAAC3D,QAAQ;EAC7B,CAAC;EAED5C,QAAQ,CAAC6B,SAAS,CAACsH,aAAa,GAAG,UAAU9F,SAAS,EAAE;IAEtD,IAAI,OAAOA,SAAS,KAAK,WAAW,EAAE;MACpC,IAAI,CAACkD,MAAM,CAACC,QAAQ,CAAC,WAAW,EAAEnD,SAAS,CAAC;MAC5C,OAAO,IAAI,CAACqD,oBAAoB,CAAC,CAAC;IACpC;IACA,OAAO,IAAI,CAACH,MAAM,CAAClD,SAAS;EAC9B,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACErD,QAAQ,CAAC6B,SAAS,CAACuH,YAAY,GAAG,UAAUZ,IAAI,EAAEa,KAAK,EAAEC,IAAI,EAAE;IAE7D,IAAIC,QAAQ,GAAG,KAAK;MAAEzB,KAAK,GAAGwB,IAAI,EAAExB,KAAK,IAAI,KAAK;;IAElD;IACA,IAAI,OAAOuB,KAAK,KAAK,WAAW,EAAE;MAChC,IAAIlB,KAAK,GAAG,IAAI,CAACN,cAAc,CAAC,CAAC;MACjC,IAAIW,IAAI,IAAIL,KAAK,EAAE,OAAOA,KAAK,CAACK,IAAI,CAAC;MACrC,MAAM1G,KAAK,CAAC,uBAAuB,GAAG0G,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC;IACrD;;IAEA;IACA,IAAIA,IAAI,IAAI,IAAI,CAACjC,MAAM,IAAI,IAAI,CAACA,MAAM,CAACiC,IAAI,CAAC,KAAKa,KAAK,EAAE;MACtD,IAAI,CAAC9C,MAAM,CAACiC,IAAI,CAAC,GAAGa,KAAK;MACzBE,QAAQ,GAAG,IAAI;MACf,IAAIzB,KAAK,EAAE;QACTC,OAAO,CAACC,GAAG,CAAC,cAAc,GAAGQ,IAAI,GAAG,IAAI,GAAGxB,OAAO,CAACwB,IAAI,CAAC,GAAG,GAAG,CAAC;MACjE;IACF;IACA;IAAA,KACK,IAAIA,IAAI,IAAI,IAAI,CAAClE,kBAAkB,CAAC,CAAC,EAAE;MAC1C,IAAI,CAACkF,mBAAmB,CAAChB,IAAI,EAAEa,KAAK,EAAEvB,KAAK,CAAC;MAC5CyB,QAAQ,GAAG,IAAI;IACjB;IACA;IAAA,KACK,IAAIf,IAAI,IAAI,IAAI,CAACiB,UAAU,CAAC,CAAC,CAACnB,KAAK,EAAE;MACxC,IAAI,CAACQ,uBAAuB,CAACN,IAAI,EAAEa,KAAK,EAAEvB,KAAK,CAAC;MAChDyB,QAAQ,GAAG,IAAI;IACjB,CAAC,MACI;MACHxB,OAAO,CAAC2B,IAAI,CAAC,iCAAiC,GAAGlB,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC;IAClE;IAEA,OAAOe,QAAQ,GAAG,IAAI,CAAC7C,oBAAoB,CAAC,CAAC,GAAG,IAAI,CAACwC,MAAM;EAC7D,CAAC;;EAED;AACF;AACA;AACA;AACA;EACElJ,QAAQ,CAAC6B,SAAS,CAACgG,cAAc,GAAG,UAAU8B,UAAU,EAAE;IAExD;IACA,IAAI,OAAOA,UAAU,KAAK,WAAW,EAAE;MACrCnG,MAAM,CAACC,IAAI,CAACkG,UAAU,CAAC,CAACjI,OAAO,CAACkI,GAAG,IAAI;QACrC,IAAI,CAACR,YAAY,CAACQ,GAAG,EAAED,UAAU,CAACC,GAAG,CAAC,CAAC;MACzC,CAAC,CAAC;MACF,OAAO,IAAI,CAACV,MAAM;IACpB;;IAEA;IACA,IAAIW,OAAO,GAAG,IAAI,CAACvF,kBAAkB,CAAC,CAAC;IACvCqF,UAAU,GAAGrG,gBAAgB,CAAC4E,MAAM,CAAC,CAACC,KAAK,EAAExE,CAAC,KAAK;MACjDwE,KAAK,CAACxE,CAAC,CAAC,GAAGkG,OAAO,CAAClG,CAAC,CAAC;MACrB,OAAOwE,KAAK;IACd,CAAC,EAAE,CAAC,CAAC,CAAC;;IAEN;IACA3E,MAAM,CAACC,IAAI,CAACxB,iBAAiB,CAAC,CAACP,OAAO,CAACiC,CAAC,IAAI;MAC1C,IAAI1B,iBAAiB,CAAC0B,CAAC,CAAC,EAAEtB,IAAI,KAAK,WAAW,EAAE;QAC9CsH,UAAU,CAAChG,CAAC,CAAC,GAAGkG,OAAO,CAAClG,CAAC,CAAC;MAC5B,CAAC,MACI;QAAE;QACL,IAAIA,CAAC,KAAK,UAAU,EAAE;UACpB;UACA,IAAImG,OAAO,GAAG,IAAI,CAACjD,gBAAgB,CAAC,CAAC;UACrC,IAAI,OAAOiD,OAAO,KAAK,QAAQ,IAAI,QAAQ,IAAIA,OAAO,EAAE;YACtDA,OAAO,GAAGtG,MAAM,CAACuG,MAAM,CAAC,CAAC,CAAC,EAAED,OAAO,CAAC;YACpC,OAAOA,OAAO,CAACZ,MAAM;UACvB;UACAS,UAAU,CAAChG,CAAC,CAAC,GAAGmG,OAAO;QACzB,CAAC,MACI;UACHH,UAAU,CAAChG,CAAC,CAAC,GAAG,IAAI,CAAC4C,MAAM,CAAC5C,CAAC,CAAC;QAChC;MACF;IACF,CAAC,CAAC;IAEF,OAAOgG,UAAU;EACnB,CAAC;EAED3J,QAAQ,CAAC6B,SAAS,CAACmI,QAAQ,GAAG,YAAY,CAAE,+BAAgC;;EAE5E;;EAEAhK,QAAQ,CAAC6B,SAAS,CAACgF,gBAAgB,GAAG,YAAY;IAChD,OAAO,IAAI,CAACN,MAAM,CAAC/D,QAAQ,CAACsE,IAAI,IAAI,IAAI,CAACP,MAAM,CAAC/D,QAAQ,CAACC,MAAM;EACjE,CAAC;;EAED;AACF;AACA;AACA;AACA;EACEzC,QAAQ,CAAC6B,SAAS,CAACiD,cAAc,GAAG,UAAUzC,IAAI,EAAE2B,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEkF,IAAI,EAAE;IAElF,IAAIO,OAAO,GAAG,IAAI,CAACvF,kBAAkB,CAAC,CAAC;IACvC,IAAID,WAAW,GAAGwF,OAAO,CAACvH,YAAY;IACtC,IAAI;MAAEI,WAAW;MAAER;IAAU,CAAC,GAAG,IAAI,CAACqE,MAAM;;IAE5C;IACA,CAAC;MAAEpC,KAAK;MAAEC;IAAO,CAAC,GAAG,IAAI,CAAC6F,eAAe,CAAChG,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC;;IAE9D;IACA,IAAII,KAAK,GAAG,IAAI,CAACC,aAAa,CAACT,GAAG,EAAEG,KAAK,EAAEC,MAAM,CAAC;;IAElD;IACA,IAAI8F,KAAK,GAAG1F,KAAK,CAACa,GAAG,CAAC,CAACV,IAAI,EAAEwF,CAAC,KAAK,IAAI,CAAC9H,IAAI,CAAC,CAAC+H,IAAI,CAAC,IAAI,CAAC,CACrDzF,IAAI,EAAEV,CAAC,EAAEC,CAAC,GAAGiG,CAAC,GAAGzH,WAAW,CAAC,CAAC;;IAEjC;IACA,IAAI8B,KAAK,CAACoB,MAAM,GAAG,CAAC,EAAE;MACpB;MACA;MACAsE,KAAK,CAACxI,OAAO,CAAC2I,EAAE,IAAIA,EAAE,CAACpG,CAAC,IAAIrD,EAAE,CAAC0J,UAAU,CAACzI,SAAS,CAAC0I,aAAa,CAACC,IAAI,CAAC,IAAI,EAAEtI,SAAS,EAAEiC,KAAK,CAAC,CAAC;IACjG;;IAEA;IACA,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;MACjC;MACA;MACAxD,EAAE,CAAC0J,UAAU,CAACzI,SAAS,CAAC4I,aAAa,CAACD,IAAI,CAAC,IAAI,EAAEN,KAAK,EAAE9F,MAAM,CAAC;IACjE;;IAEA;IACA,IAAIW,MAAM,GAAGmF,KAAK,CAAC,CAAC,CAAC;IACrB,IAAI1F,KAAK,CAACoB,MAAM,GAAG,CAAC,EAAE;MAEpB;MACAb,MAAM,GAAG,IAAI,CAAC2F,gBAAgB,CAACR,KAAK,CAAC;;MAErC;MACA,IAAI,CAACZ,IAAI,EAAEqB,cAAc,EAAE;QACzB,IAAI,CAACC,cAAc,CAAC7F,MAAM,EAAEZ,KAAK,IAAI,CAAC,EAAEC,MAAM,IAAI,CAAC,CAAC;MACtD;IACF;IAEAyF,OAAO,CAACvH,YAAY,GAAG+B,WAAW,CAAC,CAAC;;IAEpC,OAAO;MAAEU,MAAM;MAAEP;IAAM,CAAC;EAC1B,CAAC;;EAED;AACF;AACA;AACA;EACExE,QAAQ,CAAC6B,SAAS,CAACoI,eAAe,GAAG,UAAUhG,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAE;IAElE,IAAI,OAAOD,KAAK,KAAK,WAAW,EAAE;MAChC,QAAQ,IAAI,CAACoC,MAAM,CAACsE,QAAQ;QAC1B,KAAKhK,EAAE,CAAC4F,MAAM;UACZ;QACF,KAAK5F,EAAE,CAACiK,OAAO;UACb3G,KAAK,IAAIF,CAAC;UACVG,MAAM,IAAIF,CAAC;UACX;QACF,KAAKrD,EAAE,CAACkK,MAAM;UACZ5G,KAAK,IAAI,CAAC;UACVC,MAAM,IAAI,CAAC;UACX;MACJ;IACF;IACA,OAAO;MAAEH,CAAC;MAAEC,CAAC;MAAEC,KAAK;MAAEC;IAAO,CAAC;EAChC,CAAC;;EAED;AACF;AACA;AACA;EACEpE,QAAQ,CAAC6B,SAAS,CAACiH,uBAAuB,GAAG,UAAUc,GAAG,EAAEoB,GAAG,EAAElD,KAAK,EAAE;IAEtE,IAAIuB,KAAK,GAAG2B,GAAG,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC;;IAE5B,IAAInD,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,eAAe,GAAG4B,GAAG,GAAG,IAAI,GAAGP,KAAK,GAAG,GAAG,CAAC;;IAElE;IACA,IAAIO,GAAG,KAAKxI,qBAAqB,EAAE;MACjC,IAAI,CAAC8J,4BAA4B,CAAC7B,KAAK,CAAC;IAC1C;;IAEA;IACA,IAAI,CAACI,UAAU,CAAC,CAAC,CAACnB,KAAK,CAACsB,GAAG,CAAC,GAAGP,KAAK;;IAEpC;IACA,IAAI,IAAI,CAACI,UAAU,CAAC,CAAC,CAACnB,KAAK,CAACsB,GAAG,CAAC,KAAKP,KAAK,EAAE;EAC9C,CAAC;;EAED;AACF;AACA;AACA;AACA;EACErJ,QAAQ,CAAC6B,SAAS,CAACqJ,4BAA4B,GAAG,UAAU7B,KAAK,EAAEvB,KAAK,GAAG,KAAK,EAAE;IAChF;IACA,IAAI,OAAOuB,KAAK,KAAK,QAAQ,EAAE;MAC7BA,KAAK,GAAG7F,MAAM,CAACC,IAAI,CAAC4F,KAAK,CAAC,CAAChE,GAAG,CAAC8F,CAAC,IAAIA,CAAC,GAAG,GAAG,GAAG9B,KAAK,CAAC8B,CAAC,CAAC,CAAC,CAAC3J,IAAI,CAAC,IAAI,CAAC;IACpE;IACA,IAAI4J,MAAM,GAAG/B,KAAK,CAACgC,KAAK,CAACpK,YAAY,CAAC;IACtCmK,MAAM,CAAC1J,OAAO,CAAC4E,CAAC,IAAI;MAClBA,CAAC,GAAGA,CAAC,CAACgF,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;MAC5B,IAAIC,OAAO,GAAGjK,cAAc,CAACkK,IAAI,CAAClF,CAAC,CAAC;MACpC;MACA,IAAIiF,OAAO,IAAIA,OAAO,CAAC3F,MAAM,EAAE;QAC7B,IAAI6F,IAAI,GAAGF,OAAO,CAAC,CAAC,CAAC;QACrB;QACA,IAAIP,GAAG,GAAGU,UAAU,CAACA,UAAU,CAACpF,CAAC,CAACgF,OAAO,CAACG,IAAI,EAAE,EAAE,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;QACvE,QAAQH,IAAI;UACV,KAAK,MAAM;YACT,IAAI3D,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,sBAAsB,GAAGgD,GAAG,CAAC;YACpD;YACA,IAAI,IAAI,CAACzE,MAAM,CAACtD,UAAU,KAAK+H,GAAG,EAAE,IAAI,CAACrC,UAAU,CAACqC,GAAG,CAAC;YACxD,OAAOA,GAAG;UACZ,KAAK,MAAM;YACT;UACF,KAAK,MAAM;YACT,IAAIlD,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,qBAAqB,IAAIgD,GAAG,GAAG,QAAQ,GAAG,QAAQ,CAAC,CAAC;YAC3E;UACF,KAAK,MAAM;YACT,IAAIlD,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,qBAAqB,IAAIgD,GAAG,GAAG,SAAS,GAAG,QAAQ,CAAC,CAAC;YAC5E;UACF,KAAK,MAAM;YACT,IAAIlD,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,4BAA4B,GAAGgD,GAAG,CAAC;YAC1D;QACJ;MACF;IACF,CAAC,CAAC;EACJ,CAAC;;EAKD;AACF;AACA;AACA;AACA;EACEhL,QAAQ,CAAC6B,SAAS,CAAC2H,mBAAmB,GAAG,UAAUhB,IAAI,EAAEwC,GAAG,EAAElD,KAAK,GAAG,KAAK,EAAE;IAE3E;IACA,IAAI,IAAI,CAACxD,kBAAkB,CAAC,CAAC,CAACkE,IAAI,CAAC,KAAKwC,GAAG,EAAE;MAC3C,OAAO,IAAI,CAAC9B,MAAM;IACpB;;IAEA;IACA;IACA,CAACrF,YAAY,KAAK,EAAE,EAAEgI,IAAI,CAAC,CAACrD,IAAI,EAAEwC,GAAG,CAAC,CAAC;IAEvC,IAAIlD,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,mBAAmB,GAAGQ,IAAI,GAAG,IAAI,GAAGwC,GAAG,GAAG,GAAG,CAAC;EACvE,CAAC;;EAED;AACF;AACA;EACEhL,QAAQ,CAAC6B,SAAS,CAAC0C,eAAe,GAAG,UAAUN,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAE;IAElE,IAAIyG,QAAQ,GAAG,IAAI,CAACtE,MAAM,CAACsE,QAAQ;IAEnC,IAAI,OAAO1G,KAAK,KAAK,WAAW,EAAE;MAChC,QAAQ0G,QAAQ;QACd,KAAKhK,EAAE,CAACkK,MAAM;UACZ5G,KAAK,IAAI,CAAC;UACVF,CAAC,IAAIE,KAAK,GAAG,CAAC;UACd,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;YACjCA,MAAM,IAAI,CAAC;YACXF,CAAC,IAAIE,MAAM,GAAG,CAAC;UACjB;UACA;QACF,KAAKvD,EAAE,CAAC4F,MAAM;UACZxC,CAAC,IAAIE,KAAK,GAAG,CAAC;UACd,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;YACjCF,CAAC,IAAIE,MAAM,GAAG,CAAC;UACjB;UACA;QACF,KAAKvD,EAAE,CAACiK,OAAO;UACb3G,KAAK,IAAIF,CAAC;UACV,IAAI,OAAOG,MAAM,KAAK,WAAW,EAAE;YACjCA,MAAM,IAAIF,CAAC;UACb;UACA;MACJ;IACF;IACA,OAAO;MAAED,CAAC;MAAEC,CAAC;MAAEC,KAAK;MAAEC;IAAO,CAAC;EAChC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACEpE,QAAQ,CAAC6B,SAAS,CAACiK,WAAW,GAAG,UAAUC,OAAO,EAAE;IAAEtJ;EAAO,CAAC,GAAG,IAAI,CAAC8D,MAAM,CAAC/D,QAAQ,EAAE;IAErF,MAAMwJ,WAAW,GAAIC,GAAG,IAAK,CAACC,KAAK,CAACD,GAAG,CAAC,IAAIA,GAAG,CAACN,IAAI,CAAC,CAAC,KAAK,EAAE;;IAE7D;IACA,IAAIK,WAAW,CAACD,OAAO,CAAC,EAAE;MACxB,OAAOL,UAAU,CAACK,OAAO,CAAC;IAC5B;IACA,IAAII,GAAG,GAAG,IAAI,CAAC9D,UAAU,CAAC;MAAEI,QAAQ,EAAEsD;IAAQ,CAAC,CAAC;IAChDI,GAAG,CAAC7D,KAAK,CAACG,QAAQ,GAAGsD,OAAO;IAC5BI,GAAG,CAAC7D,KAAK,CAACf,UAAU,GAAG9E,MAAM;IAC7B,IAAI2J,WAAW,GAAG7D,gBAAgB,CAAC4D,GAAG,CAAC,CAAC1D,QAAQ;IAChD,IAAIA,QAAQ,GAAGiD,UAAU,CAACU,WAAW,CAAC;IACtC,IAAI,OAAO3D,QAAQ,KAAK,QAAQ,EAAE;MAChC,MAAM3G,KAAK,CAAC,6BAA6B,CAAC;IAC5C;IACA,OAAO2G,QAAQ;EACjB,CAAC;EAEDzI,QAAQ,CAAC6B,SAAS,CAACwG,UAAU,GAAG,UAAUF,KAAK,EAAE;IAC/C,IAAI,OAAOrE,SAAS,KAAK,WAAW,EAAE;MACpC,IAAIqI,GAAG,GAAGE,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;MACvCH,GAAG,CAACI,UAAU,GAAG,MAAM;MACvBJ,GAAG,CAAC7D,KAAK,CAACkE,OAAO,GAAG,MAAM;MAC1BhJ,MAAM,CAACiJ,OAAO,CAACtE,KAAK,CAAC,CAACzG,OAAO,CAAC,CAAC,CAAC8G,IAAI,EAAEwC,GAAG,CAAC,KAAK;QAC7CmB,GAAG,CAAC7D,KAAK,CAACE,IAAI,CAAC,GAAGwC,GAAG;MACvB,CAAC,CAAC;MACF,IAAI,CAACvB,UAAU,CAAC,CAAC,CAACiD,WAAW,CAACP,GAAG,CAAC;MAClCrI,SAAS,GAAGqI,GAAG;IACjB;IACA,OAAOrI,SAAS;EAClB,CAAC;;EAGD;AACF;AACA;AACA;AACA;AACA;EACE9D,QAAQ,CAAC6B,SAAS,CAAC6I,gBAAgB,GAAG,UAAUiC,MAAM,EAAE;IACtD;IACA,IAAIC,IAAI,GAAGzH,IAAI,CAAC0H,GAAG,CAAC,GAAGF,MAAM,CAACtH,GAAG,CAACyH,CAAC,IAAIA,CAAC,CAAC7I,CAAC,CAAC,CAAC;IAC5C,IAAI8I,IAAI,GAAG5H,IAAI,CAAC0H,GAAG,CAAC,GAAGF,MAAM,CAACtH,GAAG,CAACyH,CAAC,IAAIA,CAAC,CAAC5I,CAAC,CAAC,CAAC;IAC5C,IAAI8I,IAAI,GAAG7H,IAAI,CAACC,GAAG,CAAC,GAAGuH,MAAM,CAACtH,GAAG,CAACyH,CAAC,IAAIA,CAAC,CAAC5I,CAAC,GAAG4I,CAAC,CAACzG,CAAC,CAAC,CAAC;IAClD,IAAI4G,IAAI,GAAG9H,IAAI,CAACC,GAAG,CAAC,GAAGuH,MAAM,CAACtH,GAAG,CAACyH,CAAC,IAAIA,CAAC,CAAC7I,CAAC,GAAG6I,CAAC,CAACI,CAAC,CAAC,CAAC;IAClD,OAAO;MAAEjJ,CAAC,EAAE2I,IAAI;MAAE1I,CAAC,EAAE6I,IAAI;MAAEG,CAAC,EAAED,IAAI,GAAGL,IAAI;MAAEvG,CAAC,EAAE2G,IAAI,GAAGD;IAAK,CAAC;EAC7D,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;;EAGA;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE/M,QAAQ,CAAC6B,SAAS,CAAC4C,aAAa,GAAG,UAAUT,GAAG,EAAEG,KAAK,EAAEC,MAAM,EAAE;IAE/D,IAAI,OAAOD,KAAK,KAAK,WAAW,EAAE;MAAE;MAClC,IAAIgJ,cAAc,GAAG,IAAI,CAAC7I,kBAAkB,CAAC,CAAC;MAC9C,IAAI6I,cAAc,CAAC7K,YAAY,KAAKzB,EAAE,CAAC0B,QAAQ,EAAE;QAC/C,IAAI,CAAC4K,cAAc,CAAC7K,YAAY,GAAGzB,EAAE,CAACuM,GAAG;MAC3C;IACF;IAEA,IAAI5I,KAAK,GAAG,IAAI,CAAC6I,cAAc,CAACrJ,GAAG,CAACiH,QAAQ,CAAC,CAAC,CAAC;IAC/C,IAAIqC,aAAa,GAAG9I,KAAK,CAACoB,MAAM,GAAG,CAAC;IACpC,IAAI2H,QAAQ,GAAG,OAAOpJ,KAAK,KAAK,WAAW;IAC3C,IAAIqJ,YAAY,GAAGD,QAAQ,IAAI/I,KAAK,CAACiJ,IAAI,CAACnI,CAAC,IAAI,IAAI,CAACC,gBAAgB,CAACD,CAAC,CAAC,GAAGnB,KAAK,CAAC;IAChF,IAAI;MAAEzB,WAAW,EAAEgG,OAAO;MAAE9F;IAAS,CAAC,GAAG,IAAI,CAAC2D,MAAM;;IAEpD;IACA,IAAI+G,aAAa,IAAIE,YAAY,EAAE;MACjC,IAAID,QAAQ,EAAE/I,KAAK,GAAG,IAAI,CAACkJ,QAAQ,CAAC9K,QAAQ,EAAE4B,KAAK,EAAEL,KAAK,CAAC;IAC7D;;IAEA;IACA,IAAIoJ,QAAQ,IAAI,OAAOnJ,MAAM,KAAK,WAAW,EAAE;MAE7C,IAAI,OAAOsE,OAAO,KAAK,WAAW,EAAE;QAClC,MAAM5G,KAAK,CAAC,4CAA4C,CAAC;MAC3D;;MAEA;MACA,KAAK,IAAIqI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3F,KAAK,CAACoB,MAAM,EAAEuE,CAAC,EAAE,EAAE;QACrC,IAAIwD,EAAE,GAAGjF,OAAO,IAAIyB,CAAC,GAAG,CAAC,CAAC;QAC1B,IAAIwD,EAAE,GAAGvJ,MAAM,EAAE;UACf;UACAI,KAAK,GAAGA,KAAK,CAACoJ,KAAK,CAAC,CAAC,EAAEzD,CAAC,CAAC;UACzB;QACF;MACF;IACF;IAEA,OAAO3F,KAAK;EACd,CAAC;;EAED;AACF;AACA;EACExE,QAAQ,CAAC6B,SAAS,CAAC0I,aAAa,GAAG,UAAUrI,SAAS,EAAEiC,KAAK,EAAE;IAC7D,QAAQjC,SAAS;MACf,KAAKrB,EAAE,CAACuB,IAAI;QACV,OAAO,CAAC;MACV,KAAKvB,EAAE,CAAC4F,MAAM;QACZ,OAAOtC,KAAK,GAAG,CAAC;MAClB,KAAKtD,EAAE,CAACgN,KAAK;QACX,OAAO1J,KAAK;MACd,KAAKlE,iBAAiB,CAACQ,KAAK;QAC1B,OAAO,CAAC;MACV,KAAKR,iBAAiB,CAACS,GAAG;QACxB,MAAM,IAAIoB,KAAK,CAAC,iDAAiD,CAAC;MACpE;QACE,OAAO,CAAC;IACZ;EACF,CAAC;;EAED;AACF;AACA;EACE9B,QAAQ,CAAC6B,SAAS,CAAC+I,cAAc,GAAG,UAAUP,EAAE,EAAElG,KAAK,EAAEC,MAAM,EAAE;IAC/D,IAAI,OAAOD,KAAK,KAAK,WAAW,EAAE;MAEhC,QAAQ,IAAI,CAACoC,MAAM,CAACsE,QAAQ;QAC1B,KAAKhK,EAAE,CAAC4F,MAAM;UACZ4D,EAAE,CAACpG,CAAC,IAAI,CAACE,KAAK,GAAGkG,EAAE,CAAC6C,CAAC,IAAI,CAAC;UAC1B7C,EAAE,CAACnG,CAAC,IAAI,CAACE,MAAM,GAAGiG,EAAE,CAAChE,CAAC,IAAI,CAAC;UAC3B;QACF,KAAKxF,EAAE,CAACiK,OAAO;UACbT,EAAE,CAAC6C,CAAC,IAAI7C,EAAE,CAACpG,CAAC;UACZoG,EAAE,CAAChE,CAAC,IAAIgE,EAAE,CAACnG,CAAC;UACZ;QACF,KAAKrD,EAAE,CAACkK,MAAM;UACZV,EAAE,CAACpG,CAAC,IAAI,CAACE,KAAK,GAAGkG,EAAE,CAAC6C,CAAC,IAAI,CAAC;UAC1B7C,EAAE,CAACnG,CAAC,IAAI,CAACE,MAAM,GAAGiG,EAAE,CAAChE,CAAC,IAAI,CAAC;UAC3BgE,EAAE,CAAC6C,CAAC,IAAI,CAAC;UACT7C,EAAE,CAAChE,CAAC,IAAI,CAAC;UACT;MACJ;MACA,OAAOgE,EAAE;IACX;EACF,CAAC;EAEDrK,QAAQ,CAAC6B,SAAS,CAACiM,oBAAoB,GAAG,UAAUzD,EAAE,EAAElG,KAAK,EAAEC,MAAM,EAAE;IACrE,IAAI,OAAOD,KAAK,KAAK,WAAW,EAAE;MAEhC,QAAQ,IAAI,CAACoC,MAAM,CAACsE,QAAQ;QAC1B,KAAKhK,EAAE,CAAC4F,MAAM;UACZ4D,EAAE,CAACpG,CAAC,IAAI,CAACE,KAAK,GAAGkG,EAAE,CAAC6C,CAAC,IAAI,CAAC;UAC1B7C,EAAE,CAACnG,CAAC,IAAI,CAACE,MAAM,GAAGiG,EAAE,CAAChE,CAAC,IAAI,CAAC;UAC3B;QACF,KAAKxF,EAAE,CAACiK,OAAO;UACbT,EAAE,CAAC6C,CAAC,IAAI7C,EAAE,CAACpG,CAAC;UACZoG,EAAE,CAAChE,CAAC,IAAIgE,EAAE,CAACnG,CAAC;UACZ;QACF,KAAKrD,EAAE,CAACkK,MAAM;UACZV,EAAE,CAACpG,CAAC,IAAI,CAACE,KAAK,GAAGkG,EAAE,CAAC6C,CAAC,IAAI,CAAC;UAC1B7C,EAAE,CAACnG,CAAC,IAAI,CAACE,MAAM,GAAGiG,EAAE,CAAChE,CAAC,IAAI,CAAC;UAC3BgE,EAAE,CAAC6C,CAAC,IAAI,CAAC;UACT7C,EAAE,CAAChE,CAAC,IAAI,CAAC;UACT;MACJ;MACA,OAAOgE,EAAE;IACX;EACF,CAAC;;EAED;AACF;AACA;EACErK,QAAQ,CAAC6B,SAAS,CAAC0D,gBAAgB,GAAG,UAAUwI,CAAC,EAAE;IACjD,IAAIC,OAAO,GAAG,IAAI,CAAC1J,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAACiI,CAAC,CAAC;IACtD,IAAIE,GAAG,GAAGD,OAAO,CAACE,qBAAqB;IACvC,IAAIC,GAAG,GAAGH,OAAO,CAACI,sBAAsB;IACxC,OAAOD,GAAG,GAAGF,GAAG;EAClB,CAAC;;EAED;AACF;AACA;EACEjO,QAAQ,CAAC6B,SAAS,CAAC4D,gBAAgB,GAAG,UAAUsI,CAAC,EAAE;IACjD,OAAO,IAAI,CAACzJ,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAACiI,CAAC,CAAC,CAAC5J,KAAK;EACvD,CAAC;;EAED;AACF;AACA;EACEnE,QAAQ,CAAC6B,SAAS,CAACwM,iBAAiB,GAAG,UAAUN,CAAC,EAAE9J,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAE;IAEhE,IAAI8J,OAAO,GAAG,IAAI,CAAC1J,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAACiI,CAAC,CAAC;IACtD,IAAIO,GAAG,GAAGN,OAAO,CAACjI,uBAAuB;IACzC,IAAIwI,IAAI,GAAGP,OAAO,CAAC7H,wBAAwB;IAC3C,IAAI8H,GAAG,GAAGD,OAAO,CAACE,qBAAqB;IACvC,IAAIC,GAAG,GAAGH,OAAO,CAACI,sBAAsB;IACxC,OAAO;MAAEnK,CAAC,EAAEA,CAAC,GAAGgK,GAAG;MAAE/J,CAAC,EAAEA,CAAC,GAAGoK,GAAG;MAAEpB,CAAC,EAAEiB,GAAG,GAAGF,GAAG;MAAE5H,CAAC,EAAEiI,GAAG,GAAGC;IAAK,CAAC;EAChE,CAAC;;EAED;AACF;AACA;EACEvO,QAAQ,CAAC6B,SAAS,CAAC2M,iBAAiB,GAAG,UAAUT,CAAC,EAAE9J,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAE;IAEhE,IAAI8J,OAAO,GAAG,IAAI,CAAC1J,kBAAkB,CAAC,CAAC,CAACwB,WAAW,CAACiI,CAAC,CAAC;IACtD,IAAIO,GAAG,GAAGN,OAAO,CAAChI,qBAAqB;IACvC,IAAIuI,IAAI,GAAGP,OAAO,CAAC5H,sBAAsB;IACzCnC,CAAC,IAAI,IAAI,CAACsG,aAAa,CAAC,IAAI,CAAChE,MAAM,CAACrE,SAAS,EAAE8L,OAAO,CAAC7J,KAAK,CAAC;IAC7D,OAAO;MAAEF,CAAC;MAAEC,CAAC,EAAEA,CAAC,GAAGoK,GAAG;MAAEpB,CAAC,EAAEc,OAAO,CAAC7J,KAAK;MAAEkC,CAAC,EAAEiI,GAAG,GAAGC;IAAK,CAAC;EAAG,CAAC;;EAE/D;AACF;AACA;AACA;AACA;EACEvO,QAAQ,CAAC6B,SAAS,CAAC+F,YAAY,GAAG,UAAUmE,OAAO,EAAE;IAEnD,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC/B;MACAA,OAAO,GAAG,IAAI,CAACD,WAAW,CAACC,OAAO,CAAC;IACrC;;IAEA;IACA,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAE/B;MACA,IAAI,IAAI,CAACxF,MAAM,CAAC5D,QAAQ,KAAKoJ,OAAO,EAAE;QACpC,IAAI,CAACxF,MAAM,CAACC,QAAQ,CAAC,UAAU,EAAEuF,OAAO,CAAC;;QAEzC;QACA,IAAI,CAAC,IAAI,CAACxF,MAAM,CAACkI,UAAU,EAAE;UAC3B,IAAI,CAAClI,MAAM,CAACC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAACD,MAAM,CAAC5D,QAAQ,GAAG7B,YAAY,CAAC;QAC1E;QACA,OAAO,IAAI,CAAC,CAAC;MACf;IACF,CAAC,MACI;MACHiH,OAAO,CAAC2B,IAAI,CAAC,0BAA0B,GAAGqC,OAAO,CAAC;IACpD;IAEA,OAAO,KAAK;EACd,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE/L,QAAQ,CAAC6B,SAAS,CAAC6L,QAAQ,GAAG,UAAU9K,QAAQ,EAAE4B,KAAK,EAAEkK,QAAQ,GAAGC,QAAQ,EAAErF,IAAI,GAAG,CAAC,CAAC,EAAE;IAEvF,IAAIsF,QAAQ,GAAGtF,IAAI,CAACuF,SAAS,KAAKjM,QAAQ,KAAK/B,EAAE,CAACgC,IAAI,GAAG,GAAG,GAAG,EAAE,CAAC;IAClE,IAAI8B,IAAI;MAAEmK,QAAQ;MAAEC,SAAS;MAAEC,KAAK;MAAEC,QAAQ,GAAG,EAAE;IAEnD,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG1K,KAAK,CAACoB,MAAM,EAAEsJ,IAAI,EAAE,EAAE;MAC9CvK,IAAI,GAAG,EAAE;MACTqK,KAAK,GAAGxK,KAAK,CAAC0K,IAAI,CAAC,CAAC7D,KAAK,CAACuD,QAAQ,CAAC;MACnC,KAAK,IAAIO,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGH,KAAK,CAACpJ,MAAM,EAAEuJ,IAAI,EAAE,EAAE;QAC9CL,QAAQ,GAAG,GAAGnK,IAAI,GAAGqK,KAAK,CAACG,IAAI,CAAC,EAAE,GAAGP,QAAQ;QAC7CG,SAAS,GAAG,IAAI,CAACxJ,gBAAgB,CAACuJ,QAAQ,CAAC;QAC3C,IAAInK,IAAI,CAACiB,MAAM,GAAG,CAAC,IAAImJ,SAAS,GAAGL,QAAQ,EAAE;UAC3CO,QAAQ,CAACpD,IAAI,CAAClH,IAAI,CAACgH,IAAI,CAAC,CAAC,CAAC;UAC1BhH,IAAI,GAAG,GAAGqK,KAAK,CAACG,IAAI,CAAC,EAAE,GAAGP,QAAQ;QACpC,CAAC,MAAM;UACLjK,IAAI,GAAGmK,QAAQ;QACjB;MACF;MACAG,QAAQ,CAACpD,IAAI,CAAClH,IAAI,CAACgH,IAAI,CAAC,CAAC,CAAC;IAC5B;IACA,OAAOsD,QAAQ;EACjB,CAAC;;EAED;AACF;AACA;EACEjP,QAAQ,CAAC6B,SAAS,CAACwL,cAAc,GAAG,UAAUU,CAAC,EAAE;IAC/C,IAAI,CAACA,CAAC,IAAIA,CAAC,CAACnI,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC;IACrC,OAAOmI,CAAC,CAACzC,OAAO,CAACnK,MAAM,EAAE,IAAI,CAAC,CAACkK,KAAK,CAACrK,WAAW,CAAC;EACnD,CAAC;;EAED;AACF;AACA;EACEhB,QAAQ,CAAC6B,SAAS,CAACuN,gBAAgB,GAAG,UAAUC,SAAS,EAAE;IAEzD,IAAIC,KAAK,GAAGD,SAAS,CAAChE,KAAK,CAACpK,YAAY,CAAC;IACzC,IAAIwB,MAAM,GAAG6M,KAAK,CAACjK,GAAG,CAACkK,IAAI,IAAI;MAC7BA,IAAI,GAAGA,IAAI,CAAC5D,IAAI,CAAC,CAAC;MAClB,IAAI4D,IAAI,CAACC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAACtO,QAAQ,CAACuG,IAAI,CAAC8H,IAAI,CAAC,EAAE;QAClDA,IAAI,GAAG,IAAIA,IAAI,GAAG,CAAC,CAAC;MACtB;MACA,OAAOA,IAAI;IACb,CAAC,CAAC,CAAC/N,IAAI,CAAC,IAAI,CAAC;IAEb,OAAOiB,MAAM;EACf,CAAC;EAEDzC,QAAQ,CAAC6B,SAAS,CAAC4N,gBAAgB,GAAG,YAAY;IAChD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI;MAAEjN,QAAQ;MAAEG,QAAQ;MAAEO,UAAU;MAAEE,SAAS;MAAEH,UAAU;MAAEE;IAAY,CAAC,GAAG,IAAI,CAACoD,MAAM;IACxF,IAAI4G,cAAc,GAAG,IAAI,CAAC7I,kBAAkB,CAAC,CAAC;IAE9C,IAAI7B,MAAM,GAAG,IAAI,CAAC2M,gBAAgB,CAAC5M,QAAQ,CAACC,MAAM,CAAC;IACnD,IAAI6F,KAAK,GAAGlF,SAAS,KAAKvC,EAAE,CAACkC,MAAM,GAAG,GAAGK,SAAS,GAAG,GAAG,EAAE;IAC1D,IAAIwF,MAAM,GAAG3F,UAAU,KAAKpC,EAAE,CAACkC,MAAM,GAAG,GAAGE,UAAU,GAAG,GAAG,EAAE;IAC7D,IAAIyM,OAAO,GAAGvM,WAAW,KAAKtC,EAAE,CAACkC,MAAM,GAAG,GAAGI,WAAW,GAAG,GAAG,EAAE;IAChE,IAAIwM,KAAK,GAAG,GAAGhN,QAAQ,IAAI,IAAIO,UAAU,KAAKrC,EAAE,CAACkC,MAAM,GAAG,IAAIG,UAAU,GAAG,GAAG,GAAG,CAAC;IAClF,IAAI0M,UAAU,GAAG,GAAGtH,KAAK,GAAGoH,OAAO,GAAG9G,MAAM,GAAG+G,KAAK,GAAGlN,MAAM,EAAE,CAACkJ,IAAI,CAAC,CAAC;IACtE;;IAEA;IACAwB,cAAc,CAACrG,IAAI,GAAG8I,UAAU;;IAEhC;IACA,IAAIzC,cAAc,CAACrG,IAAI,KAAK8I,UAAU,EAAE;MACtC,IAAIC,QAAQ,GAAGD,UAAU;MACzB,IAAIE,MAAM,GAAG3C,cAAc,CAACrG,IAAI;MAChC,IAAI+I,QAAQ,KAAKC,MAAM,EAAE;QACvB;QACA;QACA,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;EACE9P,QAAQ,CAAC6B,SAAS,CAAC6E,oBAAoB,GAAG,UAAUoB,KAAK,GAAG,KAAK,EAAE;IAEjE,IAAI,CAAC2H,gBAAgB,CAAC,CAAC;;IAEvB;IACA,IAAI5F,OAAO,GAAG,IAAI,CAACvF,kBAAkB,CAAC,CAAC;IACvCuF,OAAO,CAACxG,SAAS,GAAG,IAAI,CAACkD,MAAM,CAAClD,SAAS;IACzCwG,OAAO,CAAC3H,SAAS,GAAG,IAAI,CAACqE,MAAM,CAACrE,SAAS;IACzC2H,OAAO,CAACvH,YAAY,GAAG,IAAI,CAACiE,MAAM,CAACjE,YAAY;;IAE/C;IACA,IAAIyN,OAAO,GAAG,IAAI,CAACxJ,MAAM,CAACzD,WAAW;IACrC,IAAIc,eAAe,CAACoM,QAAQ,CAACD,OAAO,CAAC,IAAIlG,OAAO,CAAC/G,WAAW,KAAKiN,OAAO,EAAE;MACxElG,OAAO,CAAC/G,WAAW,GAAGiN,OAAO;IAC/B;;IAEA;IACA,OAAOlM,YAAY,EAAE+B,MAAM,EAAE;MAE3B,IAAI,CAAC4C,IAAI,EAAEwC,GAAG,CAAC,GAAGnH,YAAY,CAACoM,KAAK,CAAC,CAAC;MACtC,IAAInI,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,0BAA0B,GAAGQ,IAAI,GAAG,OAAO,GAAGwC,GAAG,GAAG,GAAG,CAAC;MAC/EnB,OAAO,CAACrB,IAAI,CAAC,GAAGwC,GAAG;;MAEnB;MACA,IAAInB,OAAO,CAACrB,IAAI,CAAC,KAAKwC,GAAG,EAAE;QACzBjD,OAAO,CAAC2B,IAAI,CAAC,kBAAkBlB,IAAI,mDAAmD,CAAC,CAAC,CAAC;QACzFT,OAAO,CAACC,GAAG,CAAC,YAAY,GAAGgD,GAAG,GAAG,cAAc,GAAGnB,OAAO,CAACrB,IAAI,CAAC,GAAG,GAAG,CAAC;MACxE;IACF;IAEA,OAAO,IAAI,CAACU,MAAM;EACpB,CAAC;EAED,IAAItI,EAAE,CAAC0J,UAAU,EAAE;IACjB1J,EAAE,CAAC0J,UAAU,CAACzI,SAAS,CAAC4H,UAAU,GAAG,YAAY;MAC/C,OAAO,IAAI,CAACyG,MAAM;IACpB,CAAC;IACDtP,EAAE,CAAC0J,UAAU,CAACzI,SAAS,CAACyC,kBAAkB,GAAG,YAAY;MACvD,OAAO,IAAI,CAAC6I,cAAc;IAC5B,CAAC;IAEDvM,EAAE,CAAC0J,UAAU,CAACzI,SAAS,CAAC+C,WAAW,GAAG,UAAUb,IAAI,EAAEE,CAAC,EAAEC,CAAC,EAAE8I,IAAI,EAAED,IAAI,EAAE;MACtE,IAAIxG,MAAM,GAAG,IAAI,CAACA,MAAM;MACxB,IAAIsD,OAAO,GAAG,IAAI,CAACvF,kBAAkB,CAAC,CAAC;MAEvC,IAAIJ,CAAC,GAAG6I,IAAI,IAAI7I,CAAC,IAAI8I,IAAI,EAAE;QACzB,OAAO,CAAC;MACV;MAEA,IAAI,CAACnB,IAAI,CAAC,CAAC;;MAEX;MACA,IAAItF,MAAM,CAAC4J,WAAW,IAAI5J,MAAM,CAAC6J,SAAS,EAAE;QAC1CvG,OAAO,CAACwG,UAAU,CAACtM,IAAI,EAAEE,CAAC,EAAEC,CAAC,CAAC;MAChC;MAEA,IAAI,CAAC,IAAI,CAACoM,SAAS,IAAI/J,MAAM,CAACgK,SAAS,EAAE;QAEvC;QACA,IAAI,CAAChK,MAAM,CAACiK,OAAO,EAAE;UACnB,IAAI,CAACC,QAAQ,CAAC1P,WAAW,CAAC;QAC5B;QACA8I,OAAO,CAAC6G,QAAQ,CAAC3M,IAAI,EAAEE,CAAC,EAAEC,CAAC,CAAC;MAC9B;MAEA,IAAI,CAACyM,GAAG,CAAC,CAAC;IACZ,CAAC;;IAED;AACJ;AACA;IACI/P,EAAE,CAAC0J,UAAU,CAACzI,SAAS,CAAC6C,cAAc,GAAG,UAAUT,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEI,KAAK,EAAE;MAE7E,IAAI;QAAE9B,WAAW;QAAER;MAAU,CAAC,GAAG,IAAI,CAACqE,MAAM;MAC5C,IAAIqK,SAAS;QAAEC,QAAQ,GAAG,IAAIC,KAAK,CAACtM,KAAK,CAACoB,MAAM,CAAC;MACjD,IAAImL,SAAS,GAAG,OAAO5M,KAAK,KAAK,WAAW,GAAG,CAAC,GAAGA,KAAK;MACxD,IAAI6M,SAAS,GAAG,OAAO5M,MAAM,KAAK,WAAW,GAAG,CAAC,GAAGA,MAAM;MAE1D,KAAK,IAAI+F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3F,KAAK,CAACoB,MAAM,EAAEuE,CAAC,EAAE,EAAE;QACrC,QAAQjI,SAAS;UACf,KAAKjC,iBAAiB,CAACQ,KAAK;YAC1B,MAAM,IAAIqB,KAAK,CAAC,mDAAmD,CAAC;UAAE;UACxE,KAAKjB,EAAE,CAACuB,IAAI;YACVwO,SAAS,GAAG3M,CAAC;YACb;UACF,KAAKpD,EAAE,CAAC4F,MAAM;YACZmK,SAAS,GAAG3M,CAAC,GAAG8M,SAAS,GAAG,CAAC;YAC7B;UACF,KAAKlQ,EAAE,CAACgN,KAAK;YACX+C,SAAS,GAAG3M,CAAC,GAAG8M,SAAS;YACzB;UACF,KAAK9Q,iBAAiB,CAACS,GAAG;YACxB,MAAM,IAAIoB,KAAK,CAAC,iDAAiD,CAAC;QACtE;QACA+O,QAAQ,CAAC1G,CAAC,CAAC,GAAG;UAAEpG,IAAI,EAAES,KAAK,CAAC2F,CAAC,CAAC;UAAElG,CAAC,EAAE2M,SAAS;UAAE1M,CAAC,EAAEA,CAAC,GAAGiG,CAAC,GAAGzH;QAAY,CAAC;MACxE;MAEA,OAAO,IAAI,CAAC+H,aAAa,CAACoG,QAAQ,EAAEG,SAAS,CAAC;IAChD,CAAC;;IAED;AACJ;AACA;IACIpQ,EAAE,CAAC0J,UAAU,CAACzI,SAAS,CAAC4I,aAAa,GAAG,UAAUwG,OAAO,EAAE7M,MAAM,EAAE;MAEjE,IAAI,OAAOA,MAAM,KAAK,WAAW,EAAE;QACjC,MAAMtC,KAAK,CAAC,mCAAmC,CAAC;MAClD;MAEA,IAAI;QAAEY,WAAW;QAAEJ;MAAa,CAAC,GAAG,IAAI,CAACiE,MAAM;MAC/C,IAAI2K,IAAI,GAAG,CAAC;QAAEC,QAAQ,GAAGF,OAAO,CAACrL,MAAM;MACvC,IAAIwL,KAAK,GAAGhN,MAAM,GAAI1B,WAAW,IAAIyO,QAAQ,GAAG,CAAC,CAAE;MACnD,QAAQ7O,YAAY;QAAI;QACtB,KAAKzB,EAAE,CAACuM,GAAG;UACT;QAAO;QACT,KAAKvM,EAAE,CAAC0B,QAAQ;UACd;QACF,KAAKtC,iBAAiB,CAACI,WAAW;UAChC6Q,IAAI,GAAGE,KAAK,GAAG,CAAC;UAChB;QACF,KAAKvQ,EAAE,CAACwQ,MAAM;UACZH,IAAI,GAAGE,KAAK;UACZ;QACF,KAAKnR,iBAAiB,CAACC,WAAW;UAChC6H,OAAO,CAAC2B,IAAI,CAAC,4DAA4D,CAAC,CAAC,CAAC;UAC5E;QACF,KAAKzJ,iBAAiB,CAACO,OAAO;UAC5BuH,OAAO,CAAC2B,IAAI,CAAC,wDAAwD,CAAC,CAAC,CAAC;UACxE;MACJ;MACAuH,OAAO,CAACvP,OAAO,CAACyK,GAAG,IAAIA,GAAG,CAACjI,CAAC,IAAIgN,IAAI,CAAC;MACrC,OAAOD,OAAO;IAChB,CAAC;EACH;EAEA,IAAIrQ,EAAE,CAAC0Q,UAAU,EAAE;IACjB1Q,EAAE,CAAC0Q,UAAU,CAACzP,SAAS,CAAC4H,UAAU,GAAG,YAAW;MAC9C,IAAI,CAAC,IAAI,CAAC8H,WAAW,EAAE;QACrB,IAAI,CAACA,WAAW,GAAGlF,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;QACnD,IAAI,CAACiF,WAAW,CAACpN,KAAK,GAAG,CAAC;QAC1B,IAAI,CAACoN,WAAW,CAACnN,MAAM,GAAG,CAAC;QAC3B,IAAI,CAACmN,WAAW,CAACjJ,KAAK,CAACkE,OAAO,GAAG,MAAM;QACvC;QACA,IAAI,CAAC0D,MAAM,CAACsB,aAAa,CAACC,YAAY,CAAC,IAAI,CAACF,WAAW,EAAE,IAAI,CAACrB,MAAM,CAAC;MACvE;MACA,OAAO,IAAI,CAACqB,WAAW;IACzB,CAAC;IACD3Q,EAAE,CAAC0Q,UAAU,CAACzP,SAAS,CAACyC,kBAAkB,GAAG,YAAW;MACtD,IAAI,CAAC,IAAI,CAACoN,mBAAmB,EAAE;QAC7B,MAAMjI,UAAU,GAAG,IAAI,CAACA,UAAU,CAAC,CAAC;QACpC,IAAI,CAACiI,mBAAmB,GAAGjI,UAAU,CAACkI,UAAU,CAAC,IAAI,CAAC;MACxD;MACA,OAAO,IAAI,CAACD,mBAAmB;IACjC,CAAC;IACD,MAAME,SAAS,GAAGhR,EAAE,CAAC0Q,UAAU,CAACzP,SAAS,CAACgQ,MAAM;IAChDjR,EAAE,CAAC0Q,UAAU,CAACzP,SAAS,CAACgQ,MAAM,GAAG,YAAW;MAC1C,IAAI,IAAI,CAACN,WAAW,EAAE;QACpB,IAAI,CAACA,WAAW,CAACC,aAAa,CAACM,WAAW,CAAC,IAAI,CAACP,WAAW,CAAC;MAC9D;MACAK,SAAS,CAACpH,IAAI,CAAC,IAAI,CAAC;IACtB,CAAC;IAED5J,EAAE,CAAC0Q,UAAU,CAACzP,SAAS,CAAC6C,cAAc,GAAG,UAAUT,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEI,KAAK,EAAE;MAE7E,IAAI;QAAE9B,WAAW;QAAER;MAAU,CAAC,GAAG,IAAI,CAACqE,MAAM;MAC5C,MAAMwL,MAAM,GAAGvN,KAAK,CAACa,GAAG,CAAEV,IAAI,IAAK,IAAI,CAACc,gBAAgB,CAACd,IAAI,CAAC,CAAC;MAC/D,IAAIiM,SAAS;QAAEC,QAAQ,GAAG,IAAIC,KAAK,CAACtM,KAAK,CAACoB,MAAM,CAAC;MACjD,IAAImL,SAAS,GAAG,OAAO5M,KAAK,KAAK,WAAW,GAAGgB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,GAAG2M,MAAM,CAAC,GAAG5N,KAAK;MAC7E,IAAI6M,SAAS,GAAG,OAAO5M,MAAM,KAAK,WAAW,GAAG,CAAC,GAAGA,MAAM;MAE1D,KAAK,IAAI+F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3F,KAAK,CAACoB,MAAM,EAAEuE,CAAC,EAAE,EAAE;QACrC,QAAQjI,SAAS;UACf,KAAKjC,iBAAiB,CAACQ,KAAK;YAC1B,MAAM,IAAIqB,KAAK,CAAC,mDAAmD,CAAC;UAAE;UACxE,KAAKjB,EAAE,CAACuB,IAAI;YACVwO,SAAS,GAAG3M,CAAC;YACb;UACF,KAAKpD,EAAE,CAAC4F,MAAM;YACZmK,SAAS,GAAG3M,CAAC,GAAG,CAAC8M,SAAS,GAAGgB,MAAM,CAAC5H,CAAC,CAAC,IAAI,CAAC,GAAG4G,SAAS,GAAG,CAAC,GAAG,CAAC5M,KAAK,IAAI,CAAC,IAAI,CAAC;YAC9E;UACF,KAAKtD,EAAE,CAACgN,KAAK;YACX+C,SAAS,GAAG3M,CAAC,GAAG8M,SAAS,GAAGgB,MAAM,CAAC5H,CAAC,CAAC,GAAG4G,SAAS,IAAI5M,KAAK,IAAI,CAAC,CAAC;YAChE;UACF,KAAKlE,iBAAiB,CAACS,GAAG;YACxB,MAAM,IAAIoB,KAAK,CAAC,iDAAiD,CAAC;QACtE;QACA+O,QAAQ,CAAC1G,CAAC,CAAC,GAAG;UAAEpG,IAAI,EAAES,KAAK,CAAC2F,CAAC,CAAC;UAAElG,CAAC,EAAE2M,SAAS;UAAE1M,CAAC,EAAEA,CAAC,GAAGiG,CAAC,GAAGzH;QAAY,CAAC;MACxE;MAEA,OAAO,IAAI,CAAC+H,aAAa,CAACoG,QAAQ,EAAEG,SAAS,CAAC;IAChD,CAAC;IAEDpQ,EAAE,CAAC0Q,UAAU,CAACzP,SAAS,CAAC4I,aAAa,GAAG,UAAUwG,OAAO,EAAE7M,MAAM,EAAE;MAEjE,IAAI,OAAOA,MAAM,KAAK,WAAW,EAAE;QACjC,MAAMtC,KAAK,CAAC,mCAAmC,CAAC;MAClD;MAEA,IAAI;QAAEY,WAAW;QAAEJ,YAAY;QAAEK,QAAQ;QAAEH;MAAS,CAAC,GAAG,IAAI,CAAC+D,MAAM;MACnE,IAAI2K,IAAI,GAAG,CAAC;QAAEC,QAAQ,GAAGF,OAAO,CAACrL,MAAM;MACvC,IAAIoM,WAAW,GAAGrP,QAAQ,GAAGwO,QAAQ,GAAI,CAACzO,WAAW,GAAGC,QAAQ,KAAKwO,QAAQ,GAAG,CAAC,CAAE;MACnF,QAAQ7O,YAAY;QAAI;QACtB,KAAKzB,EAAE,CAACuM,GAAG;UACT8D,IAAI,GAAGvO,QAAQ;UACf;QACF,KAAK9B,EAAE,CAAC0B,QAAQ;UACd;QACF,KAAKtC,iBAAiB,CAACI,WAAW;UAChC6Q,IAAI,GAAG,CAACc,WAAW,GAAG,CAAC,GAAGrP,QAAQ,GAAG,CAACyB,MAAM,IAAI,CAAC,IAAI,CAAC;UACtD;QACF,KAAKvD,EAAE,CAACwQ,MAAM;UACZH,IAAI,GAAG,EAAEc,WAAW,GAAGrP,QAAQ,CAAC,IAAIyB,MAAM,IAAI,CAAC,CAAC;UAChD;QACF;UACE2D,OAAO,CAAC2B,IAAI,CAAC,GAAGpH,YAAY,kCAAkC,CAAC,CAAC,CAAC;UACjE;MACJ;MACA4O,IAAI,IAAI,IAAI,CAAC3K,MAAM,CAAC/D,QAAQ,CAACsE,IAAI,EAAEmL,cAAc,CAACtP,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;MAClEsO,OAAO,CAACvP,OAAO,CAACyK,GAAG,IAAIA,GAAG,CAACjI,CAAC,IAAIgN,IAAI,CAAC;MACrC,OAAOD,OAAO;IAChB,CAAC;EACH;AACF;AAEA,IAAI,OAAOrQ,EAAE,KAAK,WAAW,EAAE;EAC7BD,QAAQ,CAACC,EAAE,EAAEA,EAAE,CAACiB,SAAS,CAAC;AAC5B;AAEA,SAASlB,QAAQ,IAAIwB,OAAO,EAAElC,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}