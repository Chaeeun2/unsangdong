{"ast":null,"code":"import lab from \"../spaces/lab.js\";\nimport lch from \"../spaces/lch.js\";\nimport getColor from \"../getColor.js\";\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// CMC by the Color Measurement Committee of the\n// Bradford Society of Dyeists and Colorsts, 1994.\n// Uses LCH rather than Lab,\n// with different weights for L, C and H differences\n// A nice increase in accuracy for modest increase in complexity\nconst π = Math.PI;\nconst d2r = π / 180;\nexport default function (color, sample, {\n  l = 2,\n  c = 1\n} = {}) {\n  [color, sample] = getColor([color, sample]);\n\n  // Given this color as the reference\n  // and a sample,\n  // calculate deltaE CMC.\n\n  // This implementation assumes the parametric\n  // weighting factors l:c are 2:1\n  // which is typical for non-textile uses.\n\n  let [L1, a1, b1] = lab.from(color);\n  let [, C1, H1] = lch.from(lab, [L1, a1, b1]);\n  let [L2, a2, b2] = lab.from(sample);\n  let C2 = lch.from(lab, [L2, a2, b2])[1];\n\n  // let [L1, a1, b1] = color.getAll(lab);\n  // let C1 = color.get(\"lch.c\");\n  // let H1 = color.get(\"lch.h\");\n  // let [L2, a2, b2] = sample.getAll(lab);\n  // let C2 = sample.get(\"lch.c\");\n\n  // Check for negative Chroma,\n  // which might happen through\n  // direct user input of LCH values\n\n  if (C1 < 0) {\n    C1 = 0;\n  }\n  if (C2 < 0) {\n    C2 = 0;\n  }\n\n  // we don't need H2 as ΔH is calculated from Δa, Δb and ΔC\n\n  // Lightness and Chroma differences\n  // These are (color - sample), unlike deltaE2000\n  let ΔL = L1 - L2;\n  let ΔC = C1 - C2;\n  let Δa = a1 - a2;\n  let Δb = b1 - b2;\n\n  // weighted Hue difference, less for larger Chroma difference\n\n  let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;\n  // due to roundoff error it is possible that, for zero a and b,\n  // ΔC > Δa + Δb is 0, resulting in attempting\n  // to take the square root of a negative number\n\n  // trying instead the equation from Industrial Color Physics\n  // By Georg A. Klein\n\n  // let ΔH = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));\n  // console.log({ΔH});\n  // This gives the same result to 12 decimal places\n  // except it sometimes NaNs when trying to root a negative number\n\n  // let ΔH = Math.sqrt(H2); we never actually use the root, it gets squared again!!\n\n  // positional corrections to the lack of uniformity of CIELAB\n  // These are all trying to make JND ellipsoids more like spheres\n\n  // SL Lightness crispening factor, depends entirely on L1 not L2\n  let SL = 0.511; // linear portion of the Y to L transfer function\n  if (L1 >= 16) {\n    // cubic portion\n    SL = 0.040975 * L1 / (1 + 0.01765 * L1);\n  }\n\n  // SC Chroma factor\n  let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;\n\n  // Cross term T for blue non-linearity\n  let T;\n  if (Number.isNaN(H1)) {\n    H1 = 0;\n  }\n  if (H1 >= 164 && H1 <= 345) {\n    T = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));\n  } else {\n    T = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));\n  }\n  // console.log({T});\n\n  // SH Hue factor also depends on C1,\n  let C4 = Math.pow(C1, 4);\n  let F = Math.sqrt(C4 / (C4 + 1900));\n  let SH = SC * (F * T + 1 - F);\n\n  // Finally calculate the deltaE, term by term as root sume of squares\n  let dE = (ΔL / (l * SL)) ** 2;\n  dE += (ΔC / (c * SC)) ** 2;\n  dE += H2 / SH ** 2;\n  // dE += (ΔH / SH)  ** 2;\n  return Math.sqrt(dE);\n  // Yay!!!\n}","map":{"version":3,"names":["lab","lch","getColor","π","Math","PI","d2r","color","sample","l","c","L1","a1","b1","from","C1","H1","L2","a2","b2","C2","ΔL","ΔC","Δa","Δb","H2","SL","SC","T","Number","isNaN","abs","cos","C4","pow","F","sqrt","SH","dE"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/deltaE/deltaECMC.js"],"sourcesContent":["import lab from \"../spaces/lab.js\";\nimport lch from \"../spaces/lch.js\";\nimport getColor from \"../getColor.js\";\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// CMC by the Color Measurement Committee of the\n// Bradford Society of Dyeists and Colorsts, 1994.\n// Uses LCH rather than Lab,\n// with different weights for L, C and H differences\n// A nice increase in accuracy for modest increase in complexity\nconst π = Math.PI;\nconst d2r = π / 180;\n\nexport default function (color, sample, {l = 2, c = 1} = {}) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE CMC.\n\n\t// This implementation assumes the parametric\n\t// weighting factors l:c are 2:1\n\t// which is typical for non-textile uses.\n\n\tlet [L1, a1, b1] = lab.from(color);\n\tlet [, C1, H1] = lch.from(lab, [L1, a1, b1]);\n\tlet [L2, a2, b2] = lab.from(sample);\n\tlet C2 = lch.from(lab, [L2, a2, b2])[1];\n\n\t// let [L1, a1, b1] = color.getAll(lab);\n\t// let C1 = color.get(\"lch.c\");\n\t// let H1 = color.get(\"lch.h\");\n\t// let [L2, a2, b2] = sample.getAll(lab);\n\t// let C2 = sample.get(\"lch.c\");\n\n\t// Check for negative Chroma,\n\t// which might happen through\n\t// direct user input of LCH values\n\n\tif (C1 < 0) {\n\t\tC1 = 0;\n\t}\n\tif (C2 < 0) {\n\t\tC2 = 0;\n\t}\n\n\t// we don't need H2 as ΔH is calculated from Δa, Δb and ΔC\n\n\t// Lightness and Chroma differences\n\t// These are (color - sample), unlike deltaE2000\n\tlet ΔL = L1 - L2;\n\tlet ΔC = C1 - C2;\n\n\tlet Δa = a1 - a2;\n\tlet Δb = b1 - b2;\n\n\t// weighted Hue difference, less for larger Chroma difference\n\n\tlet H2 = (Δa ** 2) + (Δb ** 2) - (ΔC ** 2);\n\t// due to roundoff error it is possible that, for zero a and b,\n\t// ΔC > Δa + Δb is 0, resulting in attempting\n\t// to take the square root of a negative number\n\n\t// trying instead the equation from Industrial Color Physics\n\t// By Georg A. Klein\n\n\t// let ΔH = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));\n\t// console.log({ΔH});\n\t// This gives the same result to 12 decimal places\n\t// except it sometimes NaNs when trying to root a negative number\n\n\t// let ΔH = Math.sqrt(H2); we never actually use the root, it gets squared again!!\n\n\t// positional corrections to the lack of uniformity of CIELAB\n\t// These are all trying to make JND ellipsoids more like spheres\n\n\t// SL Lightness crispening factor, depends entirely on L1 not L2\n\tlet SL = 0.511;\t// linear portion of the Y to L transfer function\n\tif (L1 >= 16) {\t// cubic portion\n\t\tSL = (0.040975 * L1) / (1 + 0.01765 * L1);\n\t}\n\n\t// SC Chroma factor\n\tlet SC = ((0.0638 * C1) / (1 + 0.0131 * C1)) + 0.638;\n\n\t// Cross term T for blue non-linearity\n\tlet T;\n\tif (Number.isNaN(H1)) {\n\t\tH1 = 0;\n\t}\n\n\tif (H1 >= 164 && H1 <= 345) {\n\t\tT = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));\n\t}\n\telse {\n\t\tT = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));\n\t}\n\t// console.log({T});\n\n\t// SH Hue factor also depends on C1,\n\tlet C4 = Math.pow(C1, 4);\n\tlet F = Math.sqrt(C4 / (C4 + 1900));\n\tlet SH = SC * ((F * T) + 1 - F);\n\n\t// Finally calculate the deltaE, term by term as root sume of squares\n\tlet dE = (ΔL / (l * SL)) ** 2;\n\tdE += (ΔC / (c * SC)) ** 2;\n\tdE += (H2 / (SH ** 2));\n\t// dE += (ΔH / SH)  ** 2;\n\treturn Math.sqrt(dE);\n\t// Yay!!!\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}