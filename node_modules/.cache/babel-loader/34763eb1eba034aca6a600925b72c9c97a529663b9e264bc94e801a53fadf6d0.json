{"ast":null,"code":"/**\n * @module Environment\n * @submodule Environment\n * @for p5\n * @requires core\n */\n\nfunction outputs(p5, fn) {\n  /**\n   * Creates a screen reader-accessible description of shapes on the canvas.\n   *\n   * `textOutput()` adds a general description, list of shapes, and\n   * table of shapes to the web page. The general description includes the\n   * canvas size, canvas color, and number of shapes. For example,\n   * `Your output is a, 100 by 100 pixels, gray canvas containing the following 2 shapes:`.\n   *\n   * A list of shapes follows the general description. The list describes the\n   * color, location, and area of each shape. For example,\n   * `a red circle at middle covering 3% of the canvas`. Each shape can be\n   * selected to get more details.\n   *\n   * `textOutput()` uses its table of shapes as a list. The table describes the\n   * shape, color, location, coordinates and area. For example,\n   * `red circle location = middle area = 3%`. This is different from\n   * <a href=\"#/p5/gridOutput\">gridOutput()</a>, which uses its table as a grid.\n   *\n   * The `display` parameter is optional. It determines how the description is\n   * displayed. If `LABEL` is passed, as in `textOutput(LABEL)`, the description\n   * will be visible in a div element next to the canvas. Using `LABEL` creates\n   * unhelpful duplicates for screen readers. Only use `LABEL` during\n   * development. If `FALLBACK` is passed, as in `textOutput(FALLBACK)`, the\n   * description will only be visible to screen readers. This is the default\n   * mode.\n   *\n   * Read\n   * <a href=\"/learn/accessible-labels.html\">Writing accessible canvas descriptions</a>\n   * to learn more about making sketches accessible.\n   *\n   * @method textOutput\n   * @param  {(FALLBACK|LABEL)} [display] either FALLBACK or LABEL.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the text description.\n   *   textOutput();\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the text description and\n   *   // display it for debugging.\n   *   textOutput(LABEL);\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup(){\n   *  createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the text description.\n   *   textOutput();\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup(){\n   *  createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the text description and\n   *   // display it for debugging.\n   *   textOutput(LABEL);\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.textOutput = function (display) {\n    // p5._validateParameters('textOutput', arguments);\n    //if textOutput is already true\n    if (this._accessibleOutputs.text) {\n      return;\n    } else {\n      //make textOutput true\n      this._accessibleOutputs.text = true;\n      //create output for fallback\n      this._createOutput('textOutput', 'Fallback');\n      if (display === this.LABEL) {\n        //make textOutput label true\n        this._accessibleOutputs.textLabel = true;\n        //create output for label\n        this._createOutput('textOutput', 'Label');\n      }\n    }\n  };\n\n  /**\n   * Creates a screen reader-accessible description of shapes on the canvas.\n   *\n   * `gridOutput()` adds a general description, table of shapes, and list of\n   * shapes to the web page. The general description includes the canvas size,\n   * canvas color, and number of shapes. For example,\n   * `gray canvas, 100 by 100 pixels, contains 2 shapes:  1 circle 1 square`.\n   *\n   * `gridOutput()` uses its table of shapes as a grid. Each shape in the grid\n   * is placed in a cell whose row and column correspond to the shape's location\n   * on the canvas. The grid cells describe the color and type of shape at that\n   * location. For example, `red circle`. These descriptions can be selected\n   * individually to get more details. This is different from\n   * <a href=\"#/p5/textOutput\">textOutput()</a>, which uses its table as a list.\n   *\n   * A list of shapes follows the table. The list describes the color, type,\n   * location, and area of each shape. For example,\n   * `red circle, location = middle, area = 3 %`.\n   *\n   * The `display` parameter is optional. It determines how the description is\n   * displayed. If `LABEL` is passed, as in `gridOutput(LABEL)`, the description\n   * will be visible in a div element next to the canvas. Using `LABEL` creates\n   * unhelpful duplicates for screen readers. Only use `LABEL` during\n   * development. If `FALLBACK` is passed, as in `gridOutput(FALLBACK)`, the\n   * description will only be visible to screen readers. This is the default\n   * mode.\n   *\n   * Read\n   * <a href=\"/learn/accessible-labels.html\">Writing accessible canvas descriptions</a>\n   * to learn more about making sketches accessible.\n   *\n   * @method gridOutput\n   * @param  {(FALLBACK|LABEL)} [display] either FALLBACK or LABEL.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the grid description.\n   *   gridOutput();\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the grid description and\n   *   // display it for debugging.\n   *   gridOutput(LABEL);\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup() {\n   *   createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the grid description.\n   *   gridOutput();\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup(){\n   *  createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the grid description and\n   *   // display it for debugging.\n   *   gridOutput(LABEL);\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  fn.gridOutput = function (display) {\n    // p5._validateParameters('gridOutput', arguments);\n    //if gridOutput is already true\n    if (this._accessibleOutputs.grid) {\n      return;\n    } else {\n      //make gridOutput true\n      this._accessibleOutputs.grid = true;\n      //create output for fallback\n      this._createOutput('gridOutput', 'Fallback');\n      if (display === this.LABEL) {\n        //make gridOutput label true\n        this._accessibleOutputs.gridLabel = true;\n        //create output for label\n        this._createOutput('gridOutput', 'Label');\n      }\n    }\n  };\n\n  //helper function returns true when accessible outputs are true\n  fn._addAccsOutput = function () {\n    //if there are no accessible outputs create object with all false\n    if (!this._accessibleOutputs) {\n      this._accessibleOutputs = {\n        text: false,\n        grid: false,\n        textLabel: false,\n        gridLabel: false\n      };\n    }\n    return this._accessibleOutputs.grid || this._accessibleOutputs.text;\n  };\n\n  //helper function that creates html structure for accessible outputs\n  fn._createOutput = function (type, display) {\n    let cnvId = this.canvas.id;\n    //if there are no ingredients create object. this object stores data for the outputs\n    if (!this.ingredients) {\n      this.ingredients = {\n        shapes: {},\n        colors: {\n          background: 'white',\n          fill: 'white',\n          stroke: 'black'\n        },\n        pShapes: '',\n        pBackground: ''\n      };\n    }\n    //if there is no dummyDOM create it\n    if (!this.dummyDOM) {\n      this.dummyDOM = document.getElementById(cnvId).parentNode;\n    }\n    let cIdT, container, inner;\n    let query = '';\n    if (display === 'Fallback') {\n      cIdT = cnvId + type;\n      container = cnvId + 'accessibleOutput';\n      if (!this.dummyDOM.querySelector(`#${container}`)) {\n        //if there is no canvas description (see describe() and describeElement())\n        if (!this.dummyDOM.querySelector(`#${cnvId}_Description`)) {\n          //create html structure inside of canvas\n          this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = `<div id=\"${container}\" role=\"region\" aria-label=\"Canvas Outputs\"></div>`;\n        } else {\n          //create html structure after canvas description container\n          this.dummyDOM.querySelector(`#${cnvId}_Description`).insertAdjacentHTML('afterend', `<div id=\"${container}\" role=\"region\" aria-label=\"Canvas Outputs\"></div>`);\n        }\n      }\n    } else if (display === 'Label') {\n      query = display;\n      cIdT = cnvId + type + display;\n      container = cnvId + 'accessibleOutput' + display;\n      if (!this.dummyDOM.querySelector(`#${container}`)) {\n        //if there is no canvas description label (see describe() and describeElement())\n        if (!this.dummyDOM.querySelector(`#${cnvId}_Label`)) {\n          //create html structure adjacent to canvas\n          this.dummyDOM.querySelector(`#${cnvId}`).insertAdjacentHTML('afterend', `<div id=\"${container}\"></div>`);\n        } else {\n          //create html structure after canvas label\n          this.dummyDOM.querySelector(`#${cnvId}_Label`).insertAdjacentHTML('afterend', `<div id=\"${container}\"></div>`);\n        }\n      }\n    }\n    //create an object to store the latest output. this object is used in _updateTextOutput() and _updateGridOutput()\n    this._accessibleOutputs[cIdT] = {};\n    if (type === 'textOutput') {\n      query = `#${cnvId}gridOutput${query}`; //query is used to check if gridOutput already exists\n      inner = `<div id=\"${cIdT}\">Text Output<div id=\"${cIdT}Summary\" aria-label=\"text output summary\"><p id=\"${cIdT}_summary\"></p><ul id=\"${cIdT}_list\"></ul></div><table id=\"${cIdT}_shapeDetails\" summary=\"text output shape details\"></table></div>`;\n      //if gridOutput already exists\n      if (this.dummyDOM.querySelector(query)) {\n        //create textOutput before gridOutput\n        this.dummyDOM.querySelector(query).insertAdjacentHTML('beforebegin', inner);\n      } else {\n        //create output inside of container\n        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;\n      }\n      //store output html elements\n      this._accessibleOutputs[cIdT].list = this.dummyDOM.querySelector(`#${cIdT}_list`);\n    } else if (type === 'gridOutput') {\n      query = `#${cnvId}textOutput${query}`; //query is used to check if textOutput already exists\n      inner = `<div id=\"${cIdT}\">Grid Output<p id=\"${cIdT}_summary\" aria-label=\"grid output summary\"><table id=\"${cIdT}_map\" summary=\"grid output content\"></table><ul id=\"${cIdT}_shapeDetails\" aria-label=\"grid output shape details\"></ul></div>`;\n      //if textOutput already exists\n      if (this.dummyDOM.querySelector(query)) {\n        //create gridOutput after textOutput\n        this.dummyDOM.querySelector(query).insertAdjacentHTML('afterend', inner);\n      } else {\n        //create output inside of container\n        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;\n      }\n      //store output html elements\n      this._accessibleOutputs[cIdT].map = this.dummyDOM.querySelector(`#${cIdT}_map`);\n    }\n    this._accessibleOutputs[cIdT].shapeDetails = this.dummyDOM.querySelector(`#${cIdT}_shapeDetails`);\n    this._accessibleOutputs[cIdT].summary = this.dummyDOM.querySelector(`#${cIdT}_summary`);\n  };\n\n  //this function is called at the end of setup and draw if using\n  //accessibleOutputs and calls update functions of outputs\n  fn._updateAccsOutput = function () {\n    let cnvId = this.canvas.id;\n    //if the shapes are not the same as before\n    if (JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes || this.ingredients.colors.background !== this.ingredients.pBackground) {\n      //save current shapes as string in pShapes\n      this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);\n      if (this._accessibleOutputs.text) {\n        this._updateTextOutput(cnvId + 'textOutput');\n      }\n      if (this._accessibleOutputs.grid) {\n        this._updateGridOutput(cnvId + 'gridOutput');\n      }\n      if (this._accessibleOutputs.textLabel) {\n        this._updateTextOutput(cnvId + 'textOutputLabel');\n      }\n      if (this._accessibleOutputs.gridLabel) {\n        this._updateGridOutput(cnvId + 'gridOutputLabel');\n      }\n    }\n  };\n\n  //helper function that resets all ingredients when background is called\n  //and saves background color name\n  fn._accsBackground = function (args) {\n    //save current shapes as string in pShapes\n    this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);\n    this.ingredients.pBackground = this.ingredients.colors.background;\n    //empty shapes JSON\n    this.ingredients.shapes = {};\n    //update background different\n    if (this.ingredients.colors.backgroundRGBA !== args) {\n      this.ingredients.colors.backgroundRGBA = args;\n      this.ingredients.colors.background = this._rgbColorName(args);\n    }\n  };\n\n  //helper function that gets fill and stroke of shapes\n  fn._accsCanvasColors = function (f, args) {\n    if (f === 'fill') {\n      //update fill different\n      if (this.ingredients.colors.fillRGBA !== args) {\n        this.ingredients.colors.fillRGBA = args;\n        this.ingredients.colors.fill = this._rgbColorName(args);\n      }\n    } else if (f === 'stroke') {\n      //update stroke if different\n      if (this.ingredients.colors.strokeRGBA !== args) {\n        this.ingredients.colors.strokeRGBA = args;\n        this.ingredients.colors.stroke = this._rgbColorName(args);\n      }\n    }\n  };\n\n  //builds ingredients.shapes used for building outputs\n  fn._accsOutput = function (f, args) {\n    if (f === 'ellipse' && args[2] === args[3]) {\n      f = 'circle';\n    } else if (f === 'rectangle' && args[2] === args[3]) {\n      f = 'square';\n    }\n    let include = {};\n    let add = true;\n    let middle = _getMiddle(f, args);\n    if (f === 'line') {\n      //make color stroke\n      include.color = this.ingredients.colors.stroke;\n      //get lenght\n      include.length = Math.round(Math.hypot(args[2] - args[0], args[3] - args[1]));\n      //get position of end points\n      let p1 = this._getPos(args[0], [1]);\n      let p2 = this._getPos(args[2], [3]);\n      include.loc = _canvasLocator(middle, this.width, this.height);\n      if (p1 === p2) {\n        include.pos = `at ${p1}`;\n      } else {\n        include.pos = `from ${p1} to ${p2}`;\n      }\n    } else {\n      if (f === 'point') {\n        //make color stroke\n        include.color = this.ingredients.colors.stroke;\n      } else {\n        //make color fill\n        include.color = this.ingredients.colors.fill;\n        //get area of shape\n        include.area = this._getArea(f, args);\n      }\n      //get middle of shapes\n      //calculate position using middle of shape\n      include.pos = this._getPos(...middle);\n      //calculate location using middle of shape\n      include.loc = _canvasLocator(middle, this.width, this.height);\n    }\n    //if it is the first time this shape is created\n    if (!this.ingredients.shapes[f]) {\n      this.ingredients.shapes[f] = [include];\n      //if other shapes of this type have been created\n    } else if (this.ingredients.shapes[f] !== [include]) {\n      //for every shape of this type\n      for (let y in this.ingredients.shapes[f]) {\n        //compare it with current shape and if it already exists make add false\n        if (JSON.stringify(this.ingredients.shapes[f][y]) === JSON.stringify(include)) {\n          add = false;\n        }\n      }\n      //add shape by pushing it to the end\n      if (add === true) {\n        this.ingredients.shapes[f].push(include);\n      }\n    }\n  };\n\n  //gets middle point / centroid of shape\n  function _getMiddle(f, args) {\n    let x, y;\n    if (f === 'rectangle' || f === 'ellipse' || f === 'arc' || f === 'circle' || f === 'square') {\n      x = Math.round(args[0] + args[2] / 2);\n      y = Math.round(args[1] + args[3] / 2);\n    } else if (f === 'triangle') {\n      x = (args[0] + args[2] + args[4]) / 3;\n      y = (args[1] + args[3] + args[5]) / 3;\n    } else if (f === 'quadrilateral') {\n      x = (args[0] + args[2] + args[4] + args[6]) / 4;\n      y = (args[1] + args[3] + args[5] + args[7]) / 4;\n    } else if (f === 'line') {\n      x = (args[0] + args[2]) / 2;\n      y = (args[1] + args[3]) / 2;\n    } else {\n      x = args[0];\n      y = args[1];\n    }\n    return [x, y];\n  }\n\n  //gets position of shape in the canvas\n  fn._getPos = function (x, y) {\n    const {\n      x: transformedX,\n      y: transformedY\n    } = this.worldToScreen(new p5.Vector(x, y));\n    const canvasWidth = this.width;\n    const canvasHeight = this.height;\n    if (transformedX < 0.4 * canvasWidth) {\n      if (transformedY < 0.4 * canvasHeight) {\n        return 'top left';\n      } else if (transformedY > 0.6 * canvasHeight) {\n        return 'bottom left';\n      } else {\n        return 'mid left';\n      }\n    } else if (transformedX > 0.6 * canvasWidth) {\n      if (transformedY < 0.4 * canvasHeight) {\n        return 'top right';\n      } else if (transformedY > 0.6 * canvasHeight) {\n        return 'bottom right';\n      } else {\n        return 'mid right';\n      }\n    } else {\n      if (transformedY < 0.4 * canvasHeight) {\n        return 'top middle';\n      } else if (transformedY > 0.6 * canvasHeight) {\n        return 'bottom middle';\n      } else {\n        return 'middle';\n      }\n    }\n  };\n\n  //locates shape in a 10*10 grid\n  function _canvasLocator(args, canvasWidth, canvasHeight) {\n    const noRows = 10;\n    const noCols = 10;\n    let locX = Math.floor(args[0] / canvasWidth * noRows);\n    let locY = Math.floor(args[1] / canvasHeight * noCols);\n    if (locX === noRows) {\n      locX = locX - 1;\n    }\n    if (locY === noCols) {\n      locY = locY - 1;\n    }\n    return {\n      locX,\n      locY\n    };\n  }\n\n  //calculates area of shape\n  fn._getArea = function (objectType, shapeArgs) {\n    let objectArea = 0;\n    if (objectType === 'arc') {\n      // area of full ellipse = PI * horizontal radius * vertical radius.\n      // therefore, area of arc = difference bet. arc's start and end radians * horizontal radius * vertical radius.\n      // the below expression is adjusted for negative values and differences in arc's start and end radians over PI*2\n      const arcSizeInRadians = ((shapeArgs[5] - shapeArgs[4]) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);\n      objectArea = arcSizeInRadians * shapeArgs[2] * shapeArgs[3] / 8;\n      if (shapeArgs[6] === 'open' || shapeArgs[6] === 'chord') {\n        // when the arc's mode is OPEN or CHORD, we need to account for the area of the triangle that is formed to close the arc\n        // (Ax( By −  Cy) + Bx(Cy − Ay) + Cx(Ay − By ) )/2\n        const Ax = shapeArgs[0];\n        const Ay = shapeArgs[1];\n        const Bx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[4]).toFixed(2);\n        const By = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[4]).toFixed(2);\n        const Cx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[5]).toFixed(2);\n        const Cy = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[5]).toFixed(2);\n        const areaOfExtraTriangle = Math.abs(Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By)) / 2;\n        if (arcSizeInRadians > Math.PI) {\n          objectArea = objectArea + areaOfExtraTriangle;\n        } else {\n          objectArea = objectArea - areaOfExtraTriangle;\n        }\n      }\n    } else if (objectType === 'ellipse' || objectType === 'circle') {\n      objectArea = 3.14 * shapeArgs[2] / 2 * shapeArgs[3] / 2;\n    } else if (objectType === 'line') {\n      objectArea = 0;\n    } else if (objectType === 'point') {\n      objectArea = 0;\n    } else if (objectType === 'quadrilateral') {\n      // ((x4+x1)*(y4-y1)+(x1+x2)*(y1-y2)+(x2+x3)*(y2-y3)+(x3+x4)*(y3-y4))/2\n      objectArea = Math.abs((shapeArgs[6] + shapeArgs[0]) * (shapeArgs[7] - shapeArgs[1]) + (shapeArgs[0] + shapeArgs[2]) * (shapeArgs[1] - shapeArgs[3]) + (shapeArgs[2] + shapeArgs[4]) * (shapeArgs[3] - shapeArgs[5]) + (shapeArgs[4] + shapeArgs[6]) * (shapeArgs[5] - shapeArgs[7])) / 2;\n    } else if (objectType === 'rectangle' || objectType === 'square') {\n      objectArea = shapeArgs[2] * shapeArgs[3];\n    } else if (objectType === 'triangle') {\n      objectArea = Math.abs(shapeArgs[0] * (shapeArgs[3] - shapeArgs[5]) + shapeArgs[2] * (shapeArgs[5] - shapeArgs[1]) + shapeArgs[4] * (shapeArgs[1] - shapeArgs[3])) / 2;\n      // (Ax( By −  Cy) + Bx(Cy − Ay) + Cx(Ay − By ))/2\n    }\n    //  Store the positions of the canvas corners\n    const canvasWidth = this.width * this._renderer._pixelDensity;\n    const canvasHeight = this.height * this._renderer._pixelDensity;\n    const canvasCorners = [new DOMPoint(0, 0), new DOMPoint(canvasWidth, 0), new DOMPoint(canvasWidth, canvasHeight), new DOMPoint(0, canvasHeight)];\n    //  Apply the inverse of the current transformations to the canvas corners\n    const currentTransform = this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform();\n    const invertedTransform = currentTransform.inverse();\n    const tc = canvasCorners.map(corner => corner.matrixTransform(invertedTransform));\n    /*  Use same shoelace formula used for quad area (above) to calculate\n    the area of the canvas with inverted transformation applied */\n    const transformedCanvasArea = Math.abs((tc[3].x + tc[0].x) * (tc[3].y - tc[0].y) + (tc[0].x + tc[1].x) * (tc[0].y - tc[1].y) + (tc[1].x + tc[2].x) * (tc[1].y - tc[2].y) + (tc[2].x + tc[3].x) * (tc[2].y - tc[3].y)) / 2;\n    /*  Compare area of shape (minus transformations) to area of canvas\n    with inverted transformation applied.\n    Return percentage  */\n    const untransformedArea = Math.round(objectArea * 100 / transformedCanvasArea);\n    return untransformedArea;\n  };\n}\nif (typeof p5 !== 'undefined') {\n  outputs(p5, p5.prototype);\n}\nexport { outputs as default };","map":{"version":3,"names":["outputs","p5","fn","textOutput","display","_accessibleOutputs","text","_createOutput","LABEL","textLabel","gridOutput","grid","gridLabel","_addAccsOutput","type","cnvId","canvas","id","ingredients","shapes","colors","background","fill","stroke","pShapes","pBackground","dummyDOM","document","getElementById","parentNode","cIdT","container","inner","query","querySelector","innerHTML","insertAdjacentHTML","list","map","shapeDetails","summary","_updateAccsOutput","JSON","stringify","_updateTextOutput","_updateGridOutput","_accsBackground","args","backgroundRGBA","_rgbColorName","_accsCanvasColors","f","fillRGBA","strokeRGBA","_accsOutput","include","add","middle","_getMiddle","color","length","Math","round","hypot","p1","_getPos","p2","loc","_canvasLocator","width","height","pos","area","_getArea","y","push","x","transformedX","transformedY","worldToScreen","Vector","canvasWidth","canvasHeight","noRows","noCols","locX","floor","locY","objectType","shapeArgs","objectArea","arcSizeInRadians","PI","Ax","Ay","Bx","cos","toFixed","By","sin","Cx","Cy","areaOfExtraTriangle","abs","_renderer","_pixelDensity","canvasCorners","DOMPoint","currentTransform","isP3D","DOMMatrix","uMVMatrix","mat4","drawingContext","getTransform","invertedTransform","inverse","tc","corner","matrixTransform","transformedCanvasArea","untransformedArea","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/accessibility/outputs.js"],"sourcesContent":["/**\n * @module Environment\n * @submodule Environment\n * @for p5\n * @requires core\n */\n\nfunction outputs(p5, fn){\n  /**\n   * Creates a screen reader-accessible description of shapes on the canvas.\n   *\n   * `textOutput()` adds a general description, list of shapes, and\n   * table of shapes to the web page. The general description includes the\n   * canvas size, canvas color, and number of shapes. For example,\n   * `Your output is a, 100 by 100 pixels, gray canvas containing the following 2 shapes:`.\n   *\n   * A list of shapes follows the general description. The list describes the\n   * color, location, and area of each shape. For example,\n   * `a red circle at middle covering 3% of the canvas`. Each shape can be\n   * selected to get more details.\n   *\n   * `textOutput()` uses its table of shapes as a list. The table describes the\n   * shape, color, location, coordinates and area. For example,\n   * `red circle location = middle area = 3%`. This is different from\n   * <a href=\"#/p5/gridOutput\">gridOutput()</a>, which uses its table as a grid.\n   *\n   * The `display` parameter is optional. It determines how the description is\n   * displayed. If `LABEL` is passed, as in `textOutput(LABEL)`, the description\n   * will be visible in a div element next to the canvas. Using `LABEL` creates\n   * unhelpful duplicates for screen readers. Only use `LABEL` during\n   * development. If `FALLBACK` is passed, as in `textOutput(FALLBACK)`, the\n   * description will only be visible to screen readers. This is the default\n   * mode.\n   *\n   * Read\n   * <a href=\"/learn/accessible-labels.html\">Writing accessible canvas descriptions</a>\n   * to learn more about making sketches accessible.\n   *\n   * @method textOutput\n   * @param  {(FALLBACK|LABEL)} [display] either FALLBACK or LABEL.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the text description.\n   *   textOutput();\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the text description and\n   *   // display it for debugging.\n   *   textOutput(LABEL);\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup(){\n   *  createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the text description.\n   *   textOutput();\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup(){\n   *  createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the text description and\n   *   // display it for debugging.\n   *   textOutput(LABEL);\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.textOutput = function(display) {\n    // p5._validateParameters('textOutput', arguments);\n    //if textOutput is already true\n    if (this._accessibleOutputs.text) {\n      return;\n    } else {\n      //make textOutput true\n      this._accessibleOutputs.text = true;\n      //create output for fallback\n      this._createOutput('textOutput', 'Fallback');\n      if (display === this.LABEL) {\n        //make textOutput label true\n        this._accessibleOutputs.textLabel = true;\n        //create output for label\n        this._createOutput('textOutput', 'Label');\n      }\n    }\n  };\n\n  /**\n   * Creates a screen reader-accessible description of shapes on the canvas.\n   *\n   * `gridOutput()` adds a general description, table of shapes, and list of\n   * shapes to the web page. The general description includes the canvas size,\n   * canvas color, and number of shapes. For example,\n   * `gray canvas, 100 by 100 pixels, contains 2 shapes:  1 circle 1 square`.\n   *\n   * `gridOutput()` uses its table of shapes as a grid. Each shape in the grid\n   * is placed in a cell whose row and column correspond to the shape's location\n   * on the canvas. The grid cells describe the color and type of shape at that\n   * location. For example, `red circle`. These descriptions can be selected\n   * individually to get more details. This is different from\n   * <a href=\"#/p5/textOutput\">textOutput()</a>, which uses its table as a list.\n   *\n   * A list of shapes follows the table. The list describes the color, type,\n   * location, and area of each shape. For example,\n   * `red circle, location = middle, area = 3 %`.\n   *\n   * The `display` parameter is optional. It determines how the description is\n   * displayed. If `LABEL` is passed, as in `gridOutput(LABEL)`, the description\n   * will be visible in a div element next to the canvas. Using `LABEL` creates\n   * unhelpful duplicates for screen readers. Only use `LABEL` during\n   * development. If `FALLBACK` is passed, as in `gridOutput(FALLBACK)`, the\n   * description will only be visible to screen readers. This is the default\n   * mode.\n   *\n   * Read\n   * <a href=\"/learn/accessible-labels.html\">Writing accessible canvas descriptions</a>\n   * to learn more about making sketches accessible.\n   *\n   * @method gridOutput\n   * @param  {(FALLBACK|LABEL)} [display] either FALLBACK or LABEL.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the grid description.\n   *   gridOutput();\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   // Add the grid description and\n   *   // display it for debugging.\n   *   gridOutput(LABEL);\n   *\n   *   // Draw a couple of shapes.\n   *   background(200);\n   *   fill(255, 0, 0);\n   *   circle(20, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle and a blue square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup() {\n   *   createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the grid description.\n   *   gridOutput();\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * \n   * function setup(){\n   *  createCanvas(100, 100);\n   * }\n   * \n   * function draw() {\n   *   // Add the grid description and\n   *   // display it for debugging.\n   *   gridOutput(LABEL);\n   *\n   *   // Draw a moving circle.\n   *   background(200);\n   *   let x = frameCount * 0.1;\n   *   fill(255, 0, 0);\n   *   circle(x, 20, 20);\n   *   fill(0, 0, 255);\n   *   square(50, 50, 50);\n   *\n   *   // Add a general description of the canvas.\n   *   describe('A red circle moves from left to right above a blue square.');\n   * }\n   * </code>\n   * </div>\n   */\n\n\n  fn.gridOutput = function(display) {\n    // p5._validateParameters('gridOutput', arguments);\n    //if gridOutput is already true\n    if (this._accessibleOutputs.grid) {\n      return;\n    } else {\n      //make gridOutput true\n      this._accessibleOutputs.grid = true;\n      //create output for fallback\n      this._createOutput('gridOutput', 'Fallback');\n      if (display === this.LABEL) {\n        //make gridOutput label true\n        this._accessibleOutputs.gridLabel = true;\n        //create output for label\n        this._createOutput('gridOutput', 'Label');\n      }\n    }\n  };\n\n  //helper function returns true when accessible outputs are true\n  fn._addAccsOutput = function() {\n    //if there are no accessible outputs create object with all false\n    if (!this._accessibleOutputs) {\n      this._accessibleOutputs = {\n        text: false,\n        grid: false,\n        textLabel: false,\n        gridLabel: false\n      };\n    }\n    return this._accessibleOutputs.grid || this._accessibleOutputs.text;\n  };\n\n  //helper function that creates html structure for accessible outputs\n  fn._createOutput = function(type, display) {\n    let cnvId = this.canvas.id;\n    //if there are no ingredients create object. this object stores data for the outputs\n    if (!this.ingredients) {\n      this.ingredients = {\n        shapes: {},\n        colors: { background: 'white', fill: 'white', stroke: 'black' },\n        pShapes: '',\n        pBackground: ''\n      };\n    }\n    //if there is no dummyDOM create it\n    if (!this.dummyDOM) {\n      this.dummyDOM = document.getElementById(cnvId).parentNode;\n    }\n    let cIdT, container, inner;\n    let query = '';\n    if (display === 'Fallback') {\n      cIdT = cnvId + type;\n      container = cnvId + 'accessibleOutput';\n      if (!this.dummyDOM.querySelector(`#${container}`)) {\n        //if there is no canvas description (see describe() and describeElement())\n        if (!this.dummyDOM.querySelector(`#${cnvId}_Description`)) {\n          //create html structure inside of canvas\n          this.dummyDOM.querySelector(\n            `#${cnvId}`\n          ).innerHTML = `<div id=\"${container}\" role=\"region\" aria-label=\"Canvas Outputs\"></div>`;\n        } else {\n          //create html structure after canvas description container\n          this.dummyDOM\n            .querySelector(`#${cnvId}_Description`)\n            .insertAdjacentHTML(\n              'afterend',\n              `<div id=\"${container}\" role=\"region\" aria-label=\"Canvas Outputs\"></div>`\n            );\n        }\n      }\n    } else if (display === 'Label') {\n      query = display;\n      cIdT = cnvId + type + display;\n      container = cnvId + 'accessibleOutput' + display;\n      if (!this.dummyDOM.querySelector(`#${container}`)) {\n        //if there is no canvas description label (see describe() and describeElement())\n        if (!this.dummyDOM.querySelector(`#${cnvId}_Label`)) {\n          //create html structure adjacent to canvas\n          this.dummyDOM\n            .querySelector(`#${cnvId}`)\n            .insertAdjacentHTML('afterend', `<div id=\"${container}\"></div>`);\n        } else {\n          //create html structure after canvas label\n          this.dummyDOM\n            .querySelector(`#${cnvId}_Label`)\n            .insertAdjacentHTML('afterend', `<div id=\"${container}\"></div>`);\n        }\n      }\n    }\n    //create an object to store the latest output. this object is used in _updateTextOutput() and _updateGridOutput()\n    this._accessibleOutputs[cIdT] = {};\n    if (type === 'textOutput') {\n      query = `#${cnvId}gridOutput${query}`; //query is used to check if gridOutput already exists\n      inner = `<div id=\"${cIdT}\">Text Output<div id=\"${cIdT}Summary\" aria-label=\"text output summary\"><p id=\"${cIdT}_summary\"></p><ul id=\"${cIdT}_list\"></ul></div><table id=\"${cIdT}_shapeDetails\" summary=\"text output shape details\"></table></div>`;\n      //if gridOutput already exists\n      if (this.dummyDOM.querySelector(query)) {\n        //create textOutput before gridOutput\n        this.dummyDOM\n          .querySelector(query)\n          .insertAdjacentHTML('beforebegin', inner);\n      } else {\n        //create output inside of container\n        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;\n      }\n      //store output html elements\n      this._accessibleOutputs[cIdT].list = this.dummyDOM.querySelector(\n        `#${cIdT}_list`\n      );\n    } else if (type === 'gridOutput') {\n      query = `#${cnvId}textOutput${query}`; //query is used to check if textOutput already exists\n      inner = `<div id=\"${cIdT}\">Grid Output<p id=\"${cIdT}_summary\" aria-label=\"grid output summary\"><table id=\"${cIdT}_map\" summary=\"grid output content\"></table><ul id=\"${cIdT}_shapeDetails\" aria-label=\"grid output shape details\"></ul></div>`;\n      //if textOutput already exists\n      if (this.dummyDOM.querySelector(query)) {\n        //create gridOutput after textOutput\n        this.dummyDOM.querySelector(query).insertAdjacentHTML('afterend', inner);\n      } else {\n        //create output inside of container\n        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;\n      }\n      //store output html elements\n      this._accessibleOutputs[cIdT].map = this.dummyDOM.querySelector(\n        `#${cIdT}_map`\n      );\n    }\n    this._accessibleOutputs[cIdT].shapeDetails = this.dummyDOM.querySelector(\n      `#${cIdT}_shapeDetails`\n    );\n    this._accessibleOutputs[cIdT].summary = this.dummyDOM.querySelector(\n      `#${cIdT}_summary`\n    );\n  };\n\n  //this function is called at the end of setup and draw if using\n  //accessibleOutputs and calls update functions of outputs\n  fn._updateAccsOutput = function() {\n    let cnvId = this.canvas.id;\n    //if the shapes are not the same as before\n    if (\n      JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes ||\n      this.ingredients.colors.background !== this.ingredients.pBackground\n    ) {\n      //save current shapes as string in pShapes\n      this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);\n      if (this._accessibleOutputs.text) {\n        this._updateTextOutput(cnvId + 'textOutput');\n      }\n      if (this._accessibleOutputs.grid) {\n        this._updateGridOutput(cnvId + 'gridOutput');\n      }\n      if (this._accessibleOutputs.textLabel) {\n        this._updateTextOutput(cnvId + 'textOutputLabel');\n      }\n      if (this._accessibleOutputs.gridLabel) {\n        this._updateGridOutput(cnvId + 'gridOutputLabel');\n      }\n    }\n  };\n\n  //helper function that resets all ingredients when background is called\n  //and saves background color name\n  fn._accsBackground = function(args) {\n    //save current shapes as string in pShapes\n    this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);\n    this.ingredients.pBackground = this.ingredients.colors.background;\n    //empty shapes JSON\n    this.ingredients.shapes = {};\n    //update background different\n    if (this.ingredients.colors.backgroundRGBA !== args) {\n      this.ingredients.colors.backgroundRGBA = args;\n      this.ingredients.colors.background = this._rgbColorName(args);\n    }\n  };\n\n  //helper function that gets fill and stroke of shapes\n  fn._accsCanvasColors = function(f, args) {\n    if (f === 'fill') {\n      //update fill different\n      if (this.ingredients.colors.fillRGBA !== args) {\n        this.ingredients.colors.fillRGBA = args;\n        this.ingredients.colors.fill = this._rgbColorName(args);\n      }\n    } else if (f === 'stroke') {\n      //update stroke if different\n      if (this.ingredients.colors.strokeRGBA !== args) {\n        this.ingredients.colors.strokeRGBA = args;\n        this.ingredients.colors.stroke = this._rgbColorName(args);\n      }\n    }\n  };\n\n  //builds ingredients.shapes used for building outputs\n  fn._accsOutput = function(f, args) {\n    if (f === 'ellipse' && args[2] === args[3]) {\n      f = 'circle';\n    } else if (f === 'rectangle' && args[2] === args[3]) {\n      f = 'square';\n    }\n    let include = {};\n    let add = true;\n    let middle = _getMiddle(f, args);\n    if (f === 'line') {\n      //make color stroke\n      include.color = this.ingredients.colors.stroke;\n      //get lenght\n      include.length = Math.round(\n        Math.hypot(args[2] - args[0], args[3] - args[1])\n      );\n      //get position of end points\n      let p1 = this._getPos(args[0], [1]);\n      let p2 = this._getPos(args[2], [3]);\n      include.loc = _canvasLocator(middle, this.width, this.height);\n      if (p1 === p2) {\n        include.pos = `at ${p1}`;\n      } else {\n        include.pos = `from ${p1} to ${p2}`;\n      }\n    } else {\n      if (f === 'point') {\n        //make color stroke\n        include.color = this.ingredients.colors.stroke;\n      } else {\n        //make color fill\n        include.color = this.ingredients.colors.fill;\n        //get area of shape\n        include.area = this._getArea(f, args);\n      }\n      //get middle of shapes\n      //calculate position using middle of shape\n      include.pos = this._getPos(...middle);\n      //calculate location using middle of shape\n      include.loc = _canvasLocator(middle, this.width, this.height);\n    }\n    //if it is the first time this shape is created\n    if (!this.ingredients.shapes[f]) {\n      this.ingredients.shapes[f] = [include];\n      //if other shapes of this type have been created\n    } else if (this.ingredients.shapes[f] !== [include]) {\n      //for every shape of this type\n      for (let y in this.ingredients.shapes[f]) {\n        //compare it with current shape and if it already exists make add false\n        if (\n          JSON.stringify(this.ingredients.shapes[f][y]) ===\n          JSON.stringify(include)\n        ) {\n          add = false;\n        }\n      }\n      //add shape by pushing it to the end\n      if (add === true) {\n        this.ingredients.shapes[f].push(include);\n      }\n    }\n  };\n\n  //gets middle point / centroid of shape\n  function _getMiddle(f, args) {\n    let x, y;\n    if (\n      f === 'rectangle' ||\n      f === 'ellipse' ||\n      f === 'arc' ||\n      f === 'circle' ||\n      f === 'square'\n    ) {\n      x = Math.round(args[0] + args[2] / 2);\n      y = Math.round(args[1] + args[3] / 2);\n    } else if (f === 'triangle') {\n      x = (args[0] + args[2] + args[4]) / 3;\n      y = (args[1] + args[3] + args[5]) / 3;\n    } else if (f === 'quadrilateral') {\n      x = (args[0] + args[2] + args[4] + args[6]) / 4;\n      y = (args[1] + args[3] + args[5] + args[7]) / 4;\n    } else if (f === 'line') {\n      x = (args[0] + args[2]) / 2;\n      y = (args[1] + args[3]) / 2;\n    } else {\n      x = args[0];\n      y = args[1];\n    }\n    return [x, y];\n  }\n\n  //gets position of shape in the canvas\n  fn._getPos = function (x, y) {\n    const { x: transformedX, y: transformedY } = this.worldToScreen(new p5.Vector(x, y));\n    const canvasWidth = this.width;\n    const canvasHeight = this.height;\n    if (transformedX < 0.4 * canvasWidth) {\n      if (transformedY < 0.4 * canvasHeight) {\n        return 'top left';\n      } else if (transformedY > 0.6 * canvasHeight) {\n        return 'bottom left';\n      } else {\n        return 'mid left';\n      }\n    } else if (transformedX > 0.6 * canvasWidth) {\n      if (transformedY < 0.4 * canvasHeight) {\n        return 'top right';\n      } else if (transformedY > 0.6 * canvasHeight) {\n        return 'bottom right';\n      } else {\n        return 'mid right';\n      }\n    } else {\n      if (transformedY < 0.4 * canvasHeight) {\n        return 'top middle';\n      } else if (transformedY > 0.6 * canvasHeight) {\n        return 'bottom middle';\n      } else {\n        return 'middle';\n      }\n    }\n  };\n\n  //locates shape in a 10*10 grid\n  function _canvasLocator(args, canvasWidth, canvasHeight) {\n    const noRows = 10;\n    const noCols = 10;\n    let locX = Math.floor(args[0] / canvasWidth * noRows);\n    let locY = Math.floor(args[1] / canvasHeight * noCols);\n    if (locX === noRows) {\n      locX = locX - 1;\n    }\n    if (locY === noCols) {\n      locY = locY - 1;\n    }\n    return {\n      locX,\n      locY\n    };\n  }\n\n  //calculates area of shape\n  fn._getArea = function (objectType, shapeArgs) {\n    let objectArea = 0;\n    if (objectType === 'arc') {\n      // area of full ellipse = PI * horizontal radius * vertical radius.\n      // therefore, area of arc = difference bet. arc's start and end radians * horizontal radius * vertical radius.\n      // the below expression is adjusted for negative values and differences in arc's start and end radians over PI*2\n      const arcSizeInRadians =\n        ((shapeArgs[5] - shapeArgs[4]) % (Math.PI * 2) + Math.PI * 2) %\n        (Math.PI * 2);\n      objectArea = arcSizeInRadians * shapeArgs[2] * shapeArgs[3] / 8;\n      if (shapeArgs[6] === 'open' || shapeArgs[6] === 'chord') {\n        // when the arc's mode is OPEN or CHORD, we need to account for the area of the triangle that is formed to close the arc\n        // (Ax( By −  Cy) + Bx(Cy − Ay) + Cx(Ay − By ) )/2\n        const Ax = shapeArgs[0];\n        const Ay = shapeArgs[1];\n        const Bx =\n          shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[4]).toFixed(2);\n        const By =\n          shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[4]).toFixed(2);\n        const Cx =\n          shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[5]).toFixed(2);\n        const Cy =\n          shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[5]).toFixed(2);\n        const areaOfExtraTriangle =\n          Math.abs(Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By)) / 2;\n        if (arcSizeInRadians > Math.PI) {\n          objectArea = objectArea + areaOfExtraTriangle;\n        } else {\n          objectArea = objectArea - areaOfExtraTriangle;\n        }\n      }\n    } else if (objectType === 'ellipse' || objectType === 'circle') {\n      objectArea = 3.14 * shapeArgs[2] / 2 * shapeArgs[3] / 2;\n    } else if (objectType === 'line') {\n      objectArea = 0;\n    } else if (objectType === 'point') {\n      objectArea = 0;\n    } else if (objectType === 'quadrilateral') {\n      // ((x4+x1)*(y4-y1)+(x1+x2)*(y1-y2)+(x2+x3)*(y2-y3)+(x3+x4)*(y3-y4))/2\n      objectArea =\n        Math.abs(\n          (shapeArgs[6] + shapeArgs[0]) * (shapeArgs[7] - shapeArgs[1]) +\n            (shapeArgs[0] + shapeArgs[2]) * (shapeArgs[1] - shapeArgs[3]) +\n            (shapeArgs[2] + shapeArgs[4]) * (shapeArgs[3] - shapeArgs[5]) +\n            (shapeArgs[4] + shapeArgs[6]) * (shapeArgs[5] - shapeArgs[7])\n        ) / 2;\n    } else if (objectType === 'rectangle' || objectType === 'square') {\n      objectArea = shapeArgs[2] * shapeArgs[3];\n    } else if (objectType === 'triangle') {\n      objectArea =\n        Math.abs(\n          shapeArgs[0] * (shapeArgs[3] - shapeArgs[5]) +\n            shapeArgs[2] * (shapeArgs[5] - shapeArgs[1]) +\n            shapeArgs[4] * (shapeArgs[1] - shapeArgs[3])\n        ) / 2;\n      // (Ax( By −  Cy) + Bx(Cy − Ay) + Cx(Ay − By ))/2\n    }\n    //  Store the positions of the canvas corners\n    const canvasWidth = this.width * this._renderer._pixelDensity;\n    const canvasHeight = this.height * this._renderer._pixelDensity;\n    const canvasCorners = [\n      new DOMPoint(0, 0),\n      new DOMPoint(canvasWidth, 0),\n      new DOMPoint(canvasWidth, canvasHeight),\n      new DOMPoint(0, canvasHeight)\n    ];\n    //  Apply the inverse of the current transformations to the canvas corners\n    const currentTransform = this._renderer.isP3D ?\n      new DOMMatrix(this._renderer.uMVMatrix.mat4) :\n      this.drawingContext.getTransform();\n    const invertedTransform = currentTransform.inverse();\n    const tc = canvasCorners.map(\n      corner => corner.matrixTransform(invertedTransform)\n    );\n    /*  Use same shoelace formula used for quad area (above) to calculate\n    the area of the canvas with inverted transformation applied */\n    const transformedCanvasArea = Math.abs(\n      (tc[3].x + tc[0].x) * (tc[3].y - tc[0].y) +\n      (tc[0].x + tc[1].x) * (tc[0].y - tc[1].y) +\n      (tc[1].x + tc[2].x) * (tc[1].y - tc[2].y)+\n      (tc[2].x + tc[3].x) * (tc[2].y - tc[3].y)\n    ) / 2;\n    /*  Compare area of shape (minus transformations) to area of canvas\n    with inverted transformation applied.\n    Return percentage  */\n    const untransformedArea = Math.round(\n      objectArea * 100 / (transformedCanvasArea)\n    );\n    return untransformedArea;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  outputs(p5, p5.prototype);\n}\n\nexport { outputs as default };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,OAAOA,CAACC,EAAE,EAAEC,EAAE,EAAC;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEA,EAAE,CAACC,UAAU,GAAG,UAASC,OAAO,EAAE;IAChC;IACA;IACA,IAAI,IAAI,CAACC,kBAAkB,CAACC,IAAI,EAAE;MAChC;IACF,CAAC,MAAM;MACL;MACA,IAAI,CAACD,kBAAkB,CAACC,IAAI,GAAG,IAAI;MACnC;MACA,IAAI,CAACC,aAAa,CAAC,YAAY,EAAE,UAAU,CAAC;MAC5C,IAAIH,OAAO,KAAK,IAAI,CAACI,KAAK,EAAE;QAC1B;QACA,IAAI,CAACH,kBAAkB,CAACI,SAAS,GAAG,IAAI;QACxC;QACA,IAAI,CAACF,aAAa,CAAC,YAAY,EAAE,OAAO,CAAC;MAC3C;IACF;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGEL,EAAE,CAACQ,UAAU,GAAG,UAASN,OAAO,EAAE;IAChC;IACA;IACA,IAAI,IAAI,CAACC,kBAAkB,CAACM,IAAI,EAAE;MAChC;IACF,CAAC,MAAM;MACL;MACA,IAAI,CAACN,kBAAkB,CAACM,IAAI,GAAG,IAAI;MACnC;MACA,IAAI,CAACJ,aAAa,CAAC,YAAY,EAAE,UAAU,CAAC;MAC5C,IAAIH,OAAO,KAAK,IAAI,CAACI,KAAK,EAAE;QAC1B;QACA,IAAI,CAACH,kBAAkB,CAACO,SAAS,GAAG,IAAI;QACxC;QACA,IAAI,CAACL,aAAa,CAAC,YAAY,EAAE,OAAO,CAAC;MAC3C;IACF;EACF,CAAC;;EAED;EACAL,EAAE,CAACW,cAAc,GAAG,YAAW;IAC7B;IACA,IAAI,CAAC,IAAI,CAACR,kBAAkB,EAAE;MAC5B,IAAI,CAACA,kBAAkB,GAAG;QACxBC,IAAI,EAAE,KAAK;QACXK,IAAI,EAAE,KAAK;QACXF,SAAS,EAAE,KAAK;QAChBG,SAAS,EAAE;MACb,CAAC;IACH;IACA,OAAO,IAAI,CAACP,kBAAkB,CAACM,IAAI,IAAI,IAAI,CAACN,kBAAkB,CAACC,IAAI;EACrE,CAAC;;EAED;EACAJ,EA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}