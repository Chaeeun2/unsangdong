{"ast":null,"code":"class RenderBuffer {\n  constructor(size, src, dst, attr, renderer, map) {\n    this.size = size; // the number of FLOATs in each vertex\n    this.src = src; // the name of the model's source array\n    this.dst = dst; // the name of the geometry's buffer\n    this.attr = attr; // the name of the vertex attribute\n    this._renderer = renderer;\n    this.map = map; // optional, a transformation function to apply to src\n  }\n\n  /**\n   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.\n   * Must always be done prior to drawing geometry in WebGL.\n   * @param {p5.Geometry} geometry Geometry that is going to be drawn\n   * @param {p5.Shader} shader Active shader\n   * @private\n   */\n  _prepareBuffer(geometry, shader) {\n    const attributes = shader.attributes;\n    const gl = this._renderer.GL;\n    const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry);\n\n    // loop through each of the buffer definitions\n    const attr = attributes[this.attr];\n    if (!attr) {\n      return;\n    }\n    // check if the geometry has the appropriate source array\n    let buffer = glBuffers[this.dst];\n    const src = geometry[this.src];\n    if (src && src.length > 0) {\n      // check if we need to create the GL buffer\n      const createBuffer = !buffer;\n      if (createBuffer) {\n        // create and remember the buffer\n        glBuffers[this.dst] = buffer = gl.createBuffer();\n      }\n      // bind the buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n      // check if we need to fill the buffer with data\n      if (createBuffer || geometry.dirtyFlags[this.src] !== false) {\n        const map = this.map;\n        // get the values from the geometry, possibly transformed\n        const values = map ? map(src) : src;\n        // fill the buffer with the values\n        this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);\n        // mark the geometry's source array as clean\n        geometry.dirtyFlags[this.src] = false;\n      }\n      // enable the attribute\n      shader.enableAttrib(attr, this.size);\n    } else {\n      const loc = attr.location;\n      if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {\n        return;\n      }\n      // Disable register corresponding to unused attribute\n      gl.disableVertexAttribArray(loc);\n      // Record register availability\n      this._renderer.registerEnabled.delete(loc);\n    }\n  }\n}\nfunction renderBuffer(p5, fn) {\n  p5.RenderBuffer = RenderBuffer;\n}\nif (typeof p5 !== \"undefined\") {\n  renderBuffer(p5, p5.prototype);\n}\nexport { RenderBuffer, renderBuffer as default };","map":{"version":3,"names":["RenderBuffer","constructor","size","src","dst","attr","renderer","map","_renderer","_prepareBuffer","geometry","shader","attributes","gl","GL","glBuffers","_getOrMakeCachedBuffers","buffer","length","createBuffer","bindBuffer","ARRAY_BUFFER","dirtyFlags","values","_bindBuffer","enableAttrib","loc","location","registerEnabled","has","disableVertexAttribArray","delete","renderBuffer","p5","fn","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/webgl/p5.RenderBuffer.js"],"sourcesContent":["class RenderBuffer {\n  constructor(size, src, dst, attr, renderer, map) {\n    this.size = size; // the number of FLOATs in each vertex\n    this.src = src; // the name of the model's source array\n    this.dst = dst; // the name of the geometry's buffer\n    this.attr = attr; // the name of the vertex attribute\n    this._renderer = renderer;\n    this.map = map; // optional, a transformation function to apply to src\n  }\n\n  /**\n   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.\n   * Must always be done prior to drawing geometry in WebGL.\n   * @param {p5.Geometry} geometry Geometry that is going to be drawn\n   * @param {p5.Shader} shader Active shader\n   * @private\n   */\n  _prepareBuffer(geometry, shader) {\n    const attributes = shader.attributes;\n    const gl = this._renderer.GL;\n    const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry);\n\n    // loop through each of the buffer definitions\n    const attr = attributes[this.attr];\n    if (!attr) {\n      return;\n    }\n    // check if the geometry has the appropriate source array\n    let buffer = glBuffers[this.dst];\n    const src = geometry[this.src];\n    if (src && src.length > 0) {\n      // check if we need to create the GL buffer\n      const createBuffer = !buffer;\n      if (createBuffer) {\n        // create and remember the buffer\n        glBuffers[this.dst] = buffer = gl.createBuffer();\n      }\n      // bind the buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n      // check if we need to fill the buffer with data\n      if (createBuffer || geometry.dirtyFlags[this.src] !== false) {\n        const map = this.map;\n        // get the values from the geometry, possibly transformed\n        const values = map ? map(src) : src;\n        // fill the buffer with the values\n        this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);\n        // mark the geometry's source array as clean\n        geometry.dirtyFlags[this.src] = false;\n      }\n      // enable the attribute\n      shader.enableAttrib(attr, this.size);\n    } else {\n      const loc = attr.location;\n      if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {\n        return;\n      }\n      // Disable register corresponding to unused attribute\n      gl.disableVertexAttribArray(loc);\n      // Record register availability\n      this._renderer.registerEnabled.delete(loc);\n    }\n  }\n}\n\nfunction renderBuffer(p5, fn) {\n  p5.RenderBuffer = RenderBuffer;\n}\n\nif (typeof p5 !== \"undefined\") {\n  renderBuffer(p5, p5.prototype);\n}\n\nexport { RenderBuffer, renderBuffer as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}