{"ast":null,"code":"import { F as FLAT, y as SMOOTH } from '../constants-BRcElHU3.js';\nimport { DataArray } from './p5.DataArray.js';\nimport { Vector } from '../math/p5.Vector.js';\n\n/**\n * @module Shape\n * @submodule 3D Primitives\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\nclass Geometry {\n  constructor(detailX, detailY, callback, renderer) {\n    this.renderer = renderer;\n    this.vertices = [];\n    this.boundingBoxCache = null;\n\n    //an array containing every vertex for stroke drawing\n    this.lineVertices = new DataArray();\n\n    // The tangents going into or out of a vertex on a line. Along a straight\n    // line segment, both should be equal. At an endpoint, one or the other\n    // will not exist and will be all 0. In joins between line segments, they\n    // may be different, as they will be the tangents on either side of the join.\n    this.lineTangentsIn = new DataArray();\n    this.lineTangentsOut = new DataArray();\n\n    // When drawing lines with thickness, entries in this buffer represent which\n    // side of the centerline the vertex will be placed. The sign of the number\n    // will represent the side of the centerline, and the absolute value will be\n    // used as an enum to determine which part of the cap or join each vertex\n    // represents. See the doc comments for _addCap and _addJoin for diagrams.\n    this.lineSides = new DataArray();\n    this.vertexNormals = [];\n    this.faces = [];\n    this.uvs = [];\n    // a 2D array containing edge connectivity pattern for create line vertices\n    //based on faces for most objects;\n    this.edges = [];\n    this.vertexColors = [];\n\n    // One color per vertex representing the stroke color at that vertex\n    this.vertexStrokeColors = [];\n    this.userVertexProperties = {};\n\n    // One color per line vertex, generated automatically based on\n    // vertexStrokeColors in _edgesToVertices()\n    this.lineVertexColors = new DataArray();\n    this.detailX = detailX !== undefined ? detailX : 1;\n    this.detailY = detailY !== undefined ? detailY : 1;\n    this.dirtyFlags = {};\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n    this.gid = `_p5_Geometry_${Geometry.nextId}`;\n    Geometry.nextId++;\n    if (callback instanceof Function) {\n      callback.call(this);\n    }\n  }\n\n  /**\n  * Calculates the position and size of the smallest box that contains the geometry.\n  *\n  * A bounding box is the smallest rectangular prism that contains the entire\n  * geometry. It's defined by the box's minimum and maximum coordinates along\n  * each axis, as well as the size (length) and offset (center).\n  *\n  * Calling `myGeometry.calculateBoundingBox()` returns an object with four\n  * properties that describe the bounding box:\n  *\n  * ```js\n  * // Get myGeometry's bounding box.\n  * let bbox = myGeometry.calculateBoundingBox();\n  *\n  * // Print the bounding box to the console.\n  * console.log(bbox);\n  *\n  * // {\n  * //  // The minimum coordinate along each axis.\n  * //  min: { x: -1, y: -2, z: -3 },\n  * //\n  * //  // The maximum coordinate along each axis.\n  * //  max: { x: 1, y: 2, z: 3},\n  * //\n  * //  // The size (length) along each axis.\n  * //  size: { x: 2, y: 4, z: 6},\n  * //\n  * //  // The offset (center) along each axis.\n  * //  offset: { x: 0, y: 0, z: 0}\n  * // }\n  * ```\n  *\n  * @returns {Object} bounding box of the geometry.\n  *\n  * @example\n  * <div>\n  * <code>\n  * // Click and drag the mouse to view the scene from different angles.\n  *\n  * let particles;\n  *\n  * function setup() {\n  *   createCanvas(100, 100, WEBGL);\n  *\n  *   // Create a new p5.Geometry object with random spheres.\n  *   particles = buildGeometry(createParticles);\n  *\n  *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');\n  * }\n  *\n  * function draw() {\n  *   background(50);\n  *\n  *   // Enable orbiting with the mouse.\n  *   orbitControl();\n  *\n  *   // Turn on the lights.\n  *   lights();\n  *\n  *   // Style the particles.\n  *   noStroke();\n  *   fill(255);\n  *\n  *   // Draw the particles.\n  *   model(particles);\n  *\n  *   // Calculate the bounding box.\n  *   let bbox = particles.calculateBoundingBox();\n  *\n  *   // Translate to the bounding box's center.\n  *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);\n  *\n  *   // Style the bounding box.\n  *   stroke(255);\n  *   noFill();\n  *\n  *   // Draw the bounding box.\n  *   box(bbox.size.x, bbox.size.y, bbox.size.z);\n  * }\n  *\n  * function createParticles() {\n  *   for (let i = 0; i < 10; i += 1) {\n  *     // Calculate random coordinates.\n  *     let x = randomGaussian(0, 15);\n  *     let y = randomGaussian(0, 15);\n  *     let z = randomGaussian(0, 15);\n  *\n  *     push();\n  *     // Translate to the particle's coordinates.\n  *     translate(x, y, z);\n  *     // Draw the particle.\n  *     sphere(3);\n  *     pop();\n  *   }\n  * }\n  * </code>\n  * </div>\n  */\n  calculateBoundingBox() {\n    if (this.boundingBoxCache) {\n      return this.boundingBoxCache; // Return cached result if available\n    }\n    let minVertex = new Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    let maxVertex = new Vector(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n    for (let i = 0; i < this.vertices.length; i++) {\n      let vertex = this.vertices[i];\n      minVertex.x = Math.min(minVertex.x, vertex.x);\n      minVertex.y = Math.min(minVertex.y, vertex.y);\n      minVertex.z = Math.min(minVertex.z, vertex.z);\n      maxVertex.x = Math.max(maxVertex.x, vertex.x);\n      maxVertex.y = Math.max(maxVertex.y, vertex.y);\n      maxVertex.z = Math.max(maxVertex.z, vertex.z);\n    }\n    // Calculate size and offset properties\n    let size = new Vector(maxVertex.x - minVertex.x, maxVertex.y - minVertex.y, maxVertex.z - minVertex.z);\n    let offset = new Vector((minVertex.x + maxVertex.x) / 2, (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2);\n\n    // Cache the result for future access\n    this.boundingBoxCache = {\n      min: minVertex,\n      max: maxVertex,\n      size: size,\n      offset: offset\n    };\n    return this.boundingBoxCache;\n  }\n  reset() {\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n    this.vertices.length = 0;\n    this.edges.length = 0;\n    this.vertexColors.length = 0;\n    this.vertexStrokeColors.length = 0;\n    this.lineVertexColors.clear();\n    this.vertexNormals.length = 0;\n    this.uvs.length = 0;\n    for (const propName in this.userVertexProperties) {\n      this.userVertexProperties[propName].delete();\n    }\n    this.userVertexProperties = {};\n    this.dirtyFlags = {};\n  }\n  hasFillTransparency() {\n    if (this._hasFillTransparency === undefined) {\n      this._hasFillTransparency = false;\n      for (let i = 0; i < this.vertexColors.length; i += 4) {\n        if (this.vertexColors[i + 3] < 1) {\n          this._hasFillTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasFillTransparency;\n  }\n  hasStrokeTransparency() {\n    if (this._hasStrokeTransparency === undefined) {\n      this._hasStrokeTransparency = false;\n      for (let i = 0; i < this.lineVertexColors.length; i += 4) {\n        if (this.lineVertexColors[i + 3] < 1) {\n          this._hasStrokeTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasStrokeTransparency;\n  }\n\n  /**\n   * Removes the geometry’s internal colors.\n   *\n   * `p5.Geometry` objects can be created with \"internal colors\" assigned to\n   * vertices or the entire shape. When a geometry has internal colors,\n   * <a href=\"#/p5/fill\">fill()</a> has no effect. Calling\n   * `myGeometry.clearColors()` allows the\n   * <a href=\"#/p5/fill\">fill()</a> function to apply color to the geometry.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Geometry object.\n   *   // Set its internal color to red.\n   *   let myGeometry = buildGeometry(function() {\n   *     fill(255, 0, 0);\n   *     plane(20);\n   *   });\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object (center).\n   *   model(myGeometry);\n   *\n   *   // Translate the origin to the bottom-right.\n   *   translate(25, 25, 0);\n   *\n   *   // Try to fill the geometry with green.\n   *   fill(0, 255, 0);\n   *\n   *   // Draw the geometry again (bottom-right).\n   *   model(myGeometry);\n   *\n   *   // Clear the geometry's colors.\n   *   myGeometry.clearColors();\n   *\n   *   // Fill the geometry with blue.\n   *   fill(0, 0, 255);\n   *\n   *   // Translate the origin up.\n   *   translate(0, -50, 0);\n   *\n   *   // Draw the geometry again (top-right).\n   *   model(myGeometry);\n   *\n   *   describe(\n   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   */\n  clearColors() {\n    this.vertexColors = [];\n    return this;\n  }\n\n  /**\n   * The `saveObj()` function exports `p5.Geometry` objects as\n   * 3D models in the Wavefront .obj file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,\n   * as well as its texture coordinates and normals, if it has them.\n   *\n   * @method saveObj\n   * @param {String} [fileName='model.obj'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.obj'.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function()) {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn = createButton('Save .obj');\n   *   saveBtn.mousePressed(() => myModel.saveObj());\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveObj(fileName = 'model.obj') {\n    let objStr = '';\n\n    // Vertices\n    this.vertices.forEach(v => {\n      objStr += `v ${v.x} ${v.y} ${v.z}\\n`;\n    });\n\n    // Texture Coordinates (UVs)\n    if (this.uvs && this.uvs.length > 0) {\n      for (let i = 0; i < this.uvs.length; i += 2) {\n        objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}\\n`;\n      }\n    }\n\n    // Vertex Normals\n    if (this.vertexNormals && this.vertexNormals.length > 0) {\n      this.vertexNormals.forEach(n => {\n        objStr += `vn ${n.x} ${n.y} ${n.z}\\n`;\n      });\n    }\n    // Faces, obj vertex indices begin with 1 and not 0\n    // texture coordinate (uvs) and vertexNormal indices\n    // are indicated with trailing ints vertex/normal/uv\n    // ex 1/1/1 or 2//2 for vertices without uvs\n    this.faces.forEach(face => {\n      let faceStr = 'f';\n      face.forEach(index => {\n        faceStr += ' ';\n        faceStr += index + 1;\n        if (this.vertexNormals.length > 0 || this.uvs.length > 0) {\n          faceStr += '/';\n          if (this.uvs.length > 0) {\n            faceStr += index + 1;\n          }\n          faceStr += '/';\n          if (this.vertexNormals.length > 0) {\n            faceStr += index + 1;\n          }\n        }\n      });\n      objStr += faceStr + '\\n';\n    });\n    const blob = new Blob([objStr], {\n      type: 'text/plain'\n    });\n    fn.downloadFile(blob, fileName, 'obj');\n  }\n\n  /**\n   * The `saveStl()` function exports `p5.Geometry` objects as\n   * 3D models in the STL stereolithography file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.\n   *\n   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact\n   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.\n   *\n   * @method saveStl\n   * @param {String} [fileName='model.stl'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.stl'.\n   * @param {Object} [options] Optional settings. Options can include a boolean `binary` property, which\n   * controls whether or not a binary .stl file is saved. It defaults to false.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn1;\n   * let saveBtn2;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function() {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn1 = createButton('Save .stl');\n   *   saveBtn1.mousePressed(function() {\n   *     myModel.saveStl();\n   *   });\n   *   saveBtn2 = createButton('Save binary .stl');\n   *   saveBtn2.mousePressed(function() {\n   *     myModel.saveStl('model.stl', { binary: true });\n   *   });\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveStl(fileName = 'model.stl', {\n    binary = false\n  } = {}) {\n    let modelOutput;\n    let name = fileName.substring(0, fileName.lastIndexOf('.'));\n    let faceNormals = [];\n    for (let f of this.faces) {\n      const U = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);\n      const V = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);\n      const nx = U.y * V.z - U.z * V.y;\n      const ny = U.z * V.x - U.x * V.z;\n      const nz = U.x * V.y - U.y * V.x;\n      faceNormals.push(new Vector(nx, ny, nz).normalize());\n    }\n    if (binary) {\n      let offset = 80;\n      const bufferLength = this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      modelOutput = new DataView(arrayBuffer);\n      modelOutput.setUint32(offset, this.faces.length, true);\n      offset += 4;\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput.setFloat32(offset, norm.x, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.y, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.z, true);\n        offset += 4;\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput.setFloat32(offset, vert.x, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.y, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.z, true);\n          offset += 4;\n        }\n        modelOutput.setUint16(offset, 0, true);\n        offset += 2;\n      }\n    } else {\n      modelOutput = 'solid ' + name + '\\n';\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput += ' facet norm ' + norm.x + ' ' + norm.y + ' ' + norm.z + '\\n';\n        modelOutput += '  outer loop' + '\\n';\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput += '   vertex ' + vert.x + ' ' + vert.y + ' ' + vert.z + '\\n';\n        }\n        modelOutput += '  endloop' + '\\n';\n        modelOutput += ' endfacet' + '\\n';\n      }\n      modelOutput += 'endsolid ' + name + '\\n';\n    }\n    const blob = new Blob([modelOutput], {\n      type: 'text/plain'\n    });\n    fn.downloadFile(blob, fileName, 'stl');\n  }\n\n  /**\n   * Flips the geometry’s texture u-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates\n   * so that the texture appears mirrored horizontally.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipU()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the u-coordinates.\n   * myGeometry.flipU();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]\n   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]\n   * ```\n   *\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's U texture coordinates.\n   *   geom2.flipU();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipU() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return 1 - val;\n      } else {\n        return val;\n      }\n    });\n  }\n\n  /**\n   * Flips the geometry’s texture v-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates\n   * so that the texture appears mirrored vertically.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipV()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the v-coordinates.\n   * myGeometry.flipV();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Left vertices: [0, 0] <--> [1, 0]\n   * // Right vertices: [1, 0] <--> [1, 1]\n   * ```\n   *\n   * @method flipV\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's V texture coordinates.\n   *   geom2.flipV();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipV() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return val;\n      } else {\n        return 1 - val;\n      }\n    });\n  }\n\n  /**\n   * Computes the geometry's faces using its vertices.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles that\n   * are stitched together. Each triangular patch on the geometry's surface is\n   * called a *face*. `myGeometry.computeFaces()` performs the math needed to\n   * define each face based on the distances between vertices.\n   *\n   * The geometry's vertices are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a>\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * Calling `myGeometry.computeFaces()` fills the\n   * <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> array with three-element\n   * arrays that list the vertices that form each face. For example, a geometry\n   * made from a rectangle has two faces because a rectangle is made by joining\n   * two triangles. <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> for a\n   * rectangle would be the two-dimensional array\n   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the\n   * array `[0, 1, 2]` because it's formed by connecting\n   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the\n   * array `[2, 1, 3]` because it's formed by connecting\n   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and\n   * `myGeometry.vertices[3]`.\n   *\n   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to myGeometry's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute myGeometry's faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   * }\n   * </code>\n   * </div>\n   */\n  computeFaces() {\n    this.faces.length = 0;\n    const sliceCount = this.detailX + 1;\n    let a, b, c, d;\n    for (let i = 0; i < this.detailY; i++) {\n      for (let j = 0; j < this.detailX; j++) {\n        a = i * sliceCount + j; // + offset;\n        b = i * sliceCount + j + 1; // + offset;\n        c = (i + 1) * sliceCount + j + 1; // + offset;\n        d = (i + 1) * sliceCount + j; // + offset;\n        this.faces.push([a, b, d]);\n        this.faces.push([d, b, c]);\n      }\n    }\n    return this;\n  }\n  _getFaceNormal(faceId) {\n    //This assumes that vA->vB->vC is a counter-clockwise ordering\n    const face = this.faces[faceId];\n    const vA = this.vertices[face[0]];\n    const vB = this.vertices[face[1]];\n    const vC = this.vertices[face[2]];\n    const ab = Vector.sub(vB, vA);\n    const ac = Vector.sub(vC, vA);\n    const n = Vector.cross(ab, ac);\n    const ln = Vector.mag(n);\n    let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));\n    if (sinAlpha === 0 || isNaN(sinAlpha)) {\n      console.warn('p5.Geometry.prototype._getFaceNormal:', 'face has colinear sides or a repeated vertex');\n      return n;\n    }\n    if (sinAlpha > 1) sinAlpha = 1; // handle float rounding error\n    return n.mult(Math.asin(sinAlpha) / ln);\n  }\n  /**\n   * Calculates the normal vector for each vertex on the geometry.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to create triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*. `myGeometry.computeNormals()` performs the\n   * math needed to orient each face. Orientation is important for lighting\n   * and other effects.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal vector.\n   * Then it calculates the normal vector for each vertex by averaging the\n   * normal vectors of the faces surrounding the vertex. The vertex normals\n   * are stored as <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertexNormals\">myGeometry.vertexNormals</a> array.\n   *\n   * The first parameter, `shadingType`, is optional. Passing the constant\n   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring\n   * faces with their own copies of the vertices they share. Surfaces appear\n   * tiled with flat shading. Passing the constant `SMOOTH`, as in\n   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their\n   * shared vertices. Surfaces appear smoother with smooth shading. By\n   * default, `shadingType` is `FLAT`.\n   *\n   * The second parameter, `options`, is also optional. If an object with a\n   * `roundToPrecision` property is passed, as in\n   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the\n   * number of decimal places to use for calculations. By default,\n   * `roundToPrecision` uses 3 decimal places.\n   *\n   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.\n   * @param {Object} [options] shading options.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus();\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     \"A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices.\"\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   stroke(0);\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 5);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using default (FLAT) shading.\n   *   myGeometry.computeNormals(FLAT);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Create an options object.\n   *   let options = { roundToPrecision: 5 };\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH, options);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  computeNormals(shadingType = FLAT, {\n    roundToPrecision = 3\n  } = {}) {\n    const vertexNormals = this.vertexNormals;\n    let vertices = this.vertices;\n    const faces = this.faces;\n    let iv;\n    if (shadingType === SMOOTH) {\n      const vertexIndices = {};\n      const uniqueVertices = [];\n      const power = Math.pow(10, roundToPrecision);\n      const rounded = val => Math.round(val * power) / power;\n      const getKey = vert => `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;\n\n      // loop through each vertex and add uniqueVertices\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i];\n        const key = getKey(vertex);\n        if (vertexIndices[key] === undefined) {\n          vertexIndices[key] = uniqueVertices.length;\n          uniqueVertices.push(vertex);\n        }\n      }\n\n      // update face indices to use the deduplicated vertex indices\n      faces.forEach(face => {\n        for (let fv = 0; fv < 3; ++fv) {\n          const originalVertexIndex = face[fv];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          face[fv] = vertexIndices[key];\n        }\n      });\n\n      // update edge indices to use the deduplicated vertex indices\n      this.edges.forEach(edge => {\n        for (let ev = 0; ev < 2; ++ev) {\n          const originalVertexIndex = edge[ev];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          edge[ev] = vertexIndices[key];\n        }\n      });\n\n      // update the deduplicated vertices\n      this.vertices = vertices = uniqueVertices;\n    }\n\n    // initialize the vertexNormals array with empty vectors\n    vertexNormals.length = 0;\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals.push(new Vector());\n    }\n\n    // loop through all the faces adding its normal to the normal\n    // of each of its vertices\n    faces.forEach((face, f) => {\n      const faceNormal = this._getFaceNormal(f);\n\n      // all three vertices get the normal added\n      for (let fv = 0; fv < 3; ++fv) {\n        const vertexIndex = face[fv];\n        vertexNormals[vertexIndex].add(faceNormal);\n      }\n    });\n\n    // normalize the normals\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals[iv].normalize();\n    }\n    return this;\n  }\n\n  /**\n   * Averages the vertex normals. Used in curved\n   * surfaces\n   * @private\n   * @chainable\n   */\n  averageNormals() {\n    for (let i = 0; i <= this.detailY; i++) {\n      const offset = this.detailX + 1;\n      let temp = Vector.add(this.vertexNormals[i * offset], this.vertexNormals[i * offset + this.detailX]);\n      temp = Vector.div(temp, 2);\n      this.vertexNormals[i * offset] = temp;\n      this.vertexNormals[i * offset + this.detailX] = temp;\n    }\n    return this;\n  }\n\n  /**\n   * Averages pole normals.  Used in spherical primitives\n   * @private\n   * @chainable\n   */\n  averagePoleNormals() {\n    //average the north pole\n    let sum = new Vector(0, 0, 0);\n    for (let i = 0; i < this.detailX; i++) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n    for (let i = 0; i < this.detailX; i++) {\n      this.vertexNormals[i] = sum;\n    }\n\n    //average the south pole\n    sum = new Vector(0, 0, 0);\n    for (let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n    for (let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--) {\n      this.vertexNormals[i] = sum;\n    }\n    return this;\n  }\n\n  /**\n   * Create a 2D array for establishing stroke connections\n   * @private\n   * @chainable\n   */\n  _makeTriangleEdges() {\n    this.edges.length = 0;\n    for (let j = 0; j < this.faces.length; j++) {\n      this.edges.push([this.faces[j][0], this.faces[j][1]]);\n      this.edges.push([this.faces[j][1], this.faces[j][2]]);\n      this.edges.push([this.faces[j][2], this.faces[j][0]]);\n    }\n    return this;\n  }\n\n  /**\n   * @example\n   * <div>\n   * <code>\n   * let tetrahedron;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   describe('A rotating tetrahedron');\n   *\n   *   tetrahedron = new p5.Geometry();\n   *\n   *   // Give each geometry a unique gid\n   *   tetrahedron.gid = 'tetrahedron';\n   *\n   *   // Add four points of the tetrahedron\n   *\n   *   let radius = 50;\n   *   // A 2D triangle:\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));\n   *   // Add a tip in the z axis:\n   *   tetrahedron.vertices.push(createVector(0, 0, radius));\n   *\n   *   // Create the four faces by connecting the sets of three points\n   *   tetrahedron.faces.push([0, 1, 2]);\n   *   tetrahedron.faces.push([0, 1, 3]);\n   *   tetrahedron.faces.push([0, 2, 3]);\n   *   tetrahedron.faces.push([1, 2, 3]);\n   *   tetrahedron.makeEdgesFromFaces();\n   * }\n   * function draw() {\n   *   background(200);\n   *   strokeWeight(2);\n   *   orbitControl();\n   *   rotateY(millis() * 0.001);\n   *   model(tetrahedron);\n   * }\n   * </code>\n   * </div>\n   */\n  makeEdgesFromFaces() {\n    this._makeTriangleEdges();\n  }\n\n  /**\n   * Converts each line segment into the vertices and vertex attributes needed\n   * to turn the line into a polygon on screen. This will include:\n   * - Two triangles line segment to create a rectangle\n   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment\n   *   shader is responsible for displaying the appropriate cap style within\n   *   that rectangle.\n   * - Four triangles per join between adjacent line segments, creating a quad on\n   *   either side of the join, perpendicular to the lines. A vertex shader will\n   *   discard the quad in the \"elbow\" of the join, and a fragment shader will\n   *   display the appropriate join style within the remaining quad.\n   *\n   * @private\n   * @chainable\n   */\n  _edgesToVertices() {\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n    const potentialCaps = new Map();\n    const connected = new Set();\n    let lastValidDir;\n    for (let i = 0; i < this.edges.length; i++) {\n      const prevEdge = this.edges[i - 1];\n      const currEdge = this.edges[i];\n      const begin = this.vertices[currEdge[0]];\n      const end = this.vertices[currEdge[1]];\n      const prevColor = this.vertexStrokeColors.length > 0 && prevEdge ? this.vertexStrokeColors.slice(prevEdge[1] * 4, (prevEdge[1] + 1) * 4) : [0, 0, 0, 0];\n      const fromColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[0] * 4, (currEdge[0] + 1) * 4) : [0, 0, 0, 0];\n      const toColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[1] * 4, (currEdge[1] + 1) * 4) : [0, 0, 0, 0];\n      const dir = end.copy().sub(begin).normalize();\n      const dirOK = dir.magSq() > 0;\n      if (dirOK) {\n        this._addSegment(begin, end, fromColor, toColor, dir);\n      }\n      if (!this.renderer?._simpleLines) {\n        if (i > 0 && prevEdge[1] === currEdge[0]) {\n          if (!connected.has(currEdge[0])) {\n            connected.add(currEdge[0]);\n            potentialCaps.delete(currEdge[0]);\n            // Add a join if this segment shares a vertex with the previous. Skip\n            // actually adding join vertices if either the previous segment or this\n            // one has a length of 0.\n            //\n            // Don't add a join if the tangents point in the same direction, which\n            // would mean the edges line up exactly, and there is no need for a join.\n            if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {\n              this._addJoin(begin, lastValidDir, dir, fromColor);\n            }\n          }\n        } else {\n          // Start a new line\n          if (dirOK && !connected.has(currEdge[0])) {\n            const existingCap = potentialCaps.get(currEdge[0]);\n            if (existingCap) {\n              this._addJoin(begin, existingCap.dir, dir, fromColor);\n              potentialCaps.delete(currEdge[0]);\n              connected.add(currEdge[0]);\n            } else {\n              potentialCaps.set(currEdge[0], {\n                point: begin,\n                dir: dir.copy().mult(-1),\n                color: fromColor\n              });\n            }\n          }\n          if (lastValidDir && !connected.has(prevEdge[1])) {\n            const existingCap = potentialCaps.get(prevEdge[1]);\n            if (existingCap) {\n              this._addJoin(this.vertices[prevEdge[1]], lastValidDir, existingCap.dir.copy().mult(-1), prevColor);\n              potentialCaps.delete(prevEdge[1]);\n              connected.add(prevEdge[1]);\n            } else {\n              // Close off the last segment with a cap\n              potentialCaps.set(prevEdge[1], {\n                point: this.vertices[prevEdge[1]],\n                dir: lastValidDir,\n                color: prevColor\n              });\n            }\n            lastValidDir = undefined;\n          }\n        }\n        if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {\n          const existingCap = potentialCaps.get(currEdge[1]);\n          if (existingCap) {\n            this._addJoin(end, dir, existingCap.dir.copy().mult(-1), toColor);\n            potentialCaps.delete(currEdge[1]);\n            connected.add(currEdge[1]);\n          } else {\n            potentialCaps.set(currEdge[1], {\n              point: end,\n              dir,\n              color: toColor\n            });\n          }\n        }\n        if (dirOK) {\n          lastValidDir = dir;\n        }\n      }\n    }\n    for (const {\n      point,\n      dir,\n      color\n    } of potentialCaps.values()) {\n      this._addCap(point, dir, color);\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles making a rectangle\n   * for a straight line segment. A vertex shader is responsible for picking\n   * proper coordinates on the screen given the centerline positions, the tangent,\n   * and the side of the centerline each vertex belongs to. Sides follow the\n   * following scheme:\n   *\n   *  -1            -1\n   *   o-------------o\n   *   |             |\n   *   o-------------o\n   *   1             1\n   *\n   * @private\n   * @chainable\n   */\n  _addSegment(begin, end, fromColor, toColor, dir) {\n    const a = begin.array();\n    const b = end.array();\n    const dirArr = dir.array();\n    this.lineSides.push(1, 1, -1, 1, -1, -1);\n    for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) {\n      for (let i = 0; i < 6; i++) {\n        tangents.push(...dirArr);\n      }\n    }\n    this.lineVertices.push(...a, ...b, ...a, ...b, ...b, ...a);\n    if (!this.renderer?._simpleLines) {\n      this.lineVertexColors.push(...fromColor, ...toColor, ...fromColor, ...toColor, ...toColor, ...fromColor);\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles representing the\n   * stroke cap of a line. A fragment shader is responsible for displaying the\n   * appropriate cap style within the rectangle they make.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the cap rectangle:\n   *\n   *           -1  -2\n   * -----------o---o\n   *            |   |\n   * -----------o---o\n   *            1   2\n   * @private\n   * @chainable\n   */\n  _addCap(point, tangent, color) {\n    const ptArray = point.array();\n    const tanInArray = tangent.array();\n    const tanOutArray = [0, 0, 0];\n    for (let i = 0; i < 6; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, 2, -2, 1, 2, -1);\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for four triangles representing a\n   * join between two adjacent line segments. This creates a quad on either side\n   * of the shared vertex of the two line segments, with each quad perpendicular\n   * to the lines. A vertex shader will discard all but the quad in the \"elbow\" of\n   * the join, and a fragment shader will display the appropriate join style\n   * within the remaining quad.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the join rectangles:\n   *\n   *            -1     -2\n   * -------------o----o\n   *              |    |\n   *       1 o----o----o -3\n   *         |    | 0  |\n   * --------o----o    |\n   *        2|    3    |\n   *         |         |\n   *         |         |\n   * @private\n   * @chainable\n   */\n  _addJoin(point, fromTangent, toTangent, color) {\n    const ptArray = point.array();\n    const tanInArray = fromTangent.array();\n    const tanOutArray = toTangent.array();\n    for (let i = 0; i < 12; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, -3, -2, -1, 0, -3);\n    this.lineSides.push(3, 1, 2, 3, 0, 1);\n    return this;\n  }\n\n  /**\n   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box\n   * centered at the origin.\n   *\n   * Calling `myGeometry.normalize()` translates the geometry's vertices so that\n   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so\n   * that they fill a 100×100×100 box. As a result, small geometries will grow\n   * and large geometries will shrink.\n   *\n   * Note: `myGeometry.normalize()` only works when called in the\n   * <a href=\"#/p5/setup\">setup()</a> function.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a very small torus.\n   *   myGeometry = buildGeometry(function() {;\n   *     torus(1, 0.25);\n   *   });\n   *\n   *   // Normalize the torus so its vertices fill\n   *   // the range [-100, 100].\n   *   myGeometry.normalize();\n   *\n   *   describe('A white torus rotates slowly against a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the torus.\n   *   noStroke();\n   *\n   *   // Draw the torus.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n  normalize() {\n    if (this.vertices.length > 0) {\n      // Find the corners of our bounding box\n      const maxPosition = this.vertices[0].copy();\n      const minPosition = this.vertices[0].copy();\n      for (let i = 0; i < this.vertices.length; i++) {\n        maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);\n        minPosition.x = Math.min(minPosition.x, this.vertices[i].x);\n        maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);\n        minPosition.y = Math.min(minPosition.y, this.vertices[i].y);\n        maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);\n        minPosition.z = Math.min(minPosition.z, this.vertices[i].z);\n      }\n      const center = Vector.lerp(maxPosition, minPosition, 0.5);\n      const dist = Vector.sub(maxPosition, minPosition);\n      const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);\n      const scale = 200 / longestDist;\n      for (let i = 0; i < this.vertices.length; i++) {\n        this.vertices[i].sub(center);\n        this.vertices[i].mult(scale);\n      }\n    }\n    return this;\n  }\n\n  /** Sets the shader's vertex property or attribute variables.\n   *\n   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some\n   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are\n   * set using <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/normal\">normal()</a>\n   * and <a href=\"#/p5/fill\">fill()</a> respectively. Custom properties can also\n   * be defined within <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * The first parameter, `propertyName`, is a string with the property's name.\n   * This is the same variable name which should be declared in the shader, as in\n   * `in vec3 aProperty`, similar to .`setUniform()`.\n   *\n   * The second parameter, `data`, is the value assigned to the shader variable. This value\n   * will be pushed directly onto the Geometry object. There should be the same number\n   * of custom property values as vertices, this method should be invoked once for each\n   * vertex.\n   *\n   * The `data` can be a Number or an array of numbers. Tn the shader program the type\n   * can be declared according to the WebGL specification. Common types include `float`,\n   * `vec2`, `vec3`, `vec4` or matrices.\n   *\n   * See also the global <a href=\"#/p5/vertexProperty\">vertexProperty()</a> function.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let geo;\n   *\n   * function cartesianToSpherical(x, y, z) {\n   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n   *   let theta = acos(z / r);\n   *   let phi = atan2(y, x);\n   *   return { theta, phi };\n   * }\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Modify the material shader to display roughness.\n   *   const myShader = baseMaterialShader().modify({\n   *     vertexDeclarations:`in float aRoughness;\n   *                         out float vRoughness;`,\n   *     fragmentDeclarations: 'in float vRoughness;',\n   *     'void afterVertex': `() {\n   *         vRoughness = aRoughness;\n   *     }`,\n   *     'vec4 combineColors': `(ColorComponents components) {\n   *             vec4 color = vec4(0.);\n   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);\n   *             color.rgb += components.ambient * components.ambientColor;\n   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);\n   *             color.a = components.opacity;\n   *             return color;\n   *     }`\n   *   });\n   *\n   *   // Create the Geometry object.\n   *   geo = buildGeometry(function() {\n   *     fill('hotpink');\n   *     sphere(45, 50, 50);\n   *   });\n   *\n   *   // Set the roughness value for every vertex.\n   *   for (let v of geo.vertices){\n   *\n   *     // convert coordinates to spherical coordinates\n   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);\n   *\n   *     // Set the custom roughness vertex property.\n   *     let roughness = noise(spherical.theta*5, spherical.phi*5);\n   *     geo.vertexProperty('aRoughness', roughness);\n   *   }\n   *\n   *   // Use the custom shader.\n   *   shader(myShader);\n   *\n   *   describe('A rough pink sphere rotating on a blue background.');\n   * }\n   *\n   * function draw() {\n   *   // Set some styles and lighting\n   *   background('lightblue');\n   *   noStroke();\n   *\n   *   specularMaterial(255,125,100);\n   *   shininess(2);\n   *\n   *   directionalLight('white', -1, 1, -1);\n   *   ambientLight(320);\n   *\n   *   rotateY(millis()*0.001);\n   *\n   *   // Draw the geometry\n   *   model(geo);\n   * }\n   * </code>\n   * </div>\n   *\n   * @param {String} propertyName the name of the vertex property.\n   * @param {Number|Number[]} data the data tied to the vertex property.\n   * @param {Number} [size] optional size of each unit of data.\n   */\n  vertexProperty(propertyName, data, size) {\n    let prop;\n    if (!this.userVertexProperties[propertyName]) {\n      prop = this.userVertexProperties[propertyName] = this._userVertexPropertyHelper(propertyName, data, size);\n    }\n    prop = this.userVertexProperties[propertyName];\n    if (size) {\n      prop.pushDirect(data);\n    } else {\n      prop.setCurrentData(data);\n      prop.pushCurrentData();\n    }\n  }\n  _userVertexPropertyHelper(propertyName, data, size) {\n    const geometryInstance = this;\n    const prop = this.userVertexProperties[propertyName] = {\n      name: propertyName,\n      dataSize: size ? size : data.length ? data.length : 1,\n      geometry: geometryInstance,\n      // Getters\n      getName() {\n        return this.name;\n      },\n      getCurrentData() {\n        if (this.currentData === undefined) {\n          this.currentData = new Array(this.getDataSize()).fill(0);\n        }\n        return this.currentData;\n      },\n      getDataSize() {\n        return this.dataSize;\n      },\n      getSrcName() {\n        const src = this.name.concat('Src');\n        return src;\n      },\n      getDstName() {\n        const dst = this.name.concat('Buffer');\n        return dst;\n      },\n      getSrcArray() {\n        const srcName = this.getSrcName();\n        return this.geometry[srcName];\n      },\n      //Setters\n      setCurrentData(data) {\n        data.length ? data.length : 1;\n        // if (size != this.getDataSize()){\n        //   p5._friendlyError(`Custom vertex property '${this.name}' has been set with various data sizes. You can change it's name, or if it was an accident, set '${this.name}' to have the same number of inputs each time!`, 'vertexProperty()');\n        // }\n        this.currentData = data;\n      },\n      // Utilities\n      pushCurrentData() {\n        const data = this.getCurrentData();\n        this.pushDirect(data);\n      },\n      pushDirect(data) {\n        if (data.length) {\n          this.getSrcArray().push(...data);\n        } else {\n          this.getSrcArray().push(data);\n        }\n      },\n      resetSrcArray() {\n        this.geometry[this.getSrcName()] = [];\n      },\n      delete() {\n        const srcName = this.getSrcName();\n        delete this.geometry[srcName];\n        delete this;\n      }\n    };\n    this[prop.getSrcName()] = [];\n    return this.userVertexProperties[propertyName];\n  }\n}\n/**\n * Keeps track of how many custom geometry objects have been made so that each\n * can be assigned a unique ID.\n */\nGeometry.nextId = 0;\nfunction geometry(p5, fn) {\n  /**\n   * A class to describe a 3D shape.\n   *\n   * Each `p5.Geometry` object represents a 3D shape as a set of connected\n   * points called *vertices*. All 3D shapes are made by connecting vertices to\n   * form triangles that are stitched together. Each triangular patch on the\n   * geometry's surface is called a *face*. The geometry stores information\n   * about its vertices and faces for use with effects such as lighting and\n   * texture mapping.\n   *\n   * The first parameter, `detailX`, is optional. If a number is passed, as in\n   * `new p5.Geometry(24)`, it sets the number of triangle subdivisions to use\n   * along the geometry's x-axis. By default, `detailX` is 1.\n   *\n   * The second parameter, `detailY`, is also optional. If a number is passed,\n   * as in `new p5.Geometry(24, 16)`, it sets the number of triangle\n   * subdivisions to use along the geometry's y-axis. By default, `detailX` is\n   * 1.\n   *\n   * The third parameter, `callback`, is also optional. If a function is passed,\n   * as in `new p5.Geometry(24, 16, createShape)`, it will be called once to add\n   * vertices to the new 3D shape.\n   *\n   * @class p5.Geometry\n   * @param  {Integer} [detailX] number of vertices along the x-axis.\n   * @param  {Integer} [detailY] number of vertices along the y-axis.\n   * @param {function} [callback] function to call once the geometry is created.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * // Adapted from Paul Wheeler's wonderful p5.Geometry tutorial.\n   * // https://www.paulwheeler.us/articles/custom-3d-geometry-in-p5js/\n   * // CC-BY-SA 4.0\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   // Set detailX to 48 and detailY to 2.\n   *   // >>> try changing them.\n   *   myGeometry = new p5.Geometry(48, 2, createShape);\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   strokeWeight(0.2);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Define the Möbius strip with a few parameters.\n   *   let spread = 0.1;\n   *   let radius = 30;\n   *   let stripWidth = 15;\n   *   let xInterval = 4 * PI / this.detailX;\n   *   let yOffset = -stripWidth / 2;\n   *   let yInterval = stripWidth / this.detailY;\n   *\n   *   for (let j = 0; j <= this.detailY; j += 1) {\n   *     // Calculate the \"vertical\" point along the strip.\n   *     let v = yOffset + yInterval * j;\n   *\n   *     for (let i = 0; i <= this.detailX; i += 1) {\n   *       // Calculate the angle of rotation around the strip.\n   *       let u = i * xInterval;\n   *\n   *       // Calculate the coordinates of the vertex.\n   *       let x = (radius + v * cos(u / 2)) * cos(u) - sin(u / 2) * 2 * spread;\n   *       let y = (radius + v * cos(u / 2)) * sin(u);\n   *       if (u < TWO_PI) {\n   *         y += sin(u) * spread;\n   *       } else {\n   *         y -= sin(u) * spread;\n   *       }\n   *       let z = v * sin(u / 2) + sin(u / 4) * 4 * spread;\n   *\n   *       // Create a p5.Vector object to position the vertex.\n   *       let vert = createVector(x, y, z);\n   *\n   *       // Add the vertex to the p5.Geometry object's vertices array.\n   *       this.vertices.push(vert);\n   *     }\n   *   }\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   */\n  p5.Geometry = Geometry;\n\n  /**\n   * An array with the geometry's vertices.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the `myGeometry.vertices`\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * @property vertices\n   * @for p5.Geometry\n   * @name vertices\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   describe('A white torus rotates slowly against a dark gray background. Red spheres mark its vertices.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   fill(255);\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the vertices.\n   *   fill(255, 0, 0);\n   *   noStroke();\n   *\n   *   // Iterate over the vertices array.\n   *   for (let v of myGeometry.vertices) {\n   *     // Draw a sphere to mark the vertex.\n   *     push();\n   *     translate(v);\n   *     sphere(2.5);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array with the vectors that are normal to the geometry's vertices.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal\n   * vector. Then it calculates the normal vector for each vertex by\n   * averaging the normal vectors of the faces surrounding the vertex. The\n   * vertex normals are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the `myGeometry.vertexNormals` array.\n   *\n   * @property vertexNormals\n   * @name vertexNormals\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     'A white torus rotates against a dark gray background. Red lines extend outward from its vertices.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 8);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists which of the geometry's vertices form each of its\n   * faces.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a> array. The\n   * geometry's first vertex is the <a href=\"#/p5.Vector\">p5.Vector</a>\n   * object at `myGeometry.vertices[0]`, its second vertex is\n   * `myGeometry.vertices[1]`, its third vertex is `myGeometry.vertices[2]`,\n   * and so on.\n   *\n   * For example, a geometry made from a rectangle has two faces because a\n   * rectangle is made by joining two triangles. `myGeometry.faces` for a\n   * rectangle would be the two-dimensional array `[[0, 1, 2], [2, 1, 3]]`.\n   * The first face, `myGeometry.faces[0]`, is the array `[0, 1, 2]` because\n   * it's formed by connecting `myGeometry.vertices[0]`,\n   * `myGeometry.vertices[1]`,and `myGeometry.vertices[2]`. The second face,\n   * `myGeometry.faces[1]`, is the array `[2, 1, 3]` because it's formed by\n   * connecting `myGeometry.vertices[2]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[3]`.\n   *\n   * @property faces\n   * @name faces\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     sphere();\n   *   });\n   *\n   *   describe(\"A sphere drawn on a gray background. The sphere's surface is a grayscale patchwork of triangles.\");\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *\n   *   // Set a random seed.\n   *   randomSeed(1234);\n   *\n   *   // Iterate over the faces array.\n   *   for (let face of myGeometry.faces) {\n   *\n   *     // Style the face.\n   *     let g = random(0, 255);\n   *     fill(g);\n   *\n   *     // Draw the face.\n   *     beginShape();\n   *     // Iterate over the vertices that form the face.\n   *     for (let f of face) {\n   *       // Get the vertex's p5.Vector object.\n   *       let v = myGeometry.vertices[f];\n   *       vertex(v.x, v.y, v.z);\n   *     }\n   *     endShape();\n   *\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists the texture coordinates for each of the geometry's\n   * vertices.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a\n   * rectangular image that's used as a texture. The geometry's vertex at\n   * coordinates `(x, y, z)` maps to the texture image's pixel at coordinates\n   * `(u, v)`.\n   *\n   * The `myGeometry.uvs` array stores the `(u, v)` coordinates for each\n   * vertex in the order it was added to the geometry. For example, the\n   * first vertex, `myGeometry.vertices[0]`, has its `(u, v)` coordinates\n   * stored at `myGeometry.uvs[0]` and `myGeometry.uvs[1]`.\n   *\n   * @property uvs\n   * @name uvs\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Set geom2's texture coordinates.\n   *   geom2.uvs = [0.25, 0.25, 0.75, 0.25, 0.25, 0.75, 0.75, 0.75];\n   *\n   *   // Right (zoomed in).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photo on the right zooms in to the center of the photo.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n}\nif (typeof p5 !== 'undefined') {\n  geometry(p5, p5.prototype);\n}\nexport { Geometry, geometry as default };","map":{"version":3,"names":["F","FLAT","y","SMOOTH","DataArray","Vector","Geometry","constructor","detailX","detailY","callback","renderer","vertices","boundingBoxCache","lineVertices","lineTangentsIn","lineTangentsOut","lineSides","vertexNormals","faces","uvs","edges","vertexColors","vertexStrokeColors","userVertexProperties","lineVertexColors","undefined","dirtyFlags","_hasFillTransparency","_hasStrokeTransparency","gid","nextId","Function","call","calculateBoundingBox","minVertex","Number","MAX_VALUE","maxVertex","MIN_VALUE","i","length","vertex","x","Math","min","z","max","size","offset","reset","clear","propName","delete","hasFillTransparency","hasStrokeTransparency","clearColors","saveObj","fileName","objStr","forEach","v","n","face","faceStr","index","blob","Blob","type","fn","downloadFile","saveStl","binary","modelOutput","name","substring","lastIndexOf","faceNormals","f","U","sub","V","nx","ny","nz","push","normalize","bufferLength","arrayBuffer","ArrayBuffer","DataView","setUint32","key","Object","entries","norm","setFloat32","vertexIndex","vert","setUint16","flipU","flat","map","val","flipV","computeFaces","sliceCount","a","b","c","d","j","_getFaceNormal","faceId","vA","vB","vC","ab","ac","cross","ln","mag","sinAlpha","isNaN","console","warn","mult","asin","computeNormals","shadingType","roundToPrecision","iv","vertexIndices","uniqueVertices","power","pow","rounded","round","getKey","fv","originalVertexIndex","originalVertex","edge","ev","faceNormal","add","averageNormals","temp","div","averagePoleNormals","sum","_makeTriangleEdges","makeEdgesFromFaces","_edgesToVertices","potentialCaps","Map","connected","Set","lastValidDir","prevEdge","currEdge","begin","end","prevColor","slice","fromColor","toColor","dir","copy","dirOK","magSq","_addSegment","_simpleLines","has","dot","_addJoin","existingCap","get","set","point","color","values","_addCap","array","dirArr","tangents","tangent","ptArray","tanInArray","tanOutArray","fromTangent","toTangent","maxPosition","minPosition","center","lerp","dist","longestDist","scale","vertexProperty","propertyName","data","prop","_userVertexPropertyHelper","pushDirect","setCurrentData","pushCurrentData","geometryInstance","dataSize","geometry","getName","getCurrentData","currentData","Array","getDataSize","fill","getSrcName","src","concat","getDstName","dst","getSrcArray","srcName","resetSrcArray","p5","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/webgl/p5.Geometry.js"],"sourcesContent":["import { F as FLAT, y as SMOOTH } from '../constants-BRcElHU3.js';\nimport { DataArray } from './p5.DataArray.js';\nimport { Vector } from '../math/p5.Vector.js';\n\n/**\n * @module Shape\n * @submodule 3D Primitives\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\n\nclass Geometry {\n  constructor(detailX, detailY, callback, renderer) {\n    this.renderer = renderer;\n    this.vertices = [];\n\n    this.boundingBoxCache = null;\n\n\n    //an array containing every vertex for stroke drawing\n    this.lineVertices = new DataArray();\n\n    // The tangents going into or out of a vertex on a line. Along a straight\n    // line segment, both should be equal. At an endpoint, one or the other\n    // will not exist and will be all 0. In joins between line segments, they\n    // may be different, as they will be the tangents on either side of the join.\n    this.lineTangentsIn = new DataArray();\n    this.lineTangentsOut = new DataArray();\n\n    // When drawing lines with thickness, entries in this buffer represent which\n    // side of the centerline the vertex will be placed. The sign of the number\n    // will represent the side of the centerline, and the absolute value will be\n    // used as an enum to determine which part of the cap or join each vertex\n    // represents. See the doc comments for _addCap and _addJoin for diagrams.\n    this.lineSides = new DataArray();\n\n    this.vertexNormals = [];\n\n    this.faces = [];\n\n    this.uvs = [];\n    // a 2D array containing edge connectivity pattern for create line vertices\n    //based on faces for most objects;\n    this.edges = [];\n    this.vertexColors = [];\n\n    // One color per vertex representing the stroke color at that vertex\n    this.vertexStrokeColors = [];\n\n    this.userVertexProperties = {};\n\n    // One color per line vertex, generated automatically based on\n    // vertexStrokeColors in _edgesToVertices()\n    this.lineVertexColors = new DataArray();\n    this.detailX = detailX !== undefined ? detailX : 1;\n    this.detailY = detailY !== undefined ? detailY : 1;\n    this.dirtyFlags = {};\n\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n\n    this.gid = `_p5_Geometry_${Geometry.nextId}`;\n    Geometry.nextId++;\n    if (callback instanceof Function) {\n      callback.call(this);\n    }\n  }\n\n  /**\n * Calculates the position and size of the smallest box that contains the geometry.\n *\n * A bounding box is the smallest rectangular prism that contains the entire\n * geometry. It's defined by the box's minimum and maximum coordinates along\n * each axis, as well as the size (length) and offset (center).\n *\n * Calling `myGeometry.calculateBoundingBox()` returns an object with four\n * properties that describe the bounding box:\n *\n * ```js\n * // Get myGeometry's bounding box.\n * let bbox = myGeometry.calculateBoundingBox();\n *\n * // Print the bounding box to the console.\n * console.log(bbox);\n *\n * // {\n * //  // The minimum coordinate along each axis.\n * //  min: { x: -1, y: -2, z: -3 },\n * //\n * //  // The maximum coordinate along each axis.\n * //  max: { x: 1, y: 2, z: 3},\n * //\n * //  // The size (length) along each axis.\n * //  size: { x: 2, y: 4, z: 6},\n * //\n * //  // The offset (center) along each axis.\n * //  offset: { x: 0, y: 0, z: 0}\n * // }\n * ```\n *\n * @returns {Object} bounding box of the geometry.\n *\n * @example\n * <div>\n * <code>\n * // Click and drag the mouse to view the scene from different angles.\n *\n * let particles;\n *\n * function setup() {\n *   createCanvas(100, 100, WEBGL);\n *\n *   // Create a new p5.Geometry object with random spheres.\n *   particles = buildGeometry(createParticles);\n *\n *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');\n * }\n *\n * function draw() {\n *   background(50);\n *\n *   // Enable orbiting with the mouse.\n *   orbitControl();\n *\n *   // Turn on the lights.\n *   lights();\n *\n *   // Style the particles.\n *   noStroke();\n *   fill(255);\n *\n *   // Draw the particles.\n *   model(particles);\n *\n *   // Calculate the bounding box.\n *   let bbox = particles.calculateBoundingBox();\n *\n *   // Translate to the bounding box's center.\n *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);\n *\n *   // Style the bounding box.\n *   stroke(255);\n *   noFill();\n *\n *   // Draw the bounding box.\n *   box(bbox.size.x, bbox.size.y, bbox.size.z);\n * }\n *\n * function createParticles() {\n *   for (let i = 0; i < 10; i += 1) {\n *     // Calculate random coordinates.\n *     let x = randomGaussian(0, 15);\n *     let y = randomGaussian(0, 15);\n *     let z = randomGaussian(0, 15);\n *\n *     push();\n *     // Translate to the particle's coordinates.\n *     translate(x, y, z);\n *     // Draw the particle.\n *     sphere(3);\n *     pop();\n *   }\n * }\n * </code>\n * </div>\n */\n  calculateBoundingBox() {\n    if (this.boundingBoxCache) {\n      return this.boundingBoxCache; // Return cached result if available\n    }\n\n    let minVertex = new Vector(\n      Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    let maxVertex = new Vector(\n      Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      let vertex = this.vertices[i];\n      minVertex.x = Math.min(minVertex.x, vertex.x);\n      minVertex.y = Math.min(minVertex.y, vertex.y);\n      minVertex.z = Math.min(minVertex.z, vertex.z);\n\n      maxVertex.x = Math.max(maxVertex.x, vertex.x);\n      maxVertex.y = Math.max(maxVertex.y, vertex.y);\n      maxVertex.z = Math.max(maxVertex.z, vertex.z);\n    }\n    // Calculate size and offset properties\n    let size = new Vector(maxVertex.x - minVertex.x,\n      maxVertex.y - minVertex.y, maxVertex.z - minVertex.z);\n    let offset = new Vector((minVertex.x + maxVertex.x) / 2,\n      (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2);\n\n    // Cache the result for future access\n    this.boundingBoxCache = {\n      min: minVertex,\n      max: maxVertex,\n      size: size,\n      offset: offset\n    };\n\n    return this.boundingBoxCache;\n  }\n\n  reset() {\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n\n    this.vertices.length = 0;\n    this.edges.length = 0;\n    this.vertexColors.length = 0;\n    this.vertexStrokeColors.length = 0;\n    this.lineVertexColors.clear();\n    this.vertexNormals.length = 0;\n    this.uvs.length = 0;\n\n    for (const propName in this.userVertexProperties){\n      this.userVertexProperties[propName].delete();\n    }\n    this.userVertexProperties = {};\n\n    this.dirtyFlags = {};\n  }\n\n  hasFillTransparency() {\n    if (this._hasFillTransparency === undefined) {\n      this._hasFillTransparency = false;\n      for (let i = 0; i < this.vertexColors.length; i += 4) {\n        if (this.vertexColors[i + 3] < 1) {\n          this._hasFillTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasFillTransparency;\n  }\n  hasStrokeTransparency() {\n    if (this._hasStrokeTransparency === undefined) {\n      this._hasStrokeTransparency = false;\n      for (let i = 0; i < this.lineVertexColors.length; i += 4) {\n        if (this.lineVertexColors[i + 3] < 1) {\n          this._hasStrokeTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasStrokeTransparency;\n  }\n\n  /**\n   * Removes the geometry’s internal colors.\n   *\n   * `p5.Geometry` objects can be created with \"internal colors\" assigned to\n   * vertices or the entire shape. When a geometry has internal colors,\n   * <a href=\"#/p5/fill\">fill()</a> has no effect. Calling\n   * `myGeometry.clearColors()` allows the\n   * <a href=\"#/p5/fill\">fill()</a> function to apply color to the geometry.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Geometry object.\n   *   // Set its internal color to red.\n   *   let myGeometry = buildGeometry(function() {\n   *     fill(255, 0, 0);\n   *     plane(20);\n   *   });\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object (center).\n   *   model(myGeometry);\n   *\n   *   // Translate the origin to the bottom-right.\n   *   translate(25, 25, 0);\n   *\n   *   // Try to fill the geometry with green.\n   *   fill(0, 255, 0);\n   *\n   *   // Draw the geometry again (bottom-right).\n   *   model(myGeometry);\n   *\n   *   // Clear the geometry's colors.\n   *   myGeometry.clearColors();\n   *\n   *   // Fill the geometry with blue.\n   *   fill(0, 0, 255);\n   *\n   *   // Translate the origin up.\n   *   translate(0, -50, 0);\n   *\n   *   // Draw the geometry again (top-right).\n   *   model(myGeometry);\n   *\n   *   describe(\n   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   */\n  clearColors() {\n    this.vertexColors = [];\n    return this;\n  }\n\n  /**\n   * The `saveObj()` function exports `p5.Geometry` objects as\n   * 3D models in the Wavefront .obj file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,\n   * as well as its texture coordinates and normals, if it has them.\n   *\n   * @method saveObj\n   * @param {String} [fileName='model.obj'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.obj'.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function()) {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn = createButton('Save .obj');\n   *   saveBtn.mousePressed(() => myModel.saveObj());\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveObj(fileName = 'model.obj') {\n    let objStr= '';\n\n\n    // Vertices\n    this.vertices.forEach(v => {\n      objStr += `v ${v.x} ${v.y} ${v.z}\\n`;\n    });\n\n    // Texture Coordinates (UVs)\n    if (this.uvs && this.uvs.length > 0) {\n      for (let i = 0; i < this.uvs.length; i += 2) {\n        objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}\\n`;\n      }\n    }\n\n    // Vertex Normals\n    if (this.vertexNormals && this.vertexNormals.length > 0) {\n      this.vertexNormals.forEach(n => {\n        objStr += `vn ${n.x} ${n.y} ${n.z}\\n`;\n      });\n\n    }\n    // Faces, obj vertex indices begin with 1 and not 0\n    // texture coordinate (uvs) and vertexNormal indices\n    // are indicated with trailing ints vertex/normal/uv\n    // ex 1/1/1 or 2//2 for vertices without uvs\n    this.faces.forEach(face => {\n      let faceStr = 'f';\n      face.forEach(index =>{\n        faceStr += ' ';\n        faceStr += index + 1;\n        if (this.vertexNormals.length > 0 || this.uvs.length > 0) {\n          faceStr += '/';\n          if (this.uvs.length > 0) {\n            faceStr += index + 1;\n          }\n          faceStr += '/';\n          if (this.vertexNormals.length > 0) {\n            faceStr += index + 1;\n          }\n        }\n      });\n      objStr += faceStr + '\\n';\n    });\n\n    const blob = new Blob([objStr], { type: 'text/plain' });\n    fn.downloadFile(blob, fileName , 'obj');\n\n  }\n\n  /**\n   * The `saveStl()` function exports `p5.Geometry` objects as\n   * 3D models in the STL stereolithography file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.\n   *\n   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact\n   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.\n   *\n   * @method saveStl\n   * @param {String} [fileName='model.stl'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.stl'.\n   * @param {Object} [options] Optional settings. Options can include a boolean `binary` property, which\n   * controls whether or not a binary .stl file is saved. It defaults to false.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn1;\n   * let saveBtn2;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function() {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn1 = createButton('Save .stl');\n   *   saveBtn1.mousePressed(function() {\n   *     myModel.saveStl();\n   *   });\n   *   saveBtn2 = createButton('Save binary .stl');\n   *   saveBtn2.mousePressed(function() {\n   *     myModel.saveStl('model.stl', { binary: true });\n   *   });\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveStl(fileName = 'model.stl', { binary = false } = {}){\n    let modelOutput;\n    let name = fileName.substring(0, fileName.lastIndexOf('.'));\n    let faceNormals = [];\n    for (let f of this.faces) {\n      const U = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);\n      const V = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);\n      const nx = U.y * V.z - U.z * V.y;\n      const ny = U.z * V.x - U.x * V.z;\n      const nz = U.x * V.y - U.y * V.x;\n      faceNormals.push(new Vector(nx, ny, nz).normalize());\n    }\n    if (binary) {\n      let offset = 80;\n      const bufferLength =\n        this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      modelOutput = new DataView(arrayBuffer);\n      modelOutput.setUint32(offset, this.faces.length, true);\n      offset += 4;\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput.setFloat32(offset, norm.x, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.y, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.z, true);\n        offset += 4;\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput.setFloat32(offset, vert.x, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.y, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.z, true);\n          offset += 4;\n        }\n        modelOutput.setUint16(offset, 0, true);\n        offset += 2;\n      }\n    } else {\n      modelOutput = 'solid ' + name + '\\n';\n\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput +=\n          ' facet norm ' + norm.x + ' ' + norm.y + ' ' + norm.z + '\\n';\n        modelOutput += '  outer loop' + '\\n';\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput +=\n            '   vertex ' + vert.x + ' ' + vert.y + ' ' + vert.z + '\\n';\n        }\n        modelOutput += '  endloop' + '\\n';\n        modelOutput += ' endfacet' + '\\n';\n      }\n      modelOutput += 'endsolid ' + name + '\\n';\n    }\n    const blob = new Blob([modelOutput], { type: 'text/plain' });\n    fn.downloadFile(blob, fileName, 'stl');\n  }\n\n  /**\n   * Flips the geometry’s texture u-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates\n   * so that the texture appears mirrored horizontally.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipU()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the u-coordinates.\n   * myGeometry.flipU();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]\n   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]\n   * ```\n   *\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's U texture coordinates.\n   *   geom2.flipU();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipU() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return 1 - val;\n      } else {\n        return val;\n      }\n    });\n  }\n\n  /**\n   * Flips the geometry’s texture v-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates\n   * so that the texture appears mirrored vertically.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipV()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the v-coordinates.\n   * myGeometry.flipV();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Left vertices: [0, 0] <--> [1, 0]\n   * // Right vertices: [1, 0] <--> [1, 1]\n   * ```\n   *\n   * @method flipV\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's V texture coordinates.\n   *   geom2.flipV();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipV() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return val;\n      } else {\n        return 1 - val;\n      }\n    });\n  }\n\n  /**\n   * Computes the geometry's faces using its vertices.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles that\n   * are stitched together. Each triangular patch on the geometry's surface is\n   * called a *face*. `myGeometry.computeFaces()` performs the math needed to\n   * define each face based on the distances between vertices.\n   *\n   * The geometry's vertices are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a>\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * Calling `myGeometry.computeFaces()` fills the\n   * <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> array with three-element\n   * arrays that list the vertices that form each face. For example, a geometry\n   * made from a rectangle has two faces because a rectangle is made by joining\n   * two triangles. <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> for a\n   * rectangle would be the two-dimensional array\n   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the\n   * array `[0, 1, 2]` because it's formed by connecting\n   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the\n   * array `[2, 1, 3]` because it's formed by connecting\n   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and\n   * `myGeometry.vertices[3]`.\n   *\n   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to myGeometry's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute myGeometry's faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   * }\n   * </code>\n   * </div>\n   */\n  computeFaces() {\n    this.faces.length = 0;\n    const sliceCount = this.detailX + 1;\n    let a, b, c, d;\n    for (let i = 0; i < this.detailY; i++) {\n      for (let j = 0; j < this.detailX; j++) {\n        a = i * sliceCount + j; // + offset;\n        b = i * sliceCount + j + 1; // + offset;\n        c = (i + 1) * sliceCount + j + 1; // + offset;\n        d = (i + 1) * sliceCount + j; // + offset;\n        this.faces.push([a, b, d]);\n        this.faces.push([d, b, c]);\n      }\n    }\n    return this;\n  }\n\n  _getFaceNormal(faceId) {\n    //This assumes that vA->vB->vC is a counter-clockwise ordering\n    const face = this.faces[faceId];\n    const vA = this.vertices[face[0]];\n    const vB = this.vertices[face[1]];\n    const vC = this.vertices[face[2]];\n    const ab = Vector.sub(vB, vA);\n    const ac = Vector.sub(vC, vA);\n    const n = Vector.cross(ab, ac);\n    const ln = Vector.mag(n);\n    let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));\n    if (sinAlpha === 0 || isNaN(sinAlpha)) {\n      console.warn(\n        'p5.Geometry.prototype._getFaceNormal:',\n        'face has colinear sides or a repeated vertex'\n      );\n      return n;\n    }\n    if (sinAlpha > 1) sinAlpha = 1; // handle float rounding error\n    return n.mult(Math.asin(sinAlpha) / ln);\n  }\n  /**\n   * Calculates the normal vector for each vertex on the geometry.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to create triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*. `myGeometry.computeNormals()` performs the\n   * math needed to orient each face. Orientation is important for lighting\n   * and other effects.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal vector.\n   * Then it calculates the normal vector for each vertex by averaging the\n   * normal vectors of the faces surrounding the vertex. The vertex normals\n   * are stored as <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertexNormals\">myGeometry.vertexNormals</a> array.\n   *\n   * The first parameter, `shadingType`, is optional. Passing the constant\n   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring\n   * faces with their own copies of the vertices they share. Surfaces appear\n   * tiled with flat shading. Passing the constant `SMOOTH`, as in\n   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their\n   * shared vertices. Surfaces appear smoother with smooth shading. By\n   * default, `shadingType` is `FLAT`.\n   *\n   * The second parameter, `options`, is also optional. If an object with a\n   * `roundToPrecision` property is passed, as in\n   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the\n   * number of decimal places to use for calculations. By default,\n   * `roundToPrecision` uses 3 decimal places.\n   *\n   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.\n   * @param {Object} [options] shading options.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus();\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     \"A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices.\"\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   stroke(0);\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 5);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using default (FLAT) shading.\n   *   myGeometry.computeNormals(FLAT);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Create an options object.\n   *   let options = { roundToPrecision: 5 };\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH, options);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  computeNormals(shadingType = FLAT, { roundToPrecision = 3 } = {}) {\n    const vertexNormals = this.vertexNormals;\n    let vertices = this.vertices;\n    const faces = this.faces;\n    let iv;\n\n    if (shadingType === SMOOTH) {\n      const vertexIndices = {};\n      const uniqueVertices = [];\n\n      const power = Math.pow(10, roundToPrecision);\n      const rounded = val => Math.round(val * power) / power;\n      const getKey = vert =>\n        `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;\n\n      // loop through each vertex and add uniqueVertices\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i];\n        const key = getKey(vertex);\n        if (vertexIndices[key] === undefined) {\n          vertexIndices[key] = uniqueVertices.length;\n          uniqueVertices.push(vertex);\n        }\n      }\n\n      // update face indices to use the deduplicated vertex indices\n      faces.forEach(face => {\n        for (let fv = 0; fv < 3; ++fv) {\n          const originalVertexIndex = face[fv];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          face[fv] = vertexIndices[key];\n        }\n      });\n\n      // update edge indices to use the deduplicated vertex indices\n      this.edges.forEach(edge => {\n        for (let ev = 0; ev < 2; ++ev) {\n          const originalVertexIndex = edge[ev];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          edge[ev] = vertexIndices[key];\n        }\n      });\n\n      // update the deduplicated vertices\n      this.vertices = vertices = uniqueVertices;\n    }\n\n    // initialize the vertexNormals array with empty vectors\n    vertexNormals.length = 0;\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals.push(new Vector());\n    }\n\n    // loop through all the faces adding its normal to the normal\n    // of each of its vertices\n    faces.forEach((face, f) => {\n      const faceNormal = this._getFaceNormal(f);\n\n      // all three vertices get the normal added\n      for (let fv = 0; fv < 3; ++fv) {\n        const vertexIndex = face[fv];\n        vertexNormals[vertexIndex].add(faceNormal);\n      }\n    });\n\n    // normalize the normals\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals[iv].normalize();\n    }\n\n    return this;\n  }\n\n  /**\n   * Averages the vertex normals. Used in curved\n   * surfaces\n   * @private\n   * @chainable\n   */\n  averageNormals() {\n    for (let i = 0; i <= this.detailY; i++) {\n      const offset = this.detailX + 1;\n      let temp = Vector.add(\n        this.vertexNormals[i * offset],\n        this.vertexNormals[i * offset + this.detailX]\n      );\n\n      temp = Vector.div(temp, 2);\n      this.vertexNormals[i * offset] = temp;\n      this.vertexNormals[i * offset + this.detailX] = temp;\n    }\n    return this;\n  }\n\n  /**\n   * Averages pole normals.  Used in spherical primitives\n   * @private\n   * @chainable\n   */\n  averagePoleNormals() {\n    //average the north pole\n    let sum = new Vector(0, 0, 0);\n    for (let i = 0; i < this.detailX; i++) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n\n    for (let i = 0; i < this.detailX; i++) {\n      this.vertexNormals[i] = sum;\n    }\n\n    //average the south pole\n    sum = new Vector(0, 0, 0);\n    for (\n      let i = this.vertices.length - 1;\n      i > this.vertices.length - 1 - this.detailX;\n      i--\n    ) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n\n    for (\n      let i = this.vertices.length - 1;\n      i > this.vertices.length - 1 - this.detailX;\n      i--\n    ) {\n      this.vertexNormals[i] = sum;\n    }\n    return this;\n  }\n\n  /**\n   * Create a 2D array for establishing stroke connections\n   * @private\n   * @chainable\n   */\n  _makeTriangleEdges() {\n    this.edges.length = 0;\n\n    for (let j = 0; j < this.faces.length; j++) {\n      this.edges.push([this.faces[j][0], this.faces[j][1]]);\n      this.edges.push([this.faces[j][1], this.faces[j][2]]);\n      this.edges.push([this.faces[j][2], this.faces[j][0]]);\n    }\n\n    return this;\n  }\n\n  /**\n   * @example\n   * <div>\n   * <code>\n   * let tetrahedron;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   describe('A rotating tetrahedron');\n   *\n   *   tetrahedron = new p5.Geometry();\n   *\n   *   // Give each geometry a unique gid\n   *   tetrahedron.gid = 'tetrahedron';\n   *\n   *   // Add four points of the tetrahedron\n   *\n   *   let radius = 50;\n   *   // A 2D triangle:\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));\n   *   // Add a tip in the z axis:\n   *   tetrahedron.vertices.push(createVector(0, 0, radius));\n   *\n   *   // Create the four faces by connecting the sets of three points\n   *   tetrahedron.faces.push([0, 1, 2]);\n   *   tetrahedron.faces.push([0, 1, 3]);\n   *   tetrahedron.faces.push([0, 2, 3]);\n   *   tetrahedron.faces.push([1, 2, 3]);\n   *   tetrahedron.makeEdgesFromFaces();\n   * }\n   * function draw() {\n   *   background(200);\n   *   strokeWeight(2);\n   *   orbitControl();\n   *   rotateY(millis() * 0.001);\n   *   model(tetrahedron);\n   * }\n   * </code>\n   * </div>\n   */\n  makeEdgesFromFaces() {\n    this._makeTriangleEdges();\n  }\n\n  /**\n   * Converts each line segment into the vertices and vertex attributes needed\n   * to turn the line into a polygon on screen. This will include:\n   * - Two triangles line segment to create a rectangle\n   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment\n   *   shader is responsible for displaying the appropriate cap style within\n   *   that rectangle.\n   * - Four triangles per join between adjacent line segments, creating a quad on\n   *   either side of the join, perpendicular to the lines. A vertex shader will\n   *   discard the quad in the \"elbow\" of the join, and a fragment shader will\n   *   display the appropriate join style within the remaining quad.\n   *\n   * @private\n   * @chainable\n   */\n  _edgesToVertices() {\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n\n    const potentialCaps = new Map();\n    const connected = new Set();\n    let lastValidDir;\n    for (let i = 0; i < this.edges.length; i++) {\n      const prevEdge = this.edges[i - 1];\n      const currEdge = this.edges[i];\n      const begin = this.vertices[currEdge[0]];\n      const end = this.vertices[currEdge[1]];\n      const prevColor = (this.vertexStrokeColors.length > 0 && prevEdge)\n        ? this.vertexStrokeColors.slice(\n          prevEdge[1] * 4,\n          (prevEdge[1] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const fromColor = this.vertexStrokeColors.length > 0\n        ? this.vertexStrokeColors.slice(\n          currEdge[0] * 4,\n          (currEdge[0] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const toColor = this.vertexStrokeColors.length > 0\n        ? this.vertexStrokeColors.slice(\n          currEdge[1] * 4,\n          (currEdge[1] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const dir = end\n        .copy()\n        .sub(begin)\n        .normalize();\n      const dirOK = dir.magSq() > 0;\n      if (dirOK) {\n        this._addSegment(begin, end, fromColor, toColor, dir);\n      }\n      if (!this.renderer?._simpleLines) {\n        if (i > 0 && prevEdge[1] === currEdge[0]) {\n          if (!connected.has(currEdge[0])) {\n            connected.add(currEdge[0]);\n            potentialCaps.delete(currEdge[0]);\n            // Add a join if this segment shares a vertex with the previous. Skip\n            // actually adding join vertices if either the previous segment or this\n            // one has a length of 0.\n            //\n            // Don't add a join if the tangents point in the same direction, which\n            // would mean the edges line up exactly, and there is no need for a join.\n            if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {\n              this._addJoin(begin, lastValidDir, dir, fromColor);\n            }\n          }\n        } else {\n          // Start a new line\n          if (dirOK && !connected.has(currEdge[0])) {\n            const existingCap = potentialCaps.get(currEdge[0]);\n            if (existingCap) {\n              this._addJoin(\n                begin,\n                existingCap.dir,\n                dir,\n                fromColor\n              );\n              potentialCaps.delete(currEdge[0]);\n              connected.add(currEdge[0]);\n            } else {\n              potentialCaps.set(currEdge[0], {\n                point: begin,\n                dir: dir.copy().mult(-1),\n                color: fromColor\n              });\n            }\n          }\n          if (lastValidDir && !connected.has(prevEdge[1])) {\n            const existingCap = potentialCaps.get(prevEdge[1]);\n            if (existingCap) {\n              this._addJoin(\n                this.vertices[prevEdge[1]],\n                lastValidDir,\n                existingCap.dir.copy().mult(-1),\n                prevColor\n              );\n              potentialCaps.delete(prevEdge[1]);\n              connected.add(prevEdge[1]);\n            } else {\n              // Close off the last segment with a cap\n              potentialCaps.set(prevEdge[1], {\n                point: this.vertices[prevEdge[1]],\n                dir: lastValidDir,\n                color: prevColor\n              });\n            }\n            lastValidDir = undefined;\n          }\n        }\n\n        if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {\n          const existingCap = potentialCaps.get(currEdge[1]);\n          if (existingCap) {\n            this._addJoin(\n              end,\n              dir,\n              existingCap.dir.copy().mult(-1),\n              toColor\n            );\n            potentialCaps.delete(currEdge[1]);\n            connected.add(currEdge[1]);\n          } else {\n            potentialCaps.set(currEdge[1], {\n              point: end,\n              dir,\n              color: toColor\n            });\n          }\n        }\n\n        if (dirOK) {\n          lastValidDir = dir;\n        }\n      }\n    }\n    for (const { point, dir, color } of potentialCaps.values()) {\n      this._addCap(point, dir, color);\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles making a rectangle\n   * for a straight line segment. A vertex shader is responsible for picking\n   * proper coordinates on the screen given the centerline positions, the tangent,\n   * and the side of the centerline each vertex belongs to. Sides follow the\n   * following scheme:\n   *\n   *  -1            -1\n   *   o-------------o\n   *   |             |\n   *   o-------------o\n   *   1             1\n   *\n   * @private\n   * @chainable\n   */\n  _addSegment(\n    begin,\n    end,\n    fromColor,\n    toColor,\n    dir\n  ) {\n    const a = begin.array();\n    const b = end.array();\n    const dirArr = dir.array();\n    this.lineSides.push(1, 1, -1, 1, -1, -1);\n    for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) {\n      for (let i = 0; i < 6; i++) {\n        tangents.push(...dirArr);\n      }\n    }\n    this.lineVertices.push(...a, ...b, ...a, ...b, ...b, ...a);\n    if (!this.renderer?._simpleLines) {\n      this.lineVertexColors.push(\n        ...fromColor,\n        ...toColor,\n        ...fromColor,\n        ...toColor,\n        ...toColor,\n        ...fromColor\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles representing the\n   * stroke cap of a line. A fragment shader is responsible for displaying the\n   * appropriate cap style within the rectangle they make.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the cap rectangle:\n   *\n   *           -1  -2\n   * -----------o---o\n   *            |   |\n   * -----------o---o\n   *            1   2\n   * @private\n   * @chainable\n   */\n  _addCap(point, tangent, color) {\n    const ptArray = point.array();\n    const tanInArray = tangent.array();\n    const tanOutArray = [0, 0, 0];\n    for (let i = 0; i < 6; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, 2, -2, 1, 2, -1);\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for four triangles representing a\n   * join between two adjacent line segments. This creates a quad on either side\n   * of the shared vertex of the two line segments, with each quad perpendicular\n   * to the lines. A vertex shader will discard all but the quad in the \"elbow\" of\n   * the join, and a fragment shader will display the appropriate join style\n   * within the remaining quad.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the join rectangles:\n   *\n   *            -1     -2\n   * -------------o----o\n   *              |    |\n   *       1 o----o----o -3\n   *         |    | 0  |\n   * --------o----o    |\n   *        2|    3    |\n   *         |         |\n   *         |         |\n   * @private\n   * @chainable\n   */\n  _addJoin(\n    point,\n    fromTangent,\n    toTangent,\n    color\n  ) {\n    const ptArray = point.array();\n    const tanInArray = fromTangent.array();\n    const tanOutArray = toTangent.array();\n    for (let i = 0; i < 12; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, -3, -2, -1, 0, -3);\n    this.lineSides.push(3, 1, 2, 3, 0, 1);\n    return this;\n  }\n\n  /**\n   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box\n   * centered at the origin.\n   *\n   * Calling `myGeometry.normalize()` translates the geometry's vertices so that\n   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so\n   * that they fill a 100×100×100 box. As a result, small geometries will grow\n   * and large geometries will shrink.\n   *\n   * Note: `myGeometry.normalize()` only works when called in the\n   * <a href=\"#/p5/setup\">setup()</a> function.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a very small torus.\n   *   myGeometry = buildGeometry(function() {;\n   *     torus(1, 0.25);\n   *   });\n   *\n   *   // Normalize the torus so its vertices fill\n   *   // the range [-100, 100].\n   *   myGeometry.normalize();\n   *\n   *   describe('A white torus rotates slowly against a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the torus.\n   *   noStroke();\n   *\n   *   // Draw the torus.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n  normalize() {\n    if (this.vertices.length > 0) {\n      // Find the corners of our bounding box\n      const maxPosition = this.vertices[0].copy();\n      const minPosition = this.vertices[0].copy();\n\n      for (let i = 0; i < this.vertices.length; i++) {\n        maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);\n        minPosition.x = Math.min(minPosition.x, this.vertices[i].x);\n        maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);\n        minPosition.y = Math.min(minPosition.y, this.vertices[i].y);\n        maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);\n        minPosition.z = Math.min(minPosition.z, this.vertices[i].z);\n      }\n\n      const center = Vector.lerp(maxPosition, minPosition, 0.5);\n      const dist = Vector.sub(maxPosition, minPosition);\n      const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);\n      const scale = 200 / longestDist;\n\n      for (let i = 0; i < this.vertices.length; i++) {\n        this.vertices[i].sub(center);\n        this.vertices[i].mult(scale);\n      }\n    }\n    return this;\n  }\n\n  /** Sets the shader's vertex property or attribute variables.\n   *\n   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some\n   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are\n   * set using <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/normal\">normal()</a>\n   * and <a href=\"#/p5/fill\">fill()</a> respectively. Custom properties can also\n   * be defined within <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * The first parameter, `propertyName`, is a string with the property's name.\n   * This is the same variable name which should be declared in the shader, as in\n   * `in vec3 aProperty`, similar to .`setUniform()`.\n   *\n   * The second parameter, `data`, is the value assigned to the shader variable. This value\n   * will be pushed directly onto the Geometry object. There should be the same number\n   * of custom property values as vertices, this method should be invoked once for each\n   * vertex.\n   *\n   * The `data` can be a Number or an array of numbers. Tn the shader program the type\n   * can be declared according to the WebGL specification. Common types include `float`,\n   * `vec2`, `vec3`, `vec4` or matrices.\n   *\n   * See also the global <a href=\"#/p5/vertexProperty\">vertexProperty()</a> function.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let geo;\n   *\n   * function cartesianToSpherical(x, y, z) {\n   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n   *   let theta = acos(z / r);\n   *   let phi = atan2(y, x);\n   *   return { theta, phi };\n   * }\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Modify the material shader to display roughness.\n   *   const myShader = baseMaterialShader().modify({\n   *     vertexDeclarations:`in float aRoughness;\n   *                         out float vRoughness;`,\n   *     fragmentDeclarations: 'in float vRoughness;',\n   *     'void afterVertex': `() {\n   *         vRoughness = aRoughness;\n   *     }`,\n   *     'vec4 combineColors': `(ColorComponents components) {\n   *             vec4 color = vec4(0.);\n   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);\n   *             color.rgb += components.ambient * components.ambientColor;\n   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);\n   *             color.a = components.opacity;\n   *             return color;\n   *     }`\n   *   });\n   *\n   *   // Create the Geometry object.\n   *   geo = buildGeometry(function() {\n   *     fill('hotpink');\n   *     sphere(45, 50, 50);\n   *   });\n   *\n   *   // Set the roughness value for every vertex.\n   *   for (let v of geo.vertices){\n   *\n   *     // convert coordinates to spherical coordinates\n   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);\n   *\n   *     // Set the custom roughness vertex property.\n   *     let roughness = noise(spherical.theta*5, spherical.phi*5);\n   *     geo.vertexProperty('aRoughness', roughness);\n   *   }\n   *\n   *   // Use the custom shader.\n   *   shader(myShader);\n   *\n   *   describe('A rough pink sphere rotating on a blue background.');\n   * }\n   *\n   * function draw() {\n   *   // Set some styles and lighting\n   *   background('lightblue');\n   *   noStroke();\n   *\n   *   specularMaterial(255,125,100);\n   *   shininess(2);\n   *\n   *   directionalLight('white', -1, 1, -1);\n   *   ambientLight(320);\n   *\n   *   rotateY(millis()*0.001);\n   *\n   *   // Draw the geometry\n   *   model(geo);\n   * }\n   * </code>\n   * </div>\n   *\n   * @param {String} propertyName the name of the vertex property.\n   * @param {Number|Number[]} data the data tied to the vertex property.\n   * @param {Number} [size] optional size of each unit of data.\n   */\n  vertexProperty(propertyName, data, size){\n    let prop;\n    if (!this.userVertexProperties[propertyName]){\n      prop = this.userVertexProperties[propertyName] =\n        this._userVertexPropertyHelper(propertyName, data, size);\n    }\n    prop = this.userVertexProperties[propertyName];\n    if (size){\n      prop.pushDirect(data);\n    } else {\n      prop.setCurrentData(data);\n      prop.pushCurrentData();\n    }\n  }\n\n  _userVertexPropertyHelper(propertyName, data, size){\n    const geometryInstance = this;\n    const prop = this.userVertexProperties[propertyName] = {\n      name: propertyName,\n      dataSize: size ? size : data.length ? data.length : 1,\n      geometry: geometryInstance,\n      // Getters\n      getName(){\n        return this.name;\n      },\n      getCurrentData(){\n        if (this.currentData === undefined) {\n          this.currentData = new Array(this.getDataSize()).fill(0);\n        }\n        return this.currentData;\n      },\n      getDataSize() {\n        return this.dataSize;\n      },\n      getSrcName() {\n        const src = this.name.concat('Src');\n        return src;\n      },\n      getDstName() {\n        const dst = this.name.concat('Buffer');\n        return dst;\n      },\n      getSrcArray() {\n        const srcName = this.getSrcName();\n        return this.geometry[srcName];\n      },\n      //Setters\n      setCurrentData(data) {\n        data.length ? data.length : 1;\n        // if (size != this.getDataSize()){\n        //   p5._friendlyError(`Custom vertex property '${this.name}' has been set with various data sizes. You can change it's name, or if it was an accident, set '${this.name}' to have the same number of inputs each time!`, 'vertexProperty()');\n        // }\n        this.currentData = data;\n      },\n      // Utilities\n      pushCurrentData(){\n        const data = this.getCurrentData();\n        this.pushDirect(data);\n      },\n      pushDirect(data) {\n        if (data.length){\n          this.getSrcArray().push(...data);\n        } else {\n          this.getSrcArray().push(data);\n        }\n      },\n      resetSrcArray(){\n        this.geometry[this.getSrcName()] = [];\n      },\n      delete() {\n        const srcName = this.getSrcName();\n        delete this.geometry[srcName];\n        delete this;\n      }\n    };\n    this[prop.getSrcName()] = [];\n    return this.userVertexProperties[propertyName];\n  }\n}\n/**\n * Keeps track of how many custom geometry objects have been made so that each\n * can be assigned a unique ID.\n */\nGeometry.nextId = 0;\n\nfunction geometry(p5, fn){\n  /**\n   * A class to describe a 3D shape.\n   *\n   * Each `p5.Geometry` object represents a 3D shape as a set of connected\n   * points called *vertices*. All 3D shapes are made by connecting vertices to\n   * form triangles that are stitched together. Each triangular patch on the\n   * geometry's surface is called a *face*. The geometry stores information\n   * about its vertices and faces for use with effects such as lighting and\n   * texture mapping.\n   *\n   * The first parameter, `detailX`, is optional. If a number is passed, as in\n   * `new p5.Geometry(24)`, it sets the number of triangle subdivisions to use\n   * along the geometry's x-axis. By default, `detailX` is 1.\n   *\n   * The second parameter, `detailY`, is also optional. If a number is passed,\n   * as in `new p5.Geometry(24, 16)`, it sets the number of triangle\n   * subdivisions to use along the geometry's y-axis. By default, `detailX` is\n   * 1.\n   *\n   * The third parameter, `callback`, is also optional. If a function is passed,\n   * as in `new p5.Geometry(24, 16, createShape)`, it will be called once to add\n   * vertices to the new 3D shape.\n   *\n   * @class p5.Geometry\n   * @param  {Integer} [detailX] number of vertices along the x-axis.\n   * @param  {Integer} [detailY] number of vertices along the y-axis.\n   * @param {function} [callback] function to call once the geometry is created.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * // Adapted from Paul Wheeler's wonderful p5.Geometry tutorial.\n   * // https://www.paulwheeler.us/articles/custom-3d-geometry-in-p5js/\n   * // CC-BY-SA 4.0\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   // Set detailX to 48 and detailY to 2.\n   *   // >>> try changing them.\n   *   myGeometry = new p5.Geometry(48, 2, createShape);\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   strokeWeight(0.2);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Define the Möbius strip with a few parameters.\n   *   let spread = 0.1;\n   *   let radius = 30;\n   *   let stripWidth = 15;\n   *   let xInterval = 4 * PI / this.detailX;\n   *   let yOffset = -stripWidth / 2;\n   *   let yInterval = stripWidth / this.detailY;\n   *\n   *   for (let j = 0; j <= this.detailY; j += 1) {\n   *     // Calculate the \"vertical\" point along the strip.\n   *     let v = yOffset + yInterval * j;\n   *\n   *     for (let i = 0; i <= this.detailX; i += 1) {\n   *       // Calculate the angle of rotation around the strip.\n   *       let u = i * xInterval;\n   *\n   *       // Calculate the coordinates of the vertex.\n   *       let x = (radius + v * cos(u / 2)) * cos(u) - sin(u / 2) * 2 * spread;\n   *       let y = (radius + v * cos(u / 2)) * sin(u);\n   *       if (u < TWO_PI) {\n   *         y += sin(u) * spread;\n   *       } else {\n   *         y -= sin(u) * spread;\n   *       }\n   *       let z = v * sin(u / 2) + sin(u / 4) * 4 * spread;\n   *\n   *       // Create a p5.Vector object to position the vertex.\n   *       let vert = createVector(x, y, z);\n   *\n   *       // Add the vertex to the p5.Geometry object's vertices array.\n   *       this.vertices.push(vert);\n   *     }\n   *   }\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   */\n  p5.Geometry = Geometry;\n\n  /**\n   * An array with the geometry's vertices.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the `myGeometry.vertices`\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * @property vertices\n   * @for p5.Geometry\n   * @name vertices\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   describe('A white torus rotates slowly against a dark gray background. Red spheres mark its vertices.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   fill(255);\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the vertices.\n   *   fill(255, 0, 0);\n   *   noStroke();\n   *\n   *   // Iterate over the vertices array.\n   *   for (let v of myGeometry.vertices) {\n   *     // Draw a sphere to mark the vertex.\n   *     push();\n   *     translate(v);\n   *     sphere(2.5);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array with the vectors that are normal to the geometry's vertices.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal\n   * vector. Then it calculates the normal vector for each vertex by\n   * averaging the normal vectors of the faces surrounding the vertex. The\n   * vertex normals are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the `myGeometry.vertexNormals` array.\n   *\n   * @property vertexNormals\n   * @name vertexNormals\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     'A white torus rotates against a dark gray background. Red lines extend outward from its vertices.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 8);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists which of the geometry's vertices form each of its\n   * faces.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a> array. The\n   * geometry's first vertex is the <a href=\"#/p5.Vector\">p5.Vector</a>\n   * object at `myGeometry.vertices[0]`, its second vertex is\n   * `myGeometry.vertices[1]`, its third vertex is `myGeometry.vertices[2]`,\n   * and so on.\n   *\n   * For example, a geometry made from a rectangle has two faces because a\n   * rectangle is made by joining two triangles. `myGeometry.faces` for a\n   * rectangle would be the two-dimensional array `[[0, 1, 2], [2, 1, 3]]`.\n   * The first face, `myGeometry.faces[0]`, is the array `[0, 1, 2]` because\n   * it's formed by connecting `myGeometry.vertices[0]`,\n   * `myGeometry.vertices[1]`,and `myGeometry.vertices[2]`. The second face,\n   * `myGeometry.faces[1]`, is the array `[2, 1, 3]` because it's formed by\n   * connecting `myGeometry.vertices[2]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[3]`.\n   *\n   * @property faces\n   * @name faces\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     sphere();\n   *   });\n   *\n   *   describe(\"A sphere drawn on a gray background. The sphere's surface is a grayscale patchwork of triangles.\");\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *\n   *   // Set a random seed.\n   *   randomSeed(1234);\n   *\n   *   // Iterate over the faces array.\n   *   for (let face of myGeometry.faces) {\n   *\n   *     // Style the face.\n   *     let g = random(0, 255);\n   *     fill(g);\n   *\n   *     // Draw the face.\n   *     beginShape();\n   *     // Iterate over the vertices that form the face.\n   *     for (let f of face) {\n   *       // Get the vertex's p5.Vector object.\n   *       let v = myGeometry.vertices[f];\n   *       vertex(v.x, v.y, v.z);\n   *     }\n   *     endShape();\n   *\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists the texture coordinates for each of the geometry's\n   * vertices.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a\n   * rectangular image that's used as a texture. The geometry's vertex at\n   * coordinates `(x, y, z)` maps to the texture image's pixel at coordinates\n   * `(u, v)`.\n   *\n   * The `myGeometry.uvs` array stores the `(u, v)` coordinates for each\n   * vertex in the order it was added to the geometry. For example, the\n   * first vertex, `myGeometry.vertices[0]`, has its `(u, v)` coordinates\n   * stored at `myGeometry.uvs[0]` and `myGeometry.uvs[1]`.\n   *\n   * @property uvs\n   * @name uvs\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Set geom2's texture coordinates.\n   *   geom2.uvs = [0.25, 0.25, 0.75, 0.25, 0.25, 0.75, 0.75, 0.75];\n   *\n   *   // Right (zoomed in).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photo on the right zooms in to the center of the photo.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n}\n\nif(typeof p5 !== 'undefined'){\n  geometry(p5, p5.prototype);\n}\n\nexport { Geometry, geometry as default };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,IAAI,EAAEC,CAAC,IAAIC,MAAM,QAAQ,0BAA0B;AACjE,SAASC,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,MAAM,QAAQ,sBAAsB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,MAAMC,QAAQ,CAAC;EACbC,WAAWA,CAACC,OAAO,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;IAChD,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAG,EAAE;IAElB,IAAI,CAACC,gBAAgB,GAAG,IAAI;;IAG5B;IACA,IAAI,CAACC,YAAY,GAAG,IAAIV,SAAS,CAAC,CAAC;;IAEnC;IACA;IACA;IACA;IACA,IAAI,CAACW,cAAc,GAAG,IAAIX,SAAS,CAAC,CAAC;IACrC,IAAI,CAACY,eAAe,GAAG,IAAIZ,SAAS,CAAC,CAAC;;IAEtC;IACA;IACA;IACA;IACA;IACA,IAAI,CAACa,SAAS,GAAG,IAAIb,SAAS,CAAC,CAAC;IAEhC,IAAI,CAACc,aAAa,GAAG,EAAE;IAEvB,IAAI,CAACC,KAAK,GAAG,EAAE;IAEf,IAAI,CAACC,GAAG,GAAG,EAAE;IACb;IACA;IACA,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,YAAY,GAAG,EAAE;;IAEtB;IACA,IAAI,CAACC,kBAAkB,GAAG,EAAE;IAE5B,IAAI,CAACC,oBAAoB,GAAG,CAAC,CAAC;;IAE9B;IACA;IACA,IAAI,CAACC,gBAAgB,GAAG,IAAIrB,SAAS,CAAC,CAAC;IACvC,IAAI,CAACI,OAAO,GAAGA,OAAO,KAAKkB,SAAS,GAAGlB,OAAO,GAAG,CAAC;IAClD,IAAI,CAACC,OAAO,GAAGA,OAAO,KAAKiB,SAAS,GAAGjB,OAAO,GAAG,CAAC;IAClD,IAAI,CAACkB,UAAU,GAAG,CAAC,CAAC;IAEpB,IAAI,CAACC,oBAAoB,GAAGF,SAAS;IACrC,IAAI,CAACG,sBAAsB,GAAGH,SAAS;IAEvC,IAAI,CAACI,GAAG,GAAG,gBAAgBxB,QAAQ,CAACyB,MAAM,EAAE;IAC5CzB,QAAQ,CAACyB,MAAM,EAAE;IACjB,IAAIrB,QAAQ,YAAYsB,QAAQ,EAAE;MAChCtB,QAAQ,CAACuB,IAAI,CAAC,IAAI,CAAC;IACrB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,oBAAoBA,CAAA,EAAG;IACrB,IAAI,IAAI,CAACrB,gBAAgB,EAAE;MACzB,OAAO,IAAI,CAACA,gBAAgB,CAAC,CAAC;IAChC;IAEA,IAAIsB,SAAS,GAAG,IAAI9B,MAAM,CACxB+B,MAAM,CAACC,SAAS,EAAED,MAAM,CAACC,SAAS,EAAED,MAAM,CAACC,SAAS,CAAC;IACvD,IAAIC,SAAS,GAAG,IAAIjC,MAAM,CACxB+B,MAAM,CAACG,SAAS,EAAEH,MAAM,CAACG,SAAS,EAAEH,MAAM,CAACG,SAAS,CAAC;IAEvD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC5B,QAAQ,CAAC6B,MAAM,EAAED,CAAC,EAAE,EAAE;MAC7C,IAAIE,MAAM,GAAG,IAAI,CAAC9B,QAAQ,CAAC4B,CAAC,CAAC;MAC7BL,SAAS,CAACQ,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACV,SAAS,CAACQ,CAAC,EAAED,MAAM,CAACC,CAAC,CAAC;MAC7CR,SAAS,CAACjC,CAAC,GAAG0C,IAAI,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IAAI,CAACf,gBAAgB,CAACe,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;UACpC,IAAI,CAACX,sBAAsB,GAAG,IAAI;UAClC;QACF;MACF;IACF;IACA,OAAO,IAAI,CAACA,sBAAsB;EACpC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2B,WAAWA,CAAA,EAAG;IACZ,IAAI,CAAClC,YAAY,GAAG,EAAE;IACtB,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEmC,OAAOA,CAACC,QAAQ,GAAG,WAAW,EAAE;IAC9B,IAAIC,MAAM,GAAE,EAAE;;IAGd;IACA,IAAI,CAAC/C,QAAQ,CAACgD,OAAO,CAACC,CAAC,IAAI;MACzBF,MAAM,IAAI,KAAKE,CAAC,CAAClB,CAAC,IAAIkB,CAAC,CAAC3D,CAAC,IAAI2D,CAAC,CAACf,CAAC,IAAI;IACtC,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAAC1B,GAAG,IAAI,IAAI,CAACA,GAAG,CAACqB,MAAM,GAAG,CAAC,EAAE;MACnC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACpB,GAAG,CAACqB,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;QAC3CmB,MAAM,IAAI,MAAM,IA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE0C,KAAKA,CAAA,EAAG;IACN,IAAI,CAAChF,GAAG,GAAG,IAAI,CAACA,GAAG,CAACiF,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,GAAG,EAAEtC,KAAK,KAAK;MAC7C,IAAIA,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE;QACnB,OAAO,CAAC,GAAGsC,GAAG;MAChB,CAAC,MAAM;QACL,OAAOA,GAAG;MACZ;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,KAAKA,CAAA,EAAG;IACN,IAAI,CAACpF,GAAG,GAAG,IAAI,CAACA,GAAG,CAACiF,IAAI,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,GAAG,EAAEtC,KAAK,KAAK;MAC7C,IAAIA,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE;QACnB,OAAOsC,GAAG;MACZ,CAAC,MAAM;QACL,OAAO,CAAC,GAAGA,GAAG;MAChB;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,YAAYA,CAAA,EAAG;IACb,IAAI,CAACtF,KAAK,CAACsB,MAAM,GAAG,CAAC;IACrB,MAAMiE,UAAU,GAAG,IAAI,CAAClG,OAAO,GAAG,CAAC;IACnC,IAAImG,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC;IACd,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC/B,OAAO,EAAE+B,CAAC,EAAE,EAAE;MACrC,KAAK,IAAIuE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACvG,OAAO,EAAEuG,CAAC,EAAE,EAAE;QACrCJ,CAAC,GAAGnE,CAAC,GAAGkE,UAAU,GAAGK,CAAC,CAAC,CAAC;QACxBH,CAAC,GAAGpE,CAAC,GAAGkE,UAAU,GAAGK,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5BF,CAAC,GAAG,CAACrE,CAAC,GAAG,CAAC,IAAIkE,UAAU,GAAGK,CAAC,GAAG,CAAC,CAAC,CAAC;QAClCD,CAAC,GAAG,CAACtE,CAAC,GAAG,CAAC,IAAIkE,UAAU,GAAGK,CAAC,CAAC,CAAC;QAC9B,IAAI,CAAC5F,KAAK,CAACkE,IAAI,CAAC,CAACsB,CAAC,EAAEC,CAAC,EAAEE,CAAC,CAAC,CAAC;QAC1B,IAAI,CAAC3F,KAAK,CAACkE,IAAI,CAAC,CAACyB,CAAC,EAAEF,CAAC,EAAEC,CAAC,CAAC,CAAC;MAC5B;IACF;IACA,OAAO,IAAI;EACb;EAEAG,cAAcA,CAACC,MAAM,EAAE;IACrB;IACA,MAAMlD,IAAI,GAAG,IAAI,CAAC5C,KAAK,CAAC8F,MAAM,CAAC;IAC/B,MAAMC,EAAE,GAAG,IAAI,CAACtG,QAAQ,CAACmD,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,MAAMoD,EAAE,GAAG,IAAI,CAACvG,QAAQ,CAACmD,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,MAAMqD,EAAE,GAAG,IAAI,CAACxG,QAAQ,CAACmD,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,MAAMsD,EAAE,GAAGhH,MAAM,CAAC2E,GAAG,CAACmC,EAAE,EAAED,EAAE,CAAC;IAC7B,MAAMI,EAAE,GAAGjH,MAAM,CAAC2E,GAAG,CAACoC,EAAE,EAAEF,EAAE,CAAC;IAC7B,MAAMpD,CAAC,GAAGzD,MAAM,CAACkH,KAAK,CAACF,EAAE,EAAEC,EAAE,CAAC;IAC9B,MAAME,EAAE,GAAGnH,MAAM,CAACoH,GAAG,CAAC3D,CAAC,CAAC;IACxB,IAAI4D,QAAQ,GAAGF,EAAE,IAAInH,MAAM,CAACoH,GAAG,CAACJ,EAAE,CAAC,GAAGhH,MAAM,CAACoH,GAAG,CAACH,EAAE,CAAC,CAAC;IACrD,IAAII,QAAQ,KAAK,CAAC,IAAIC,KAAK,CAACD,QAAQ,CAAC,EAAE;MACrCE,OAAO,CAACC,IAAI,CACV,uCAAuC,EACvC,8CACF,CAAC;MACD,OAAO/D,CAAC;IACV;IACA,IAAI4D,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAG,CAAC,CAAC,CAAC;IAChC,OAAO5D,CAAC,CAACgE,IAAI,CAAClF,IAAI,CAACmF,IAAI,CAACL,QAAQ,CAAC,GAAGF,EAAE,CAAC;EACzC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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ACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,cAAcA,CAACC,YAAY,EAAEC,IAAI,EAAEzJ,IAAI,EAAC;IACtC,IAAI0J,IAAI;IACR,IAAI,CAAC,IAAI,CAAClL,oBAAoB,CAACgL,YAAY,CAAC,EAAC;MAC3CE,IAAI,GAAG,IAAI,CAAClL,oBAAoB,CAACgL,YAAY,CAAC,GAC5C,IAAI,CAACG,yBAAyB,CAACH,YAAY,EAAEC,IAAI,EAAEzJ,IAAI,CAAC;IAC5D;IACA0J,IAAI,GAAG,IAAI,CAAClL,oBAAoB,CAACgL,YAAY,CAAC;IAC9C,IAAIxJ,IAAI,EAAC;MACP0J,IAAI,CAACE,UAAU,CAACH,IAAI,CAAC;IACvB,CAAC,MAAM;MACLC,IAAI,CAACG,cAAc,CAACJ,IAAI,CAAC;MACzBC,IAAI,CAACI,eAAe,CAAC,CAAC;IACxB;EACF;EAEAH,yBAAyBA,CAACH,YAAY,EAAEC,IAAI,EAAEzJ,IAAI,EAAC;IACjD,MAAM+J,gBAAgB,GAAG,IAAI;IAC7B,MAAML,IAAI,GAAG,IAAI,CAAClL,oBAAoB,CAACgL,YAAY,CAAC,GAAG;MACrD9H,IAAI,EAAE8H,YAAY;MAClBQ,QAAQ,EAAEhK,IAAI,GAAGA,IAAI,GAAGyJ,IAAI,CAAChK,MAAM,GAAGgK,IAAI,CAAChK,MAAM,GAAG,CAAC;MACrDwK,QAAQ,EAAEF,gBAAgB;MAC1B;MACAG,OAAOA,CAAA,EAAE;QACP,OAAO,IAAI,CAACxI,IAAI;MAClB,CAAC;MACDyI,cAAcA,CAAA,EAAE;QACd,IAAI,IAAI,CAACC,WAAW,KAAK1L,SAAS,EAAE;UAClC,IAAI,CAAC0L,WAAW,GAAG,IAAIC,KAAK,CAAC,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;QAC1D;QACA,OAAO,IAAI,CAACH,WAAW;MACzB,CAAC;MACDE,WAAWA,CAAA,EAAG;QACZ,OAAO,IAAI,CAACN,QAAQ;MACtB,CAAC;MACDQ,UAAUA,CAAA,EAAG;QACX,MAAMC,GAAG,GAAG,IAAI,CAAC/I,IAAI,CAACgJ,MAAM,CAAC,KAAK,CAAC;QACnC,OAAOD,GAAG;MACZ,CAAC;MACDE,UAAUA,CAAA,EAAG;QACX,MAAMC,GAAG,GAAG,IAAI,CAAClJ,IAAI,CAACgJ,MAAM,CAAC,QAAQ,CAAC;QACtC,OAAOE,GAAG;MACZ,CAAC;MACDC,WAAWA,CAAA,EAAG;QACZ,MAAMC,OAAO,GAAG,IAAI,CAACN,UAAU,CAAC,CAAC;QACjC,OAAO,IAAI,CAACP,QAAQ,CAACa,OAAO,CAAC;MAC/B,CAAC;MACD;MACAjB,cAAcA,CAACJ,IAAI,EAAE;QACnBA,IAAI,CAAChK,MAAM,GAAGgK,IAAI,CAAChK,MAAM,GAAG,CAAC;QAC7B;QACA;QACA;QACA,IAAI,CAAC2K,WAAW,GAAGX,IAAI;MACzB,CAAC;MACD;MACAK,eAAeA,CAAA,EAAE;QACf,MAAML,IAAI,GAAG,IAAI,CAACU,cAAc,CAAC,CAAC;QAClC,IAAI,CAACP,UAAU,CAACH,IAAI,CAAC;MACvB,CAAC;MACDG,UAAUA,CAACH,IAAI,EAAE;QACf,IAAIA,IAAI,CAAChK,MAAM,EAAC;UACd,IAAI,CAACoL,WAAW,CAAC,CAAC,CAACxI,IAAI,CAAC,GAAGoH,IAAI,CAAC;QAClC,CAAC,MAAM;UACL,IAAI,CAACoB,WAAW,CAAC,CAAC,CAACxI,IAAI,CAACoH,IAAI,CAAC;QAC/B;MACF,CAAC;MACDsB,aAAaA,CAAA,EAAE;QACb,IAAI,CAACd,QAAQ,CAAC,IAAI,CAACO,UAAU,CAAC,CAAC,CAAC,GAAG,EAAE;MACvC,CAAC;MACDnK,MAAMA,CAAA,EAAG;QACP,MAAMyK,OAAO,GAAG,IAAI,CAACN,UAAU,CAAC,CAAC;QACjC,OAAO,IAAI,CAACP,QAAQ,CAACa,OAAO,CAAC;QAC7B,OAAO,IAAI;MACb;IACF,CAAC;IACD,IAAI,CAACpB,IAAI,CAACc,UAAU,CAAC,CAAC,CAAC,GAAG,EAAE;IAC5B,OAAO,IAAI,CAAChM,oBAAoB,CAACgL,YAAY,CAAC;EAChD;AACF;AACA;AACA;AACA;AACA;AACAlM,QAAQ,CAACyB,MAAM,GAAG,CAAC;AAEnB,SAASkL,QAAQA,CAACe,EAAE,EAAE3J,EAAE,EAAC;EACvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2J,EAAE,CAAC1N,QAAQ,GAAGA,QAAQ;;EAEtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAG,OAAO0N,EAAE,KAAK,WAAW,EAAC;EAC3Bf,QAAQ,CAACe,EAAE,EAAEA,EAAE,CAACC,SAAS,CAAC;AAC5B;AAEA,SAAS3N,QAAQ,EAAE2M,QAAQ,IAAIiB,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}