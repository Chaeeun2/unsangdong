{"ast":null,"code":"import { textCoreConstants } from './textCore.js';\nimport { C as CENTER, R as RIGHT, a as RADIUS } from '../constants-BRcElHU3.js';\nimport { UnicodeRange } from '@japont/unicode-range';\nimport { unicodeRanges } from './unicodeRanges.js';\nimport Typr from './lib/Typr.js';\nimport { createFromCommands } from '@davepagurek/bezier-path';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../image/filters.js';\nimport '../math/p5.Vector.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport 'pako';\n\n/**\n * @module Typography\n */\n\nconst pathArgCounts = {\n  M: 2,\n  L: 2,\n  C: 6,\n  Q: 4\n};\nconst validFontTypes = ['ttf', 'otf', 'woff']; //, 'woff2'];\nconst validFontTypesRe = new RegExp(`\\\\.(${validFontTypes.join('|')})`, 'i');\nconst extractFontNameRe = new RegExp(`([^/]+)(\\\\.(?:${validFontTypes.join('|')}))`, 'i');\nconst invalidFontError = 'Sorry, only TTF, OTF and WOFF files are supported.'; // and WOFF2\nconst fontFaceVariations = ['weight', 'stretch', 'style'];\nclass Font {\n  constructor(p, fontFace, name, path, data) {\n    if (!(fontFace instanceof FontFace)) {\n      throw Error('FontFace is required');\n    }\n    this._pInst = p;\n    this.name = name;\n    this.path = path;\n    this.data = data;\n    this.face = fontFace;\n  }\n\n  /**\n   * Checks whether a font has glyph point data and\n   * can thus be used for textToPoints(), WEBGL mode, etc.\n   * @private\n   */\n  static hasGlyphData(textFont) {\n    let {\n      font\n    } = textFont;\n    return typeof font === 'object' && typeof font.data !== 'undefined';\n  }\n  fontBounds(str, x, y, width, height, options) {\n    ({\n      width,\n      height,\n      options\n    } = this._parseArgs(width, height, options));\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n    if (!renderer) throw Error('p5 or graphics required for fontBounds()');\n    return renderer.fontBounds(str, x, y, width, height);\n  }\n  textBounds(str, x, y, width, height, options) {\n    ({\n      width,\n      height,\n      options\n    } = this._parseArgs(width, height, options));\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n    if (!renderer) throw Error('p5 or graphics required for fontBounds()');\n    return renderer.textBounds(str, x, y, width, height);\n  }\n\n  /**\n   * Returns a flat array of path commands that describe the outlines of a string of text.\n   *\n   * Each command is represented as an array of the form `[type, ...coords]`, where:\n   * - `type` is one of `'M'`, `'L'`, `'Q'`, `'C'`, or `'Z'`,\n   * - `coords` are the numeric values needed for that command.\n   *\n   * `'M'` indicates a \"move to\" (starting a new contour),\n   * `'L'` a line segment,\n   * `'Q'` a quadratic bezier,\n   * `'C'` a cubic bezier, and\n   * `'Z'` closes the current path.\n   *\n   * The first two parameters, `x` and `y`, specify the baseline origin for the text.\n   * Optionally, you can provide a `width` and `height` for text wrapping; if you don't need\n   * wrapping, you can omit them and directly pass `options` as the fourth parameter.\n   *\n   * @param  {String} str            The text to convert into path commands.\n   * @param  {Number} x              x‐coordinate of the text baseline.\n   * @param  {Number} y              y‐coordinate of the text baseline.\n   * @param  {Number} [width]        Optional width for text wrapping.\n   * @param  {Number} [height]       Optional height for text wrapping.\n   * @param  {Object} [options]      Configuration object for rendering text.\n   * @return {Array<Array>}          A flat array of path commands.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   font = await loadFont('assets/inconsolata.otf');\n   *   createCanvas(200, 200);\n   *   background(220);\n   *   noLoop();\n   * }\n   *\n   * function draw() {\n   *   background(220);\n   *   stroke(0);\n   *   noFill();\n   *   textSize(60);\n   *\n   *   // Get path commands for \"Hello\" (drawn at baseline x=50, y=100):\n   *   const pathCommands = font.textToPaths('Hello', 30, 110);\n   *\n   *   beginShape();\n   *   for (let i = 0; i < pathCommands.length; i++) {\n   *     const cmd = pathCommands[i];\n   *     const type = cmd[0];\n   *\n   *     switch (type) {\n   *       case 'M': {\n   *         // Move to (start a new contour)\n   *         const x = cmd[1];\n   *         const y = cmd[2];\n   *         endContour(); // In case we were already drawing\n   *         beginContour();\n   *         vertex(x, y);\n   *         break;\n   *       }\n   *       case 'L': {\n   *         // Line to\n   *         const x = cmd[1];\n   *         const y = cmd[2];\n   *         vertex(x, y);\n   *         break;\n   *       }\n   *       case 'Q': {\n   *         // Quadratic bezier\n   *         const cx = cmd[1];\n   *         const cy = cmd[2];\n   *         const x = cmd[3];\n   *         const y = cmd[4];\n   *         bezierOrder(2);\n   *         bezierVertex(cx, cy);\n   *         bezierVertex(x, y);\n   *         break;\n   *       }\n   *       case 'C': {\n   *         // Cubic bezier\n   *         const cx1 = cmd[1];\n   *         const cy1 = cmd[2];\n   *         const cx2 = cmd[3];\n   *         const cy2 = cmd[4];\n   *         const x = cmd[5];\n   *         const y = cmd[6];\n   *         bezierOrder(3);\n   *         bezierVertex(cx1, cy1);\n   *         bezierVertex(cx2, cy2);\n   *         bezierVertex(x, y);\n   *         break;\n   *       }\n   *       case 'Z': {\n   *         // Close path\n   *         endContour(CLOSE);\n   *         beginContour();\n   *         break;\n   *       }\n   *     }\n   *   }\n   *   endContour();\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  textToPaths(str, x, y, width, height, options) {\n    ({\n      width,\n      height,\n      options\n    } = this._parseArgs(width, height, options));\n    if (!this.data) {\n      throw Error('No font data available for \"' + this.name + '\"\\nTry downloading a local copy of the font file');\n    }\n\n    // lineate and get glyphs/paths for each line\n    let lines = this._lineateAndPathify(str, x, y, width, height, options);\n\n    // flatten into a single array containing all the glyphs\n    let glyphs = lines.map(o => o.glyphs).flat();\n\n    // flatten into a single array with all the path commands\n    return glyphs.map(g => g.path.commands).flat();\n  }\n\n  /**\n   * Returns an array of points outlining a string of text written using the\n   * font.\n   *\n   * Each point object in the array has three properties that describe the\n   * point's location and orientation, called its path angle. For example,\n   * `{ x: 10, y: 20, alpha: 450 }`.\n   *\n   * The first parameter, `str`, is a string of text. The second and third\n   * parameters, `x` and `y`, are the text's position. By default, they set the\n   * coordinates of the bounding box's bottom-left corner. See\n   * <a href=\"#/p5/textAlign\">textAlign()</a> for more ways to align text.\n   *\n   * The fourth parameter, `options`, is also optional. `font.textToPoints()`\n   * expects an object with the following properties:\n   *\n   * `sampleFactor` is the ratio of the text's path length to the number of\n   * samples. It defaults to 0.1. Higher values produce more points along the\n   * path and are more precise.\n   *\n   * `simplifyThreshold` removes collinear points if it's set to a number other\n   * than 0. The value represents the threshold angle to use when determining\n   * whether two edges are collinear.\n   *\n   * @param  {String} str        string of text.\n   * @param  {Number} x          x-coordinate of the text.\n   * @param  {Number} y          y-coordinate of the text.\n   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold\n   *                             properties.\n   * @return {Array<Object>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont('assets/inconsolata.otf');\n   *\n   *   background(200);\n   *   textSize(35);\n   *\n   *   // Get the point array.\n   *   let points = font.textToPoints('p5*js', 6, 60, { sampleFactor: 0.5 });\n   *\n   *   // Draw a dot at each point.\n   *   for (let p of points) {\n   *     point(p.x, p.y);\n   *   }\n   *\n   *   describe('A set of black dots outlining the text \"p5*js\" on a gray background.');\n   * }\n   * </code>\n   * </div>\n   */\n  textToPoints(str, x, y, width, height, options) {\n    // By segmenting per contour, pointAtLength becomes much faster\n    const contourPoints = this.textToContours(str, x, y, width, height, options);\n    return contourPoints.reduce((acc, next) => {\n      acc.push(...next);\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Returns an array of arrays of points outlining a string of text written using the\n   * font. Each array represents a contour, so the letter O will have two outer arrays:\n   * one for the outer edge of the shape, and one for the inner edge of the hole.\n   *\n   * Each point object in a contour array has three properties that describe the\n   * point's location and orientation, called its path angle. For example,\n   * `{ x: 10, y: 20, alpha: 450 }`.\n   *\n   * The first parameter, `str`, is a string of text. The second and third\n   * parameters, `x` and `y`, are the text's position. By default, they set the\n   * coordinates of the bounding box's bottom-left corner. See\n   * <a href=\"#/p5/textAlign\">textAlign()</a> for more ways to align text.\n   *\n   * The fourth parameter, `options`, is also optional. `font.textToPoints()`\n   * expects an object with the following properties:\n   *\n   * `sampleFactor` is the ratio of the text's path length to the number of\n   * samples. It defaults to 0.1. Higher values produce more points along the\n   * path and are more precise.\n   *\n   * `simplifyThreshold` removes collinear points if it's set to a number other\n   * than 0. The value represents the threshold angle to use when determining\n   * whether two edges are collinear.\n   *\n   * @param  {String} str        string of text.\n   * @param  {Number} x          x-coordinate of the text.\n   * @param  {Number} y          y-coordinate of the text.\n   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold\n   *                             properties.\n   * @return {Array<Array<Object>>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont('/assets/inconsolata.otf');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   textAlign(CENTER, CENTER);\n   *   textSize(30);\n   *\n   *   // Get the point array.\n   *   let contours = font.textToContours('p5*js', width/2, height/2, { sampleFactor: 0.5 });\n   *\n   *   beginShape();\n   *   for (const pts of contours) {\n   *     beginContour();\n   *     for (const pt of pts) {\n   *       vertex(pt.x + 5*sin(pt.y*0.1 + millis()*0.01), pt.y);\n   *     }\n   *     endContour(CLOSE);\n   *   }\n   *   endShape();\n   *\n   *   describe('The text p5*js wobbling over time');\n   * }\n   * </code>\n   * </div>\n   */\n  textToContours(str, x = 0, y = 0, width, height, options) {\n    ({\n      width,\n      height,\n      options\n    } = this._parseArgs(width, height, options));\n    const cmds = this.textToPaths(str, x, y, width, height, options);\n    const cmdContours = [];\n    for (const cmd of cmds) {\n      if (cmd[0] === 'M') {\n        cmdContours.push([]);\n      }\n      cmdContours[cmdContours.length - 1].push(cmd);\n    }\n    return cmdContours.map(commands => pathToPoints(commands, options, this));\n  }\n  /**\n      *\n      * Converts text into a 3D model that can be rendered in WebGL mode.\n      *\n      * This method transforms flat text into extruded 3D geometry, allowing\n      * for dynamic effects like depth, warping, and custom shading.\n      *\n      * It works by taking the outlines (contours) of each character in the\n      * provided text string and constructing a 3D shape from them.\n      *\n      * Once your 3D text is ready, you can rotate it in 3D space using <a href=\"#/p5/orbitControl\">orbitControl()</a>\n      * — just click and drag with your mouse to see it from all angles!\n      *\n      * Use the extrude slider to give your letters depth: slide it up, and your\n      * flat text turns into a solid, multi-dimensional object.\n      *\n      * You can also choose from various fonts such as \"Anton\", \"Montserrat\", or \"Source Serif\",\n      * much like selecting fancy fonts in a word processor,\n      *\n      * The generated model (a Geometry object) can be manipulated further—rotated, scaled,\n      * or styled with shaders—to create engaging, interactive visual art.\n      *\n      * @param {String} str The text string to convert into a 3D model.\n      * @param {Number} x The x-coordinate for the starting position of the text.\n      * @param {Number} y The y-coordinate for the starting position of the text.\n      * @param {Number} width Maximum width of the text block (wraps text if exceeded).\n      * @param {Number} height Maximum height of the text block.\n      * @param {Object} [options] Configuration options for the 3D text:\n      * @param {Number} [options.extrude=0] The depth to extrude the text. A value of 0 produces\n      * flat text; higher values create thicker, 3D models.\n      * @param {Number} [options.sampleFactor=1] A factor controlling the level of detail for the text contours.\n      *  Higher values result in smoother curves.\n      * @return {p5.Geometry} A geometry object representing the 3D model of the text.\n      *\n      * @example\n      * <div modernizr='webgl'>\n      * <code>\n      * let font;\n      * let geom;\n      *\n      * async function setup() {\n      *   createCanvas(200, 200, WEBGL);\n      *   font = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');\n      *\n      *   geom = font.textToModel(\"Hello\", 50, 0, { sampleFactor: 2 });\n      *   geom.clearColors();\n      *   geom.normalize();\n      * }\n      *\n      * function draw() {\n      *   background(255);\n      *   orbitControl();\n      *   fill(\"red\");\n      *   strokeWeight(4);\n      *   scale(min(width, height) / 300);\n      *   model(geom);\n      *   describe('A red non-extruded \"Hello\" in Anton on white canvas, rotatable via mouse.');\n      * }\n      * </code>\n      * </div>\n      *\n      * @example\n      * <div modernizr='webgl'>\n      * <code>\n      * let font;\n      * let geom;\n      *\n      * async function setup() {\n      *   createCanvas(200, 200, WEBGL);\n      *\n      *   // Alternative fonts:\n      *   // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'\n      *   // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'\n      *   // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'\n      *\n      *   // Using Source Serif for this example:\n      *   font = await loadFont('https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf');\n      *\n      *   geom = font.textToModel(\"Hello\", 50, 0, { sampleFactor: 2, extrude: 5 });\n      *   geom.clearColors();\n      *   geom.normalize();\n      * }\n      *\n      * function draw() {\n      *   background(255);\n      *   orbitControl();\n      *   fill(\"red\");\n      *   strokeWeight(4);\n      *   scale(min(width, height) / 300);\n      *   model(geom);\n      *   describe('3D red extruded \"Hello\" in Source Serif on white, rotatable via mouse.');\n      * }\n      * </code>\n      * </div>\n      *\n      * @example\n      * <div modernizr='webgl'>\n      * <code>\n      * let geom;\n      * let activeFont;\n      * let artShader;\n      * let lineShader;\n      *\n      * // Define parameters as simple variables\n      * let words = 'HELLO';\n      * let warp = 1;\n      * let extrude = 5;\n      * let palette = [\"#ffe03d\", \"#fe4830\", \"#d33033\", \"#6d358a\", \"#1c509e\", \"#00953c\"];\n      *\n      * async function setup() {\n      *   createCanvas(200, 200, WEBGL);\n      *\n      *   // Using Anton as the default font for this example:\n      *\n      *  // Alternative fonts:\n      *  // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'\n      *  // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'\n      *  // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'\n      *   activeFont = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');\n      *\n      *   geom = activeFont.textToModel(words, 0, 50, { sampleFactor: 2, extrude });\n      *   geom.clearColors();\n      *   geom.normalize();\n      *\n      *   artShader = baseMaterialShader().modify({\n      *     uniforms: {\n      *       'float time': () => millis(),\n      *       'float warp': () => warp,\n      *       'float numColors': () => palette.length,\n      *       'vec3[6] colors': () => palette.flatMap((c) => [red(c)/255, green(c)/255, blue(c)/255]),\n      *     },\n      *     vertexDeclarations: 'out vec3 vPos;',\n      *     fragmentDeclarations: 'in vec3 vPos;',\n      *     'Vertex getObjectInputs': `(Vertex inputs) {\n      *       vPos = inputs.position;\n      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);\n      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);\n      *       return inputs;\n      *     }`,\n      *     'vec4 getFinalColor': `(vec4 _c) {\n      *       float x = vPos.x * 0.005;\n      *       float a = floor(fract(x) * numColors);\n      *       float b = a == numColors - 1. ? 0. : a + 1.;\n      *       float t = fract(x * numColors);\n      *       vec3 c = mix(colors[int(a)], colors[int(b)], t);\n      *       return vec4(c, 1.);\n      *     }`\n      *   });\n      *\n      *   lineShader = baseStrokeShader().modify({\n      *     uniforms: {\n      *       'float time': () => millis(),\n      *       'float warp': () => warp,\n      *     },\n      *     'StrokeVertex getObjectInputs': `(StrokeVertex inputs) {\n      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);\n      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);\n      *       return inputs;\n      *     }`,\n      *   });\n      * }\n      *\n      * function draw() {\n      *   background(255);\n      *   orbitControl();\n      *   shader(artShader);\n      *   strokeShader(lineShader);\n      *   strokeWeight(4);\n      *   scale(min(width, height) / 210);\n      *   model(geom);\n      *   describe('3D wavy with different color sets \"Hello\" in Anton on white canvas, rotatable via mouse.');\n      * }\n      * </code>\n      * </div>\n      */\n  textToModel(str, x, y, width, height, options) {\n    ({\n      width,\n      height,\n      options\n    } = this._parseArgs(width, height, options));\n    const extrude = options?.extrude || 0;\n    const contours = this.textToContours(str, x, y, width, height, options);\n    const geom = this._pInst.buildGeometry(() => {\n      if (extrude === 0) {\n        this._pInst.beginShape();\n        this._pInst.normal(0, 0, 1);\n        for (const contour of contours) {\n          this._pInst.beginContour();\n          for (const {\n            x,\n            y\n          } of contour) {\n            this._pInst.vertex(x, y);\n          }\n          this._pInst.endContour(this._pInst.CLOSE);\n        }\n        this._pInst.endShape();\n      } else {\n        // Draw front faces\n        for (const side of [1, -1]) {\n          this._pInst.beginShape();\n          for (const contour of contours) {\n            this._pInst.beginContour();\n            for (const {\n              x,\n              y\n            } of contour) {\n              this._pInst.vertex(x, y, side * extrude * 0.5);\n            }\n            this._pInst.endContour(this._pInst.CLOSE);\n          }\n          this._pInst.endShape();\n          this._pInst.beginShape();\n        }\n        // Draw sides\n        for (const contour of contours) {\n          this._pInst.beginShape(this._pInst.QUAD_STRIP);\n          for (const v of contour) {\n            for (const side of [-1, 1]) {\n              this._pInst.vertex(v.x, v.y, side * extrude * 0.5);\n            }\n          }\n          this._pInst.endShape();\n        }\n      }\n    });\n    if (extrude !== 0) {\n      geom.computeNormals();\n      for (const face of geom.faces) {\n        if (face.every(idx => geom.vertices[idx].z <= -extrude * 0.5 + 0.1)) {\n          for (const idx of face) geom.vertexNormals[idx].set(0, 0, -1);\n          face.reverse();\n        }\n      }\n    }\n    return geom;\n  }\n  variations() {\n    let vars = {};\n    if (this.data) {\n      let axes = this.face?.axes;\n      if (axes) {\n        axes.forEach(ax => {\n          vars[ax.tag] = ax.value;\n        });\n      }\n    }\n    fontFaceVariations.forEach(v => {\n      let val = this.face[v];\n      if (val !== 'normal') {\n        vars[v] = vars[v] || val;\n      }\n    });\n    return vars;\n  }\n  metadata() {\n    let meta = this.data?.name || {};\n    for (let p in this.face) {\n      if (!/^load/.test(p)) {\n        meta[p] = meta[p] || this.face[p];\n      }\n    }\n    return meta;\n  }\n  static async list(log = false) {\n    // tmp\n    if (log) {\n      console.log('There are', document.fonts.size, 'font-faces\\n');\n      let loaded = 0;\n      for (let fontFace of document.fonts.values()) {\n        console.log('FontFace: {');\n        for (let property in fontFace) {\n          console.log('  ' + property + ': ' + fontFace[property]);\n        }\n        console.log('}\\n');\n        if (fontFace.status === 'loaded') {\n          loaded++;\n        }\n      }\n      console.log(loaded + ' loaded');\n    }\n    return await Array.from(document.fonts);\n  }\n\n  /////////////////////////////// HELPERS ////////////////////////////////\n\n  _verticalAlign(size) {\n    const {\n      sCapHeight\n    } = this.data?.['OS/2'] || {};\n    const {\n      unitsPerEm = 1000\n    } = this.data?.head || {};\n    const {\n      ascender = 0,\n      descender = 0\n    } = this.data?.hhea || {};\n    const current = ascender / 2;\n    const target = (sCapHeight || ascender + descender) / 2;\n    const offset = target - current;\n    return offset * size / unitsPerEm;\n  }\n\n  /*\n    Returns an array of line objects, each containing { text, x, y, glyphs: [ {g, path} ] }\n  */\n  _lineateAndPathify(str, x, y, width, height, options = {}) {\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n\n    // save the baseline\n    let setBaseline = renderer.drawingContext.textBaseline;\n\n    // lineate and compute bounds for the text\n    let {\n      lines,\n      bounds\n    } = renderer._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height, {\n      ignoreRectMode: true,\n      ...options\n    });\n\n    // compute positions for each of the lines\n    lines = this._position(renderer, lines, bounds, width, height);\n\n    // convert lines to paths\n    let uPE = this.data?.head?.unitsPerEm || 1000;\n    let scale = renderer.states.textSize / uPE;\n    const axs = this._currentAxes(renderer);\n    let pathsForLine = lines.map(l => this._lineToGlyphs(l, {\n      scale,\n      axs\n    }));\n\n    // restore the baseline\n    renderer.drawingContext.textBaseline = setBaseline;\n    return pathsForLine;\n  }\n  _currentAxes(renderer) {\n    let axs;\n    if ((this.data?.fvar?.length ?? 0) > 0) {\n      const fontAxes = this.data.fvar[0];\n      axs = fontAxes.map(([tag, minVal, defaultVal, maxVal, flags, name]) => {\n        if (!renderer) return defaultVal;\n        if (tag === 'wght') {\n          return renderer.states.fontWeight;\n        } else if (tag === 'wdth') {\n          // TODO: map from keywords (normal, ultra-condensed, etc) to values\n          // return renderer.states.fontStretch\n          return 100;\n        } else if (renderer.textCanvas().style.fontVariationSettings) {\n          const match = new RegExp(`\\\\b${tag}\\s+(\\d+)`).exec(renderer.textCanvas().style.fontVariationSettings);\n          if (match) {\n            return parseInt(match[1]);\n          } else {\n            return defaultVal;\n          }\n        } else {\n          return defaultVal;\n        }\n      });\n    }\n    return axs;\n  }\n  _textToPathPoints(str, x, y, width, height, options) {\n    ({\n      width,\n      height,\n      options\n    } = this._parseArgs(width, height, options));\n\n    // lineate and get the points for each line\n    let cmds = this.textToPaths(str, x, y, width, height, options);\n\n    // divide line-segments with intermediate points\n    const subdivide = (pts, pt1, pt2, md) => {\n      if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {\n        let middle = {\n          x: (pt1.x + pt2.x) / 2,\n          y: (pt1.y + pt2.y) / 2\n        };\n        pts.push(middle);\n        subdivide(pts, pt1, middle, md);\n        subdivide(pts, middle, pt2, md);\n      }\n    };\n\n    // a point for each path-command plus line subdivisions\n    let pts = [];\n    let {\n      textSize\n    } = this._pInst._renderer.states;\n    let maxDist = textSize / this.data.head.unitsPerEm * 500;\n    for (let i = 0; i < cmds.length; i++) {\n      let {\n        type,\n        data: d\n      } = cmds[i];\n      if (type !== 'Z') {\n        let pt = {\n          x: d[d.length - 2],\n          y: d[d.length - 1]\n        };\n        if (type === 'L' && pts.length && !options?.nodivide > 0) {\n          subdivide(pts, pts[pts.length - 1], pt, maxDist);\n        }\n        pts.push(pt);\n      }\n    }\n    return pts;\n  }\n  _parseArgs(width, height, options = {}) {\n    if (typeof width === 'object') {\n      options = width;\n      width = height = undefined;\n    } else if (typeof height === 'object') {\n      options = height;\n      height = undefined;\n    }\n    return {\n      width,\n      height,\n      options\n    };\n  }\n  _position(renderer, lines, bounds, width, height) {\n    let {\n      textAlign,\n      textLeading\n    } = renderer.states;\n    let metrics = this._measureTextDefault(renderer, 'X');\n    let ascent = metrics.fontBoundingBoxAscent;\n    let coordify = (text, i) => {\n      let x = bounds.x;\n      let y = bounds.y + i * textLeading + ascent;\n      let lineWidth = renderer._fontWidthSingle(text);\n      if (textAlign === CENTER) {\n        x += (bounds.w - lineWidth) / 2;\n      } else if (textAlign === RIGHT) {\n        x += bounds.w - lineWidth;\n      }\n      if (typeof width !== 'undefined') {\n        switch (renderer.states.rectMode) {\n          case CENTER:\n            x -= width / 2;\n            y -= height / 2;\n            break;\n          case RADIUS:\n            x -= width;\n            y -= height;\n            break;\n        }\n      }\n      return {\n        text,\n        x,\n        y\n      };\n    };\n    return lines.map(coordify);\n  }\n  _lineToGlyphs(line, {\n    scale = 1,\n    axs\n  } = {}) {\n    if (!this.data) {\n      throw Error('No font data available for \"' + this.name + '\"\\nTry downloading a local copy of the font file');\n    }\n    let glyphShapes = Typr.U.shape(this.data, line.text, {\n      axs\n    });\n    line.glyphShapes = glyphShapes;\n    line.glyphs = this._shapeToPaths(glyphShapes, line, {\n      scale,\n      axs\n    });\n    return line;\n  }\n  _positionGlyphs(text, options) {\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n    const axs = this._currentAxes(renderer);\n    const glyphShapes = Typr.U.shape(this.data, text, {\n      axs\n    });\n    const positionedGlyphs = [];\n    let x = 0;\n    for (const glyph of glyphShapes) {\n      positionedGlyphs.push({\n        x,\n        index: glyph.g,\n        shape: glyph\n      });\n      x += glyph.ax;\n    }\n    return positionedGlyphs;\n  }\n  _singleShapeToPath(shape, {\n    scale = 1,\n    x = 0,\n    y = 0,\n    lineX = 0,\n    lineY = 0,\n    axs\n  } = {}) {\n    let font = this.data;\n    let crdIdx = 0;\n    let {\n      g,\n      ax,\n      ay,\n      dx,\n      dy\n    } = shape;\n    let {\n      crds,\n      cmds\n    } = Typr.U.glyphToPath(font, g, true, axs);\n\n    // can get simple points for each glyph here, but we don't need them ?\n    let glyph = {\n      /*g: line.text[i], points: [],*/path: {\n        commands: []\n      }\n    };\n    for (let j = 0; j < cmds.length; j++) {\n      let type = cmds[j],\n        command = [type];\n      if (type in pathArgCounts) {\n        let argCount = pathArgCounts[type];\n        for (let k = 0; k < argCount; k += 2) {\n          let gx = crds[k + crdIdx] + x + dx;\n          let gy = crds[k + crdIdx + 1] + y + dy;\n          let fx = lineX + gx * scale;\n          let fy = lineY + gy * -scale;\n          command.push(fx);\n          command.push(fy);\n          /*if (k === argCount - 2) {\n            glyph.points.push({ x: fx, y: fy });\n          }*/\n        }\n        crdIdx += argCount;\n      }\n      glyph.path.commands.push(command);\n    }\n    return {\n      glyph,\n      ax,\n      ay\n    };\n  }\n  _shapeToPaths(glyphs, line, {\n    scale = 1,\n    axs\n  } = {}) {\n    let x = 0,\n      y = 0,\n      paths = [];\n    if (glyphs.length !== line.text.length) {\n      throw Error('Invalid shape data');\n    }\n\n    // iterate over the glyphs, converting each to a glyph object\n    // with a path property containing an array of commands\n    for (let i = 0; i < glyphs.length; i++) {\n      const {\n        glyph,\n        ax,\n        ay\n      } = this._singleShapeToPath(glyphs[i], {\n        scale,\n        x,\n        y,\n        lineX: line.x,\n        lineY: line.y,\n        axs\n      });\n      paths.push(glyph);\n      x += ax;\n      y += ay;\n    }\n    return paths;\n  }\n  _measureTextDefault(renderer, str) {\n    let {\n      textAlign,\n      textBaseline\n    } = renderer.states;\n    let ctx = renderer.textDrawingContext();\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'alphabetic';\n    let metrics = ctx.measureText(str);\n    ctx.textAlign = textAlign;\n    ctx.textBaseline = textBaseline;\n    return metrics;\n  }\n  drawPaths(ctx, commands, opts) {\n    // for debugging\n    ctx.strokeStyle = opts?.stroke || ctx.strokeStyle;\n    ctx.fillStyle = opts?.fill || ctx.fillStyle;\n    ctx.beginPath();\n    commands.forEach(([type, ...data]) => {\n      if (type === 'M') {\n        ctx.moveTo(...data);\n      } else if (type === 'L') {\n        ctx.lineTo(...data);\n      } else if (type === 'C') {\n        ctx.bezierCurveTo(...data);\n      } else if (type === 'Q') {\n        ctx.quadraticCurveTo(...data);\n      } else if (type === 'Z') {\n        ctx.closePath();\n      }\n    });\n    if (opts?.fill) ctx.fill();\n    if (opts?.stroke) ctx.stroke();\n  }\n  _pathsToCommands(paths, scale) {\n    let commands = [];\n    for (let i = 0; i < paths.length; i++) {\n      let pathData = paths[i];\n      let {\n        x,\n        y,\n        path\n      } = pathData;\n      let {\n        crds,\n        cmds\n      } = path;\n\n      // iterate over the path, storing each non-control point\n      for (let c = 0, j = 0; j < cmds.length; j++) {\n        let cmd = cmds[j],\n          obj = {\n            type: cmd,\n            data: []\n          };\n        if (cmd == \"M\" || cmd == \"L\") {\n          obj.data.push(x + crds[c] * scale, y + crds[c + 1] * -scale);\n          c += 2;\n        } else if (cmd == \"C\") {\n          for (let i = 0; i < 6; i += 2) {\n            obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);\n          }\n          c += 6;\n        } else if (cmd == \"Q\") {\n          for (let i = 0; i < 4; i += 2) {\n            obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);\n          }\n          c += 4;\n        }\n        commands.push(obj);\n      }\n    }\n    return commands;\n  }\n}\nasync function create(pInst, name, path, descriptors, rawFont) {\n  let face = createFontFace(name, path, descriptors, rawFont);\n\n  // load if we need to\n  if (face.status !== 'loaded') await face.load();\n\n  // add it to the document\n  document.fonts.add(face);\n\n  // return a new p5.Font\n  return new Font(pInst, face, name, path, rawFont);\n}\nfunction createFontFace(name, path, descriptors, rawFont) {\n  if (name.includes(' ')) name = \"'\" + name + \"'\"; // NOTE: must be single-quotes\n\n  let fontArg = rawFont?._compressedData ?? rawFont?._data;\n  if (!fontArg) {\n    if (!validFontTypesRe.test(path)) {\n      throw Error(invalidFontError);\n    }\n    if (!path.startsWith('url(')) {\n      path = 'url(' + path + ')';\n    }\n    fontArg = path;\n  }\n  if ((rawFont?.fvar?.length ?? 0) > 0) {\n    descriptors = descriptors || {};\n    for (const [tag, minVal, defaultVal, maxVal, flags, name] of rawFont.fvar[0]) {\n      if (tag === 'wght') {\n        descriptors.weight = `${minVal} ${maxVal}`;\n      } else if (tag === 'wdth') {\n        descriptors.stretch = `${minVal}% ${maxVal}%`;\n      }\n      // TODO add other descriptors\n    }\n  }\n\n  // create/return the FontFace object\n  let face = new FontFace(name, fontArg, descriptors);\n  if (face.status === 'error') {\n    throw Error('Failed to create FontFace for \"' + name + '\"');\n  }\n  return face;\n}\nfunction extractFontName(font, path) {\n  let result,\n    meta = font?.name;\n\n  // use the metadata if we have it\n  if (meta) {\n    if (meta.fullName) {\n      return meta.fullName;\n    }\n    if (meta.familyName) {\n      result = meta.familyName;\n    }\n  }\n  if (!result) {\n    // if not, try to extract the name from the path\n    let matches = extractFontNameRe.exec(path);\n    if (matches && matches.length >= 3) {\n      result = matches[1];\n    } else {\n      // give up and return the full path\n      result = path;\n    }\n  }\n\n  // replace spaces with underscores\n  if (result.includes(' ')) {\n    result = result.replace(/ /g, '_');\n  }\n  return result;\n}\nfunction pathToPoints(cmds, options, font) {\n  const parseOpts = (options, defaults) => {\n    if (typeof options !== 'object') {\n      options = defaults;\n    } else {\n      for (const key in defaults) {\n        if (typeof options[key] === 'undefined') {\n          options[key] = defaults[key];\n        }\n      }\n    }\n    return options;\n  };\n  const at = (v, i) => {\n    const s = v.length;\n    return v[i < 0 ? i % s + s : i % s];\n  };\n  const simplify = (pts, angle) => {\n    angle = angle || 0;\n    let num = 0;\n    for (let i = pts.length - 1; pts.length > 3 && i >= 0; --i) {\n      if (collinear(at(pts, i - 1), at(pts, i), at(pts, i + 1), angle)) {\n        pts.splice(i % pts.length, 1); // Remove middle point\n        num++;\n      }\n    }\n    return num;\n  };\n  const path = createFromCommands(arrayCommandsToObjects(cmds));\n  let opts = parseOpts(options, {\n    sampleFactor: 0.1,\n    simplifyThreshold: 0\n  });\n  const totalPoints = Math.max(1, Math.ceil(path.getTotalLength() * opts.sampleFactor));\n  let points = [];\n  const mode = font._pInst.angleMode();\n  const DEGREES = font._pInst.DEGREES;\n  for (let i = 0; i < totalPoints; i++) {\n    const length = path.getTotalLength() * (totalPoints === 1 ? 0 : i / (totalPoints - 1));\n    points.push({\n      ...path.getPointAtLength(length),\n      get angle() {\n        const angle = path.getAngleAtLength(length);\n        if (mode === DEGREES) {\n          return angle * 180 / Math.PI;\n        } else {\n          return angle;\n        }\n      },\n      // For backwards compatibility\n      get alpha() {\n        return this.angle;\n      }\n    });\n  }\n  if (opts.simplifyThreshold) {\n    simplify(points, opts.simplifyThreshold);\n  }\n  return points;\n}\nfunction unquote(name) {\n  // Unquote name from CSS\n  if ((name.startsWith('\"') || name.startsWith(\"'\")) && name.at(0) === name.at(-1)) {\n    return name.slice(1, -1).replace(/\\/(['\"])/g, '$1');\n  }\n  return name;\n}\nfunction parseCreateArgs(...args /*path, name, onSuccess, onError*/) {\n  // parse the path\n  let path = args.shift();\n  if (typeof path !== 'string' || path.length === 0) {\n    p5._friendlyError(invalidFontError, 'p5.loadFont'); // ?\n  }\n\n  // parse the name\n  let name;\n  if (typeof args[0] === 'string') {\n    name = args.shift();\n  }\n\n  // get the callbacks/descriptors if any\n  let success, error, options;\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (typeof arg === 'function') {\n      if (!success) {\n        success = arg;\n      } else {\n        error = arg;\n      }\n    } else if (typeof arg === 'object') {\n      options = arg;\n    }\n  }\n  return {\n    path,\n    name,\n    success,\n    error,\n    options\n  };\n}\nfunction font(p5, fn) {\n  /**\n   * A class to describe fonts. Create through <a href=\"#/p5/loadFont\">`loadFont()`</a>.\n   *\n   * @class p5.Font\n   */\n  p5.Font = Font;\n\n  /**\n   * @private\n   */\n  fn.parseFontData = async function (pathOrData) {\n    // load the raw font bytes\n    let result = pathOrData instanceof Uint8Array ? pathOrData : await fn.loadBytes(pathOrData);\n    //console.log('result:', result);\n\n    if (!result) {\n      throw Error('Failed to load font data');\n    }\n\n    // parse the font data\n    let fonts = Typr.parse(result);\n\n    // TODO: generate descriptors from font in the future\n\n    if (fonts.length === 0 || fonts[0].cmap === undefined) {\n      throw Error('parsing font data');\n    }\n    return fonts[0];\n  };\n\n  /**\n   * Loads a font and creates a <a href=\"#/p5.Font\">p5.Font</a> object.\n   * `loadFont()` can load fonts in either .otf or .ttf format. Loaded fonts can\n   * be used to style text on the canvas and in HTML elements.\n   *\n   * The first parameter, `path`, is the path to a font file.\n   * Paths to local files should be relative. For example,\n   * `'assets/inconsolata.otf'`. The Inconsolata font used in the following\n   * examples can be downloaded for free\n   * <a href=\"https://www.fontsquirrel.com/fonts/inconsolata\" target=\"_blank\">here</a>.\n   * Paths to remote files should be URLs. For example,\n   * `'https://example.com/inconsolata.otf'`. URLs may be blocked due to browser\n   * security.\n   *\n   * In 2D mode, `path` can take on a few other forms. It could be a path to a CSS file,\n   * such as one from <a href=\"https://fonts.google.com/\">Google Fonts.</a> It could also\n   * be a string with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face\">CSS `@font-face` declaration.</a>\n   *\n   * The second parameter, `successCallback`, is optional. If a function is\n   * passed, it will be called once the font has loaded. The callback function\n   * may use the new <a href=\"#/p5.Font\">p5.Font</a> object if needed.\n   *\n   * The third parameter, `failureCallback`, is also optional. If a function is\n   * passed, it will be called if the font fails to load. The callback function\n   * may use the error\n   * <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event\" target=\"_blank\">Event</a>\n   * object if needed.\n   *\n   * Fonts can take time to load. `await` the result of `loadFont()` in\n   * <a href=\"#/p5/setup\">setup()</a> before using the result.\n   *\n   * @method loadFont\n   * @for p5\n   * @param  {String}        path       path of the font or CSS file to be loaded, or a CSS `@font-face` string.\n   * @param  {String}        [name]            An alias that can be used for this font in `textFont()`. Defaults to the name in the font's metadata.\n   * @param  {Object}        [options]         An optional object with extra CSS font face descriptors, or p5.js font settings.\n   * @param  {String|Array<String>} [options.sets] (Experimental) An optional string of list of strings with Unicode character set names that should be included. When a CSS file is used as the font, it may contain multiple font files. The font best matching the requested character sets will be picked.\n   * @param  {Function}      [successCallback] function called with the\n   *                                           <a href=\"#/p5.Font\">p5.Font</a> object after it\n   *                                           loads.\n   * @param  {Function}      [failureCallback] function called with the error\n   *                                           <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event\" target=\"_blank\">Event</a>\n   *                                           object if the font fails to load.\n   * @return {Promise<p5.Font>}                         <a href=\"#/p5.Font\">p5.Font</a> object.\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont('assets/inconsolata.otf');\n   *   fill('deeppink');\n   *   textFont(font);\n   *   textSize(36);\n   *   text('p5*js', 10, 50);\n   *\n   *   describe('The text \"p5*js\" written in pink on a white background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   loadFont('assets/inconsolata.otf', font => {\n   *     fill('deeppink');\n   *     textFont(font);\n   *     textSize(36);\n   *     text('p5*js', 10, 50);\n   *\n   *     describe('The text \"p5*js\" written in pink on a white background.');\n   *   });\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   loadFont('assets/inconsolata.otf', success, failure);\n   * }\n   *\n   * function success(font) {\n   *   fill('deeppink');\n   *   textFont(font);\n   *   textSize(36);\n   *   text('p5*js', 10, 50);\n   *\n   *   describe('The text \"p5*js\" written in pink on a white background.');\n   * }\n   *\n   * function failure(event) {\n   *   console.error('Oops!', event);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   await loadFont('assets/inconsolata.otf');\n   *   let p = createP('p5*js');\n   *   p.style('color', 'deeppink');\n   *   p.style('font-family', 'Inconsolata');\n   *   p.style('font-size', '36px');\n   *   p.position(10, 50);\n   *\n   *   describe('The text \"p5*js\" written in pink on a white background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Some other forms of loading fonts:\n   * loadFont(\"https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&display=swap\");\n   * loadFont(`@font-face { font-family: \"Bricolage Grotesque\", serif; font-optical-sizing: auto; font-weight: 400; font-style: normal; font-variation-settings: \"wdth\" 100; }`);\n   * </code>\n   * </div>\n   */\n  /**\n    * @method loadFont\n    * @for p5\n    * @param  {String}        path              path of the font to be loaded.\n    * @param  {Function}      [successCallback] function called with the\n    *                                           <a href=\"#/p5.Font\">p5.Font</a> object after it\n    *                                           loads.\n    * @param  {Function}      [failureCallback] function called with the error\n    *                                           <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event\" target=\"_blank\">Event</a>\n    *                                           object if the font fails to load.\n    * @returns {Promise<p5.Font>} The font.\n    */\n  fn.loadFont = async function (...args /*path, name, onSuccess, onError, descriptors*/) {\n    let {\n      path,\n      name,\n      success,\n      error,\n      options: {\n        sets,\n        ...descriptors\n      } = {}\n    } = parseCreateArgs(...args);\n    let isCSS = path.includes('@font-face');\n    if (!isCSS) {\n      const info = await fetch(path, {\n        method: 'HEAD'\n      });\n      const isCSSFile = info.headers.get('content-type')?.startsWith('text/css');\n      if (isCSSFile) {\n        isCSS = true;\n        path = await fetch(path).then(res => res.text());\n      }\n    }\n    if (isCSS) {\n      const stylesheet = new CSSStyleSheet();\n      await stylesheet.replace(path);\n      const possibleFonts = [];\n      for (const rule of stylesheet.cssRules) {\n        if (rule instanceof CSSFontFaceRule) {\n          const style = rule.style;\n          let name = unquote(style.getPropertyValue('font-family'));\n          const src = style.getPropertyValue('src');\n          const fontDescriptors = {\n            ...(descriptors || {})\n          };\n          for (const key of style) {\n            if (key === 'font-family' || key === 'src') continue;\n            const camelCaseKey = key.replace(/^font-/, '').split('-').map((v, i) => i === 0 ? v : `${v[0].toUpperCase()}${v.slice(1)}`).join('');\n            fontDescriptors[camelCaseKey] = style.getPropertyValue(key);\n          }\n          possibleFonts.push({\n            name,\n            src,\n            fontDescriptors,\n            loadWithData: async () => {\n              let fontData;\n              try {\n                const urlMatch = /url\\(([^\\)]+)\\)/.exec(src);\n                if (urlMatch) {\n                  let url = urlMatch[1];\n                  if (/^['\"]/.exec(url) && url.at(0) === url.at(-1)) {\n                    url = url.slice(1, -1);\n                  }\n                  fontData = await fn.parseFontData(url);\n                }\n              } catch (_e) {}\n              return create(this, name, src, fontDescriptors, fontData);\n            },\n            loadWithoutData: () => create(this, name, src, fontDescriptors)\n          });\n        }\n      }\n\n      // TODO: handle multiple font faces?\n      sets = sets || ['latin']; // Default to latin for now if omitted\n      const requestedGroups = (sets instanceof Array ? sets : [sets]).map(s => s.toLowerCase());\n      // Grab thr named groups with names that include the requested keywords\n      const requestedCategories = unicodeRanges.filter(r => requestedGroups.some(g => r.category.includes(g) &&\n      // Only include extended character sets if specifically requested\n      r.category.includes('ext') === g.includes('ext')));\n      const requestedRanges = new Set(UnicodeRange.parse(requestedCategories.map(c => `U+${c.hexrange[0]}-${c.hexrange[1]}`)));\n      let closestRangeOverlap = 0;\n      let closestDescriptorOverlap = 0;\n      let closestMatch = undefined;\n      for (const font of possibleFonts) {\n        if (!font.fontDescriptors.unicodeRange) continue;\n        const fontRange = new Set(UnicodeRange.parse(font.fontDescriptors.unicodeRange.split(/,\\s*/g)));\n        const rangeOverlap = [...fontRange.values()].filter(v => requestedRanges.has(v)).length;\n        const targetDescriptors = {\n          // Default to normal style at regular weight\n          style: 'normal',\n          weight: 400,\n          // Override from anything else passed in\n          ...descriptors\n        };\n        const descriptorOverlap = Object.keys(font.fontDescriptors).filter(k => font.fontDescriptors[k] === targetDescriptors[k]).length;\n        if (descriptorOverlap > closestDescriptorOverlap || descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap) {\n          closestDescriptorOverlap = descriptorOverlap;\n          closestRangeOverlap = rangeOverlap;\n          closestMatch = font;\n        }\n      }\n      const picked = closestMatch || possibleFonts.at(-1);\n      for (const font of possibleFonts) {\n        if (font !== picked) {\n          // Load without parsing data with Typr so that it still can be accessed\n          // via regular CSS by name\n          font.loadWithoutData();\n        }\n      }\n      return picked?.loadWithData();\n    }\n    let pfont;\n    try {\n      const fontData = await fn.parseFontData(path);\n\n      // make sure we have a valid name\n      name = name || extractFontName(fontData, path);\n\n      // create a FontFace object and pass it to the p5.Font constructor\n      pfont = await create(this, name, path, descriptors, fontData);\n    } catch (err) {\n      // failed to parse the font, load it as a simple FontFace\n      let ident = name || path.substring(path.lastIndexOf('/') + 1).replace(/\\.[^/.]+$/, \"\");\n      console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);\n      try {\n        // create a FontFace object and pass it to p5.Font\n        pfont = await create(this, ident, path, descriptors);\n      } catch (err) {\n        if (error) return error(err);\n        throw err;\n      }\n    }\n    if (success) return success(pfont);\n    return pfont;\n  };\n}\n// Convert arrays to named objects\nconst arrayCommandsToObjects = commands => commands.map(command => {\n  const type = command[0];\n  switch (type) {\n    case 'Z':\n      {\n        return {\n          type\n        };\n      }\n    case 'M':\n    case 'L':\n      {\n        const [, x, y] = command;\n        return {\n          type,\n          x,\n          y\n        };\n      }\n    case 'Q':\n      {\n        const [, x1, y1, x, y] = command;\n        return {\n          type,\n          x1,\n          y1,\n          x,\n          y\n        };\n      }\n    case 'C':\n      {\n        const [, x1, y1, x2, y2, x, y] = command;\n        return {\n          type,\n          x1,\n          y1,\n          x2,\n          y2,\n          x,\n          y\n        };\n      }\n    default:\n      {\n        throw new Error(`Unexpected path command: ${type}`);\n      }\n  }\n});\nif (typeof p5 !== 'undefined') {\n  font(p5, p5.prototype);\n}\nexport { Font, arrayCommandsToObjects, font as default };","map":{"version":3,"names":["textCoreConstants","C","CENTER","R","RIGHT","a","RADIUS","UnicodeRange","unicodeRanges","Typr","createFromCommands","pathArgCounts","M","L","Q","validFontTypes","validFontTypesRe","RegExp","join","extractFontNameRe","invalidFontError","fontFaceVariations","Font","constructor","p","fontFace","name","path","data","FontFace","Error","_pInst","face","hasGlyphData","textFont","font","fontBounds","str","x","y","width","height","options","_parseArgs","renderer","graphics","_renderer","textBounds","textToPaths","lines","_lineateAndPathify","glyphs","map","o","flat","g","commands","textToPoints","contourPoints","textToContours","reduce","acc","next","push","cmds","cmdContours","cmd","length","pathToPoints","textToModel","extrude","contours","geom","buildGeometry","beginShape","normal","contour","beginContour","vertex","endContour","CLOSE","endShape","side","QUAD_STRIP","v","computeNormals","faces","every","idx","vertices","z","vertexNormals","set","reverse","variations","vars","axes","forEach","ax","tag","value","val","metadata","meta","test","list","log","console","document","fonts","size","loaded","values","property","status","Array","from","_verticalAlign","sCapHeight","unitsPerEm","head","ascender","descender","hhea","current","target","offset","setBaseline","drawingContext","textBaseline","bounds","_computeBounds","_FONT_BOUNDS","ignoreRectMode","_position","uPE","scale","states","textSize","axs","_currentAxes","pathsForLine","l","_lineToGlyphs","fvar","fontAxes","minVal","defaultVal","maxVal","flags","fontWeight","textCanvas","style","fontVariationSettings","match","exec","parseInt","_textToPathPoints","subdivide","pts","pt1","pt2","md","fn","dist","middle","maxDist","i","type","d","pt","nodivide","undefined","textAlign","textLeading","metrics","_measureTextDefault","ascent","fontBoundingBoxAscent","coordify","text","lineWidth","_fontWidthSingle","w","rectMode","line","glyphShapes","U","shape","_shapeToPaths","_positionGlyphs","positionedGlyphs","glyph","index","_singleShapeToPath","lineX","lineY","crdIdx","ay","dx","dy","crds","glyphToPath","j","command","argCount","k","gx","gy","fx","fy","paths","ctx","textDrawingContext","measureText","drawPaths","opts","strokeStyle","stroke","fillStyle","fill","beginPath","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","closePath","_pathsToCommands","pathData","c","obj","create","pInst","descriptors","rawFont","createFontFace","load","add","includes","fontArg","_compressedData","_data","startsWith","weight","stretch","extractFontName","result","fullName","familyName","matches","replace","parseOpts","defaults","key","at","s","simplify","angle","num","collinear","splice","arrayCommandsToObjects","sampleFactor","simplifyThreshold","totalPoints","Math","max","ceil","getTotalLength","points","mode","angleMode","DEGREES","getPointAtLength","getAngleAtLength","PI","alpha","unquote","slice","parseCreateArgs","args","shift","p5","_friendlyError","success","error","arg","parseFontData","pathOrData","Uint8Array","loadBytes","parse","cmap","loadFont","sets","isCSS","info","fetch","method","isCSSFile","headers","get","then","res","stylesheet","CSSStyleSheet","possibleFonts","rule","cssRules","CSSFontFaceRule","getPropertyValue","src","fontDescriptors","camelCaseKey","split","toUpperCase","loadWithData","fontData","urlMatch","url","_e","loadWithoutData","requestedGroups","toLowerCase","requestedCategories","filter","r","some","category","requestedRanges","Set","hexrange","closestRangeOverlap","closestDescriptorOverlap","closestMatch","unicodeRange","fontRange","rangeOverlap","has","targetDescriptors","descriptorOverlap","Object","keys","picked","pfont","err","ident","substring","lastIndexOf","warn","x1","y1","x2","y2","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/type/p5.Font.js"],"sourcesContent":["import { textCoreConstants } from './textCore.js';\nimport { C as CENTER, R as RIGHT, a as RADIUS } from '../constants-BRcElHU3.js';\nimport { UnicodeRange } from '@japont/unicode-range';\nimport { unicodeRanges } from './unicodeRanges.js';\nimport Typr from './lib/Typr.js';\nimport { createFromCommands } from '@davepagurek/bezier-path';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../image/filters.js';\nimport '../math/p5.Vector.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport 'pako';\n\n/**\n * @module Typography\n */\n\n\nconst pathArgCounts = { M: 2, L: 2, C: 6, Q: 4 };\nconst validFontTypes = ['ttf', 'otf', 'woff'];//, 'woff2'];\nconst validFontTypesRe = new RegExp(`\\\\.(${validFontTypes.join('|')})`, 'i');\nconst extractFontNameRe = new RegExp(`([^/]+)(\\\\.(?:${validFontTypes.join('|')}))`, 'i');\nconst invalidFontError = 'Sorry, only TTF, OTF and WOFF files are supported.'; // and WOFF2\nconst fontFaceVariations = ['weight', 'stretch', 'style'];\n\n\nclass Font {\n  constructor(p, fontFace, name, path, data) {\n    if (!(fontFace instanceof FontFace)) {\n      throw Error('FontFace is required');\n    }\n    this._pInst = p;\n    this.name = name;\n    this.path = path;\n    this.data = data;\n    this.face = fontFace;\n  }\n\n  /**\n   * Checks whether a font has glyph point data and\n   * can thus be used for textToPoints(), WEBGL mode, etc.\n   * @private\n   */\n  static hasGlyphData(textFont) {\n    let { font } = textFont;\n    return typeof font === 'object' && typeof font.data !== 'undefined';\n  }\n\n  fontBounds(str, x, y, width, height, options) {\n    ({ width, height, options } = this._parseArgs(width, height, options));\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n    if (!renderer) throw Error('p5 or graphics required for fontBounds()');\n    return renderer.fontBounds(str, x, y, width, height);\n  }\n\n  textBounds(str, x, y, width, height, options) {\n    ({ width, height, options } = this._parseArgs(width, height, options));\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n    if (!renderer) throw Error('p5 or graphics required for fontBounds()');\n    return renderer.textBounds(str, x, y, width, height);\n  }\n\n  /**\n   * Returns a flat array of path commands that describe the outlines of a string of text.\n   *\n   * Each command is represented as an array of the form `[type, ...coords]`, where:\n   * - `type` is one of `'M'`, `'L'`, `'Q'`, `'C'`, or `'Z'`,\n   * - `coords` are the numeric values needed for that command.\n   *\n   * `'M'` indicates a \"move to\" (starting a new contour),\n   * `'L'` a line segment,\n   * `'Q'` a quadratic bezier,\n   * `'C'` a cubic bezier, and\n   * `'Z'` closes the current path.\n   *\n   * The first two parameters, `x` and `y`, specify the baseline origin for the text.\n   * Optionally, you can provide a `width` and `height` for text wrapping; if you don't need\n   * wrapping, you can omit them and directly pass `options` as the fourth parameter.\n   *\n   * @param  {String} str            The text to convert into path commands.\n   * @param  {Number} x              x‐coordinate of the text baseline.\n   * @param  {Number} y              y‐coordinate of the text baseline.\n   * @param  {Number} [width]        Optional width for text wrapping.\n   * @param  {Number} [height]       Optional height for text wrapping.\n   * @param  {Object} [options]      Configuration object for rendering text.\n   * @return {Array<Array>}          A flat array of path commands.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   font = await loadFont('assets/inconsolata.otf');\n   *   createCanvas(200, 200);\n   *   background(220);\n   *   noLoop();\n   * }\n   *\n   * function draw() {\n   *   background(220);\n   *   stroke(0);\n   *   noFill();\n   *   textSize(60);\n   *\n   *   // Get path commands for \"Hello\" (drawn at baseline x=50, y=100):\n   *   const pathCommands = font.textToPaths('Hello', 30, 110);\n   *\n   *   beginShape();\n   *   for (let i = 0; i < pathCommands.length; i++) {\n   *     const cmd = pathCommands[i];\n   *     const type = cmd[0];\n   *\n   *     switch (type) {\n   *       case 'M': {\n   *         // Move to (start a new contour)\n   *         const x = cmd[1];\n   *         const y = cmd[2];\n   *         endContour(); // In case we were already drawing\n   *         beginContour();\n   *         vertex(x, y);\n   *         break;\n   *       }\n   *       case 'L': {\n   *         // Line to\n   *         const x = cmd[1];\n   *         const y = cmd[2];\n   *         vertex(x, y);\n   *         break;\n   *       }\n   *       case 'Q': {\n   *         // Quadratic bezier\n   *         const cx = cmd[1];\n   *         const cy = cmd[2];\n   *         const x = cmd[3];\n   *         const y = cmd[4];\n   *         bezierOrder(2);\n   *         bezierVertex(cx, cy);\n   *         bezierVertex(x, y);\n   *         break;\n   *       }\n   *       case 'C': {\n   *         // Cubic bezier\n   *         const cx1 = cmd[1];\n   *         const cy1 = cmd[2];\n   *         const cx2 = cmd[3];\n   *         const cy2 = cmd[4];\n   *         const x = cmd[5];\n   *         const y = cmd[6];\n   *         bezierOrder(3);\n   *         bezierVertex(cx1, cy1);\n   *         bezierVertex(cx2, cy2);\n   *         bezierVertex(x, y);\n   *         break;\n   *       }\n   *       case 'Z': {\n   *         // Close path\n   *         endContour(CLOSE);\n   *         beginContour();\n   *         break;\n   *       }\n   *     }\n   *   }\n   *   endContour();\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  textToPaths(str, x, y, width, height, options) {\n\n    ({ width, height, options } = this._parseArgs(width, height, options));\n\n    if (!this.data) {\n      throw Error('No font data available for \"' + this.name\n        + '\"\\nTry downloading a local copy of the font file');\n    }\n\n    // lineate and get glyphs/paths for each line\n    let lines = this._lineateAndPathify(str, x, y, width, height, options);\n\n    // flatten into a single array containing all the glyphs\n    let glyphs = lines.map(o => o.glyphs).flat();\n\n    // flatten into a single array with all the path commands\n    return glyphs.map(g => g.path.commands).flat();\n  }\n\n  /**\n   * Returns an array of points outlining a string of text written using the\n   * font.\n   *\n   * Each point object in the array has three properties that describe the\n   * point's location and orientation, called its path angle. For example,\n   * `{ x: 10, y: 20, alpha: 450 }`.\n   *\n   * The first parameter, `str`, is a string of text. The second and third\n   * parameters, `x` and `y`, are the text's position. By default, they set the\n   * coordinates of the bounding box's bottom-left corner. See\n   * <a href=\"#/p5/textAlign\">textAlign()</a> for more ways to align text.\n   *\n   * The fourth parameter, `options`, is also optional. `font.textToPoints()`\n   * expects an object with the following properties:\n   *\n   * `sampleFactor` is the ratio of the text's path length to the number of\n   * samples. It defaults to 0.1. Higher values produce more points along the\n   * path and are more precise.\n   *\n   * `simplifyThreshold` removes collinear points if it's set to a number other\n   * than 0. The value represents the threshold angle to use when determining\n   * whether two edges are collinear.\n   *\n   * @param  {String} str        string of text.\n   * @param  {Number} x          x-coordinate of the text.\n   * @param  {Number} y          y-coordinate of the text.\n   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold\n   *                             properties.\n   * @return {Array<Object>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont('assets/inconsolata.otf');\n   *\n   *   background(200);\n   *   textSize(35);\n   *\n   *   // Get the point array.\n   *   let points = font.textToPoints('p5*js', 6, 60, { sampleFactor: 0.5 });\n   *\n   *   // Draw a dot at each point.\n   *   for (let p of points) {\n   *     point(p.x, p.y);\n   *   }\n   *\n   *   describe('A set of black dots outlining the text \"p5*js\" on a gray background.');\n   * }\n   * </code>\n   * </div>\n   */\n  textToPoints(str, x, y, width, height, options) {\n    // By segmenting per contour, pointAtLength becomes much faster\n    const contourPoints = this.textToContours(str, x, y, width, height, options);\n    return contourPoints.reduce((acc, next) => {\n      acc.push(...next);\n      return acc;\n    }, []);\n  }\n\n  /**\n   * Returns an array of arrays of points outlining a string of text written using the\n   * font. Each array represents a contour, so the letter O will have two outer arrays:\n   * one for the outer edge of the shape, and one for the inner edge of the hole.\n   *\n   * Each point object in a contour array has three properties that describe the\n   * point's location and orientation, called its path angle. For example,\n   * `{ x: 10, y: 20, alpha: 450 }`.\n   *\n   * The first parameter, `str`, is a string of text. The second and third\n   * parameters, `x` and `y`, are the text's position. By default, they set the\n   * coordinates of the bounding box's bottom-left corner. See\n   * <a href=\"#/p5/textAlign\">textAlign()</a> for more ways to align text.\n   *\n   * The fourth parameter, `options`, is also optional. `font.textToPoints()`\n   * expects an object with the following properties:\n   *\n   * `sampleFactor` is the ratio of the text's path length to the number of\n   * samples. It defaults to 0.1. Higher values produce more points along the\n   * path and are more precise.\n   *\n   * `simplifyThreshold` removes collinear points if it's set to a number other\n   * than 0. The value represents the threshold angle to use when determining\n   * whether two edges are collinear.\n   *\n   * @param  {String} str        string of text.\n   * @param  {Number} x          x-coordinate of the text.\n   * @param  {Number} y          y-coordinate of the text.\n   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold\n   *                             properties.\n   * @return {Array<Array<Object>>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont('/assets/inconsolata.otf');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   textAlign(CENTER, CENTER);\n   *   textSize(30);\n   *\n   *   // Get the point array.\n   *   let contours = font.textToContours('p5*js', width/2, height/2, { sampleFactor: 0.5 });\n   *\n   *   beginShape();\n   *   for (const pts of contours) {\n   *     beginContour();\n   *     for (const pt of pts) {\n   *       vertex(pt.x + 5*sin(pt.y*0.1 + millis()*0.01), pt.y);\n   *     }\n   *     endContour(CLOSE);\n   *   }\n   *   endShape();\n   *\n   *   describe('The text p5*js wobbling over time');\n   * }\n   * </code>\n   * </div>\n   */\n  textToContours(str, x = 0, y = 0, width, height, options) {\n    ({ width, height, options } = this._parseArgs(width, height, options));\n\n    const cmds = this.textToPaths(str, x, y, width, height, options);\n    const cmdContours = [];\n    for (const cmd of cmds) {\n      if (cmd[0] === 'M') {\n        cmdContours.push([]);\n      }\n      cmdContours[cmdContours.length - 1].push(cmd);\n    }\n\n    return cmdContours.map((commands) => pathToPoints(commands, options, this));\n  }\n  /**\n      *\n      * Converts text into a 3D model that can be rendered in WebGL mode.\n      *\n      * This method transforms flat text into extruded 3D geometry, allowing\n      * for dynamic effects like depth, warping, and custom shading.\n      *\n      * It works by taking the outlines (contours) of each character in the\n      * provided text string and constructing a 3D shape from them.\n      *\n      * Once your 3D text is ready, you can rotate it in 3D space using <a href=\"#/p5/orbitControl\">orbitControl()</a>\n      * — just click and drag with your mouse to see it from all angles!\n      *\n      * Use the extrude slider to give your letters depth: slide it up, and your\n      * flat text turns into a solid, multi-dimensional object.\n      *\n      * You can also choose from various fonts such as \"Anton\", \"Montserrat\", or \"Source Serif\",\n      * much like selecting fancy fonts in a word processor,\n      *\n      * The generated model (a Geometry object) can be manipulated further—rotated, scaled,\n      * or styled with shaders—to create engaging, interactive visual art.\n      *\n      * @param {String} str The text string to convert into a 3D model.\n      * @param {Number} x The x-coordinate for the starting position of the text.\n      * @param {Number} y The y-coordinate for the starting position of the text.\n      * @param {Number} width Maximum width of the text block (wraps text if exceeded).\n      * @param {Number} height Maximum height of the text block.\n      * @param {Object} [options] Configuration options for the 3D text:\n      * @param {Number} [options.extrude=0] The depth to extrude the text. A value of 0 produces\n      * flat text; higher values create thicker, 3D models.\n      * @param {Number} [options.sampleFactor=1] A factor controlling the level of detail for the text contours.\n      *  Higher values result in smoother curves.\n      * @return {p5.Geometry} A geometry object representing the 3D model of the text.\n      *\n      * @example\n      * <div modernizr='webgl'>\n      * <code>\n      * let font;\n      * let geom;\n      *\n      * async function setup() {\n      *   createCanvas(200, 200, WEBGL);\n      *   font = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');\n      *\n      *   geom = font.textToModel(\"Hello\", 50, 0, { sampleFactor: 2 });\n      *   geom.clearColors();\n      *   geom.normalize();\n      * }\n      *\n      * function draw() {\n      *   background(255);\n      *   orbitControl();\n      *   fill(\"red\");\n      *   strokeWeight(4);\n      *   scale(min(width, height) / 300);\n      *   model(geom);\n      *   describe('A red non-extruded \"Hello\" in Anton on white canvas, rotatable via mouse.');\n      * }\n      * </code>\n      * </div>\n      *\n      * @example\n      * <div modernizr='webgl'>\n      * <code>\n      * let font;\n      * let geom;\n      *\n      * async function setup() {\n      *   createCanvas(200, 200, WEBGL);\n      *\n      *   // Alternative fonts:\n      *   // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'\n      *   // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'\n      *   // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'\n      *\n      *   // Using Source Serif for this example:\n      *   font = await loadFont('https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf');\n      *\n      *   geom = font.textToModel(\"Hello\", 50, 0, { sampleFactor: 2, extrude: 5 });\n      *   geom.clearColors();\n      *   geom.normalize();\n      * }\n      *\n      * function draw() {\n      *   background(255);\n      *   orbitControl();\n      *   fill(\"red\");\n      *   strokeWeight(4);\n      *   scale(min(width, height) / 300);\n      *   model(geom);\n      *   describe('3D red extruded \"Hello\" in Source Serif on white, rotatable via mouse.');\n      * }\n      * </code>\n      * </div>\n      *\n      * @example\n      * <div modernizr='webgl'>\n      * <code>\n      * let geom;\n      * let activeFont;\n      * let artShader;\n      * let lineShader;\n      *\n      * // Define parameters as simple variables\n      * let words = 'HELLO';\n      * let warp = 1;\n      * let extrude = 5;\n      * let palette = [\"#ffe03d\", \"#fe4830\", \"#d33033\", \"#6d358a\", \"#1c509e\", \"#00953c\"];\n      *\n      * async function setup() {\n      *   createCanvas(200, 200, WEBGL);\n      *\n      *   // Using Anton as the default font for this example:\n      *\n      *  // Alternative fonts:\n      *  // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'\n      *  // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'\n      *  // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'\n      *   activeFont = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');\n      *\n      *   geom = activeFont.textToModel(words, 0, 50, { sampleFactor: 2, extrude });\n      *   geom.clearColors();\n      *   geom.normalize();\n      *\n      *   artShader = baseMaterialShader().modify({\n      *     uniforms: {\n      *       'float time': () => millis(),\n      *       'float warp': () => warp,\n      *       'float numColors': () => palette.length,\n      *       'vec3[6] colors': () => palette.flatMap((c) => [red(c)/255, green(c)/255, blue(c)/255]),\n      *     },\n      *     vertexDeclarations: 'out vec3 vPos;',\n      *     fragmentDeclarations: 'in vec3 vPos;',\n      *     'Vertex getObjectInputs': `(Vertex inputs) {\n      *       vPos = inputs.position;\n      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);\n      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);\n      *       return inputs;\n      *     }`,\n      *     'vec4 getFinalColor': `(vec4 _c) {\n      *       float x = vPos.x * 0.005;\n      *       float a = floor(fract(x) * numColors);\n      *       float b = a == numColors - 1. ? 0. : a + 1.;\n      *       float t = fract(x * numColors);\n      *       vec3 c = mix(colors[int(a)], colors[int(b)], t);\n      *       return vec4(c, 1.);\n      *     }`\n      *   });\n      *\n      *   lineShader = baseStrokeShader().modify({\n      *     uniforms: {\n      *       'float time': () => millis(),\n      *       'float warp': () => warp,\n      *     },\n      *     'StrokeVertex getObjectInputs': `(StrokeVertex inputs) {\n      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);\n      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);\n      *       return inputs;\n      *     }`,\n      *   });\n      * }\n      *\n      * function draw() {\n      *   background(255);\n      *   orbitControl();\n      *   shader(artShader);\n      *   strokeShader(lineShader);\n      *   strokeWeight(4);\n      *   scale(min(width, height) / 210);\n      *   model(geom);\n      *   describe('3D wavy with different color sets \"Hello\" in Anton on white canvas, rotatable via mouse.');\n      * }\n      * </code>\n      * </div>\n      */\n  textToModel(str, x, y, width, height, options) {\n    ({ width, height, options } = this._parseArgs(width, height, options));\n    const extrude = options?.extrude || 0;\n    const contours = this.textToContours(str, x, y, width, height, options);\n    const geom = this._pInst.buildGeometry(() => {\n      if (extrude === 0) {\n        this._pInst.beginShape();\n        this._pInst.normal(0, 0, 1);\n        for (const contour of contours) {\n          this._pInst.beginContour();\n          for (const { x, y } of contour) {\n            this._pInst.vertex(x, y);\n          }\n          this._pInst.endContour(this._pInst.CLOSE);\n        }\n        this._pInst.endShape();\n      } else {\n        // Draw front faces\n        for (const side of [1, -1]) {\n          this._pInst.beginShape();\n          for (const contour of contours) {\n            this._pInst.beginContour();\n            for (const { x, y } of contour) {\n              this._pInst.vertex(x, y, side * extrude * 0.5);\n            }\n            this._pInst.endContour(this._pInst.CLOSE);\n          }\n          this._pInst.endShape();\n          this._pInst.beginShape();\n        }\n        // Draw sides\n        for (const contour of contours) {\n          this._pInst.beginShape(this._pInst.QUAD_STRIP);\n          for (const v of contour) {\n            for (const side of [-1, 1]) {\n              this._pInst.vertex(v.x, v.y, side * extrude * 0.5);\n            }\n          }\n          this._pInst.endShape();\n        }\n      }\n    });\n    if (extrude !== 0) {\n      geom.computeNormals();\n      for (const face of geom.faces) {\n        if (face.every((idx) => geom.vertices[idx].z <= -extrude * 0.5 + 0.1)) {\n          for (const idx of face) geom.vertexNormals[idx].set(0, 0, -1);\n          face.reverse();\n        }\n      }\n    }\n    return geom;\n  }\n\n  variations() {\n    let vars = {};\n    if (this.data) {\n      let axes = this.face?.axes;\n      if (axes) {\n        axes.forEach(ax => {\n          vars[ax.tag] = ax.value;\n        });\n      }\n    }\n    fontFaceVariations.forEach(v => {\n      let val = this.face[v];\n      if (val !== 'normal') {\n        vars[v] = vars[v] || val;\n      }\n    });\n    return vars;\n  }\n\n  metadata() {\n    let meta = this.data?.name || {};\n    for (let p in this.face) {\n      if (!/^load/.test(p)) {\n        meta[p] = meta[p] || this.face[p];\n      }\n    }\n    return meta;\n  }\n\n  static async list(log = false) { // tmp\n    if (log) {\n      console.log('There are', document.fonts.size, 'font-faces\\n');\n      let loaded = 0;\n      for (let fontFace of document.fonts.values()) {\n        console.log('FontFace: {');\n        for (let property in fontFace) {\n          console.log('  ' + property + ': ' + fontFace[property]);\n        }\n        console.log('}\\n');\n        if (fontFace.status === 'loaded') {\n          loaded++;\n        }\n      }\n      console.log(loaded + ' loaded');\n    }\n    return await Array.from(document.fonts);\n  }\n\n  /////////////////////////////// HELPERS ////////////////////////////////\n\n  _verticalAlign(size) {\n    const { sCapHeight } = this.data?.['OS/2'] || {};\n    const { unitsPerEm = 1000 } = this.data?.head || {};\n    const { ascender = 0, descender = 0 } = this.data?.hhea || {};\n    const current = ascender / 2;\n    const target = (sCapHeight || (ascender + descender)) / 2;\n    const offset = target - current;\n    return offset * size / unitsPerEm;\n  }\n\n  /*\n    Returns an array of line objects, each containing { text, x, y, glyphs: [ {g, path} ] }\n  */\n  _lineateAndPathify(str, x, y, width, height, options = {}) {\n\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n\n    // save the baseline\n    let setBaseline = renderer.drawingContext.textBaseline;\n\n    // lineate and compute bounds for the text\n    let { lines, bounds } = renderer._computeBounds\n      (textCoreConstants._FONT_BOUNDS, str, x, y, width, height,\n        { ignoreRectMode: true, ...options });\n\n    // compute positions for each of the lines\n    lines = this._position(renderer, lines, bounds, width, height);\n\n    // convert lines to paths\n    let uPE = this.data?.head?.unitsPerEm || 1000;\n    let scale = renderer.states.textSize / uPE;\n\n    const axs = this._currentAxes(renderer);\n    let pathsForLine = lines.map(l => this._lineToGlyphs(l, { scale, axs }));\n\n    // restore the baseline\n    renderer.drawingContext.textBaseline = setBaseline;\n\n    return pathsForLine;\n  }\n\n  _currentAxes(renderer) {\n    let axs;\n    if ((this.data?.fvar?.length ?? 0) > 0) {\n      const fontAxes = this.data.fvar[0];\n      axs = fontAxes.map(([tag, minVal, defaultVal, maxVal, flags, name]) => {\n        if (!renderer) return defaultVal;\n        if (tag === 'wght') {\n          return renderer.states.fontWeight;\n        } else if (tag === 'wdth') {\n          // TODO: map from keywords (normal, ultra-condensed, etc) to values\n          // return renderer.states.fontStretch\n          return 100;\n        } else if (renderer.textCanvas().style.fontVariationSettings) {\n          const match = new RegExp(`\\\\b${tag}\\s+(\\d+)`)\n            .exec(renderer.textCanvas().style.fontVariationSettings);\n          if (match) {\n            return parseInt(match[1]);\n          } else {\n            return defaultVal;\n          }\n        } else {\n          return defaultVal;\n        }\n      });\n    }\n    return axs;\n  }\n\n  _textToPathPoints(str, x, y, width, height, options) {\n\n    ({ width, height, options } = this._parseArgs(width, height, options));\n\n    // lineate and get the points for each line\n    let cmds = this.textToPaths(str, x, y, width, height, options);\n\n    // divide line-segments with intermediate points\n    const subdivide = (pts, pt1, pt2, md) => {\n      if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {\n        let middle = { x: (pt1.x + pt2.x) / 2, y: (pt1.y + pt2.y) / 2 };\n        pts.push(middle);\n        subdivide(pts, pt1, middle, md);\n        subdivide(pts, middle, pt2, md);\n      }\n    };\n\n    // a point for each path-command plus line subdivisions\n    let pts = [];\n    let { textSize } = this._pInst._renderer.states;\n    let maxDist = (textSize / this.data.head.unitsPerEm) * 500;\n\n    for (let i = 0; i < cmds.length; i++) {\n      let { type, data: d } = cmds[i];\n      if (type !== 'Z') {\n        let pt = { x: d[d.length - 2], y: d[d.length - 1] };\n        if (type === 'L' && pts.length && !options?.nodivide > 0) {\n          subdivide(pts, pts[pts.length - 1], pt, maxDist);\n        }\n        pts.push(pt);\n      }\n    }\n\n    return pts;\n  }\n\n  _parseArgs(width, height, options = {}) {\n\n    if (typeof width === 'object') {\n      options = width;\n      width = height = undefined;\n    }\n    else if (typeof height === 'object') {\n      options = height;\n      height = undefined;\n    }\n    return { width, height, options };\n  }\n\n  _position(renderer, lines, bounds, width, height) {\n\n    let { textAlign, textLeading } = renderer.states;\n    let metrics = this._measureTextDefault(renderer, 'X');\n    let ascent = metrics.fontBoundingBoxAscent;\n\n    let coordify = (text, i) => {\n      let x = bounds.x;\n      let y = bounds.y + (i * textLeading) + ascent;\n      let lineWidth = renderer._fontWidthSingle(text);\n      if (textAlign === CENTER) {\n        x += (bounds.w - lineWidth) / 2;\n      }\n      else if (textAlign === RIGHT) {\n        x += (bounds.w - lineWidth);\n      }\n      if (typeof width !== 'undefined') {\n        switch (renderer.states.rectMode) {\n          case CENTER:\n            x -= width / 2;\n            y -= height / 2;\n            break;\n          case RADIUS:\n            x -= width;\n            y -= height;\n            break;\n        }\n      }\n      return { text, x, y };\n    };\n\n    return lines.map(coordify);\n  }\n\n  _lineToGlyphs(line, { scale = 1, axs } = {}) {\n\n    if (!this.data) {\n      throw Error('No font data available for \"' + this.name\n        + '\"\\nTry downloading a local copy of the font file');\n    }\n    let glyphShapes = Typr.U.shape(this.data, line.text, { axs });\n    line.glyphShapes = glyphShapes;\n\n    line.glyphs = this._shapeToPaths(glyphShapes, line, { scale, axs });\n\n    return line;\n  }\n\n  _positionGlyphs(text, options) {\n    let renderer = options?.graphics?._renderer || this._pInst._renderer;\n    const axs = this._currentAxes(renderer);\n    const glyphShapes = Typr.U.shape(this.data, text, { axs });\n    const positionedGlyphs = [];\n    let x = 0;\n    for (const glyph of glyphShapes) {\n      positionedGlyphs.push({ x, index: glyph.g, shape: glyph });\n      x += glyph.ax;\n    }\n    return positionedGlyphs;\n  }\n\n  _singleShapeToPath(shape, { scale = 1, x = 0, y = 0, lineX = 0, lineY = 0, axs } = {}) {\n    let font = this.data;\n    let crdIdx = 0;\n    let { g, ax, ay, dx, dy } = shape;\n    let { crds, cmds } = Typr.U.glyphToPath(font, g, true, axs);\n\n    // can get simple points for each glyph here, but we don't need them ?\n    let glyph = { /*g: line.text[i], points: [],*/ path: { commands: [] } };\n\n    for (let j = 0; j < cmds.length; j++) {\n      let type = cmds[j], command = [type];\n      if (type in pathArgCounts) {\n        let argCount = pathArgCounts[type];\n        for (let k = 0; k < argCount; k += 2) {\n          let gx = crds[k + crdIdx] + x + dx;\n          let gy = crds[k + crdIdx + 1] + y + dy;\n          let fx = lineX + gx * scale;\n          let fy = lineY + gy * -scale;\n          command.push(fx);\n          command.push(fy);\n          /*if (k === argCount - 2) {\n            glyph.points.push({ x: fx, y: fy });\n          }*/\n        }\n        crdIdx += argCount;\n      }\n      glyph.path.commands.push(command);\n    }\n\n    return { glyph, ax, ay };\n  }\n\n  _shapeToPaths(glyphs, line, { scale = 1, axs } = {}) {\n    let x = 0, y = 0, paths = [];\n\n    if (glyphs.length !== line.text.length) {\n      throw Error('Invalid shape data');\n    }\n\n    // iterate over the glyphs, converting each to a glyph object\n    // with a path property containing an array of commands\n    for (let i = 0; i < glyphs.length; i++) {\n      const { glyph, ax, ay } = this._singleShapeToPath(glyphs[i], {\n        scale,\n        x,\n        y,\n        lineX: line.x,\n        lineY: line.y,\n        axs,\n      });\n\n      paths.push(glyph);\n      x += ax; y += ay;\n    }\n\n    return paths;\n  }\n\n  _measureTextDefault(renderer, str) {\n    let { textAlign, textBaseline } = renderer.states;\n    let ctx = renderer.textDrawingContext();\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'alphabetic';\n    let metrics = ctx.measureText(str);\n    ctx.textAlign = textAlign;\n    ctx.textBaseline = textBaseline;\n    return metrics;\n  }\n\n  drawPaths(ctx, commands, opts) { // for debugging\n    ctx.strokeStyle = opts?.stroke || ctx.strokeStyle;\n    ctx.fillStyle = opts?.fill || ctx.fillStyle;\n    ctx.beginPath();\n    commands.forEach(([type, ...data]) => {\n      if (type === 'M') {\n        ctx.moveTo(...data);\n      } else if (type === 'L') {\n        ctx.lineTo(...data);\n      } else if (type === 'C') {\n        ctx.bezierCurveTo(...data);\n      } else if (type === 'Q') {\n        ctx.quadraticCurveTo(...data);\n      } else if (type === 'Z') {\n        ctx.closePath();\n      }\n    });\n    if (opts?.fill) ctx.fill();\n    if (opts?.stroke) ctx.stroke();\n  }\n\n  _pathsToCommands(paths, scale) {\n    let commands = [];\n    for (let i = 0; i < paths.length; i++) {\n      let pathData = paths[i];\n      let { x, y, path } = pathData;\n      let { crds, cmds } = path;\n\n      // iterate over the path, storing each non-control point\n      for (let c = 0, j = 0; j < cmds.length; j++) {\n        let cmd = cmds[j], obj = { type: cmd, data: [] };\n        if (cmd == \"M\" || cmd == \"L\") {\n          obj.data.push(x + crds[c] * scale, y + crds[c + 1] * -scale);\n          c += 2;\n        }\n        else if (cmd == \"C\") {\n          for (let i = 0; i < 6; i += 2) {\n            obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);\n          }\n          c += 6;\n        }\n        else if (cmd == \"Q\") {\n          for (let i = 0; i < 4; i += 2) {\n            obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);\n          }\n          c += 4;\n        }\n        commands.push(obj);\n      }\n    }\n\n    return commands;\n  }\n}\n\nasync function create(pInst, name, path, descriptors, rawFont) {\n\n  let face = createFontFace(name, path, descriptors, rawFont);\n\n  // load if we need to\n  if (face.status !== 'loaded') await face.load();\n\n  // add it to the document\n  document.fonts.add(face);\n\n  // return a new p5.Font\n  return new Font(pInst, face, name, path, rawFont);\n}\n\nfunction createFontFace(name, path, descriptors, rawFont) {\n\n  if (name.includes(' ')) name = \"'\" + name + \"'\"; // NOTE: must be single-quotes\n\n  let fontArg = rawFont?._compressedData ?? rawFont?._data;\n  if (!fontArg) {\n    if (!validFontTypesRe.test(path)) {\n      throw Error(invalidFontError);\n    }\n    if (!path.startsWith('url(')) {\n      path = 'url(' + path + ')';\n    }\n    fontArg = path;\n  }\n\n  if ((rawFont?.fvar?.length ?? 0) > 0) {\n    descriptors = descriptors || {};\n    for (const [tag, minVal, defaultVal, maxVal, flags, name] of rawFont.fvar[0]) {\n      if (tag === 'wght') {\n        descriptors.weight = `${minVal} ${maxVal}`;\n      } else if (tag === 'wdth') {\n        descriptors.stretch = `${minVal}% ${maxVal}%`;\n      }\n      // TODO add other descriptors\n    }\n  }\n\n  // create/return the FontFace object\n  let face = new FontFace(name, fontArg, descriptors);\n  if (face.status === 'error') {\n    throw Error('Failed to create FontFace for \"' + name + '\"');\n  }\n  return face;\n}\n\nfunction extractFontName(font, path) {\n  let result, meta = font?.name;\n\n  // use the metadata if we have it\n  if (meta) {\n    if (meta.fullName) {\n      return meta.fullName;\n    }\n    if (meta.familyName) {\n      result = meta.familyName;\n    }\n  }\n\n  if (!result) {\n\n    // if not, try to extract the name from the path\n    let matches = extractFontNameRe.exec(path);\n    if (matches && matches.length >= 3) {\n      result = matches[1];\n    }\n    else {\n      // give up and return the full path\n      result = path;\n    }\n  }\n\n  // replace spaces with underscores\n  if (result.includes(' ')) {\n    result = result.replace(/ /g, '_');\n  }\n\n  return result;\n}\nfunction pathToPoints(cmds, options, font) {\n\n  const parseOpts = (options, defaults) => {\n    if (typeof options !== 'object') {\n      options = defaults;\n    } else {\n      for (const key in defaults) {\n        if (typeof options[key] === 'undefined') {\n          options[key] = defaults[key];\n        }\n      }\n    }\n    return options;\n  };\n\n  const at = (v, i) => {\n    const s = v.length;\n    return v[i < 0 ? i % s + s : i % s];\n  };\n\n  const simplify = (pts, angle) => {\n    angle = angle || 0;\n    let num = 0;\n    for (let i = pts.length - 1; pts.length > 3 && i >= 0; --i) {\n      if (collinear(at(pts, i - 1), at(pts, i), at(pts, i + 1), angle)) {\n        pts.splice(i % pts.length, 1); // Remove middle point\n        num++;\n      }\n    }\n    return num;\n  };\n\n  const path = createFromCommands(arrayCommandsToObjects(cmds));\n  let opts = parseOpts(options, {\n    sampleFactor: 0.1,\n    simplifyThreshold: 0\n  });\n\n  const totalPoints = Math.max(1, Math.ceil(path.getTotalLength() * opts.sampleFactor));\n  let points = [];\n\n  const mode = font._pInst.angleMode();\n  const DEGREES = font._pInst.DEGREES;\n  for (let i = 0; i < totalPoints; i++) {\n    const length = path.getTotalLength() * (\n      totalPoints === 1\n        ? 0\n        : (i / (totalPoints - 1))\n    );\n    points.push({\n      ...path.getPointAtLength(length),\n      get angle() {\n        const angle = path.getAngleAtLength(length);\n        if (mode === DEGREES) {\n          return angle * 180 / Math.PI;\n        } else {\n          return angle;\n        }\n      },\n      // For backwards compatibility\n      get alpha() {\n        return this.angle;\n      }\n    });\n  }\n\n  if (opts.simplifyThreshold) {\n    simplify(points, opts.simplifyThreshold);\n  }\n\n  return points;\n}\n\nfunction unquote(name) {\n  // Unquote name from CSS\n  if ((name.startsWith('\"') || name.startsWith(\"'\")) && name.at(0) === name.at(-1)) {\n    return name.slice(1, -1).replace(/\\/(['\"])/g, '$1');\n  }\n  return name;\n}\n\nfunction parseCreateArgs(...args/*path, name, onSuccess, onError*/) {\n\n  // parse the path\n  let path = args.shift();\n  if (typeof path !== 'string' || path.length === 0) {\n    p5._friendlyError(invalidFontError, 'p5.loadFont'); // ?\n  }\n\n  // parse the name\n  let name;\n  if (typeof args[0] === 'string') {\n    name = args.shift();\n  }\n\n  // get the callbacks/descriptors if any\n  let success, error, options;\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (typeof arg === 'function') {\n      if (!success) {\n        success = arg;\n      } else {\n        error = arg;\n      }\n    }\n    else if (typeof arg === 'object') {\n      options = arg;\n    }\n  }\n\n  return { path, name, success, error, options };\n}\n\nfunction font(p5, fn) {\n\n  /**\n   * A class to describe fonts. Create through <a href=\"#/p5/loadFont\">`loadFont()`</a>.\n   *\n   * @class p5.Font\n   */\n  p5.Font = Font;\n\n  /**\n   * @private\n   */\n  fn.parseFontData = async function(pathOrData) {\n    // load the raw font bytes\n    let result = pathOrData instanceof Uint8Array\n      ? pathOrData\n      : await fn.loadBytes(pathOrData);\n    //console.log('result:', result);\n\n    if (!result) {\n      throw Error('Failed to load font data');\n    }\n\n    // parse the font data\n    let fonts = Typr.parse(result);\n\n    // TODO: generate descriptors from font in the future\n\n    if (fonts.length === 0 || fonts[0].cmap === undefined) {\n      throw Error('parsing font data');\n    }\n\n    return fonts[0];\n  };\n\n  /**\n   * Loads a font and creates a <a href=\"#/p5.Font\">p5.Font</a> object.\n   * `loadFont()` can load fonts in either .otf or .ttf format. Loaded fonts can\n   * be used to style text on the canvas and in HTML elements.\n   *\n   * The first parameter, `path`, is the path to a font file.\n   * Paths to local files should be relative. For example,\n   * `'assets/inconsolata.otf'`. The Inconsolata font used in the following\n   * examples can be downloaded for free\n   * <a href=\"https://www.fontsquirrel.com/fonts/inconsolata\" target=\"_blank\">here</a>.\n   * Paths to remote files should be URLs. For example,\n   * `'https://example.com/inconsolata.otf'`. URLs may be blocked due to browser\n   * security.\n   *\n   * In 2D mode, `path` can take on a few other forms. It could be a path to a CSS file,\n   * such as one from <a href=\"https://fonts.google.com/\">Google Fonts.</a> It could also\n   * be a string with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face\">CSS `@font-face` declaration.</a>\n   *\n   * The second parameter, `successCallback`, is optional. If a function is\n   * passed, it will be called once the font has loaded. The callback function\n   * may use the new <a href=\"#/p5.Font\">p5.Font</a> object if needed.\n   *\n   * The third parameter, `failureCallback`, is also optional. If a function is\n   * passed, it will be called if the font fails to load. The callback function\n   * may use the error\n   * <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event\" target=\"_blank\">Event</a>\n   * object if needed.\n   *\n   * Fonts can take time to load. `await` the result of `loadFont()` in\n   * <a href=\"#/p5/setup\">setup()</a> before using the result.\n   *\n   * @method loadFont\n   * @for p5\n   * @param  {String}        path       path of the font or CSS file to be loaded, or a CSS `@font-face` string.\n   * @param  {String}        [name]            An alias that can be used for this font in `textFont()`. Defaults to the name in the font's metadata.\n   * @param  {Object}        [options]         An optional object with extra CSS font face descriptors, or p5.js font settings.\n   * @param  {String|Array<String>} [options.sets] (Experimental) An optional string of list of strings with Unicode character set names that should be included. When a CSS file is used as the font, it may contain multiple font files. The font best matching the requested character sets will be picked.\n   * @param  {Function}      [successCallback] function called with the\n   *                                           <a href=\"#/p5.Font\">p5.Font</a> object after it\n   *                                           loads.\n   * @param  {Function}      [failureCallback] function called with the error\n   *                                           <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event\" target=\"_blank\">Event</a>\n   *                                           object if the font fails to load.\n   * @return {Promise<p5.Font>}                         <a href=\"#/p5.Font\">p5.Font</a> object.\n   * @example\n   * <div>\n   * <code>\n   * let font;\n   *\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   font = await loadFont('assets/inconsolata.otf');\n   *   fill('deeppink');\n   *   textFont(font);\n   *   textSize(36);\n   *   text('p5*js', 10, 50);\n   *\n   *   describe('The text \"p5*js\" written in pink on a white background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   loadFont('assets/inconsolata.otf', font => {\n   *     fill('deeppink');\n   *     textFont(font);\n   *     textSize(36);\n   *     text('p5*js', 10, 50);\n   *\n   *     describe('The text \"p5*js\" written in pink on a white background.');\n   *   });\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   loadFont('assets/inconsolata.otf', success, failure);\n   * }\n   *\n   * function success(font) {\n   *   fill('deeppink');\n   *   textFont(font);\n   *   textSize(36);\n   *   text('p5*js', 10, 50);\n   *\n   *   describe('The text \"p5*js\" written in pink on a white background.');\n   * }\n   *\n   * function failure(event) {\n   *   console.error('Oops!', event);\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * async function setup() {\n   *   createCanvas(100, 100);\n   *   await loadFont('assets/inconsolata.otf');\n   *   let p = createP('p5*js');\n   *   p.style('color', 'deeppink');\n   *   p.style('font-family', 'Inconsolata');\n   *   p.style('font-size', '36px');\n   *   p.position(10, 50);\n   *\n   *   describe('The text \"p5*js\" written in pink on a white background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Some other forms of loading fonts:\n   * loadFont(\"https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&display=swap\");\n   * loadFont(`@font-face { font-family: \"Bricolage Grotesque\", serif; font-optical-sizing: auto; font-weight: 400; font-style: normal; font-variation-settings: \"wdth\" 100; }`);\n   * </code>\n   * </div>\n   */\n  /**\n    * @method loadFont\n    * @for p5\n    * @param  {String}        path              path of the font to be loaded.\n    * @param  {Function}      [successCallback] function called with the\n    *                                           <a href=\"#/p5.Font\">p5.Font</a> object after it\n    *                                           loads.\n    * @param  {Function}      [failureCallback] function called with the error\n    *                                           <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event\" target=\"_blank\">Event</a>\n    *                                           object if the font fails to load.\n    * @returns {Promise<p5.Font>} The font.\n    */\n  fn.loadFont = async function (...args/*path, name, onSuccess, onError, descriptors*/) {\n\n    let { path, name, success, error, options: { sets, ...descriptors } = {} } = parseCreateArgs(...args);\n\n    let isCSS = path.includes('@font-face');\n\n    if (!isCSS) {\n      const info = await fetch(path, { method: 'HEAD' });\n      const isCSSFile = info.headers.get('content-type')?.startsWith('text/css');\n      if (isCSSFile) {\n        isCSS = true;\n        path = await fetch(path).then((res) => res.text());\n      }\n    }\n\n    if (isCSS) {\n      const stylesheet = new CSSStyleSheet();\n      await stylesheet.replace(path);\n      const possibleFonts = [];\n      for (const rule of stylesheet.cssRules) {\n        if (rule instanceof CSSFontFaceRule) {\n          const style = rule.style;\n          let name = unquote(style.getPropertyValue('font-family'));\n          const src = style.getPropertyValue('src');\n          const fontDescriptors = { ...(descriptors || {}) };\n          for (const key of style) {\n            if (key === 'font-family' || key === 'src') continue;\n            const camelCaseKey = key\n              .replace(/^font-/, '')\n              .split('-')\n              .map((v, i) => i === 0 ? v : `${v[0].toUpperCase()}${v.slice(1)}`)\n              .join('');\n            fontDescriptors[camelCaseKey] = style.getPropertyValue(key);\n          }\n          possibleFonts.push({\n            name,\n            src,\n            fontDescriptors,\n            loadWithData: async () => {\n              let fontData;\n              try {\n                const urlMatch = /url\\(([^\\)]+)\\)/.exec(src);\n                if (urlMatch) {\n                  let url = urlMatch[1];\n                  if (/^['\"]/.exec(url) && url.at(0) === url.at(-1)) {\n                    url = url.slice(1, -1);\n                  }\n                  fontData = await fn.parseFontData(url);\n                }\n              } catch (_e) {}\n              return create(this, name, src, fontDescriptors, fontData)\n            },\n            loadWithoutData: () => create(this, name, src, fontDescriptors)\n          });\n        }\n      }\n\n      // TODO: handle multiple font faces?\n      sets = sets || ['latin']; // Default to latin for now if omitted\n      const requestedGroups = (sets instanceof Array ? sets : [sets])\n        .map(s => s.toLowerCase());\n      // Grab thr named groups with names that include the requested keywords\n      const requestedCategories = unicodeRanges\n        .filter((r) => requestedGroups.some(\n          g => r.category.includes(g) &&\n            // Only include extended character sets if specifically requested\n            r.category.includes('ext') === g.includes('ext')\n        ));\n      const requestedRanges = new Set(\n        UnicodeRange.parse(\n          requestedCategories.map((c) => `U+${c.hexrange[0]}-${c.hexrange[1]}`)\n        )\n      );\n      let closestRangeOverlap = 0;\n      let closestDescriptorOverlap = 0;\n      let closestMatch = undefined;\n      for (const font of possibleFonts) {\n        if (!font.fontDescriptors.unicodeRange) continue;\n        const fontRange = new Set(\n          UnicodeRange.parse(\n            font.fontDescriptors.unicodeRange.split(/,\\s*/g)\n          )\n        );\n        const rangeOverlap = [...fontRange.values()]\n          .filter(v => requestedRanges.has(v))\n          .length;\n\n        const targetDescriptors = {\n          // Default to normal style at regular weight\n          style: 'normal',\n          weight: 400,\n          // Override from anything else passed in\n          ...descriptors\n        };\n        const descriptorOverlap = Object.keys(font.fontDescriptors)\n          .filter(k => font.fontDescriptors[k] === targetDescriptors[k])\n          .length;\n\n        if (\n          descriptorOverlap > closestDescriptorOverlap ||\n          (descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap)\n        ) {\n          closestDescriptorOverlap = descriptorOverlap;\n          closestRangeOverlap = rangeOverlap;\n          closestMatch = font;\n        }\n      }\n      const picked = (closestMatch || possibleFonts.at(-1));\n      for (const font of possibleFonts) {\n        if (font !== picked) {\n          // Load without parsing data with Typr so that it still can be accessed\n          // via regular CSS by name\n          font.loadWithoutData();\n        }\n      }\n      return picked?.loadWithData();\n    }\n\n    let pfont;\n    try {\n      const fontData = await fn.parseFontData(path);\n\n      // make sure we have a valid name\n      name = name || extractFontName(fontData, path);\n\n      // create a FontFace object and pass it to the p5.Font constructor\n      pfont = await create(this, name, path, descriptors, fontData);\n\n    } catch (err) {\n      // failed to parse the font, load it as a simple FontFace\n      let ident = name || path\n        .substring(path.lastIndexOf('/') + 1)\n        .replace(/\\.[^/.]+$/, \"\");\n\n      console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);\n\n      try {\n        // create a FontFace object and pass it to p5.Font\n        pfont = await create(this, ident, path, descriptors);\n      }\n      catch (err) {\n        if (error) return error(err);\n        throw err;\n      }\n    }\n    if (success) return success(pfont);\n\n    return pfont;\n  };\n}\n// Convert arrays to named objects\nconst arrayCommandsToObjects = (commands) => commands.map((command) => {\n  const type = command[0];\n  switch (type) {\n    case 'Z': {\n      return { type };\n    }\n    case 'M':\n    case 'L': {\n      const [, x, y] = command;\n      return { type, x, y };\n    }\n    case 'Q': {\n      const [, x1, y1, x, y] = command;\n      return { type, x1, y1, x, y };\n    }\n    case 'C': {\n      const [, x1, y1, x2, y2, x, y] = command;\n      return { type, x1, y1, x2, y2, x, y };\n    }\n    default: {\n      throw new Error(`Unexpected path command: ${type}`);\n    }\n  }\n});\n\nif (typeof p5 !== 'undefined') {\n  font(p5, p5.prototype);\n}\n\nexport { Font, arrayCommandsToObjects, font as default };\n"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEO,WAAWA,CAACX,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAE;IAE7C,CAAC;MAAEF,KAAK;MAAEC,MAAM;MAAEC;IAAQ,CAAC,GAAG,IAAI,CAACC,UAAU,CAACH,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC;IAErE,IAAI,CAAC,IAAI,CAACd,IAAI,EAAE;MACd,MAAME,KAAK,CAAC,8BAA8B,GAAG,IAAI,CAACJ,IAAI,GAClD,kDAAkD,CAAC;IACzD;;IAEA;IACA,IAAIuB,KAAK,GAAG,IAAI,CAACC,kBAAkB,CAACb,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC;;IAEtE;IACA,IAAIS,MAAM,GAAGF,KAAK,CAACG,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACF,MAAM,CAAC,CAACG,IAAI,CAAC,CAAC;;IAE5C;IACA,OAAOH,MAAM,CAACC,GAAG,CAACG,CAAC,IAAIA,CAAC,CAAC5B,IAAI,CAAC6B,QAAQ,CAAC,CAACF,IAAI,CAAC,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,YAAYA,CAACpB,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAE;IAC9C;IACA,MAAMgB,aAAa,GAAG,IAAI,CAACC,cAAc,CAACtB,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC;IAC5E,OAAOgB,aAAa,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK;MACzCD,GAAG,CAACE,IAAI,CAAC,GAAGD,IAAI,CAAC;MACjB,OAAOD,GAAG;IACZ,CAAC,EAAE,EAAE,CAAC;EACR;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEF,cAAcA,CAACtB,GAAG,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAE;IACxD,CAAC;MAAEF,KAAK;MAAEC,MAAM;MAAEC;IAAQ,CAAC,GAAG,IAAI,CAACC,UAAU,CAACH,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC;IAErE,MAAMsB,IAAI,GAAG,IAAI,CAAChB,WAAW,CAACX,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,CAAC;IAChE,MAAMuB,WAAW,GAAG,EAAE;IACtB,KAAK,MAAMC,GAAG,IAAIF,IAAI,EAAE;MACtB,IAAIE,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAClBD,WAAW,CAACF,IAAI,CAAC,EAAE,CAAC;MACtB;MACAE,WAAW,CAACA,WAAW,CAACE,MAAM,GAAG,CAAC,CAAC,CAACJ,IAAI,CAACG,GAAG,CAAC;IAC/C;IAEA,OAAOD,WAAW,CAACb,GAAG,CAAEI,QAAQ,IAAKY,YAAY,CAACZ,QAAQ,EAAEd,OAAO,EAAE,IAAI,CAAC,CAAC;EAC7E;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2B,WAAWA,CAAChC,GAAG,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,E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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEsD,EAAE,CAACkI,QAAQ,GAAG,gBAAgB,GAAGb,IAAI,kDAAiD;IAEpF,IAAI;MAAE7P,IAAI;MAAED,IAAI;MAAEkQ,OAAO;MAAEC,KAAK;MAAEnP,OAAO,EAAE;QAAE4P,IAAI;QAAE,GAAG7D;MAAY,CAAC,GAAG,CAAC;IAAE,CAAC,GAAG8C,eAAe,CAAC,GAAGC,IAAI,CAAC;IAErG,IAAIe,KAAK,GAAG5Q,IAAI,CAACmN,QAAQ,CAAC,YAAY,CAAC;IAEvC,IAAI,CAACyD,KAAK,EAAE;MACV,MAAMC,IAAI,GAAG,MAAMC,KAAK,CAAC9Q,IAAI,EAAE;QAAE+Q,MAAM,EAAE;MAAO,CAAC,CAAC;MAClD,MAAMC,SAAS,GAAGH,IAAI,CAACI,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC,EAAE3D,UAAU,CAAC,UAAU,CAAC;MAC1E,IAAIyD,SAAS,EAAE;QACbJ,KAAK,GAAG,IAAI;QACZ5Q,IAAI,GAAG,MAAM8Q,KAAK,CAAC9Q,IAAI,CAAC,CAACmR,IAAI,CAAEC,GAAG,IAAKA,GAAG,CAAC3H,IAAI,CAAC,CAAC,CAAC;MACpD;IACF;IAEA,IAAImH,KAAK,EAAE;MACT,MAAMS,UAAU,GA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}