{"ast":null,"code":"/**\n * @module Environment\n * @submodule Environment\n * @for p5\n * @requires core\n */\n\nfunction textOutput(p5, fn) {\n  //the functions in this file support updating the text output\n\n  //updates textOutput\n  fn._updateTextOutput = function (idT) {\n    //if html structure is not there yet\n    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {\n      return;\n    }\n    let current = this._accessibleOutputs[idT];\n    //create shape list\n    let innerList = _shapeList(idT, this.ingredients.shapes);\n    //create output summary\n    let innerSummary = _textSummary(innerList.numShapes, this.ingredients.colors.background, this.width, this.height);\n    //create shape details\n    let innerShapeDetails = _shapeDetails(idT, this.ingredients.shapes);\n    //if it is different from current summary\n    if (innerSummary !== current.summary.innerHTML) {\n      //update\n      current.summary.innerHTML = innerSummary;\n    }\n    //if it is different from current shape list\n    if (innerList.listShapes !== current.list.innerHTML) {\n      //update\n      current.list.innerHTML = innerList.listShapes;\n    }\n    //if it is different from current shape details\n    if (innerShapeDetails !== current.shapeDetails.innerHTML) {\n      //update\n      current.shapeDetails.innerHTML = innerShapeDetails;\n    }\n    this._accessibleOutputs[idT] = current;\n  };\n\n  //Builds textOutput summary\n  function _textSummary(numShapes, background, width, height) {\n    let text = `Your output is a, ${width} by ${height} pixels, ${background} canvas containing the following`;\n    if (numShapes === 1) {\n      text = `${text} shape:`;\n    } else {\n      text = `${text} ${numShapes} shapes:`;\n    }\n    return text;\n  }\n\n  //Builds textOutput table with shape details\n  function _shapeDetails(idT, ingredients) {\n    let shapeDetails = '';\n    let shapeNumber = 0;\n    //goes trhough every shape type in ingredients\n    for (let x in ingredients) {\n      //and for every shape\n      for (let y in ingredients[x]) {\n        //it creates a table row\n        let row = `<tr id=\"${idT}shape${shapeNumber}\"><th>${ingredients[x][y].color} ${x}</th>`;\n        if (x === 'line') {\n          row = row + `<td>location = ${ingredients[x][y].pos}</td><td>length = ${ingredients[x][y].length} pixels</td></tr>`;\n        } else {\n          row = row + `<td>location = ${ingredients[x][y].pos}</td>`;\n          if (x !== 'point') {\n            row = row + `<td> area = ${ingredients[x][y].area}%</td>`;\n          }\n          row = row + '</tr>';\n        }\n        shapeDetails = shapeDetails + row;\n        shapeNumber++;\n      }\n    }\n    return shapeDetails;\n  }\n\n  //Builds textOutput shape list\n  function _shapeList(idT, ingredients) {\n    let shapeList = '';\n    let shapeNumber = 0;\n    //goes trhough every shape type in ingredients\n    for (let x in ingredients) {\n      for (let y in ingredients[x]) {\n        //it creates a line in a list\n        let _line = `<li><a href=\"#${idT}shape${shapeNumber}\">${ingredients[x][y].color} ${x}</a>`;\n        if (x === 'line') {\n          _line = _line + `, ${ingredients[x][y].pos}, ${ingredients[x][y].length} pixels long.</li>`;\n        } else {\n          _line = _line + `, at ${ingredients[x][y].pos}`;\n          if (x !== 'point') {\n            _line = _line + `, covering ${ingredients[x][y].area}% of the canvas`;\n          }\n          _line = _line + '.</li>';\n        }\n        shapeList = shapeList + _line;\n        shapeNumber++;\n      }\n    }\n    return {\n      numShapes: shapeNumber,\n      listShapes: shapeList\n    };\n  }\n}\nif (typeof p5 !== 'undefined') {\n  textOutput(p5, p5.prototype);\n}\nexport { textOutput as default };","map":{"version":3,"names":["textOutput","p5","fn","_updateTextOutput","idT","dummyDOM","querySelector","current","_accessibleOutputs","innerList","_shapeList","ingredients","shapes","innerSummary","_textSummary","numShapes","colors","background","width","height","innerShapeDetails","_shapeDetails","summary","innerHTML","listShapes","list","shapeDetails","text","shapeNumber","x","y","row","color","pos","length","area","shapeList","_line","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/accessibility/textOutput.js"],"sourcesContent":["/**\n * @module Environment\n * @submodule Environment\n * @for p5\n * @requires core\n */\n\nfunction textOutput(p5, fn){\n  //the functions in this file support updating the text output\n\n  //updates textOutput\n  fn._updateTextOutput = function(idT) {\n    //if html structure is not there yet\n    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {\n      return;\n    }\n    let current = this._accessibleOutputs[idT];\n    //create shape list\n    let innerList = _shapeList(idT, this.ingredients.shapes);\n    //create output summary\n    let innerSummary = _textSummary(\n      innerList.numShapes,\n      this.ingredients.colors.background,\n      this.width,\n      this.height\n    );\n    //create shape details\n    let innerShapeDetails = _shapeDetails(idT, this.ingredients.shapes);\n    //if it is different from current summary\n    if (innerSummary !== current.summary.innerHTML) {\n      //update\n      current.summary.innerHTML = innerSummary;\n    }\n    //if it is different from current shape list\n    if (innerList.listShapes !== current.list.innerHTML) {\n      //update\n      current.list.innerHTML = innerList.listShapes;\n    }\n    //if it is different from current shape details\n    if (innerShapeDetails !== current.shapeDetails.innerHTML) {\n      //update\n      current.shapeDetails.innerHTML = innerShapeDetails;\n    }\n    this._accessibleOutputs[idT] = current;\n  };\n\n  //Builds textOutput summary\n  function _textSummary(numShapes, background, width, height) {\n    let text = `Your output is a, ${width} by ${height} pixels, ${background} canvas containing the following`;\n    if (numShapes === 1) {\n      text = `${text} shape:`;\n    } else {\n      text = `${text} ${numShapes} shapes:`;\n    }\n    return text;\n  }\n\n  //Builds textOutput table with shape details\n  function _shapeDetails(idT, ingredients) {\n    let shapeDetails = '';\n    let shapeNumber = 0;\n    //goes trhough every shape type in ingredients\n    for (let x in ingredients) {\n      //and for every shape\n      for (let y in ingredients[x]) {\n        //it creates a table row\n        let row = `<tr id=\"${idT}shape${shapeNumber}\"><th>${\n          ingredients[x][y].color\n        } ${x}</th>`;\n        if (x === 'line') {\n          row =\n            row +\n            `<td>location = ${ingredients[x][y].pos}</td><td>length = ${\n              ingredients[x][y].length\n            } pixels</td></tr>`;\n        } else {\n          row = row + `<td>location = ${ingredients[x][y].pos}</td>`;\n          if (x !== 'point') {\n            row = row + `<td> area = ${ingredients[x][y].area}%</td>`;\n          }\n          row = row + '</tr>';\n        }\n        shapeDetails = shapeDetails + row;\n        shapeNumber++;\n      }\n    }\n    return shapeDetails;\n  }\n\n  //Builds textOutput shape list\n  function _shapeList(idT, ingredients) {\n    let shapeList = '';\n    let shapeNumber = 0;\n    //goes trhough every shape type in ingredients\n    for (let x in ingredients) {\n      for (let y in ingredients[x]) {\n        //it creates a line in a list\n        let _line = `<li><a href=\"#${idT}shape${shapeNumber}\">${\n          ingredients[x][y].color\n        } ${x}</a>`;\n        if (x === 'line') {\n          _line =\n            _line +\n            `, ${ingredients[x][y].pos}, ${\n              ingredients[x][y].length\n            } pixels long.</li>`;\n        } else {\n          _line = _line + `, at ${ingredients[x][y].pos}`;\n          if (x !== 'point') {\n            _line = _line + `, covering ${ingredients[x][y].area}% of the canvas`;\n          }\n          _line = _line + '.</li>';\n        }\n        shapeList = shapeList + _line;\n        shapeNumber++;\n      }\n    }\n    return { numShapes: shapeNumber, listShapes: shapeList };\n  }\n}\n\nif(typeof p5 !== 'undefined'){\n  textOutput(p5, p5.prototype);\n}\n\nexport { textOutput as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}