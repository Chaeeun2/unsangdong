{"ast":null,"code":"import Filters from './filters.js';\n\n/**\n * @module Image\n * @submodule Pixels\n * @for p5\n * @requires core\n */\n\nfunction pixels(p5, fn) {\n  /**\n   * An array containing the color of each pixel on the canvas.\n   *\n   * Colors are stored as numbers representing red, green, blue, and alpha\n   * (RGBA) values. `pixels` is a one-dimensional array for performance reasons.\n   *\n   * Each pixel occupies four elements in the `pixels` array, one for each RGBA\n   * value. For example, the pixel at coordinates (0, 0) stores its RGBA values\n   * at `pixels[0]`, `pixels[1]`, `pixels[2]`, and `pixels[3]`, respectively.\n   * The next pixel at coordinates (1, 0) stores its RGBA values at `pixels[4]`,\n   * `pixels[5]`, `pixels[6]`, and `pixels[7]`. And so on. The `pixels` array\n   * for a 100&times;100 canvas has 100 &times; 100 &times; 4 = 40,000 elements.\n   *\n   * Some displays use several smaller pixels to set the color at a single\n   * point. The <a href=\"#/p5/pixelDensity\">pixelDensity()</a> function returns\n   * the pixel density of the canvas. High density displays often have a\n   * <a href=\"#/p5/pixelDensity\">pixelDensity()</a> of 2. On such a display, the\n   * `pixels` array for a 100&times;100 canvas has 200 &times; 200 &times; 4 =\n   * 160,000 elements.\n   *\n   * Accessing the RGBA values for a point on the canvas requires a little math\n   * as shown below. The <a href=\"#/p5/loadPixels\">loadPixels()</a> function\n   * must be called before accessing the `pixels` array. The\n   * <a href=\"#/p5/updatePixels\">updatePixels()</a> function must be called\n   * after any changes are made.\n   *\n   * @property {Number[]} pixels\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(128);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Set the dot's coordinates.\n   *   let x = 50;\n   *   let y = 50;\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Set the pixel(s) at the center of the canvas black.\n   *   for (let i = 0; i < d; i += 1) {\n   *     for (let j = 0; j < d; j += 1) {\n   *       let index = 4 * ((y * d + j) * width * d + (x * d + i));\n   *       // Red.\n   *       pixels[index] = 0;\n   *       // Green.\n   *       pixels[index + 1] = 0;\n   *       // Blue.\n   *       pixels[index + 2] = 0;\n   *       // Alpha.\n   *       pixels[index + 3] = 255;\n   *     }\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A black dot in the middle of a gray rectangle.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Make the top half of the canvas red.\n   *   for (let i = 0; i < halfImage; i += 4) {\n   *     // Red.\n   *     pixels[i] = 255;\n   *     // Green.\n   *     pixels[i + 1] = 0;\n   *     // Blue.\n   *     pixels[i + 2] = 0;\n   *     // Alpha.\n   *     pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A red rectangle drawn above a gray rectangle.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   // Create a p5.Color object.\n   *   let pink = color(255, 102, 204);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Make the top half of the canvas red.\n   *   for (let i = 0; i < halfImage; i += 4) {\n   *     pixels[i] = red(pink);\n   *     pixels[i + 1] = green(pink);\n   *     pixels[i + 2] = blue(pink);\n   *     pixels[i + 3] = alpha(pink);\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A pink rectangle drawn above a gray rectangle.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Copies a region of pixels from one image to another.\n   *\n   * The first parameter, `srcImage`, is the\n   * <a href=\"#/p5.Image\">p5.Image</a> object to blend.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to blend from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the regions width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the regions width and height.\n   *\n   * The tenth parameter, `blendMode`, sets the effect used to blend the images'\n   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,\n   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,\n   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`\n   *\n   * @method blend\n   * @param  {p5.Image} srcImage source image.\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either\n   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,\n   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,\n   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img0;\n   * let img1;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   img0 = await loadImage('assets/rockies.jpg');\n   *   img1 = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img0);\n   *\n   *   // Display the bricks.\n   *   image(img1, 0, 0);\n   *\n   *   // Display the bricks faded into the landscape.\n   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img0;\n   * let img1;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   img0 = await loadImage('assets/rockies.jpg');\n   *   img1 = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img0);\n   *\n   *   // Display the bricks.\n   *   image(img1, 0, 0);\n   *\n   *   // Display the bricks partially transparent.\n   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img0;\n   * let img1;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   img0 = await loadImage('assets/rockies.jpg');\n   *   img1 = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img0);\n   *\n   *   // Display the bricks.\n   *   image(img1, 0, 0);\n   *\n   *   // Display the bricks washed out into the landscape.\n   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, ADD);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method blend\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode\n   */\n  fn.blend = function (...args) {\n    // p5._validateParameters('blend', args);\n    if (this._renderer) {\n      this._renderer.blend(...args);\n    } else {\n      p5.Renderer2D.prototype.blend.apply(this, args);\n    }\n  };\n\n  /**\n   * Copies pixels from a source image to a region of the canvas.\n   *\n   * The first parameter, `srcImage`, is the\n   * <a href=\"#/p5.Image\">p5.Image</a> object to blend. The source image can be\n   * the canvas itself or a\n   * <a href=\"#/p5.Image\">p5.Image</a> object. `copy()` will scale pixels from\n   * the source region if it isn't the same size as the destination region.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to copy from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the region's width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of the canvas to copy into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the region's width and height.\n   *\n   * @method copy\n   * @param  {p5.Image|p5.Element} srcImage source image.\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img);\n   *\n   *   // Copy a region of pixels to another spot.\n   *   copy(img, 7, 22, 10, 10, 35, 25, 50, 50);\n   *\n   *   // Outline the copied region.\n   *   stroke(255);\n   *   noFill();\n   *   square(7, 22, 10);\n   *\n   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method copy\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   */\n  fn.copy = function (...args) {\n    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;\n    if (args.length === 9) {\n      srcImage = args[0];\n      sx = args[1];\n      sy = args[2];\n      sw = args[3];\n      sh = args[4];\n      dx = args[5];\n      dy = args[6];\n      dw = args[7];\n      dh = args[8];\n    } else if (args.length === 8) {\n      srcImage = this;\n      sx = args[0];\n      sy = args[1];\n      sw = args[2];\n      sh = args[3];\n      dx = args[4];\n      dy = args[5];\n      dw = args[6];\n      dh = args[7];\n    } else {\n      throw new Error('Signature not supported');\n    }\n    fn._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);\n  };\n  fn._copyHelper = (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) => {\n    const s = srcImage.canvas.width / srcImage.width;\n    // adjust coord system for 3D when renderer\n    // ie top-left = -width/2, -height/2\n    let sxMod = 0;\n    let syMod = 0;\n    if (srcImage._renderer && srcImage._renderer.isP3D) {\n      sxMod = srcImage.width / 2;\n      syMod = srcImage.height / 2;\n    }\n    if (dstImage._renderer && dstImage._renderer.isP3D) {\n      dstImage.push();\n      dstImage.resetMatrix();\n      dstImage.noLights();\n      dstImage.blendMode(dstImage.BLEND);\n      dstImage.imageMode(dstImage.CORNER);\n      dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);\n      dstImage.pop();\n    } else {\n      dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);\n    }\n  };\n\n  /**\n   * Applies an image filter to the canvas.\n   *\n   * The preset options are:\n   *\n   * `INVERT`\n   * Inverts the colors in the image. No parameter is used.\n   *\n   * `GRAY`\n   * Converts the image to grayscale. No parameter is used.\n   *\n   * `THRESHOLD`\n   * Converts the image to black and white. Pixels with a grayscale value\n   * above a given threshold are converted to white. The rest are converted to\n   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no\n   * value is specified, 0.5 is used.\n   *\n   * `OPAQUE`\n   * Sets the alpha channel to entirely opaque. No parameter is used.\n   *\n   * `POSTERIZE`\n   * Limits the number of colors in the image. Each color channel is limited to\n   * the number of colors specified. Values between 2 and 255 are valid, but\n   * results are most noticeable with lower values. The default value is 4.\n   *\n   * `BLUR`\n   * Blurs the image. The level of blurring is specified by a blur radius. Larger\n   * values increase the blur. The default value is 4. A gaussian blur is used\n   * in `P2D` mode. A box blur is used in `WEBGL` mode.\n   *\n   * `ERODE`\n   * Reduces the light areas. No parameter is used.\n   *\n   * `DILATE`\n   * Increases the light areas. No parameter is used.\n   *\n   * `filter()` uses WebGL in the background by default because it's faster.\n   * This can be disabled in `P2D` mode by adding a `false` argument, as in\n   * `filter(BLUR, false)`. This may be useful to keep computation off the GPU\n   * or to work around a lack of WebGL support.\n   *\n   * In WebgL mode, `filter()` can also use custom shaders. See\n   * <a href=\"#/p5/createFilterShader\">createFilterShader()</a> for more\n   * information.\n   *\n   *\n   * @method filter\n   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,\n   *                                POSTERIZE, BLUR, ERODE, DILATE or BLUR.\n   * @param  {Number} [filterParam] parameter unique to each filter.\n   * @param  {Boolean} [useWebGL=true]   flag to control whether to use fast\n   *                                WebGL filters (GPU) or original image\n   *                                filters (CPU); defaults to `true`.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the INVERT filter.\n   *   filter(INVERT);\n   *\n   *   describe('A blue brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the GRAY filter.\n   *   filter(GRAY);\n   *\n   *   describe('A brick wall drawn in grayscale.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the THRESHOLD filter.\n   *   filter(THRESHOLD);\n   *\n   *   describe('A brick wall drawn in black and white.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the OPAQUE filter.\n   *   filter(OPAQUE);\n   *\n   *   describe('A red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the POSTERIZE filter.\n   *   filter(POSTERIZE, 3);\n   *\n   *   describe('An image of a red brick wall drawn with limited color palette.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the BLUR filter.\n   *   filter(BLUR, 3);\n   *\n   *   describe('A blurry image of a red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the DILATE filter.\n   *   filter(DILATE);\n   *\n   *   describe('A red brick wall with bright lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the ERODE filter.\n   *   filter(ERODE);\n   *\n   *   describe('A red brick wall with faint lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the BLUR filter.\n   *   // Don't use WebGL.\n   *   filter(BLUR, 3, false);\n   *\n   *   describe('A blurry image of a red brick wall.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method getFilterGraphicsLayer\n   * @private\n   * @returns {p5.Graphics}\n   */\n  fn.getFilterGraphicsLayer = function () {\n    return this._renderer.getFilterGraphicsLayer();\n  };\n\n  /**\n   * @method filter\n   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR)} filterType\n   * @param  {Number} [filterParam]\n   * @param  {Boolean} [useWebGL=true]\n   */\n  /**\n   * @method filter\n   * @param {p5.Shader}  shaderFilter  shader that's been loaded, with the\n   *                                   frag shader using a `tex0` uniform.\n   */\n  fn.filter = function (...args) {\n    // p5._validateParameters('filter', args);\n\n    let {\n      shader,\n      operation,\n      value,\n      useWebGL\n    } = parseFilterArgs(...args);\n\n    // when passed a shader, use it directly\n    if (this._renderer.isP3D && shader) {\n      this._renderer.filter(shader);\n      return;\n    }\n\n    // when opting out of webgl, use old pixels method\n    if (!useWebGL && !this._renderer.isP3D) {\n      if (this.canvas !== undefined) {\n        Filters.apply(this.canvas, Filters[operation], value);\n      } else {\n        Filters.apply(this.elt, Filters[operation], value);\n      }\n      return;\n    }\n    if (!useWebGL && this._renderer.isP3D) {\n      console.warn('filter() with useWebGL=false is not supported in WEBGL');\n    }\n\n    // when this is a webgl renderer, apply constant shader filter\n    if (this._renderer.isP3D) {\n      this._renderer.filter(operation, value);\n    }\n\n    // when this is P2D renderer, create/use hidden webgl renderer\n    else {\n      if (shader) {\n        this._renderer.filterRenderer.setOperation(operation, value, shader);\n      } else {\n        this._renderer.filterRenderer.setOperation(operation, value);\n      }\n      this._renderer.filterRenderer.applyFilter();\n    }\n  };\n  function parseFilterArgs(...args) {\n    // args could be:\n    // - operation, value, [useWebGL]\n    // - operation, [useWebGL]\n    // - shader\n\n    let result = {\n      shader: undefined,\n      operation: undefined,\n      value: undefined,\n      useWebGL: true\n    };\n    if (args[0] instanceof p5.Shader) {\n      result.shader = args[0];\n      return result;\n    } else {\n      result.operation = args[0];\n    }\n    if (args.length > 1 && typeof args[1] === 'number') {\n      result.value = args[1];\n    }\n    if (args[args.length - 1] === false) {\n      result.useWebGL = false;\n    }\n    return result;\n  }\n\n  /**\n   * Gets a pixel or a region of pixels from the canvas.\n   *\n   * `get()` is easy to use but it's not as fast as\n   * <a href=\"#/p5/pixels\">pixels</a>. Use <a href=\"#/p5/pixels\">pixels</a>\n   * to read many pixel values.\n   *\n   * The version of `get()` with no parameters returns the entire canvas.\n   *\n   * The version of `get()` with two parameters interprets them as\n   * coordinates. It returns an array with the `[R, G, B, A]` values of the\n   * pixel at the given point.\n   *\n   * The version of `get()` with four parameters interprets them as coordinates\n   * and dimensions. It returns a subsection of the canvas as a\n   * <a href=\"#/p5.Image\">p5.Image</a> object. The first two parameters are the\n   * coordinates for the upper-left corner of the subsection. The last two\n   * parameters are the width and height of the subsection.\n   *\n   * Use <a href=\"#/p5.Image/get\">p5.Image.get()</a> to work directly with\n   * <a href=\"#/p5.Image\">p5.Image</a> objects.\n   *\n   * @method get\n   * @param  {Number}         x x-coordinate of the pixel.\n   * @param  {Number}         y y-coordinate of the pixel.\n   * @param  {Number}         w width of the subsection to be returned.\n   * @param  {Number}         h height of the subsection to be returned.\n   * @return {p5.Image}       subsection as a <a href=\"#/p5.Image\">p5.Image</a> object.\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get the entire canvas.\n   *   let c = get();\n   *\n   *   // Display half the canvas.\n   *   image(c, 50, 0);\n   *\n   *   describe('Two identical mountain landscapes shown side-by-side.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get the color of a pixel.\n   *   let c = get(50, 90);\n   *\n   *   // Style the square with the pixel's color.\n   *   fill(c);\n   *   noStroke();\n   *\n   *   // Display the square.\n   *   square(25, 25, 50);\n   *\n   *   describe('A mountain landscape with an olive green square in its center.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get a region of the image.\n   *   let c = get(0, 0, 50, 50);\n   *\n   *   // Display the region.\n   *   image(c, 50, 50);\n   *\n   *   describe('A mountain landscape drawn on top of another mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method get\n   * @return {p5.Image}      whole canvas as a <a href=\"#/p5.Image\">p5.Image</a>.\n   */\n  /**\n   * @method get\n   * @param  {Number}        x\n   * @param  {Number}        y\n   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.\n   */\n  fn.get = function (x, y, w, h) {\n    // p5._validateParameters('get', arguments);\n    return this._renderer.get(...arguments);\n  };\n\n  /**\n   * Loads the current value of each pixel on the canvas into the\n   * <a href=\"#/p5/pixels\">pixels</a> array.\n   *\n   * `loadPixels()` must be called before reading from or writing to\n   * <a href=\"#/p5/pixels\">pixels</a>.\n   *\n   * @method loadPixels\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0, 100, 100);\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Copy the top half of the canvas to the bottom.\n   *   for (let i = 0; i < halfImage; i += 1) {\n   *     pixels[i + halfImage] = pixels[i];\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Two identical images of mountain landscapes, one on top of the other.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.loadPixels = function (...args) {\n    // p5._validateParameters('loadPixels', args);\n    this._renderer.loadPixels();\n  };\n\n  /**\n   * Sets the color of a pixel or draws an image to the canvas.\n   *\n   * `set()` is easy to use but it's not as fast as\n   * <a href=\"#/p5/pixels\">pixels</a>. Use <a href=\"#/p5/pixels\">pixels</a>\n   * to set many pixel values.\n   *\n   * `set()` interprets the first two parameters as x- and y-coordinates. It\n   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel\n   * array, a <a href=\"#/p5.Color\">p5.Color</a> object, or a\n   * <a href=\"#/p5.Image\">p5.Image</a> object. If an image is passed, the first\n   * two parameters set the coordinates for the image's upper-left corner,\n   * regardless of the current <a href=\"#/p5/imageMode\">imageMode()</a>.\n   *\n   * <a href=\"#/p5/updatePixels\">updatePixels()</a> must be called after using\n   * `set()` for changes to appear.\n   *\n   * @method set\n   * @param {Number}              x x-coordinate of the pixel.\n   * @param {Number}              y y-coordinate of the pixel.\n   * @param {Number|Number[]|Object} c grayscale value | pixel array |\n   *                                <a href=\"#/p5.Color\">p5.Color</a> object | <a href=\"#/p5.Image\">p5.Image</a> to copy.\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set four pixels to black.\n   *   set(30, 20, 0);\n   *   set(85, 20, 0);\n   *   set(85, 75, 0);\n   *   set(30, 75, 0);\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Color object.\n   *   let black = color(0);\n   *\n   *   // Set four pixels to black.\n   *   set(30, 20, black);\n   *   set(85, 20, black);\n   *   set(85, 75, black);\n   *   set(30, 75, black);\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(255);\n   *\n   *   // Draw a horizontal color gradient.\n   *   for (let x = 0; x < 100; x += 1) {\n   *     for (let y = 0; y < 100; y += 1) {\n   *       // Calculate the grayscale value.\n   *       let c = map(x, 0, 100, 0, 255);\n   *\n   *       // Set the pixel using the grayscale value.\n   *       set(x, y, c);\n   *     }\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A horiztonal color gradient from black to white.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the image to set all pixels.\n   *   set(0, 0, img);\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('An image of a mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.set = function (x, y, imgOrCol) {\n    this._renderer.set(x, y, imgOrCol);\n  };\n\n  /**\n   * Updates the canvas with the RGBA values in the\n   * <a href=\"#/p5/pixels\">pixels</a> array.\n   *\n   * `updatePixels()` only needs to be called after changing values in the\n   * <a href=\"#/p5/pixels\">pixels</a> array. Such changes can be made directly\n   * after calling <a href=\"#/p5/loadPixels\">loadPixels()</a> or by calling\n   * <a href=\"#/p5/set\">set()</a>.\n   *\n   * @method updatePixels\n   * @param  {Number} [x]    x-coordinate of the upper-left corner of region\n   *                         to update.\n   * @param  {Number} [y]    y-coordinate of the upper-left corner of region\n   *                         to update.\n   * @param  {Number} [w]    width of region to update.\n   * @param  {Number} [h]    height of region to update.\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0, 100, 100);\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Copy the top half of the canvas to the bottom.\n   *   for (let i = 0; i < halfImage; i += 1) {\n   *     pixels[i + halfImage] = pixels[i];\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Two identical images of mountain landscapes, one on top of the other.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.updatePixels = function (x, y, w, h) {\n    // p5._validateParameters('updatePixels', arguments);\n    // graceful fail - if loadPixels() or set() has not been called, pixel\n    // array will be empty, ignore call to updatePixels()\n    if (this.pixels.length === 0) {\n      return;\n    }\n    this._renderer.updatePixels(x, y, w, h);\n  };\n}\nif (typeof p5 !== 'undefined') {\n  pixels(p5, p5.prototype);\n}\nexport { pixels as default };","map":{"version":3,"names":["Filters","pixels","p5","fn","blend","args","_renderer","Renderer2D","prototype","apply","copy","srcImage","sx","sy","sw","sh","dx","dy","dw","dh","length","Error","_copyHelper","dstImage","s","canvas","width","sxMod","syMod","isP3D","height","push","resetMatrix","noLights","blendMode","BLEND","imageMode","CORNER","image","pop","drawingContext","drawImage","getFilterGraphicsLayer","filter","shader","operation","value","useWebGL","parseFilterArgs","undefined","elt","console","warn","filterRenderer","setOperation","applyFilter","result","Shader","get","x","y","w","h","arguments","loadPixels","set","imgOrCol","updatePixels","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/image/pixels.js"],"sourcesContent":["import Filters from './filters.js';\n\n/**\n * @module Image\n * @submodule Pixels\n * @for p5\n * @requires core\n */\n\n\nfunction pixels(p5, fn){\n  /**\n   * An array containing the color of each pixel on the canvas.\n   *\n   * Colors are stored as numbers representing red, green, blue, and alpha\n   * (RGBA) values. `pixels` is a one-dimensional array for performance reasons.\n   *\n   * Each pixel occupies four elements in the `pixels` array, one for each RGBA\n   * value. For example, the pixel at coordinates (0, 0) stores its RGBA values\n   * at `pixels[0]`, `pixels[1]`, `pixels[2]`, and `pixels[3]`, respectively.\n   * The next pixel at coordinates (1, 0) stores its RGBA values at `pixels[4]`,\n   * `pixels[5]`, `pixels[6]`, and `pixels[7]`. And so on. The `pixels` array\n   * for a 100&times;100 canvas has 100 &times; 100 &times; 4 = 40,000 elements.\n   *\n   * Some displays use several smaller pixels to set the color at a single\n   * point. The <a href=\"#/p5/pixelDensity\">pixelDensity()</a> function returns\n   * the pixel density of the canvas. High density displays often have a\n   * <a href=\"#/p5/pixelDensity\">pixelDensity()</a> of 2. On such a display, the\n   * `pixels` array for a 100&times;100 canvas has 200 &times; 200 &times; 4 =\n   * 160,000 elements.\n   *\n   * Accessing the RGBA values for a point on the canvas requires a little math\n   * as shown below. The <a href=\"#/p5/loadPixels\">loadPixels()</a> function\n   * must be called before accessing the `pixels` array. The\n   * <a href=\"#/p5/updatePixels\">updatePixels()</a> function must be called\n   * after any changes are made.\n   *\n   * @property {Number[]} pixels\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(128);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Set the dot's coordinates.\n   *   let x = 50;\n   *   let y = 50;\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Set the pixel(s) at the center of the canvas black.\n   *   for (let i = 0; i < d; i += 1) {\n   *     for (let j = 0; j < d; j += 1) {\n   *       let index = 4 * ((y * d + j) * width * d + (x * d + i));\n   *       // Red.\n   *       pixels[index] = 0;\n   *       // Green.\n   *       pixels[index + 1] = 0;\n   *       // Blue.\n   *       pixels[index + 2] = 0;\n   *       // Alpha.\n   *       pixels[index + 3] = 255;\n   *     }\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A black dot in the middle of a gray rectangle.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Make the top half of the canvas red.\n   *   for (let i = 0; i < halfImage; i += 4) {\n   *     // Red.\n   *     pixels[i] = 255;\n   *     // Green.\n   *     pixels[i + 1] = 0;\n   *     // Blue.\n   *     pixels[i + 2] = 0;\n   *     // Alpha.\n   *     pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A red rectangle drawn above a gray rectangle.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   // Create a p5.Color object.\n   *   let pink = color(255, 102, 204);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Make the top half of the canvas red.\n   *   for (let i = 0; i < halfImage; i += 4) {\n   *     pixels[i] = red(pink);\n   *     pixels[i + 1] = green(pink);\n   *     pixels[i + 2] = blue(pink);\n   *     pixels[i + 3] = alpha(pink);\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A pink rectangle drawn above a gray rectangle.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * Copies a region of pixels from one image to another.\n   *\n   * The first parameter, `srcImage`, is the\n   * <a href=\"#/p5.Image\">p5.Image</a> object to blend.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to blend from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the regions width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the regions width and height.\n   *\n   * The tenth parameter, `blendMode`, sets the effect used to blend the images'\n   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,\n   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,\n   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`\n   *\n   * @method blend\n   * @param  {p5.Image} srcImage source image.\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either\n   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,\n   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,\n   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img0;\n   * let img1;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   img0 = await loadImage('assets/rockies.jpg');\n   *   img1 = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img0);\n   *\n   *   // Display the bricks.\n   *   image(img1, 0, 0);\n   *\n   *   // Display the bricks faded into the landscape.\n   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img0;\n   * let img1;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   img0 = await loadImage('assets/rockies.jpg');\n   *   img1 = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img0);\n   *\n   *   // Display the bricks.\n   *   image(img1, 0, 0);\n   *\n   *   // Display the bricks partially transparent.\n   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img0;\n   * let img1;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   img0 = await loadImage('assets/rockies.jpg');\n   *   img1 = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img0);\n   *\n   *   // Display the bricks.\n   *   image(img1, 0, 0);\n   *\n   *   // Display the bricks washed out into the landscape.\n   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, ADD);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method blend\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode\n   */\n  fn.blend = function(...args) {\n    // p5._validateParameters('blend', args);\n    if (this._renderer) {\n      this._renderer.blend(...args);\n    } else {\n      p5.Renderer2D.prototype.blend.apply(this, args);\n    }\n  };\n\n  /**\n   * Copies pixels from a source image to a region of the canvas.\n   *\n   * The first parameter, `srcImage`, is the\n   * <a href=\"#/p5.Image\">p5.Image</a> object to blend. The source image can be\n   * the canvas itself or a\n   * <a href=\"#/p5.Image\">p5.Image</a> object. `copy()` will scale pixels from\n   * the source region if it isn't the same size as the destination region.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to copy from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the region's width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of the canvas to copy into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the region's width and height.\n   *\n   * @method copy\n   * @param  {p5.Image|p5.Element} srcImage source image.\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the mountains as the background.\n   *   background(img);\n   *\n   *   // Copy a region of pixels to another spot.\n   *   copy(img, 7, 22, 10, 10, 35, 25, 50, 50);\n   *\n   *   // Outline the copied region.\n   *   stroke(255);\n   *   noFill();\n   *   square(7, 22, 10);\n   *\n   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method copy\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   */\n  fn.copy = function(...args) {\n    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;\n    if (args.length === 9) {\n      srcImage = args[0];\n      sx = args[1];\n      sy = args[2];\n      sw = args[3];\n      sh = args[4];\n      dx = args[5];\n      dy = args[6];\n      dw = args[7];\n      dh = args[8];\n    } else if (args.length === 8) {\n      srcImage = this;\n      sx = args[0];\n      sy = args[1];\n      sw = args[2];\n      sh = args[3];\n      dx = args[4];\n      dy = args[5];\n      dw = args[6];\n      dh = args[7];\n    } else {\n      throw new Error('Signature not supported');\n    }\n\n    fn._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);\n  };\n\n  fn._copyHelper = (\n    dstImage,\n    srcImage,\n    sx,\n    sy,\n    sw,\n    sh,\n    dx,\n    dy,\n    dw,\n    dh\n  ) => {\n    const s = srcImage.canvas.width / srcImage.width;\n    // adjust coord system for 3D when renderer\n    // ie top-left = -width/2, -height/2\n    let sxMod = 0;\n    let syMod = 0;\n    if (srcImage._renderer && srcImage._renderer.isP3D) {\n      sxMod = srcImage.width / 2;\n      syMod = srcImage.height / 2;\n    }\n    if (dstImage._renderer && dstImage._renderer.isP3D) {\n      dstImage.push();\n      dstImage.resetMatrix();\n      dstImage.noLights();\n      dstImage.blendMode(dstImage.BLEND);\n      dstImage.imageMode(dstImage.CORNER);\n      dstImage._renderer.image(\n        srcImage,\n        sx + sxMod,\n        sy + syMod,\n        sw,\n        sh,\n        dx,\n        dy,\n        dw,\n        dh\n      );\n      dstImage.pop();\n    } else {\n      dstImage.drawingContext.drawImage(\n        srcImage.canvas,\n        s * (sx + sxMod),\n        s * (sy + syMod),\n        s * sw,\n        s * sh,\n        dx,\n        dy,\n        dw,\n        dh\n      );\n    }\n  };\n\n  /**\n   * Applies an image filter to the canvas.\n   *\n   * The preset options are:\n   *\n   * `INVERT`\n   * Inverts the colors in the image. No parameter is used.\n   *\n   * `GRAY`\n   * Converts the image to grayscale. No parameter is used.\n   *\n   * `THRESHOLD`\n   * Converts the image to black and white. Pixels with a grayscale value\n   * above a given threshold are converted to white. The rest are converted to\n   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no\n   * value is specified, 0.5 is used.\n   *\n   * `OPAQUE`\n   * Sets the alpha channel to entirely opaque. No parameter is used.\n   *\n   * `POSTERIZE`\n   * Limits the number of colors in the image. Each color channel is limited to\n   * the number of colors specified. Values between 2 and 255 are valid, but\n   * results are most noticeable with lower values. The default value is 4.\n   *\n   * `BLUR`\n   * Blurs the image. The level of blurring is specified by a blur radius. Larger\n   * values increase the blur. The default value is 4. A gaussian blur is used\n   * in `P2D` mode. A box blur is used in `WEBGL` mode.\n   *\n   * `ERODE`\n   * Reduces the light areas. No parameter is used.\n   *\n   * `DILATE`\n   * Increases the light areas. No parameter is used.\n   *\n   * `filter()` uses WebGL in the background by default because it's faster.\n   * This can be disabled in `P2D` mode by adding a `false` argument, as in\n   * `filter(BLUR, false)`. This may be useful to keep computation off the GPU\n   * or to work around a lack of WebGL support.\n   *\n   * In WebgL mode, `filter()` can also use custom shaders. See\n   * <a href=\"#/p5/createFilterShader\">createFilterShader()</a> for more\n   * information.\n   *\n   *\n   * @method filter\n   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,\n   *                                POSTERIZE, BLUR, ERODE, DILATE or BLUR.\n   * @param  {Number} [filterParam] parameter unique to each filter.\n   * @param  {Boolean} [useWebGL=true]   flag to control whether to use fast\n   *                                WebGL filters (GPU) or original image\n   *                                filters (CPU); defaults to `true`.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the INVERT filter.\n   *   filter(INVERT);\n   *\n   *   describe('A blue brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the GRAY filter.\n   *   filter(GRAY);\n   *\n   *   describe('A brick wall drawn in grayscale.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the THRESHOLD filter.\n   *   filter(THRESHOLD);\n   *\n   *   describe('A brick wall drawn in black and white.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the OPAQUE filter.\n   *   filter(OPAQUE);\n   *\n   *   describe('A red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the POSTERIZE filter.\n   *   filter(POSTERIZE, 3);\n   *\n   *   describe('An image of a red brick wall drawn with limited color palette.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the BLUR filter.\n   *   filter(BLUR, 3);\n   *\n   *   describe('A blurry image of a red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the DILATE filter.\n   *   filter(DILATE);\n   *\n   *   describe('A red brick wall with bright lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the ERODE filter.\n   *   filter(ERODE);\n   *\n   *   describe('A red brick wall with faint lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Apply the BLUR filter.\n   *   // Don't use WebGL.\n   *   filter(BLUR, 3, false);\n   *\n   *   describe('A blurry image of a red brick wall.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method getFilterGraphicsLayer\n   * @private\n   * @returns {p5.Graphics}\n   */\n  fn.getFilterGraphicsLayer = function() {\n    return this._renderer.getFilterGraphicsLayer();\n  };\n\n  /**\n   * @method filter\n   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR)} filterType\n   * @param  {Number} [filterParam]\n   * @param  {Boolean} [useWebGL=true]\n   */\n  /**\n   * @method filter\n   * @param {p5.Shader}  shaderFilter  shader that's been loaded, with the\n   *                                   frag shader using a `tex0` uniform.\n   */\n  fn.filter = function(...args) {\n    // p5._validateParameters('filter', args);\n\n    let { shader, operation, value, useWebGL } = parseFilterArgs(...args);\n\n    // when passed a shader, use it directly\n    if (this._renderer.isP3D && shader) {\n      this._renderer.filter(shader);\n      return;\n    }\n\n    // when opting out of webgl, use old pixels method\n    if (!useWebGL && !this._renderer.isP3D) {\n      if (this.canvas !== undefined) {\n        Filters.apply(this.canvas, Filters[operation], value);\n      } else {\n        Filters.apply(this.elt, Filters[operation], value);\n      }\n      return;\n    }\n\n    if(!useWebGL && this._renderer.isP3D) {\n      console.warn('filter() with useWebGL=false is not supported in WEBGL');\n    }\n\n    // when this is a webgl renderer, apply constant shader filter\n    if (this._renderer.isP3D) {\n      this._renderer.filter(operation, value);\n    }\n\n    // when this is P2D renderer, create/use hidden webgl renderer\n    else {\n\n      if (shader) {\n        this._renderer.filterRenderer.setOperation(operation, value, shader);\n      } else {\n        this._renderer.filterRenderer.setOperation(operation, value);\n      }\n\n      this._renderer.filterRenderer.applyFilter();\n    }\n  };\n\n  function parseFilterArgs(...args) {\n    // args could be:\n    // - operation, value, [useWebGL]\n    // - operation, [useWebGL]\n    // - shader\n\n    let result = {\n      shader: undefined,\n      operation: undefined,\n      value: undefined,\n      useWebGL: true\n    };\n\n    if (args[0] instanceof p5.Shader) {\n      result.shader = args[0];\n      return result;\n    }\n    else {\n      result.operation = args[0];\n    }\n\n    if (args.length > 1 && typeof args[1] === 'number') {\n      result.value = args[1];\n    }\n\n    if (args[args.length-1] === false) {\n      result.useWebGL = false;\n    }\n    return result;\n  }\n\n  /**\n   * Gets a pixel or a region of pixels from the canvas.\n   *\n   * `get()` is easy to use but it's not as fast as\n   * <a href=\"#/p5/pixels\">pixels</a>. Use <a href=\"#/p5/pixels\">pixels</a>\n   * to read many pixel values.\n   *\n   * The version of `get()` with no parameters returns the entire canvas.\n   *\n   * The version of `get()` with two parameters interprets them as\n   * coordinates. It returns an array with the `[R, G, B, A]` values of the\n   * pixel at the given point.\n   *\n   * The version of `get()` with four parameters interprets them as coordinates\n   * and dimensions. It returns a subsection of the canvas as a\n   * <a href=\"#/p5.Image\">p5.Image</a> object. The first two parameters are the\n   * coordinates for the upper-left corner of the subsection. The last two\n   * parameters are the width and height of the subsection.\n   *\n   * Use <a href=\"#/p5.Image/get\">p5.Image.get()</a> to work directly with\n   * <a href=\"#/p5.Image\">p5.Image</a> objects.\n   *\n   * @method get\n   * @param  {Number}         x x-coordinate of the pixel.\n   * @param  {Number}         y y-coordinate of the pixel.\n   * @param  {Number}         w width of the subsection to be returned.\n   * @param  {Number}         h height of the subsection to be returned.\n   * @return {p5.Image}       subsection as a <a href=\"#/p5.Image\">p5.Image</a> object.\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get the entire canvas.\n   *   let c = get();\n   *\n   *   // Display half the canvas.\n   *   image(c, 50, 0);\n   *\n   *   describe('Two identical mountain landscapes shown side-by-side.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get the color of a pixel.\n   *   let c = get(50, 90);\n   *\n   *   // Style the square with the pixel's color.\n   *   fill(c);\n   *   noStroke();\n   *\n   *   // Display the square.\n   *   square(25, 25, 50);\n   *\n   *   describe('A mountain landscape with an olive green square in its center.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get a region of the image.\n   *   let c = get(0, 0, 50, 50);\n   *\n   *   // Display the region.\n   *   image(c, 50, 50);\n   *\n   *   describe('A mountain landscape drawn on top of another mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method get\n   * @return {p5.Image}      whole canvas as a <a href=\"#/p5.Image\">p5.Image</a>.\n   */\n  /**\n   * @method get\n   * @param  {Number}        x\n   * @param  {Number}        y\n   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.\n   */\n  fn.get = function(x, y, w, h) {\n    // p5._validateParameters('get', arguments);\n    return this._renderer.get(...arguments);\n  };\n\n  /**\n   * Loads the current value of each pixel on the canvas into the\n   * <a href=\"#/p5/pixels\">pixels</a> array.\n   *\n   * `loadPixels()` must be called before reading from or writing to\n   * <a href=\"#/p5/pixels\">pixels</a>.\n   *\n   * @method loadPixels\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0, 100, 100);\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Copy the top half of the canvas to the bottom.\n   *   for (let i = 0; i < halfImage; i += 1) {\n   *     pixels[i + halfImage] = pixels[i];\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Two identical images of mountain landscapes, one on top of the other.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.loadPixels = function(...args) {\n    // p5._validateParameters('loadPixels', args);\n    this._renderer.loadPixels();\n  };\n\n  /**\n   * Sets the color of a pixel or draws an image to the canvas.\n   *\n   * `set()` is easy to use but it's not as fast as\n   * <a href=\"#/p5/pixels\">pixels</a>. Use <a href=\"#/p5/pixels\">pixels</a>\n   * to set many pixel values.\n   *\n   * `set()` interprets the first two parameters as x- and y-coordinates. It\n   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel\n   * array, a <a href=\"#/p5.Color\">p5.Color</a> object, or a\n   * <a href=\"#/p5.Image\">p5.Image</a> object. If an image is passed, the first\n   * two parameters set the coordinates for the image's upper-left corner,\n   * regardless of the current <a href=\"#/p5/imageMode\">imageMode()</a>.\n   *\n   * <a href=\"#/p5/updatePixels\">updatePixels()</a> must be called after using\n   * `set()` for changes to appear.\n   *\n   * @method set\n   * @param {Number}              x x-coordinate of the pixel.\n   * @param {Number}              y y-coordinate of the pixel.\n   * @param {Number|Number[]|Object} c grayscale value | pixel array |\n   *                                <a href=\"#/p5.Color\">p5.Color</a> object | <a href=\"#/p5.Image\">p5.Image</a> to copy.\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set four pixels to black.\n   *   set(30, 20, 0);\n   *   set(85, 20, 0);\n   *   set(85, 75, 0);\n   *   set(30, 75, 0);\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Color object.\n   *   let black = color(0);\n   *\n   *   // Set four pixels to black.\n   *   set(30, 20, black);\n   *   set(85, 20, black);\n   *   set(85, 75, black);\n   *   set(30, 75, black);\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(255);\n   *\n   *   // Draw a horizontal color gradient.\n   *   for (let x = 0; x < 100; x += 1) {\n   *     for (let y = 0; y < 100; y += 1) {\n   *       // Calculate the grayscale value.\n   *       let c = map(x, 0, 100, 0, 255);\n   *\n   *       // Set the pixel using the grayscale value.\n   *       set(x, y, c);\n   *     }\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('A horiztonal color gradient from black to white.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Use the image to set all pixels.\n   *   set(0, 0, img);\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('An image of a mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.set = function(x, y, imgOrCol) {\n    this._renderer.set(x, y, imgOrCol);\n  };\n\n  /**\n   * Updates the canvas with the RGBA values in the\n   * <a href=\"#/p5/pixels\">pixels</a> array.\n   *\n   * `updatePixels()` only needs to be called after changing values in the\n   * <a href=\"#/p5/pixels\">pixels</a> array. Such changes can be made directly\n   * after calling <a href=\"#/p5/loadPixels\">loadPixels()</a> or by calling\n   * <a href=\"#/p5/set\">set()</a>.\n   *\n   * @method updatePixels\n   * @param  {Number} [x]    x-coordinate of the upper-left corner of region\n   *                         to update.\n   * @param  {Number} [y]    y-coordinate of the upper-left corner of region\n   *                         to update.\n   * @param  {Number} [w]    width of region to update.\n   * @param  {Number} [h]    height of region to update.\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0, 100, 100);\n   *\n   *   // Get the pixel density.\n   *   let d = pixelDensity();\n   *\n   *   // Calculate the halfway index in the pixels array.\n   *   let halfImage = 4 * (d * width) * (d * height / 2);\n   *\n   *   // Load the pixels array.\n   *   loadPixels();\n   *\n   *   // Copy the top half of the canvas to the bottom.\n   *   for (let i = 0; i < halfImage; i += 1) {\n   *     pixels[i + halfImage] = pixels[i];\n   *   }\n   *\n   *   // Update the canvas.\n   *   updatePixels();\n   *\n   *   describe('Two identical images of mountain landscapes, one on top of the other.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.updatePixels = function(x, y, w, h) {\n    // p5._validateParameters('updatePixels', arguments);\n    // graceful fail - if loadPixels() or set() has not been called, pixel\n    // array will be empty, ignore call to updatePixels()\n    if (this.pixels.length === 0) {\n      return;\n    }\n    this._renderer.updatePixels(x, y, w, h);\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  pixels(p5, p5.prototype);\n}\n\nexport { pixels as default };\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,cAAc;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASC,MAAMA,CAACC,EAAE,EAAEC,EAAE,EAAC;EACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEA,EAAE,CAACC,KAAK,GAAG,UAAS,GAAGC,IAAI,EAAE;IAC3B;IACA,IAAI,IAAI,CAACC,SAAS,EAAE;MAClB,IAAI,CAACA,SAAS,CAACF,KAAK,CAAC,GAAGC,IAAI,CAAC;IAC/B,CAAC,MAAM;MACLH,EAAE,CAACK,UAAU,CAACC,SAAS,CAACJ,KAAK,CAACK,KAAK,CAAC,IAAI,EAAEJ,IAAI,CAAC;IACjD;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEF,EAAE,CAACO,IAAI,GAAG,UAAS,GAAGL,IAAI,EAAE;IAC1B,IAAIM,QAAQ,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;IAC5C,IAAId,IAAI,CAACe,MAAM,KAAK,CAAC,EAAE;MACrBT,QAAQ,GAAGN,IAAI,CAAC,CAAC,CAAC;MAClBO,EAAE,GAAGP,IAAI,CAAC,CAAC,CAAC;MACZQ,EAAE,GAAGR,IAAI,CAAC,CAAC,CAAC;MACZS,EAAE,GAAGT,IAAI,CAAC,CAAC,CAAC;MACZU,EAAE,GAAGV,IAAI,CAAC,CAAC,CAAC;MACZW,EAAE,GAAGX,IAAI,CAAC,CAAC,CAAC;MACZY,EAAE,GAAGZ,IAAI,CAAC,CAAC,CAAC;MACZa,EAAE,GAAGb,IAAI,CAAC,CAAC,CAAC;MACZc,EAAE,GAAGd,IAAI,CAAC,CAAC,CAAC;IACd,CAAC,MAAM,IAAIA,IAAI,CAACe,MAAM,KAAK,CAAC,EAAE;MAC5BT,QAAQ,GAAG,IAAI;MACfC,EAAE,GAAGP,IAAI,CAAC,CAAC,CAAC;MACZQ,EAAE,GAAGR,IAAI,CAAC,CAAC,CAAC;MACZS,EAAE,GAAGT,IAAI,CAAC,CAAC,CAAC;MACZU,EAAE,GAAGV,IAAI,CAAC,CAAC,CAAC;MACZW,EAAE,GAAGX,IAAI,CAAC,CAAC,CAAC;MACZY,EAAE,GAAGZ,IAAI,CAAC,CAAC,CAAC;MACZa,EAAE,GAAGb,IAAI,CAAC,CAAC,CAAC;MACZc,EAAE,GAAGd,IAAI,CAAC,CAAC,CAAC;IACd,CAAC,MAAM;MACL,MAAM,IAAIgB,KAAK,CAAC,yBAAyB,CAAC;IAC5C;IAEAlB,EAAE,CAACmB,WAAW,CAAC,IAAI,EAAEX,QAAQ,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;EAChE,CAAC;EAEDhB,EAAE,CAACmB,WAAW,GAAG,CACfC,QAAQ,EACRZ,QAAQ,EACRC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,KACC;IACH,MAAMK,CAAC,GAAGb,QAAQ,CAACc,MAAM,CAACC,KAAK,GAAGf,QAAQ,CAACe,KAAK;IAChD;IACA;IACA,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIjB,QAAQ,CAACL,SAAS,IAAIK,QAAQ,CAACL,SAAS,CAACuB,KAAK,EAAE;MAClDF,KAAK,GAAGhB,QAAQ,CAACe,KAAK,GAAG,CAAC;MAC1BE,KAAK,GAAGjB,QAAQ,CAACmB,MAAM,GAAG,CAAC;IAC7B;IACA,IAAIP,QAAQ,CAACjB,SAAS,IAAIiB,QAAQ,CAACjB,SAAS,CAACuB,KAAK,EAAE;MAClDN,QAAQ,CAACQ,IAAI,CAAC,CAAC;MACfR,QAAQ,CAACS,WAAW,CAAC,CAAC;MACtBT,QAAQ,CAACU,QAAQ,CAAC,CAAC;MACnBV,QAAQ,CAACW,SAAS,CAACX,QAAQ,CAACY,KAAK,CAAC;MAClCZ,QAAQ,CAACa,SAAS,CAACb,QAAQ,CAACc,MAAM,CAAC;MACnCd,QAAQ,CAACjB,SAAS,CAACgC,KAAK,CACtB3B,QAAQ,EACRC,EAAE,GAAGe,KAAK,EACVd,EAAE,GAAGe,KAAK,EACVd,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EACF,CAAC;MACDI,QAAQ,CAACgB,GAAG,CAAC,CAAC;IAChB,CAAC,MAAM;MACLhB,QAAQ,CAACiB,cAAc,CAACC,SAAS,CAC/B9B,QAAQ,CAACc,MAAM,EACfD,CAAC,IAAIZ,EAAE,GAAGe,KAAK,CAAC,EAChBH,CAAC,IAAIX,EAAE,GAAGe,KAAK,CAAC,EAChBJ,CAAC,GAAGV,EAAE,EACNU,CAAC,GAAGT,EAAE,EACNC,EAAE,EACFC,EAAE,EACFC,EAAE,EACFC,EACF,CAAC;IACH;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;EACEhB,EAAE,CAACuC,sBAAsB,GAAG,YAAW;IACrC,OAAO,IAAI,CAACpC,SAAS,CAACoC,sBAAsB,CAAC,CAAC;EAChD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;EACEvC,EAAE,CAACwC,MAAM,GAAG,UAAS,GAAGtC,IAAI,EAAE;IAC5B;;IAEA,IAAI;MAAEuC,MAAM;MAAEC,SAAS;MAAEC,KAAK;MAAEC;IAAS,CAAC,GAAGC,eAAe,CAAC,GAAG3C,IAAI,CAAC;;IAErE;IACA,IAAI,IAAI,CAACC,SAAS,CAACuB,KAAK,IAAIe,MAAM,EAAE;MAClC,IAAI,CAACtC,SAAS,CAACqC,MAAM,CAACC,MAAM,CAAC;MAC7B;IACF;;IAEA;IACA,IAAI,CAACG,QAAQ,IAAI,CAAC,IAAI,CAACzC,SAAS,CAACuB,KAAK,EAAE;MACtC,IAAI,IAAI,CAACJ,MAAM,KAAKwB,SAAS,EAAE;QAC7BjD,OAAO,CAACS,KAAK,CAAC,IAAI,CAACgB,MAAM,EAAEzB,OAAO,CAAC6C,SAAS,CAAC,EAAEC,KAAK,CAAC;MACvD,CAAC,MAAM;QACL9C,OAAO,CAACS,KAAK,CAAC,IAAI,CAACyC,GAAG,EAAElD,OAAO,CAAC6C,SAAS,CAAC,EAAEC,KAAK,CAAC;MACpD;MACA;IACF;IAEA,IAAG,CAACC,QAAQ,IAAI,IAAI,CAACzC,SAAS,CAACuB,KAAK,EAAE;MACpCsB,OAAO,CAACC,IAAI,CAAC,wDAAwD,CAAC;IACxE;;IAEA;IACA,IAAI,IAAI,CAAC9C,SAAS,CAACuB,KAAK,EAAE;MACxB,IAAI,CAACvB,SAAS,CAACqC,MAAM,CAACE,SAAS,EAAEC,KAAK,CAAC;IACzC;;IAEA;IAAA,KACK;MAEH,IAAIF,MAAM,EAAE;QACV,IAAI,CAACtC,SAAS,CAAC+C,cAAc,CAACC,YAAY,CAACT,SAAS,EAAEC,KAAK,EAAEF,MAAM,CAAC;MACtE,CAAC,MAAM;QACL,IAAI,CAACtC,SAAS,CAAC+C,cAAc,CAACC,YAAY,CAACT,SAAS,EAAEC,KAAK,CAAC;MAC9D;MAEA,IAAI,CAACxC,SAAS,CAAC+C,cAAc,CAACE,WAAW,CAAC,CAAC;IAC7C;EACF,CAAC;EAED,SAASP,eAAeA,CAAC,GAAG3C,IAAI,EAAE;IAChC;IACA;IACA;IACA;;IAEA,IAAImD,MAAM,GAAG;MACXZ,MAAM,EAAEK,SAAS;MACjBJ,SAAS,EAAEI,SAAS;MACpBH,KAAK,EAAEG,SAAS;MAChBF,QAAQ,EAAE;IACZ,CAAC;IAED,IAAI1C,IAAI,CAAC,CAAC,CAAC,YAAYH,EAAE,CAACuD,MAAM,EAAE;MAChCD,MAAM,CAACZ,MAAM,GAAGvC,IAAI,CAAC,CAAC,CAAC;MACvB,OAAOmD,MAAM;IACf,CAAC,MACI;MACHA,MAAM,CAACX,SAAS,GAAGxC,IAAI,CAAC,CAAC,CAAC;IAC5B;IAEA,IAAIA,IAAI,CAACe,MAAM,GAAG,CAAC,IAAI,OAAOf,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MAClDmD,MAAM,CAACV,KAAK,GAAGzC,IAAI,CAAC,CAAC,CAAC;IACxB;IAEA,IAAIA,IAAI,CAACA,IAAI,CAACe,MAAM,GAAC,CAAC,CAAC,KAAK,KAAK,EAAE;MACjCoC,MAAM,CAACT,QAAQ,GAAG,KAAK;IACzB;IACA,OAAOS,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;EACErD,EAAE,CAACuD,GAAG,GAAG,UAASC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IAC5B;IACA,OAAO,IAAI,CAACxD,SAAS,CAACoD,GAAG,CAAC,GAAGK,SAAS,CAAC;EACzC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE5D,EAAE,CAAC6D,UAAU,GAAG,UAAS,GAAG3D,IAAI,EAAE;IAChC;IACA,IAAI,CAACC,SAAS,CAAC0D,UAAU,CAAC,CAAC;EAC7B,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE7D,EAAE,CAAC8D,GAAG,GAAG,UAASN,CAAC,EAAEC,CAAC,EAAEM,QAAQ,EAAE;IAChC,IAAI,CAAC5D,SAAS,CAAC2D,GAAG,CAACN,CAAC,EAAEC,CAAC,EAAEM,QAAQ,CAAC;EACpC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE/D,EAAE,CAACgE,YAAY,GAAG,UAASR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IACrC;IACA;IACA;IACA,IAAI,IAAI,CAAC7D,MAAM,CAACmB,MAAM,KAAK,CAAC,EAAE;MAC5B;IACF;IACA,IAAI,CAACd,SAAS,CAAC6D,YAAY,CAACR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;EACzC,CAAC;AACH;AAEA,IAAG,OAAO5D,EAAE,KAAK,WAAW,EAAC;EAC3BD,MAAM,CAACC,EAAE,EAAEA,EAAE,CAACM,SAAS,CAAC;AAC1B;AAEA,SAASP,MAAM,IAAImE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}