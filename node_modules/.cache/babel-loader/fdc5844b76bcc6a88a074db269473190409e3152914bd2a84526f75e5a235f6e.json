{"ast":null,"code":"import { e as CORNER, i as CORNERS, a as RADIUS, C as CENTER } from '../constants-BRcElHU3.js';\n\n/**\n * @requires constants\n */\n\n/*\n  This function normalizes the first four arguments given to rect, ellipse and arc\n  according to the mode.\n  It returns a 'bounding box' object containing the coordinates of the upper left corner (x, y),\n  and width and height (w, h). The returned width and height are always positive.\n*/\nfunction modeAdjust(a, b, c, d, mode) {\n  let bbox;\n  if (mode === CORNER) {\n    // CORNER mode already corresponds to a bounding box (top-left corner, width, height).\n    // For negative widhts or heights, the absolute value is used.\n    bbox = {\n      x: a,\n      y: b,\n      w: Math.abs(c),\n      h: Math.abs(d)\n    };\n  } else if (mode === CORNERS) {\n    // CORNERS mode uses two opposite corners, in any configuration.\n    // Make sure to get the top left corner by using the minimum of the x and y coordniates.\n    bbox = {\n      x: Math.min(a, c),\n      y: Math.min(b, d),\n      w: Math.abs(c - a),\n      h: Math.abs(d - b)\n    };\n  } else if (mode === RADIUS) {\n    // RADIUS mode uses the center point and half the width and height.\n    // c (half width) and d (half height) could be negative, so use the absolute value\n    // in calculating the top left corner (x, y).\n    c = Math.abs(c);\n    d = Math.abs(d);\n    bbox = {\n      x: a - c,\n      y: b - d,\n      w: 2 * c,\n      h: 2 * d\n    };\n  } else if (mode === CENTER) {\n    // CENTER mode uses the center point, width and height.\n    // c (width) and d (height) could be negative, so use the absolute value\n    // in calculating the top-left corner (x, y).\n    c = Math.abs(c);\n    d = Math.abs(d);\n    bbox = {\n      x: a - c * 0.5,\n      y: b - d * 0.5,\n      w: c,\n      h: d\n    };\n  }\n  return bbox;\n}\nvar canvas = {\n  modeAdjust\n};\nexport { canvas as default };","map":{"version":3,"names":["e","CORNER","i","CORNERS","a","RADIUS","C","CENTER","modeAdjust","b","c","d","mode","bbox","x","y","w","Math","abs","h","min","canvas","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/core/helpers.js"],"sourcesContent":["import { e as CORNER, i as CORNERS, a as RADIUS, C as CENTER } from '../constants-BRcElHU3.js';\n\n/**\n * @requires constants\n */\n\n\n/*\n  This function normalizes the first four arguments given to rect, ellipse and arc\n  according to the mode.\n  It returns a 'bounding box' object containing the coordinates of the upper left corner (x, y),\n  and width and height (w, h). The returned width and height are always positive.\n*/\nfunction modeAdjust(a, b, c, d, mode) {\n  let bbox;\n\n  if (mode === CORNER) {\n\n    // CORNER mode already corresponds to a bounding box (top-left corner, width, height).\n    // For negative widhts or heights, the absolute value is used.\n    bbox = {\n      x: a,\n      y: b,\n      w: Math.abs(c),\n      h: Math.abs(d)\n    };\n\n  } else if (mode === CORNERS) {\n\n    // CORNERS mode uses two opposite corners, in any configuration.\n    // Make sure to get the top left corner by using the minimum of the x and y coordniates.\n    bbox = {\n      x: Math.min(a, c),\n      y: Math.min(b, d),\n      w: Math.abs(c - a),\n      h: Math.abs(d - b)\n    };\n\n  } else if (mode === RADIUS) {\n\n    // RADIUS mode uses the center point and half the width and height.\n    // c (half width) and d (half height) could be negative, so use the absolute value\n    // in calculating the top left corner (x, y).\n    c = Math.abs(c);\n    d = Math.abs(d);\n    bbox = {\n      x: a - c,\n      y: b - d,\n      w: 2 * c,\n      h: 2 * d\n    };\n\n  } else if (mode === CENTER) {\n\n    // CENTER mode uses the center point, width and height.\n    // c (width) and d (height) could be negative, so use the absolute value\n    // in calculating the top-left corner (x, y).\n    c = Math.abs(c);\n    d = Math.abs(d);\n    bbox = {\n      x: a - (c * 0.5),\n      y: b - (d * 0.5),\n      w: c,\n      h: d\n    };\n\n  }\n\n  return bbox;\n}\n\nvar canvas = { modeAdjust };\n\nexport { canvas as default };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,MAAM,EAAEC,CAAC,IAAIC,OAAO,EAAEC,CAAC,IAAIC,MAAM,EAAEC,CAAC,IAAIC,MAAM,QAAQ,0BAA0B;;AAE9F;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACJ,CAAC,EAAEK,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,IAAI,EAAE;EACpC,IAAIC,IAAI;EAER,IAAID,IAAI,KAAKX,MAAM,EAAE;IAEnB;IACA;IACAY,IAAI,GAAG;MACLC,CAAC,EAAEV,CAAC;MACJW,CAAC,EAAEN,CAAC;MACJO,CAAC,EAAEC,IAAI,CAACC,GAAG,CAACR,CAAC,CAAC;MACdS,CAAC,EAAEF,IAAI,CAACC,GAAG,CAACP,CAAC;IACf,CAAC;EAEH,CAAC,MAAM,IAAIC,IAAI,KAAKT,OAAO,EAAE;IAE3B;IACA;IACAU,IAAI,GAAG;MACLC,CAAC,EAAEG,IAAI,CAACG,GAAG,CAAChB,CAAC,EAAEM,CAAC,CAAC;MACjBK,CAAC,EAAEE,IAAI,CAACG,GAAG,CAACX,CAAC,EAAEE,CAAC,CAAC;MACjBK,CAAC,EAAEC,IAAI,CAACC,GAAG,CAACR,CAAC,GAAGN,CAAC,CAAC;MAClBe,CAAC,EAAEF,IAAI,CAACC,GAAG,CAACP,CAAC,GAAGF,CAAC;IACnB,CAAC;EAEH,CAAC,MAAM,IAAIG,IAAI,KAAKP,MAAM,EAAE;IAE1B;IACA;IACA;IACAK,CAAC,GAAGO,IAAI,CAACC,GAAG,CAACR,CAAC,CAAC;IACfC,CAAC,GAAGM,IAAI,CAACC,GAAG,CAACP,CAAC,CAAC;IACfE,IAAI,GAAG;MACLC,CAAC,EAAEV,CAAC,GAAGM,CAAC;MACRK,CAAC,EAAEN,CAAC,GAAGE,CAAC;MACRK,CAAC,EAAE,CAAC,GAAGN,CAAC;MACRS,CAAC,EAAE,CAAC,GAAGR;IACT,CAAC;EAEH,CAAC,MAAM,IAAIC,IAAI,KAAKL,MAAM,EAAE;IAE1B;IACA;IACA;IACAG,CAAC,GAAGO,IAAI,CAACC,GAAG,CAACR,CAAC,CAAC;IACfC,CAAC,GAAGM,IAAI,CAACC,GAAG,CAACP,CAAC,CAAC;IACfE,IAAI,GAAG;MACLC,CAAC,EAAEV,CAAC,GAAIM,CAAC,GAAG,GAAI;MAChBK,CAAC,EAAEN,CAAC,GAAIE,CAAC,GAAG,GAAI;MAChBK,CAAC,EAAEN,CAAC;MACJS,CAAC,EAAER;IACL,CAAC;EAEH;EAEA,OAAOE,IAAI;AACb;AAEA,IAAIQ,MAAM,GAAG;EAAEb;AAAW,CAAC;AAE3B,SAASa,MAAM,IAAIC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}