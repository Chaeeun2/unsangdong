{"ast":null,"code":"import { type, parseCoordGrammar, serializeNumber, mapRange } from \"./util.js\";\nimport { getWhite } from \"./adapt.js\";\nimport hooks from \"./hooks.js\";\nimport getColor from \"./getColor.js\";\nconst ε = .000075;\n\n/**\n * Class to represent a color space\n */\nexport default class ColorSpace {\n  constructor(options) {\n    this.id = options.id;\n    this.name = options.name;\n    this.base = options.base ? ColorSpace.get(options.base) : null;\n    this.aliases = options.aliases;\n    if (this.base) {\n      this.fromBase = options.fromBase;\n      this.toBase = options.toBase;\n    }\n\n    // Coordinate metadata\n\n    let coords = options.coords ?? this.base.coords;\n    for (let name in coords) {\n      if (!(\"name\" in coords[name])) {\n        coords[name].name = name;\n      }\n    }\n    this.coords = coords;\n\n    // White point\n\n    let white = options.white ?? this.base.white ?? \"D65\";\n    this.white = getWhite(white);\n\n    // Sort out formats\n\n    this.formats = options.formats ?? {};\n    for (let name in this.formats) {\n      let format = this.formats[name];\n      format.type ||= \"function\";\n      format.name ||= name;\n    }\n    if (!this.formats.color?.id) {\n      this.formats.color = {\n        ...(this.formats.color ?? {}),\n        id: options.cssId || this.id\n      };\n    }\n\n    // Gamut space\n\n    if (options.gamutSpace) {\n      // Gamut space explicitly specified\n      this.gamutSpace = options.gamutSpace === \"self\" ? this : ColorSpace.get(options.gamutSpace);\n    } else {\n      // No gamut space specified, calculate a sensible default\n      if (this.isPolar) {\n        // Do not check gamut through polar coordinates\n        this.gamutSpace = this.base;\n      } else {\n        this.gamutSpace = this;\n      }\n    }\n\n    // Optimize inGamut for unbounded spaces\n    if (this.gamutSpace.isUnbounded) {\n      this.inGamut = (coords, options) => {\n        return true;\n      };\n    }\n\n    // Other stuff\n    this.referred = options.referred;\n\n    // Compute ancestors and store them, since they will never change\n    Object.defineProperty(this, \"path\", {\n      value: getPath(this).reverse(),\n      writable: false,\n      enumerable: true,\n      configurable: true\n    });\n    hooks.run(\"colorspace-init-end\", this);\n  }\n  inGamut(coords, {\n    epsilon = ε\n  } = {}) {\n    if (!this.equals(this.gamutSpace)) {\n      coords = this.to(this.gamutSpace, coords);\n      return this.gamutSpace.inGamut(coords, {\n        epsilon\n      });\n    }\n    let coordMeta = Object.values(this.coords);\n    return coords.every((c, i) => {\n      let meta = coordMeta[i];\n      if (meta.type !== \"angle\" && meta.range) {\n        if (Number.isNaN(c)) {\n          // NaN is always in gamut\n          return true;\n        }\n        let [min, max] = meta.range;\n        return (min === undefined || c >= min - epsilon) && (max === undefined || c <= max + epsilon);\n      }\n      return true;\n    });\n  }\n  get isUnbounded() {\n    return Object.values(this.coords).every(coord => !(\"range\" in coord));\n  }\n  get cssId() {\n    return this.formats?.color?.id || this.id;\n  }\n  get isPolar() {\n    for (let id in this.coords) {\n      if (this.coords[id].type === \"angle\") {\n        return true;\n      }\n    }\n    return false;\n  }\n  getFormat(format) {\n    if (typeof format === \"object\") {\n      format = processFormat(format, this);\n      return format;\n    }\n    let ret;\n    if (format === \"default\") {\n      // Get first format\n      ret = Object.values(this.formats)[0];\n    } else {\n      ret = this.formats[format];\n    }\n    if (ret) {\n      ret = processFormat(ret, this);\n      return ret;\n    }\n    return null;\n  }\n\n  /**\n   * Check if this color space is the same as another color space reference.\n   * Allows proxying color space objects and comparing color spaces with ids.\n   * @param {string | ColorSpace} space ColorSpace object or id to compare to\n   * @returns {boolean}\n   */\n  equals(space) {\n    if (!space) {\n      return false;\n    }\n    return this === space || this.id === space || this.id === space.id;\n  }\n  to(space, coords) {\n    if (arguments.length === 1) {\n      const color = getColor(space);\n      [space, coords] = [color.space, color.coords];\n    }\n    space = ColorSpace.get(space);\n    if (this.equals(space)) {\n      // Same space, no change needed\n      return coords;\n    }\n\n    // Convert NaN to 0, which seems to be valid in every coordinate of every color space\n    coords = coords.map(c => Number.isNaN(c) ? 0 : c);\n\n    // Find connection space = lowest common ancestor in the base tree\n    let myPath = this.path;\n    let otherPath = space.path;\n    let connectionSpace, connectionSpaceIndex;\n    for (let i = 0; i < myPath.length; i++) {\n      if (myPath[i].equals(otherPath[i])) {\n        connectionSpace = myPath[i];\n        connectionSpaceIndex = i;\n      } else {\n        break;\n      }\n    }\n    if (!connectionSpace) {\n      // This should never happen\n      throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);\n    }\n\n    // Go up from current space to connection space\n    for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {\n      coords = myPath[i].toBase(coords);\n    }\n\n    // Go down from connection space to target space\n    for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {\n      coords = otherPath[i].fromBase(coords);\n    }\n    return coords;\n  }\n  from(space, coords) {\n    if (arguments.length === 1) {\n      const color = getColor(space);\n      [space, coords] = [color.space, color.coords];\n    }\n    space = ColorSpace.get(space);\n    return space.to(this, coords);\n  }\n  toString() {\n    return `${this.name} (${this.id})`;\n  }\n  getMinCoords() {\n    let ret = [];\n    for (let id in this.coords) {\n      let meta = this.coords[id];\n      let range = meta.range || meta.refRange;\n      ret.push(range?.min ?? 0);\n    }\n    return ret;\n  }\n  static registry = {};\n\n  // Returns array of unique color spaces\n  static get all() {\n    return [...new Set(Object.values(ColorSpace.registry))];\n  }\n  static register(id, space) {\n    if (arguments.length === 1) {\n      space = arguments[0];\n      id = space.id;\n    }\n    space = this.get(space);\n    if (this.registry[id] && this.registry[id] !== space) {\n      throw new Error(`Duplicate color space registration: '${id}'`);\n    }\n    this.registry[id] = space;\n\n    // Register aliases when called without an explicit ID.\n    if (arguments.length === 1 && space.aliases) {\n      for (let alias of space.aliases) {\n        this.register(alias, space);\n      }\n    }\n    return space;\n  }\n\n  /**\n   * Lookup ColorSpace object by name\n   * @param {ColorSpace | string} name\n   */\n  static get(space, ...alternatives) {\n    if (!space || space instanceof ColorSpace) {\n      return space;\n    }\n    let argType = type(space);\n    if (argType === \"string\") {\n      // It's a color space id\n      let ret = ColorSpace.registry[space.toLowerCase()];\n      if (!ret) {\n        throw new TypeError(`No color space found with id = \"${space}\"`);\n      }\n      return ret;\n    }\n    if (alternatives.length) {\n      return ColorSpace.get(...alternatives);\n    }\n    throw new TypeError(`${space} is not a valid color space`);\n  }\n\n  /**\n   * Get metadata about a coordinate of a color space\n   *\n   * @static\n   * @param {Array | string} ref\n   * @param {ColorSpace | string} [workingSpace]\n   * @return {Object}\n   */\n  static resolveCoord(ref, workingSpace) {\n    let coordType = type(ref);\n    let space, coord;\n    if (coordType === \"string\") {\n      if (ref.includes(\".\")) {\n        // Absolute coordinate\n        [space, coord] = ref.split(\".\");\n      } else {\n        // Relative coordinate\n        [space, coord] = [, ref];\n      }\n    } else if (Array.isArray(ref)) {\n      [space, coord] = ref;\n    } else {\n      // Object\n      space = ref.space;\n      coord = ref.coordId;\n    }\n    space = ColorSpace.get(space);\n    if (!space) {\n      space = workingSpace;\n    }\n    if (!space) {\n      throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);\n    }\n    coordType = type(coord);\n    if (coordType === \"number\" || coordType === \"string\" && coord >= 0) {\n      // Resolve numerical coord\n      let meta = Object.entries(space.coords)[coord];\n      if (meta) {\n        return {\n          space,\n          id: meta[0],\n          index: coord,\n          ...meta[1]\n        };\n      }\n    }\n    space = ColorSpace.get(space);\n    let normalizedCoord = coord.toLowerCase();\n    let i = 0;\n    for (let id in space.coords) {\n      let meta = space.coords[id];\n      if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {\n        return {\n          space,\n          id,\n          index: i,\n          ...meta\n        };\n      }\n      i++;\n    }\n    throw new TypeError(`No \"${coord}\" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(\", \")}`);\n  }\n  static DEFAULT_FORMAT = {\n    type: \"functions\",\n    name: \"color\"\n  };\n}\nfunction getPath(space) {\n  let ret = [space];\n  for (let s = space; s = s.base;) {\n    ret.push(s);\n  }\n  return ret;\n}\nfunction processFormat(format, {\n  coords\n} = {}) {\n  if (format.coords && !format.coordGrammar) {\n    format.type ||= \"function\";\n    format.name ||= \"color\";\n\n    // Format has not been processed\n    format.coordGrammar = parseCoordGrammar(format.coords);\n    let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {\n      // Preferred format for each coord is the first one\n      let outputType = format.coordGrammar[i][0];\n      let fromRange = coordMeta.range || coordMeta.refRange;\n      let toRange = outputType.range,\n        suffix = \"\";\n\n      // Non-strict equals intentional since outputType could be a string object\n      if (outputType == \"<percentage>\") {\n        toRange = [0, 100];\n        suffix = \"%\";\n      } else if (outputType == \"<angle>\") {\n        suffix = \"deg\";\n      }\n      return {\n        fromRange,\n        toRange,\n        suffix\n      };\n    });\n    format.serializeCoords = (coords, precision) => {\n      return coords.map((c, i) => {\n        let {\n          fromRange,\n          toRange,\n          suffix\n        } = coordFormats[i];\n        if (fromRange && toRange) {\n          c = mapRange(fromRange, toRange, c);\n        }\n        c = serializeNumber(c, {\n          precision,\n          unit: suffix\n        });\n        return c;\n      });\n    };\n  }\n  return format;\n}","map":{"version":3,"names":["type","parseCoordGrammar","serializeNumber","mapRange","getWhite","hooks","getColor","ε","ColorSpace","constructor","options","id","name","base","get","aliases","fromBase","toBase","coords","white","formats","format","color","cssId","gamutSpace","isPolar","isUnbounded","inGamut","referred","Object","defineProperty","value","getPath","reverse","writable","enumerable","configurable","run","epsilon","equals","to","coordMeta","values","every","c","i","meta","range","Number","isNaN","min","max","undefined","coord","getFormat","processFormat","ret","space","arguments","length","map","myPath","path","otherPath","connectionSpace","connectionSpaceIndex","Error","from","toString","getMinCoords","refRange","push","registry","all","Set","register","alias","alternatives","argType","toLowerCase","TypeError","resolveCoord","ref","workingSpace","coordType","includes","split","Array","isArray","coordId","entries","index","normalizedCoord","keys","join","DEFAULT_FORMAT","s","coordGrammar","coordFormats","outputType","fromRange","toRange","suffix","serializeCoords","precision","unit"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/space.js"],"sourcesContent":["import {type, parseCoordGrammar, serializeNumber, mapRange} from \"./util.js\";\nimport {getWhite} from \"./adapt.js\";\nimport hooks from \"./hooks.js\";\nimport getColor from \"./getColor.js\";\n\nconst ε = .000075;\n\n/**\n * Class to represent a color space\n */\nexport default class ColorSpace {\n\tconstructor (options) {\n\t\tthis.id = options.id;\n\t\tthis.name = options.name;\n\t\tthis.base = options.base ? ColorSpace.get(options.base) : null;\n\t\tthis.aliases = options.aliases;\n\n\t\tif (this.base) {\n\t\t\tthis.fromBase = options.fromBase;\n\t\t\tthis.toBase = options.toBase;\n\t\t}\n\n\t\t// Coordinate metadata\n\n\t\tlet coords = options.coords ?? this.base.coords;\n\n\t\tfor (let name in coords) {\n\t\t\tif (!(\"name\" in coords[name])) {\n\t\t\t\tcoords[name].name = name;\n\t\t\t}\n\t\t}\n\t\tthis.coords = coords;\n\n\t\t// White point\n\n\t\tlet white = options.white ?? this.base.white ?? \"D65\";\n\t\tthis.white = getWhite(white);\n\n\t\t// Sort out formats\n\n\t\tthis.formats = options.formats ?? {};\n\n\t\tfor (let name in this.formats) {\n\t\t\tlet format = this.formats[name];\n\t\t\tformat.type ||= \"function\";\n\t\t\tformat.name ||= name;\n\t\t}\n\n\t\tif (!this.formats.color?.id) {\n\t\t\tthis.formats.color = {\n\t\t\t\t...this.formats.color ?? {},\n\t\t\t\tid: options.cssId || this.id,\n\t\t\t};\n\t\t}\n\n\t\t// Gamut space\n\n\t\tif (options.gamutSpace) {\n\t\t\t// Gamut space explicitly specified\n\t\t\tthis.gamutSpace = options.gamutSpace === \"self\" ? this : ColorSpace.get(options.gamutSpace);\n\t\t}\n\t\telse {\n\t\t\t// No gamut space specified, calculate a sensible default\n\t\t\tif (this.isPolar) {\n\t\t\t\t// Do not check gamut through polar coordinates\n\t\t\t\tthis.gamutSpace = this.base;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.gamutSpace =  this;\n\t\t\t}\n\t\t}\n\n\t\t// Optimize inGamut for unbounded spaces\n\t\tif (this.gamutSpace.isUnbounded) {\n\t\t\tthis.inGamut = (coords, options) => {\n\t\t\t\treturn true;\n\t\t\t};\n\t\t}\n\n\t\t// Other stuff\n\t\tthis.referred = options.referred;\n\n\t\t// Compute ancestors and store them, since they will never change\n\t\tObject.defineProperty(this, \"path\", {\n\t\t\tvalue: getPath(this).reverse(),\n\t\t\twritable: false,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t});\n\n\t\thooks.run(\"colorspace-init-end\", this);\n\t}\n\n\tinGamut (coords, {epsilon = ε} = {}) {\n\t\tif (!this.equals(this.gamutSpace)) {\n\t\t\tcoords = this.to(this.gamutSpace, coords);\n\t\t\treturn this.gamutSpace.inGamut(coords, {epsilon});\n\t\t}\n\n\t\tlet coordMeta = Object.values(this.coords);\n\n\t\treturn coords.every((c, i) => {\n\t\t\tlet meta = coordMeta[i];\n\n\t\t\tif (meta.type !== \"angle\" && meta.range) {\n\t\t\t\tif (Number.isNaN(c)) {\n\t\t\t\t\t// NaN is always in gamut\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tlet [min, max] = meta.range;\n\t\t\t\treturn (min === undefined || c >= min - epsilon)\n\t\t\t\t    && (max === undefined || c <= max + epsilon);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\tget isUnbounded () {\n\t\treturn Object.values(this.coords).every(coord => !(\"range\" in coord));\n\t}\n\n\tget cssId () {\n\t\treturn this.formats?.color?.id || this.id;\n\t}\n\n\tget isPolar () {\n\t\tfor (let id in this.coords) {\n\t\t\tif (this.coords[id].type === \"angle\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetFormat (format) {\n\t\tif (typeof format === \"object\") {\n\t\t\tformat = processFormat(format, this);\n\t\t\treturn format;\n\t\t}\n\n\t\tlet ret;\n\t\tif (format === \"default\") {\n\t\t\t// Get first format\n\t\t\tret = Object.values(this.formats)[0];\n\t\t}\n\t\telse {\n\t\t\tret = this.formats[format];\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret = processFormat(ret, this);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check if this color space is the same as another color space reference.\n\t * Allows proxying color space objects and comparing color spaces with ids.\n\t * @param {string | ColorSpace} space ColorSpace object or id to compare to\n\t * @returns {boolean}\n\t */\n\tequals (space) {\n\t\tif (!space) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this === space || this.id === space || this.id === space.id;\n\t}\n\n\tto (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\tconst color = getColor(space);\n\t\t\t[space, coords] = [color.space, color.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (this.equals(space)) {\n\t\t\t// Same space, no change needed\n\t\t\treturn coords;\n\t\t}\n\n\t\t// Convert NaN to 0, which seems to be valid in every coordinate of every color space\n\t\tcoords = coords.map(c => Number.isNaN(c) ? 0 : c);\n\n\t\t// Find connection space = lowest common ancestor in the base tree\n\t\tlet myPath = this.path;\n\t\tlet otherPath = space.path;\n\n\t\tlet connectionSpace, connectionSpaceIndex;\n\n\t\tfor (let i = 0; i < myPath.length; i++) {\n\t\t\tif (myPath[i].equals(otherPath[i])) {\n\t\t\t\tconnectionSpace = myPath[i];\n\t\t\t\tconnectionSpaceIndex = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!connectionSpace) {\n\t\t\t// This should never happen\n\t\t\tthrow new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);\n\t\t}\n\n\t\t// Go up from current space to connection space\n\t\tfor (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {\n\t\t\tcoords = myPath[i].toBase(coords);\n\t\t}\n\n\t\t// Go down from connection space to target space\n\t\tfor (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {\n\t\t\tcoords = otherPath[i].fromBase(coords);\n\t\t}\n\n\t\treturn coords;\n\t}\n\n\tfrom (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\tconst color = getColor(space);\n\t\t\t[space, coords] = [color.space, color.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\treturn space.to(this, coords);\n\t}\n\n\ttoString () {\n\t\treturn `${this.name} (${this.id})`;\n\t}\n\n\tgetMinCoords () {\n\t\tlet ret = [];\n\n\t\tfor (let id in this.coords) {\n\t\t\tlet meta = this.coords[id];\n\t\t\tlet range = meta.range || meta.refRange;\n\t\t\tret.push(range?.min ?? 0);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic registry = {};\n\n\t// Returns array of unique color spaces\n\tstatic get all () {\n\t\treturn [...new Set(Object.values(ColorSpace.registry))];\n\t}\n\n\tstatic register (id, space) {\n\t\tif (arguments.length === 1) {\n\t\t\tspace = arguments[0];\n\t\t\tid = space.id;\n\t\t}\n\n\t\tspace = this.get(space);\n\n\t\tif (this.registry[id] && this.registry[id] !== space) {\n\t\t\tthrow new Error(`Duplicate color space registration: '${id}'`);\n\t\t}\n\t\tthis.registry[id] = space;\n\n\t\t// Register aliases when called without an explicit ID.\n\t\tif (arguments.length === 1 && space.aliases) {\n\t\t\tfor (let alias of space.aliases) {\n\t\t\t\tthis.register(alias, space);\n\t\t\t}\n\t\t}\n\n\t\treturn space;\n\t}\n\n\t/**\n\t * Lookup ColorSpace object by name\n\t * @param {ColorSpace | string} name\n\t */\n\tstatic get (space, ...alternatives) {\n\t\tif (!space || space instanceof ColorSpace) {\n\t\t\treturn space;\n\t\t}\n\n\t\tlet argType = type(space);\n\n\t\tif (argType === \"string\") {\n\t\t\t// It's a color space id\n\t\t\tlet ret = ColorSpace.registry[space.toLowerCase()];\n\n\t\t\tif (!ret) {\n\t\t\t\tthrow new TypeError(`No color space found with id = \"${space}\"`);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (alternatives.length) {\n\t\t\treturn ColorSpace.get(...alternatives);\n\t\t}\n\n\t\tthrow new TypeError(`${space} is not a valid color space`);\n\t}\n\n\t/**\n\t * Get metadata about a coordinate of a color space\n\t *\n\t * @static\n\t * @param {Array | string} ref\n\t * @param {ColorSpace | string} [workingSpace]\n\t * @return {Object}\n\t */\n\tstatic resolveCoord (ref, workingSpace) {\n\t\tlet coordType = type(ref);\n\t\tlet space, coord;\n\n\t\tif (coordType === \"string\") {\n\t\t\tif (ref.includes(\".\")) {\n\t\t\t\t// Absolute coordinate\n\t\t\t\t[space, coord] = ref.split(\".\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Relative coordinate\n\t\t\t\t[space, coord] = [, ref];\n\t\t\t}\n\t\t}\n\t\telse if (Array.isArray(ref)) {\n\t\t\t[space, coord] = ref;\n\t\t}\n\t\telse {\n\t\t\t// Object\n\t\t\tspace = ref.space;\n\t\t\tcoord = ref.coordId;\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (!space) {\n\t\t\tspace = workingSpace;\n\t\t}\n\n\t\tif (!space) {\n\t\t\tthrow new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);\n\t\t}\n\n\t\tcoordType = type(coord);\n\n\t\tif (coordType === \"number\" || coordType === \"string\" && coord >= 0) {\n\t\t\t// Resolve numerical coord\n\t\t\tlet meta = Object.entries(space.coords)[coord];\n\n\t\t\tif (meta) {\n\t\t\t\treturn {space, id: meta[0], index: coord, ...meta[1]};\n\t\t\t}\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tlet normalizedCoord = coord.toLowerCase();\n\n\t\tlet i = 0;\n\t\tfor (let id in space.coords) {\n\t\t\tlet meta = space.coords[id];\n\n\t\t\tif (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {\n\t\t\t\treturn {space, id, index: i, ...meta};\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tthrow new TypeError(`No \"${coord}\" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(\", \")}`);\n\t}\n\n\tstatic DEFAULT_FORMAT = {\n\t\ttype: \"functions\",\n\t\tname: \"color\",\n\t};\n}\n\nfunction getPath (space) {\n\tlet ret = [space];\n\n\tfor (let s = space; s = s.base;) {\n\t\tret.push(s);\n\t}\n\n\treturn ret;\n}\n\nfunction processFormat (format, {coords} = {}) {\n\tif (format.coords && !format.coordGrammar) {\n\t\tformat.type ||= \"function\";\n\t\tformat.name ||= \"color\";\n\n\t\t// Format has not been processed\n\t\tformat.coordGrammar = parseCoordGrammar(format.coords);\n\n\t\tlet coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {\n\t\t\t// Preferred format for each coord is the first one\n\t\t\tlet outputType = format.coordGrammar[i][0];\n\n\t\t\tlet fromRange = coordMeta.range || coordMeta.refRange;\n\t\t\tlet toRange = outputType.range, suffix = \"\";\n\n\t\t\t// Non-strict equals intentional since outputType could be a string object\n\t\t\tif (outputType == \"<percentage>\") {\n\t\t\t\ttoRange = [0, 100];\n\t\t\t\tsuffix = \"%\";\n\t\t\t}\n\t\t\telse if (outputType == \"<angle>\") {\n\t\t\t\tsuffix = \"deg\";\n\t\t\t}\n\n\t\t\treturn  {fromRange, toRange, suffix};\n\t\t});\n\n\t\tformat.serializeCoords = (coords, precision) => {\n\t\t\treturn coords.map((c, i) => {\n\t\t\t\tlet {fromRange, toRange, suffix} = coordFormats[i];\n\n\t\t\t\tif (fromRange && toRange) {\n\t\t\t\t\tc = mapRange(fromRange, toRange, c);\n\t\t\t\t}\n\n\t\t\t\tc = serializeNumber(c, {precision, unit: suffix});\n\n\t\t\t\treturn c;\n\t\t\t});\n\t\t};\n\t}\n\n\treturn format;\n}\n"],"mappings":"AAAA,SAAQA,IAAI,EAAEC,iBAAiB,EAAEC,eAAe,EAAEC,QAAQ,QAAO,WAAW;AAC5E,SAAQC,QAAQ,QAAO,YAAY;AACnC,OAAOC,KAAK,MAAM,YAAY;AAC9B,OAAOC,QAAQ,MAAM,eAAe;AAEpC,MAAMC,CAAC,GAAG,OAAO;;AAEjB;AACA;AACA;AACA,eAAe,MAAMC,UAAU,CAAC;EAC/BC,WAAWA,CAAEC,OAAO,EAAE;IACrB,IAAI,CAACC,EAAE,GAAGD,OAAO,CAACC,EAAE;IACpB,IAAI,CAACC,IAAI,GAAGF,OAAO,CAACE,IAAI;IACxB,IAAI,CAACC,IAAI,GAAGH,OAAO,CAACG,IAAI,GAAGL,UAAU,CAACM,GAAG,CAACJ,OAAO,CAACG,IAAI,CAAC,GAAG,IAAI;IAC9D,IAAI,CAACE,OAAO,GAAGL,OAAO,CAACK,OAAO;IAE9B,IAAI,IAAI,CAACF,IAAI,EAAE;MACd,IAAI,CAACG,QAAQ,GAAGN,OAAO,CAACM,QAAQ;MAChC,IAAI,CAACC,MAAM,GAAGP,OAAO,CAACO,MAAM;IAC7B;;IAEA;;IAEA,IAAIC,MAAM,GAAGR,OAAO,CAACQ,MAAM,IAAI,IAAI,CAACL,IAAI,CAACK,MAAM;IAE/C,KAAK,IAAIN,IAAI,IAAIM,MAAM,EAAE;MACxB,IAAI,EAAE,MAAM,IAAIA,MAAM,CAACN,IAAI,CAAC,CAAC,EAAE;QAC9BM,MAAM,CAACN,IAAI,CAAC,CAACA,IAAI,GAAGA,IAAI;MACzB;IACD;IACA,IAAI,CAACM,MAAM,GAAGA,MAAM;;IAEpB;;IAEA,IAAIC,KAAK,GAAGT,OAAO,CAACS,KAAK,IAAI,IAAI,CAACN,IAAI,CAACM,KAAK,IAAI,KAAK;IACrD,IAAI,CAACA,KAAK,GAAGf,QAAQ,CAACe,KAAK,CAAC;;IAE5B;;IAEA,IAAI,CAACC,OAAO,GAAGV,OAAO,CAACU,OAAO,IAAI,CAAC,CAAC;IAEpC,KAAK,IAAIR,IAAI,IAAI,IAAI,CAACQ,OAAO,EAAE;MAC9B,IAAIC,MAAM,GAAG,IAAI,CAACD,OAAO,CAACR,IAAI,CAAC;MAC/BS,MAAM,CAACrB,IAAI,KAAK,UAAU;MAC1BqB,MAAM,CAACT,IAAI,KAAKA,IAAI;IACrB;IAEA,IAAI,CAAC,IAAI,CAACQ,OAAO,CAACE,KAAK,EAAEX,EAAE,EAAE;MAC5B,IAAI,CAACS,OAAO,CAACE,KAAK,GAAG;QACpB,IAAG,IAAI,CAACF,OAAO,CAACE,KAAK,IAAI,CAAC,CAAC;QAC3BX,EAAE,EAAED,OAAO,CAACa,KAAK,IAAI,IAAI,CAACZ;MAC3B,CAAC;IACF;;IAEA;;IAEA,IAAID,OAAO,CAACc,UAAU,EAAE;MACvB;MACA,IAAI,CAACA,UAAU,GAAGd,OAAO,CAACc,UAAU,KAAK,MAAM,GAAG,IAAI,GAAGhB,UAAU,CAACM,GAAG,CAACJ,OAAO,CAACc,UAAU,CAAC;IAC5F,CAAC,MACI;MACJ;MACA,IAAI,IAAI,CAACC,OAAO,EAAE;QACjB;QACA,IAAI,CAACD,UAAU,GAAG,IAAI,CAACX,IAAI;MAC5B,CAAC,MACI;QACJ,IAAI,CAACW,UAAU,GAAI,IAAI;MACxB;IACD;;IAEA;IACA,IAAI,IAAI,CAACA,UAAU,CAACE,WAAW,EAAE;MAChC,IAAI,CAACC,OAAO,GAAG,CAACT,MAAM,EAAER,OAAO,KAAK;QACnC,OAAO,IAAI;MACZ,CAAC;IACF;;IAEA;IACA,IAAI,CAACkB,QAAQ,GAAGlB,OAAO,CAACkB,QAAQ;;IAEhC;IACAC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE;MACnCC,KAAK,EAAEC,OAAO,CAAC,IAAI,CAAC,CAACC,OAAO,CAAC,CAAC;MAC9BC,QAAQ,EAAE,KAAK;MACfC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE;IACf,CAAC,CAAC;IAEF/B,KAAK,CAACgC,GAAG,CAAC,qBAAqB,EAAE,IAAI,CAAC;EACvC;EAEAV,OAAOA,CAAET,MAAM,EAAE;IAACoB,OAAO,GAAG/B;EAAC,CAAC,GAAG,CAAC,CAAC,EAAE;IACpC,IAAI,CAAC,IAAI,CAACgC,MAAM,CAAC,IAAI,CAACf,UAAU,CAAC,EAAE;MAClCN,MAAM,GAAG,IAAI,CAACsB,EAAE,CAAC,IAAI,CAAChB,UAAU,EAAEN,MAAM,CAAC;MACzC,OAAO,IAAI,CAACM,UAAU,CAACG,OAAO,CAACT,MAAM,EAAE;QAACoB;MAAO,CAAC,CAAC;IAClD;IAEA,IAAIG,SAAS,GAAGZ,MAAM,CAACa,MAAM,CAAC,IAAI,CAACxB,MAAM,CAAC;IAE1C,OAAOA,MAAM,CAACyB,KAAK,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MAC7B,IAAIC,IAAI,GAAGL,SAAS,CAACI,CAAC,CAAC;MAEvB,IAAIC,IAAI,CAAC9C,IAAI,KAAK,OAAO,IAAI8C,IAAI,CAACC,KAAK,EAAE;QACxC,IAAIC,MAAM,CAACC,KAAK,CAACL,CAAC,CAAC,EAAE;UACpB;UACA,OAAO,IAAI;QACZ;QAEA,IAAI,CAACM,GAAG,EAAEC,GAAG,CAAC,GAAGL,IAAI,CAACC,KAAK;QAC3B,OAAO,CAACG,GAAG,KAAKE,SAAS,IAAIR,CAAC,IAAIM,GAAG,GAAGZ,OAAO,MACvCa,GAAG,KAAKC,SAAS,IAAIR,CAAC,IAAIO,GAAG,GAAGb,OAAO,CAAC;MACjD;MAEA,OAAO,IAAI;IACZ,CAAC,CAAC;EACH;EAEA,IAAIZ,WAAWA,CAAA,EAAI;IAClB,OAAOG,MAAM,CAACa,MAAM,CAAC,IAAI,CAACxB,MAAM,CAAC,CAACyB,KAAK,CAACU,KAAK,IAAI,EAAE,OAAO,IAAIA,KAAK,CAAC,CAAC;EACtE;EAEA,IAAI9B,KAAKA,CAAA,EAAI;IACZ,OAAO,IAAI,CAACH,OAAO,EAAEE,KAAK,EAAEX,EAAE,IAAI,IAAI,CAACA,EAAE;EAC1C;EAEA,IAAIc,OAAOA,CAAA,EAAI;IACd,KAAK,IAAId,EAAE,IAAI,IAAI,CAACO,MAAM,EAAE;MAC3B,IAAI,IAAI,CAACA,MAAM,CAACP,EAAE,CAAC,CAACX,IAAI,KAAK,OAAO,EAAE;QACrC,OAAO,IAAI;MACZ;IACD;IAEA,OAAO,KAAK;EACb;EAEAsD,SAASA,CAAEjC,MAAM,EAAE;IAClB,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;MAC/BA,MAAM,GAAGkC,aAAa,CAAClC,MAAM,EAAE,IAAI,CAAC;MACpC,OAAOA,MAAM;IACd;IAEA,IAAImC,GAAG;IACP,IAAInC,MAAM,KAAK,SAAS,EAAE;MACzB;MACAmC,GAAG,GAAG3B,MAAM,CAACa,MAAM,CAAC,IAAI,CAACtB,OAAO,CAAC,CAAC,CAAC,CAAC;IACrC,CAAC,MACI;MACJoC,GAAG,GAAG,IAAI,CAACpC,OAAO,CAACC,MAAM,CAAC;IAC3B;IAEA,IAAImC,GAAG,EAAE;MACRA,GAAG,GAAGD,aAAa,CAACC,GAAG,EAAE,IAAI,CAAC;MAC9B,OAAOA,GAAG;IACX;IAEA,OAAO,IAAI;EACZ;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCjB,MAAMA,CAAEkB,KAAK,EAAE;IACd,IAAI,CAACA,KAAK,EAAE;MACX,OAAO,KAAK;IACb;IAEA,OAAO,IAAI,KAAKA,KAAK,IAAI,IAAI,CAAC9C,EAAE,KAAK8C,KAAK,IAAI,IAAI,CAAC9C,EAAE,KAAK8C,KAAK,CAAC9C,EAAE;EACnE;EAEA6B,EAAEA,CAAEiB,KAAK,EAAEvC,MAAM,EAAE;IAClB,IAAIwC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAC3B,MAAMrC,KAAK,GAAGhB,QAAQ,CAACmD,KAAK,CAAC;MAC7B,CAACA,KAAK,EAAEvC,MAAM,CAAC,GAAG,CAACI,KAAK,CAACmC,KAAK,EAAEnC,KAAK,CAACJ,MAAM,CAAC;IAC9C;IAEAuC,KAAK,GAAGjD,UAAU,CAACM,GAAG,CAAC2C,KAAK,CAAC;IAE7B,IAAI,IAAI,CAAClB,MAAM,CAACkB,KAAK,CAAC,EAAE;MACvB;MACA,OAAOvC,MAAM;IACd;;IAEA;IACAA,MAAM,GAAGA,MAAM,CAAC0C,GAAG,CAAChB,CAAC,IAAII,MAAM,CAACC,KAAK,CAACL,CAAC,CAAC,GAAG,CAAC,GAAGA,CAAC,CAAC;;IAEjD;IACA,IAAIiB,MAAM,GAAG,IAAI,CAACC,IAAI;IACtB,IAAIC,SAAS,GAAGN,KAAK,CAACK,IAAI;IAE1B,IAAIE,eAAe,EAAEC,oBAAoB;IAEzC,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,MAAM,CAACF,MAAM,EAAEd,CAAC,EAAE,EAAE;MACvC,IAAIgB,MAAM,CAAChB,CAAC,CAAC,CAACN,MAAM,CAACwB,SAAS,CAAClB,CAAC,CAAC,CAAC,EAAE;QACnCmB,eAAe,GAAGH,MAAM,CAAChB,CAAC,CAAC;QAC3BoB,oBAAoB,GAAGpB,CAAC;MACzB,CAAC,MACI;QACJ;MACD;IACD;IAEA,IAAI,CAACmB,eAAe,EAAE;MACrB;MACA,MAAM,IAAIE,KAAK,CAAC,uCAAuC,IAAI,QAAQT,KAAK,iCAAiC,CAAC;IAC3G;;IAEA;IACA,KAAK,IAAIZ,CAAC,GAAGgB,MAAM,CAACF,MAAM,GAAG,CAAC,EAAEd,CAAC,GAAGoB,oBAAoB,EAAEpB,CAAC,EAAE,EAAE;MAC9D3B,MAAM,GAAG2C,MAAM,CAAChB,CAAC,CAAC,CAAC5B,MAAM,CAACC,MAAM,CAAC;IAClC;;IAEA;IACA,KAAK,IAAI2B,CAAC,GAAGoB,oBAAoB,GAAG,CAAC,EAAEpB,CAAC,GAAGkB,SAAS,CAACJ,MAAM,EAAEd,CAAC,EAAE,EAAE;MACjE3B,MAAM,GAAG6C,SAAS,CAAClB,CAAC,CAAC,CAAC7B,QAAQ,CAACE,MAAM,CAAC;IACvC;IAEA,OAAOA,MAAM;EACd;EAEAiD,IAAIA,CAAEV,KAAK,EAAEvC,MAAM,EAAE;IACpB,IAAIwC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAC3B,MAAMrC,KAAK,GAAGhB,QAAQ,CAACmD,KAAK,CAAC;MAC7B,CAACA,KAAK,EAAEvC,MAAM,CAAC,GAAG,CAACI,KAAK,CAACmC,KAAK,EAAEnC,KAAK,CAACJ,MAAM,CAAC;IAC9C;IAEAuC,KAAK,GAAGjD,UAAU,CAACM,GAAG,CAAC2C,KAAK,CAAC;IAE7B,OAAOA,KAAK,CAACjB,EAAE,CAAC,IAAI,EAAEtB,MAAM,CAAC;EAC9B;EAEAkD,QAAQA,CAAA,EAAI;IACX,OAAO,GAAG,IAAI,CAACxD,IAAI,KAAK,IAAI,CAACD,EAAE,GAAG;EACnC;EAEA0D,YAAYA,CAAA,EAAI;IACf,IAAIb,GAAG,GAAG,EAAE;IAEZ,KAAK,IAAI7C,EAAE,IAAI,IAAI,CAACO,MAAM,EAAE;MAC3B,IAAI4B,IAAI,GAAG,IAAI,CAAC5B,MAAM,CAACP,EAAE,CAAC;MAC1B,IAAIoC,KAAK,GAAGD,IAAI,CAACC,KAAK,IAAID,IAAI,CAACwB,QAAQ;MACvCd,GAAG,CAACe,IAAI,CAACxB,KAAK,EAAEG,GAAG,IAAI,CAAC,CAAC;IAC1B;IAEA,OAAOM,GAAG;EACX;EAEA,OAAOgB,QAAQ,GAAG,CAAC,CAAC;;EAEpB;EACA,WAAWC,GAAGA,CAAA,EAAI;IACjB,OAAO,CAAC,GAAG,IAAIC,GAAG,CAAC7C,MAAM,CAACa,MAAM,CAAClC,UAAU,CAACgE,QAAQ,CAAC,CAAC,CAAC;EACxD;EAEA,OAAOG,QAAQA,CAAEhE,EAAE,EAAE8C,KAAK,EAAE;IAC3B,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAC3BF,KAAK,GAAGC,SAAS,CAAC,CAAC,CAAC;MACpB/C,EAAE,GAAG8C,KAAK,CAAC9C,EAAE;IACd;IAEA8C,KAAK,GAAG,IAAI,CAAC3C,GAAG,CAAC2C,KAAK,CAAC;IAEvB,IAAI,IAAI,CAACe,QAAQ,CAAC7D,EAAE,CAAC,IAAI,IAAI,CAAC6D,QAAQ,CAAC7D,EAAE,CAAC,KAAK8C,KAAK,EAAE;MACrD,MAAM,IAAIS,KAAK,CAAC,wCAAwCvD,EAAE,GAAG,CAAC;IAC/D;IACA,IAAI,CAAC6D,QAAQ,CAAC7D,EAAE,CAAC,GAAG8C,KAAK;;IAEzB;IACA,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,IAAIF,KAAK,CAAC1C,OAAO,EAAE;MAC5C,KAAK,IAAI6D,KAAK,IAAInB,KAAK,CAAC1C,OAAO,EAAE;QAChC,IAAI,CAAC4D,QAAQ,CAACC,KAAK,EAAEnB,KAAK,CAAC;MAC5B;IACD;IAEA,OAAOA,KAAK;EACb;;EAEA;AACD;AACA;AACA;EACC,OAAO3C,GAAGA,CAAE2C,KAAK,EAAE,GAAGoB,YAAY,EAAE;IACnC,IAAI,CAACpB,KAAK,IAAIA,KAAK,YAAYjD,UAAU,EAAE;MAC1C,OAAOiD,KAAK;IACb;IAEA,IAAIqB,OAAO,GAAG9E,IAAI,CAACyD,KAAK,CAAC;IAEzB,IAAIqB,OAAO,KAAK,QAAQ,EAAE;MACzB;MACA,IAAItB,GAAG,GAAGhD,UAAU,CAACgE,QAAQ,CAACf,KAAK,CAACsB,WAAW,CAAC,CAAC,CAAC;MAElD,IAAI,CAACvB,GAAG,EAAE;QACT,MAAM,IAAIwB,SAAS,CAAC,mCAAmCvB,KAAK,GAAG,CAAC;MACjE;MAEA,OAAOD,GAAG;IACX;IAEA,IAAIqB,YAAY,CAAClB,MAAM,EAAE;MACxB,OAAOnD,UAAU,CAACM,GAAG,CAAC,GAAG+D,YAAY,CAAC;IACvC;IAEA,MAAM,IAAIG,SAAS,CAAC,GAAGvB,KAAK,6BAA6B,CAAC;EAC3D;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACC,OAAOwB,YAAYA,CAAEC,GAAG,EAAEC,YAAY,EAAE;IACvC,IAAIC,SAAS,GAAGpF,IAAI,CAACkF,GAAG,CAAC;IACzB,IAAIzB,KAAK,EAAEJ,KAAK;IAEhB,IAAI+B,SAAS,KAAK,QAAQ,EAAE;MAC3B,IAAIF,GAAG,CAACG,QAAQ,CAAC,GAAG,CAAC,EAAE;QACtB;QACA,CAAC5B,KAAK,EAAEJ,KAAK,CAAC,GAAG6B,GAAG,CAACI,KAAK,CAAC,GAAG,CAAC;MAChC,CAAC,MACI;QACJ;QACA,CAAC7B,KAAK,EAAEJ,KAAK,CAAC,GAAG,GAAG6B,GAAG,CAAC;MACzB;IACD,CAAC,MACI,IAAIK,KAAK,CAACC,OAAO,CAACN,GAAG,CAAC,EAAE;MAC5B,CAACzB,KAAK,EAAEJ,KAAK,CAAC,GAAG6B,GAAG;IACrB,CAAC,MACI;MACJ;MACAzB,KAAK,GAAGyB,GAAG,CAACzB,KAAK;MACjBJ,KAAK,GAAG6B,GAAG,CAACO,OAAO;IACpB;IAEAhC,KAAK,GAAGjD,UAAU,CAACM,GAAG,CAAC2C,KAAK,CAAC;IAE7B,IAAI,CAACA,KAAK,EAAE;MACXA,KAAK,GAAG0B,YAAY;IACrB;IAEA,IAAI,CAAC1B,KAAK,EAAE;MACX,MAAM,IAAIuB,SAAS,CAAC,uCAAuCE,GAAG,yEAAyE,CAAC;IACzI;IAEAE,SAAS,GAAGpF,IAAI,CAACqD,KAAK,CAAC;IAEvB,IAAI+B,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,QAAQ,IAAI/B,KAAK,IAAI,CAAC,EAAE;MACnE;MACA,IAAIP,IAAI,GAAGjB,MAAM,CAAC6D,OAAO,CAACjC,KAAK,CAACvC,MAAM,CAAC,CAACmC,KAAK,CAAC;MAE9C,IAAIP,IAAI,EAAE;QACT,OAAO;UAACW,KAAK;UAAE9C,EAAE,EAAEmC,IAAI,CAAC,CAAC,CAAC;UAAE6C,KAAK,EAAEtC,KAAK;UAAE,GAAGP,IAAI,CAAC,CAAC;QAAC,CAAC;MACtD;IACD;IAEAW,KAAK,GAAGjD,UAAU,CAACM,GAAG,CAAC2C,KAAK,CAAC;IAE7B,IAAImC,eAAe,GAAGvC,KAAK,CAAC0B,WAAW,CAAC,CAAC;IAEzC,IAAIlC,CAAC,GAAG,CAAC;IACT,KAAK,IAAIlC,EAAE,IAAI8C,KAAK,CAACvC,MAAM,EAAE;MAC5B,IAAI4B,IAAI,GAAGW,KAAK,CAACvC,MAAM,CAACP,EAAE,CAAC;MAE3B,IAAIA,EAAE,CAACoE,WAAW,CAAC,CAAC,KAAKa,eAAe,IAAI9C,IAAI,CAAClC,IAAI,EAAEmE,WAAW,CAAC,CAAC,KAAKa,eAAe,EAAE;QACzF,OAAO;UAACnC,KAAK;UAAE9C,EAAE;UAAEgF,KAAK,EAAE9C,CAAC;UAAE,GAAGC;QAAI,CAAC;MACtC;MAEAD,CAAC,EAAE;IACJ;IAEA,MAAM,IAAImC,SAAS,CAAC,OAAO3B,KAAK,yBAAyBI,KAAK,CAAC7C,IAAI,0BAA0BiB,MAAM,CAACgE,IAAI,CAACpC,KAAK,CAACvC,MAAM,CAAC,CAAC4E,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;EACrI;EAEA,OAAOC,cAAc,GAAG;IACvB/F,IAAI,EAAE,WAAW;IACjBY,IAAI,EAAE;EACP,CAAC;AACF;AAEA,SAASoB,OAAOA,CAAEyB,KAAK,EAAE;EACxB,IAAID,GAAG,GAAG,CAACC,KAAK,CAAC;EAEjB,KAAK,IAAIuC,CAAC,GAAGvC,KAAK,EAAEuC,CAAC,GAAGA,CAAC,CAACnF,IAAI,GAAG;IAChC2C,GAAG,CAACe,IAAI,CAACyB,CAAC,CAAC;EACZ;EAEA,OAAOxC,GAAG;AACX;AAEA,SAASD,aAAaA,CAAElC,MAAM,EAAE;EAACH;AAAM,CAAC,GAAG,CAAC,CAAC,EAAE;EAC9C,IAAIG,MAAM,CAACH,MAAM,IAAI,CAACG,MAAM,CAAC4E,YAAY,EAAE;IAC1C5E,MAAM,CAACrB,IAAI,KAAK,UAAU;IAC1BqB,MAAM,CAACT,IAAI,KAAK,OAAO;;IAEvB;IACAS,MAAM,CAAC4E,YAAY,GAAGhG,iBAAiB,CAACoB,MAAM,CAACH,MAAM,CAAC;IAEtD,IAAIgF,YAAY,GAAGrE,MAAM,CAAC6D,OAAO,CAACxE,MAAM,CAAC,CAAC0C,GAAG,CAAC,CAAC,CAACjD,EAAE,EAAE8B,SAAS,CAAC,EAAEI,CAAC,KAAK;MACrE;MACA,IAAIsD,UAAU,GAAG9E,MAAM,CAAC4E,YAAY,CAACpD,CAAC,CAAC,CAAC,CAAC,CAAC;MAE1C,IAAIuD,SAAS,GAAG3D,SAAS,CAACM,KAAK,IAAIN,SAAS,CAAC6B,QAAQ;MACrD,IAAI+B,OAAO,GAAGF,UAAU,CAACpD,KAAK;QAAEuD,MAAM,GAAG,EAAE;;MAE3C;MACA,IAAIH,UAAU,IAAI,cAAc,EAAE;QACjCE,OAAO,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;QAClBC,MAAM,GAAG,GAAG;MACb,CAAC,MACI,IAAIH,UAAU,IAAI,SAAS,EAAE;QACjCG,MAAM,GAAG,KAAK;MACf;MAEA,OAAQ;QAACF,SAAS;QAAEC,OAAO;QAAEC;MAAM,CAAC;IACrC,CAAC,CAAC;IAEFjF,MAAM,CAACkF,eAAe,GAAG,CAACrF,MAAM,EAAEsF,SAAS,KAAK;MAC/C,OAAOtF,MAAM,CAAC0C,GAAG,CAAC,CAAChB,CAAC,EAAEC,CAAC,KAAK;QAC3B,IAAI;UAACuD,SAAS;UAAEC,OAAO;UAAEC;QAAM,CAAC,GAAGJ,YAAY,CAACrD,CAAC,CAAC;QAElD,IAAIuD,SAAS,IAAIC,OAAO,EAAE;UACzBzD,CAAC,GAAGzC,QAAQ,CAACiG,SAAS,EAAEC,OAAO,EAAEzD,CAAC,CAAC;QACpC;QAEAA,CAAC,GAAG1C,eAAe,CAAC0C,CAAC,EAAE;UAAC4D,SAAS;UAAEC,IAAI,EAAEH;QAAM,CAAC,CAAC;QAEjD,OAAO1D,CAAC;MACT,CAAC,CAAC;IACH,CAAC;EACF;EAEA,OAAOvB,MAAM;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}