{"ast":null,"code":"import * as util from \"./util.js\";\nimport hooks from \"./hooks.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\nconst noneTypes = new Set([\"<number>\", \"<percentage>\", \"<angle>\"]);\n\n/**\n * Validates the coordinates of a color against a format's coord grammar and\n * maps the coordinates to the range or refRange of the coordinates.\n * @param {ColorSpace} space - Colorspace the coords are in\n * @param {object} format - the format object to validate against\n * @param {string} name - the name of the color function. e.g. \"oklab\" or \"color\"\n * @returns {object[]} - an array of type metadata for each coordinate\n */\nfunction coerceCoords(space, format, name, coords) {\n  let types = Object.entries(space.coords).map(([id, coordMeta], i) => {\n    let coordGrammar = format.coordGrammar[i];\n    let arg = coords[i];\n    let providedType = arg?.type;\n\n    // Find grammar alternative that matches the provided type\n    // Non-strict equals is intentional because we are comparing w/ string objects\n    let type;\n    if (arg.none) {\n      type = coordGrammar.find(c => noneTypes.has(c));\n    } else {\n      type = coordGrammar.find(c => c == providedType);\n    }\n\n    // Check that each coord conforms to its grammar\n    if (!type) {\n      // Type does not exist in the grammar, throw\n      let coordName = coordMeta.name || id;\n      throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);\n    }\n    let fromRange = type.range;\n    if (providedType === \"<percentage>\") {\n      fromRange ||= [0, 1];\n    }\n    let toRange = coordMeta.range || coordMeta.refRange;\n    if (fromRange && toRange) {\n      coords[i] = util.mapRange(fromRange, toRange, coords[i]);\n    }\n    return type;\n  });\n  return types;\n}\n\n/**\n * Convert a CSS Color string to a color object\n * @param {string} str\n * @param {object} [options]\n * @param {object} [options.meta] - Object for additional information about the parsing\n * @returns {Color}\n */\nexport default function parse(str, {\n  meta\n} = {}) {\n  let env = {\n    \"str\": String(str)?.trim()\n  };\n  hooks.run(\"parse-start\", env);\n  if (env.color) {\n    return env.color;\n  }\n  env.parsed = util.parseFunction(env.str);\n  if (env.parsed) {\n    // Is a functional syntax\n    let name = env.parsed.name;\n    if (name === \"color\") {\n      // color() function\n      let id = env.parsed.args.shift();\n      // Check against both <dashed-ident> and <ident> versions\n      let alternateId = id.startsWith(\"--\") ? id.substring(2) : `--${id}`;\n      let ids = [id, alternateId];\n      let alpha = env.parsed.rawArgs.indexOf(\"/\") > 0 ? env.parsed.args.pop() : 1;\n      for (let space of ColorSpace.all) {\n        let colorSpec = space.getFormat(\"color\");\n        if (colorSpec) {\n          if (ids.includes(colorSpec.id) || colorSpec.ids?.filter(specId => ids.includes(specId)).length) {\n            // From https://drafts.csswg.org/css-color-4/#color-function\n            // If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.\n            // If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page won’t use.)\n            const coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);\n            let types;\n            if (colorSpec.coordGrammar) {\n              types = coerceCoords(space, colorSpec, \"color\", coords);\n            }\n            if (meta) {\n              Object.assign(meta, {\n                formatId: \"color\",\n                types\n              });\n            }\n            if (colorSpec.id.startsWith(\"--\") && !id.startsWith(\"--\")) {\n              defaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. ` + `Use prefixed color(${colorSpec.id}) instead of color(${id}).`);\n            }\n            if (id.startsWith(\"--\") && !colorSpec.id.startsWith(\"--\")) {\n              defaults.warn(`${space.name} is a standard space and supported in the CSS spec. ` + `Use color(${colorSpec.id}) instead of prefixed color(${id}).`);\n            }\n            return {\n              spaceId: space.id,\n              coords,\n              alpha\n            };\n          }\n        }\n      }\n\n      // Not found\n      let didYouMean = \"\";\n      let registryId = id in ColorSpace.registry ? id : alternateId;\n      if (registryId in ColorSpace.registry) {\n        // Used color space id instead of color() id, these are often different\n        let cssId = ColorSpace.registry[registryId].formats?.color?.id;\n        if (cssId) {\n          didYouMean = `Did you mean color(${cssId})?`;\n        }\n      }\n      throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || \"Missing a plugin?\"));\n    } else {\n      for (let space of ColorSpace.all) {\n        // color space specific function\n        let format = space.getFormat(name);\n        if (format && format.type === \"function\") {\n          let alpha = 1;\n          if (format.lastAlpha || util.last(env.parsed.args).alpha) {\n            alpha = env.parsed.args.pop();\n          }\n          let coords = env.parsed.args;\n          let types;\n          if (format.coordGrammar) {\n            types = coerceCoords(space, format, name, coords);\n          }\n          if (meta) {\n            Object.assign(meta, {\n              formatId: format.name,\n              types\n            });\n          }\n          return {\n            spaceId: space.id,\n            coords,\n            alpha\n          };\n        }\n      }\n    }\n  } else {\n    // Custom, colorspace-specific format\n    for (let space of ColorSpace.all) {\n      for (let formatId in space.formats) {\n        let format = space.formats[formatId];\n        if (format.type !== \"custom\") {\n          continue;\n        }\n        if (format.test && !format.test(env.str)) {\n          continue;\n        }\n        let color = format.parse(env.str);\n        if (color) {\n          color.alpha ??= 1;\n          if (meta) {\n            meta.formatId = formatId;\n          }\n          return color;\n        }\n      }\n    }\n  }\n\n  // If we're here, we couldn't parse\n  throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);\n}","map":{"version":3,"names":["util","hooks","ColorSpace","defaults","noneTypes","Set","coerceCoords","space","format","name","coords","types","Object","entries","map","id","coordMeta","i","coordGrammar","arg","providedType","type","none","find","c","has","coordName","TypeError","raw","fromRange","range","toRange","refRange","mapRange","parse","str","meta","env","String","trim","run","color","parsed","parseFunction","args","shift","alternateId","startsWith","substring","ids","alpha","rawArgs","indexOf","pop","all","colorSpec","getFormat","includes","filter","specId","length","keys","_","assign","formatId","warn","spaceId","didYouMean","registryId","registry","cssId","formats","lastAlpha","last","test"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/parse.js"],"sourcesContent":["import * as util from \"./util.js\";\nimport hooks from \"./hooks.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\n\nconst noneTypes = new Set([\"<number>\", \"<percentage>\", \"<angle>\"]);\n\n/**\n * Validates the coordinates of a color against a format's coord grammar and\n * maps the coordinates to the range or refRange of the coordinates.\n * @param {ColorSpace} space - Colorspace the coords are in\n * @param {object} format - the format object to validate against\n * @param {string} name - the name of the color function. e.g. \"oklab\" or \"color\"\n * @returns {object[]} - an array of type metadata for each coordinate\n */\nfunction coerceCoords (space, format, name, coords) {\n\tlet types = Object.entries(space.coords).map(([id, coordMeta], i) => {\n\t\tlet coordGrammar = format.coordGrammar[i];\n\t\tlet arg = coords[i];\n\t\tlet providedType = arg?.type;\n\n\t\t// Find grammar alternative that matches the provided type\n\t\t// Non-strict equals is intentional because we are comparing w/ string objects\n\t\tlet type;\n\t\tif (arg.none) {\n\t\t\ttype = coordGrammar.find(c => noneTypes.has(c));\n\t\t}\n\t\telse {\n\t\t\ttype = coordGrammar.find(c => c == providedType);\n\t\t}\n\n\t\t// Check that each coord conforms to its grammar\n\t\tif (!type) {\n\t\t\t// Type does not exist in the grammar, throw\n\t\t\tlet coordName = coordMeta.name || id;\n\t\t\tthrow new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);\n\t\t}\n\n\t\tlet fromRange = type.range;\n\n\t\tif (providedType === \"<percentage>\") {\n\t\t\tfromRange ||= [0, 1];\n\t\t}\n\n\t\tlet toRange = coordMeta.range || coordMeta.refRange;\n\n\t\tif (fromRange && toRange) {\n\t\t\tcoords[i] = util.mapRange(fromRange, toRange, coords[i]);\n\t\t}\n\n\t\treturn type;\n\t});\n\n\treturn types;\n}\n\n\n/**\n * Convert a CSS Color string to a color object\n * @param {string} str\n * @param {object} [options]\n * @param {object} [options.meta] - Object for additional information about the parsing\n * @returns {Color}\n */\nexport default function parse (str, {meta} = {}) {\n\tlet env = {\"str\": String(str)?.trim()};\n\thooks.run(\"parse-start\", env);\n\n\tif (env.color) {\n\t\treturn env.color;\n\t}\n\n\tenv.parsed = util.parseFunction(env.str);\n\n\tif (env.parsed) {\n\t\t// Is a functional syntax\n\t\tlet name = env.parsed.name;\n\n\t\tif (name === \"color\") {\n\t\t\t// color() function\n\t\t\tlet id = env.parsed.args.shift();\n\t\t\t// Check against both <dashed-ident> and <ident> versions\n\t\t\tlet alternateId = id.startsWith(\"--\") ? id.substring(2) : `--${id}`;\n\t\t\tlet ids = [id, alternateId];\n\t\t\tlet alpha = env.parsed.rawArgs.indexOf(\"/\") > 0 ? env.parsed.args.pop() : 1;\n\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\tlet colorSpec = space.getFormat(\"color\");\n\n\t\t\t\tif (colorSpec) {\n\t\t\t\t\tif (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {\n\t\t\t\t\t\t// From https://drafts.csswg.org/css-color-4/#color-function\n\t\t\t\t\t\t// If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.\n\t\t\t\t\t\t// If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page won’t use.)\n\t\t\t\t\t\tconst coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);\n\n\t\t\t\t\t\tlet types;\n\n\t\t\t\t\t\tif (colorSpec.coordGrammar) {\n\t\t\t\t\t\t\ttypes = coerceCoords(space, colorSpec, \"color\", coords);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (meta) {\n\t\t\t\t\t\t\tObject.assign(meta, {formatId: \"color\", types});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (colorSpec.id.startsWith(\"--\") && !id.startsWith(\"--\")) {\n\t\t\t\t\t\t\tdefaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. ` +\n\t\t\t\t\t\t\t              `Use prefixed color(${colorSpec.id}) instead of color(${id}).`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (id.startsWith(\"--\") && !colorSpec.id.startsWith(\"--\")) {\n\t\t\t\t\t\t\tdefaults.warn(`${space.name} is a standard space and supported in the CSS spec. ` +\n\t\t\t\t\t\t\t              `Use color(${colorSpec.id}) instead of prefixed color(${id}).`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {spaceId: space.id, coords, alpha};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not found\n\t\t\tlet didYouMean = \"\";\n\t\t\tlet registryId = id in ColorSpace.registry ? id : alternateId;\n\t\t\tif (registryId in ColorSpace.registry) {\n\t\t\t\t// Used color space id instead of color() id, these are often different\n\t\t\t\tlet cssId = ColorSpace.registry[registryId].formats?.color?.id;\n\n\t\t\t\tif (cssId) {\n\t\t\t\t\tdidYouMean = `Did you mean color(${cssId})?`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new TypeError(`Cannot parse color(${id}). ` + (didYouMean || \"Missing a plugin?\"));\n\t\t}\n\t\telse {\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\t// color space specific function\n\t\t\t\tlet format = space.getFormat(name);\n\t\t\t\tif (format && format.type === \"function\") {\n\t\t\t\t\tlet alpha = 1;\n\n\t\t\t\t\tif (format.lastAlpha || util.last(env.parsed.args).alpha) {\n\t\t\t\t\t\talpha = env.parsed.args.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tlet coords = env.parsed.args;\n\n\t\t\t\t\tlet types;\n\n\t\t\t\t\tif (format.coordGrammar) {\n\t\t\t\t\t\ttypes = coerceCoords(space, format, name, coords);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tObject.assign(meta, {formatId: format.name, types});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tspaceId: space.id,\n\t\t\t\t\t\tcoords, alpha,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Custom, colorspace-specific format\n\t\tfor (let space of ColorSpace.all) {\n\t\t\tfor (let formatId in space.formats) {\n\t\t\t\tlet format = space.formats[formatId];\n\n\t\t\t\tif (format.type !== \"custom\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (format.test && !format.test(env.str)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet color = format.parse(env.str);\n\n\t\t\t\tif (color) {\n\t\t\t\t\tcolor.alpha ??= 1;\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tmeta.formatId = formatId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// If we're here, we couldn't parse\n\tthrow new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}