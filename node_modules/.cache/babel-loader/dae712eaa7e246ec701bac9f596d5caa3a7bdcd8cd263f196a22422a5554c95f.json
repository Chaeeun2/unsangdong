{"ast":null,"code":"import { parse } from 'acorn';\nimport { ancestor } from 'acorn-walk';\nimport escodegen from 'escodegen';\n\n/**\n* @module 3D\n* @submodule ShaderGenerator\n* @for p5\n* @requires core\n*/\n\nfunction shadergenerator(p5, fn) {\n  let GLOBAL_SHADER;\n  let BRANCH;\n  const oldModify = p5.Shader.prototype.modify;\n  p5.Shader.prototype.modify = function (shaderModifier, options = {\n    parser: true,\n    srcLocations: false\n  }) {\n    if (shaderModifier instanceof Function) {\n      let generatorFunction;\n      if (options.parser) {\n        const sourceString = shaderModifier.toString();\n        const ast = parse(sourceString, {\n          ecmaVersion: 2021,\n          locations: options.srcLocations\n        });\n        ancestor(ast, ASTCallbacks, undefined, {\n          varyings: {}\n        });\n        const transpiledSource = escodegen.generate(ast);\n        generatorFunction = new Function(transpiledSource.slice(transpiledSource.indexOf('{') + 1, transpiledSource.lastIndexOf('}')).replaceAll(';', ''));\n      } else {\n        generatorFunction = shaderModifier;\n      }\n      const generator = new ShaderGenerator(generatorFunction, this, options.srcLocations);\n      const generatedModifyArgument = generator.generate();\n      return oldModify.call(this, generatedModifyArgument);\n    } else {\n      return oldModify.call(this, shaderModifier);\n    }\n  };\n\n  // AST Transpiler Callbacks and helper functions\n  function replaceBinaryOperator(codeSource) {\n    switch (codeSource) {\n      case '+':\n        return 'add';\n      case '-':\n        return 'sub';\n      case '*':\n        return 'mult';\n      case '/':\n        return 'div';\n      case '%':\n        return 'mod';\n      case '==':\n      case '===':\n        return 'equalTo';\n      case '>':\n        return 'greaterThan';\n      case '>=':\n        return 'greaterThanEqualTo';\n      case '<':\n        return 'lessThan';\n      case '&&':\n        return 'and';\n      case '||':\n        return 'or';\n    }\n  }\n  function ancestorIsUniform(ancestor) {\n    return ancestor.type === 'CallExpression' && ancestor.callee?.type === 'Identifier' && ancestor.callee?.name.startsWith('uniform');\n  }\n  const ASTCallbacks = {\n    UnaryExpression(node, _state, _ancestors) {\n      if (_ancestors.some(ancestorIsUniform)) {\n        return;\n      }\n      const signNode = {\n        type: 'Literal',\n        value: node.operator\n      };\n      const standardReplacement = node => {\n        node.type = 'CallExpression';\n        node.callee = {\n          type: 'Identifier',\n          name: 'unaryNode'\n        };\n        node.arguments = [node.argument, signNode];\n      };\n      if (node.type === 'MemberExpression') {\n        const property = node.argument.property.name;\n        const swizzleSets = [['x', 'y', 'z', 'w'], ['r', 'g', 'b', 'a'], ['s', 't', 'p', 'q']];\n        let isSwizzle = swizzleSets.some(set => [...property].every(char => set.includes(char))) && node.argument.type === 'MemberExpression';\n        if (isSwizzle) {\n          node.type = 'MemberExpression';\n          node.object = {\n            type: 'CallExpression',\n            callee: {\n              type: 'Identifier',\n              name: 'unaryNode'\n            },\n            arguments: [node.argument.object, signNode]\n          };\n          node.property = {\n            type: 'Identifier',\n            name: property\n          };\n        } else {\n          standardReplacement(node);\n        }\n      } else {\n        standardReplacement(node);\n      }\n      delete node.argument;\n      delete node.operator;\n    },\n    VariableDeclarator(node, _state, _ancestors) {\n      if (node.init.callee && node.init.callee.name?.startsWith('uniform')) {\n        const uniformNameLiteral = {\n          type: 'Literal',\n          value: node.id.name\n        };\n        node.init.arguments.unshift(uniformNameLiteral);\n      }\n      if (node.init.callee && node.init.callee.name?.startsWith('varying')) {\n        const varyingNameLiteral = {\n          type: 'Literal',\n          value: node.id.name\n        };\n        node.init.arguments.unshift(varyingNameLiteral);\n        _state.varyings[node.id.name] = varyingNameLiteral;\n      }\n    },\n    Identifier(node, _state, _ancestors) {\n      if (_state.varyings[node.name] && !_ancestors.some(a => a.type === 'AssignmentExpression' && a.left === node)) {\n        node.type = 'ExpressionStatement';\n        node.expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: {\n              type: 'Identifier',\n              name: node.name\n            },\n            property: {\n              type: 'Identifier',\n              name: 'getValue'\n            }\n          },\n          arguments: []\n        };\n      }\n    },\n    // The callbacks for AssignmentExpression and BinaryExpression handle\n    // operator overloading including +=, *= assignment expressions\n    ArrayExpression(node, _state, _ancestors) {\n      const original = JSON.parse(JSON.stringify(node));\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'Identifier',\n        name: 'dynamicNode'\n      };\n      node.arguments = [original];\n    },\n    AssignmentExpression(node, _state, _ancestors) {\n      if (node.operator !== '=') {\n        const methodName = replaceBinaryOperator(node.operator.replace('=', ''));\n        const rightReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: node.left,\n            property: {\n              type: 'Identifier',\n              name: methodName\n            }\n          },\n          arguments: [node.right]\n        };\n        node.operator = '=';\n        node.right = rightReplacementNode;\n      }\n      if (_state.varyings[node.left.name]) {\n        node.type = 'ExpressionStatement';\n        node.expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: {\n              type: 'Identifier',\n              name: node.left.name\n            },\n            property: {\n              type: 'Identifier',\n              name: 'bridge'\n            }\n          },\n          arguments: [node.right]\n        };\n      }\n    },\n    BinaryExpression(node, _state, _ancestors) {\n      // Don't convert uniform default values to node methods, as\n      // they should be evaluated at runtime, not compiled.\n      if (_ancestors.some(ancestorIsUniform)) {\n        return;\n      }\n      // If the left hand side of an expression is one of these types,\n      // we should construct a node from it.\n      const unsafeTypes = ['Literal', 'ArrayExpression', 'Identifier'];\n      if (unsafeTypes.includes(node.left.type)) {\n        const leftReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: 'dynamicNode'\n          },\n          arguments: [node.left]\n        };\n        node.left = leftReplacementNode;\n      }\n      // Replace the binary operator with a call expression\n      // in other words a call to BaseNode.mult(), .div() etc.\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'MemberExpression',\n        object: node.left,\n        property: {\n          type: 'Identifier',\n          name: replaceBinaryOperator(node.operator)\n        }\n      };\n      node.arguments = [node.right];\n    }\n  };\n\n  // Javascript Node API.\n  class BaseNode {\n    constructor(isInternal, type) {\n      if (new.target === BaseNode) {\n        throw new TypeError('Cannot construct BaseNode instances directly. This is an abstract class.');\n      }\n      this.type = type;\n      this.componentNames = [];\n      this.componentsChanged = false;\n      // For tracking recursion depth and creating temporary variables\n      this.isInternal = isInternal;\n      this.usedIn = [];\n      this.dependsOn = [];\n      this.srcLine = null;\n      this.usedInConditional = false;\n      // Stack Capture is used to get the original line of user code for Debug purposes\n      if (GLOBAL_SHADER.srcLocations === true && isInternal === false) {\n        try {\n          throw new Error('StackCapture');\n        } catch (e) {\n          const lines = e.stack.split('\\n');\n          let userSketchLineIndex = 5;\n          if (isBinaryExpressionNode(this)) {\n            userSketchLineIndex--;\n          }\n          this.srcLine = lines[userSketchLineIndex].trim();\n        }\n      }\n    }\n    addVectorComponents() {\n      if (this.type.startsWith('vec')) {\n        const vectorDimensions = parseInt(this.type.slice(3));\n        this.componentNames = ['x', 'y', 'z', 'w'].slice(0, vectorDimensions);\n        const proxy = this;\n        for (let componentName of this.componentNames) {\n          let value = new ComponentNode(proxy, componentName, 'float', true);\n          Object.defineProperty(this, componentName, {\n            get() {\n              return value;\n            },\n            set(newValue) {\n              this.componentsChanged = true;\n              if (isUnaryExpressionNode(this)) {\n                this.node.value = newValue;\n              } else {\n                value = newValue;\n              }\n            }\n          });\n        }\n      }\n    }\n    forceTemporaryVariable() {\n      if (!(isFloatNode(this) && isVectorNode(this.parent)) || !isVariableNode(this)) this.useTemp = true;\n    }\n    assertUsedInConditional(branch) {\n      this.usedInConditional = true;\n      this.usedIn.push(branch);\n      this.forceTemporaryVariable();\n    }\n    isUsedInConditional() {\n      return this.usedInConditional;\n    }\n    checkConditionalDependencies(context) {\n      context.ifs.forEach(statement => {\n        const isUsedSatisfied = () => statement.usedInSatisfied.length >= 1;\n        const isDepsSatisfied = () => statement.dependsOn.length === statement.dependsOnSatisfied.length;\n        if (statement.insertionPoint > -1 || !statement.usedIn.length) return;\n        if (statement.dependsOn.some(d => d.node === this) && !statement.dependsOnSatisfied.includes(this)) {\n          statement.dependsOnSatisfied.push(this);\n        }\n        if (statement.usedIn.includes(this) && !statement.usedInSatisfied.includes(this)) {\n          statement.usedInSatisfied.push(this);\n        }\n        if (isDepsSatisfied() && isUsedSatisfied()) {\n          statement.saveState(context, isDepsSatisfied(), isUsedSatisfied());\n        }\n      });\n    }\n\n    // The base node implements a version of toGLSL which determines whether the generated code should be stored in a temporary variable.\n    toGLSLBase(context) {\n      let result;\n      if (this.shouldUseTemporaryVariable()) {\n        let oldLength = context.declarations.length;\n        result = this.getTemporaryVariable(context);\n        let diff = context.declarations.length - 1 - oldLength;\n        diff = diff > 0 ? diff : undefined;\n        this.dependsOn.forEach(dependency => {\n          if (dependency.isVector) {\n            const dependencies = dependency.originalComponents.map((component, i) => component === dependency.currentComponents[i]);\n            context.updateComponents(dependency.node, diff, dependencies);\n          } else {\n            context.updateComponents(dependency.node, diff);\n          }\n        });\n      } else {\n        result = this.toGLSL(context);\n      }\n      this.checkConditionalDependencies(context);\n      return result;\n    }\n    shouldUseTemporaryVariable() {\n      if (this.componentsChanged || hasTemporaryVariable(this) || this.useTemp) {\n        return true;\n      }\n      if (this.isInternal || isVariableNode(this) || isConditionalNode(this) || this.type === 'sampler2D') {\n        return false;\n      }\n\n      // return false;\n      // Swizzles must use temporary variables as otherwise they will not be registered\n      let score = 0;\n      score += isFunctionCallNode(this) * 2;\n      score += isBinaryExpressionNode(this) * 2;\n      score += isVectorType(this) * 3;\n      score += this.usedIn.length;\n      return score >= 4;\n    }\n    getTemporaryVariable(context) {\n      if (!this.temporaryVariable) {\n        this.temporaryVariable = `temp_${context.getNextID()}`;\n        let line = '';\n        if (this.srcLine) {\n          line += `\\n// From ${this.srcLine}\\n`;\n        }\n        line += '  ' + this.type + ' ' + this.temporaryVariable + ' = ' + this.toGLSL(context) + ';';\n        context.declarations.push(line);\n      }\n      return this.temporaryVariable;\n    }\n    // Binary Operators\n    add(other) {\n      return binaryExpressionNodeConstructor(this, this.enforceType(other), '+');\n    }\n    sub(other) {\n      return binaryExpressionNodeConstructor(this, this.enforceType(other), '-');\n    }\n    mult(other) {\n      return binaryExpressionNodeConstructor(this, this.enforceType(other), '*');\n    }\n    div(other) {\n      return binaryExpressionNodeConstructor(this, this.enforceType(other), '/');\n    }\n    mod(other) {\n      return binaryExpressionNodeConstructor(this, this.enforceType(other), '%');\n    }\n\n    // Check that the types of the operands are compatible.\n    enforceType(other) {\n      if (isShaderNode(other)) {\n        if (!isGLSLNativeType(other.type)) {\n          throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);\n        }\n        if (!isGLSLNativeType(other.type)) {\n          throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);\n        }\n        if ((isFloatType(this) || isVectorType(this)) && isIntType(other)) {\n          return new FloatNode(other);\n        }\n        return other;\n      } else if (typeof other === 'number') {\n        if (isIntType(this)) {\n          return new IntNode(other);\n        }\n        return new FloatNode(other);\n      } else if (Array.isArray(other)) {\n        return nodeConstructors.dynamicVector(other);\n        // return nodeConstructors[`vec${other.length}`](other);\n      } else {\n        return nodeConstructors[this.type](other);\n      }\n    }\n    toFloat() {\n      if (isFloatType(this)) {\n        return this;\n      } else if (isIntType(this)) {\n        return new FloatNode(this);\n      }\n    }\n    toGLSL(context) {\n      throw new TypeError('Not supposed to call this function on BaseNode, which is an abstract class.');\n    }\n  }\n\n  // Primitive Types\n  class IntNode extends BaseNode {\n    constructor(x = 0, isInternal = false) {\n      super(isInternal, 'int');\n      this.x = x;\n    }\n    toGLSL(context) {\n      if (isShaderNode(this.x)) {\n        let code = this.x.toGLSLBase(context);\n        return isIntType(this.x.type) ? code : `int(${code})`;\n      } else if (typeof this.x === 'number') {\n        return `${Math.floor(this.x)}`;\n      } else {\n        return `int(${this.x})`;\n      }\n    }\n  }\n  class FloatNode extends BaseNode {\n    constructor(x = 0, isInternal = false, _parent = false) {\n      super(isInternal, 'float');\n      if (Array.isArray(x)) {\n        x = x[0];\n      }\n      if (_parent) {\n        const {\n          parent,\n          name\n        } = _parent;\n        this.name = name;\n        this.parent = parent;\n      }\n      this.x = x;\n    }\n    toGLSL(context) {\n      if (isShaderNode(this.x)) {\n        let code = this.x.toGLSLBase(context);\n        return isFloatType(this.x) ? code : `float(${code})`;\n      } else if (typeof this.x === 'number') {\n        return `${this.x.toFixed(4)}`;\n      } else {\n        return `float(${this.x})`;\n      }\n    }\n  }\n  class VectorNode extends BaseNode {\n    constructor(values, type, isInternal = false) {\n      super(isInternal, type);\n      this.originalValues = conformVectorParameters(values, parseInt(type.slice(3)));\n      this.componentNames = ['x', 'y', 'z', 'w'].slice(0, this.originalValues.length);\n    }\n    addVectorComponents() {\n      const values = this.originalValues;\n      this.componentsChanged = false;\n      this.componentNames.forEach((componentName, i) => {\n        const info = {\n          name: componentName,\n          parent: this\n        };\n        let value = isFloatNode(values[i]) ? values[i] : new FloatNode(values[i], true, info);\n        Object.defineProperty(this, componentName, {\n          get() {\n            return value;\n          },\n          set(newValue) {\n            this.componentsChanged = true;\n            if (isUnaryExpressionNode(this)) {\n              this.node.value = newValue;\n            } else {\n              value = isFloatNode(newValue) ? newValue : new FloatNode(newValue, true, info);\n            }\n          }\n        });\n      });\n      this.originalValues = this.componentNames.map(name => this[name]);\n    }\n    toGLSL(context) {\n      if ((!this.componentsChanged || !this.defined) && !this.oldName) {\n        let glslArgs = this.componentNames.map((_name, i) => this.originalValues[i].toGLSLBase(context)).join(', ');\n        this.defined = true;\n        return `${this.type}(${glslArgs})`;\n      } else {\n        return this.temporaryVariable;\n      }\n    }\n  }\n\n  // Function Call Nodes\n  class FunctionCallNode extends BaseNode {\n    constructor(name, userArgs, properties, isInternal = false) {\n      let functionSignature;\n      const determineFunctionSignature = props => {\n        let genType;\n        let similarity = 0;\n        const valid = userArgs.every((userArg, i) => {\n          const userType = getType(userArg);\n          let expectedArgType = props.args[i];\n          if (expectedArgType === 'genType') {\n            // We allow conversions from float -> vec if one argument is a vector.\n            if (genType === undefined || genType === 'float' && userType.startsWith('vec')) {\n              genType = userType;\n            }\n            expectedArgType = genType;\n          }\n          similarity += userType === expectedArgType;\n          return userType === expectedArgType || userType === 'float' && expectedArgType.startsWith('vec');\n        });\n        return {\n          ...props,\n          valid,\n          similarity,\n          genType\n        };\n      };\n      if (Array.isArray(properties)) {\n        // Check if the right number of parameters were provided\n        let possibleOverloads = properties.filter(o => o.args.length === userArgs.length);\n        if (possibleOverloads.length === 0) {\n          const argsLengthSet = new Set();\n          const argsLengthArr = [];\n          properties.forEach(p => argsLengthSet.add(p.args.length));\n          argsLengthSet.forEach(len => argsLengthArr.push(`${len}`));\n          const argsLengthStr = argsLengthArr.join(' or ');\n          throw new Error(`Function '${name}' has ${properties.length} variants which expect ${argsLengthStr} arguments, but ${userArgs.length} arguments were provided.`);\n        }\n        const findBestOverload = function (best, current) {\n          current = determineFunctionSignature(current);\n          if (!current.valid) {\n            return best;\n          }\n          if (!best || current.similarity > best.similarity) {\n            best = current;\n          }\n          return best;\n        };\n        functionSignature = possibleOverloads.reduce(findBestOverload, null);\n      } else {\n        functionSignature = determineFunctionSignature(properties);\n      }\n      if (!functionSignature || !functionSignature.valid) {\n        const argsStrJoin = args => `(${args.map(arg => arg).join(', ')})`;\n        const expectedArgsString = Array.isArray(properties) ? properties.map(prop => argsStrJoin(prop.args)).join(' or ') : argsStrJoin(properties.args);\n        const providedArgsString = argsStrJoin(userArgs.map(a => getType(a)));\n        throw new Error(`Function '${name}' was called with wrong arguments. Most likely, you provided mixed lengths vectors as arguments.\\nExpected argument types: ${expectedArgsString}\\nProvided argument types: ${providedArgsString}\\nAll of the arguments with expected type 'genType' should have a matching type. If one of those is different, try to find where it was created.\n        `);\n      }\n      if (userArgs.length !== functionSignature.args.length) {\n        throw new Error(`Function '${name}' expects ${functionSignature.args.length} arguments, but ${userArgs.length} were provided.`);\n      }\n      userArgs = userArgs.map((arg, i) => {\n        if (!isShaderNode(arg)) {\n          const typeName = functionSignature.args[i] === 'genType' ? functionSignature.genType : functionSignature.args[i];\n          arg = nodeConstructors[typeName](arg);\n        } else if (isFloatType(arg) && functionSignature.args[i] === 'genType' && functionSignature.genType !== 'float') {\n          arg = nodeConstructors[functionSignature.genType](arg);\n        }\n        return arg;\n      });\n      if (functionSignature.returnType === 'genType') {\n        functionSignature.returnType = functionSignature.genType;\n      }\n      super(isInternal, functionSignature.returnType);\n      this.name = name;\n      this.args = userArgs;\n      this.argumentTypes = functionSignature.args;\n    }\n    deconstructArgs(context) {\n      let argsString = this.args.map((argNode, i) => {\n        if (isIntType(argNode) && this.argumentTypes[i] != 'float') {\n          argNode = argNode.toFloat();\n        }\n        argNode.toGLSLBase(context);\n        return argNode.toGLSLBase(context);\n      }).join(', ');\n      return argsString;\n    }\n    toGLSL(context) {\n      return `${this.name}(${this.deconstructArgs(context)})`;\n    }\n  }\n\n  // Variables and member variable nodes\n  class VariableNode extends BaseNode {\n    constructor(name, type, isInternal = false) {\n      super(isInternal, type);\n      this.name = name;\n    }\n    toGLSL(context) {\n      return `${this.name}`;\n    }\n  }\n  class ComponentNode extends BaseNode {\n    constructor(parent, componentName, type, isInternal = false) {\n      super(isInternal, type);\n      this.parent = parent;\n      this.componentName = componentName;\n      this.type = type;\n    }\n    toGLSL(context) {\n      let parentName = this.parent.toGLSLBase(context);\n      if (!isVariableNode(this.parent) && !hasTemporaryVariable(this.parent)) {\n        parentName = `(${parentName})`;\n      }\n      return `${parentName}.${this.componentName}`;\n    }\n  }\n\n  //\n  class VaryingNode extends VariableNode {\n    constructor(name, type, isInternal = false) {\n      super(name, type, isInternal);\n      this.timesChanged = 0;\n      this.tempVars = 0;\n    }\n    getValue() {\n      const context = GLOBAL_SHADER.context;\n      if (!context.varyings[this.name] || !this.timesChanged) {\n        return this;\n      }\n      let values = context.varyings[this.name].splice(0, this.timesChanged);\n      let snapshot;\n      values.forEach((val, i) => {\n        let {\n          value\n        } = val;\n        context.declarations.push(`  ${this.name} = ${value.toGLSLBase(context)};`);\n        if (i === values.length - 1) {\n          const tempName = `${this.name}_${this.tempVars++}`;\n          snapshot = dynamicAddSwizzleTrap(new VariableNode(tempName, this.type, true));\n          context.declarations.push(`  ${this.type} ${tempName} = ${this.name};`);\n        }\n      });\n      this.timesChanged = 0;\n      return snapshot;\n    }\n    bridge(value) {\n      if (!isShaderNode(value) || this.type.startsWith('vec') && getType(value) === 'float') {\n        value = nodeConstructors[this.type](value);\n      }\n      GLOBAL_SHADER.registerVarying(this, value);\n      this.timesChanged += 1;\n    }\n  }\n\n  // Binary Operator Nodes\n  class BinaryExpressionNode extends BaseNode {\n    constructor(left, right, operator, isInternal = false) {\n      super(isInternal, null);\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      for (const operand of [left, right]) {\n        operand.usedIn.push(this);\n      }\n      this.type = this.determineType();\n    }\n\n    // We know that both this.left and this.right are nodes because of BaseNode.enforceType\n    determineType() {\n      if (['==', '>', '>=', '<', '<=', '||', '!', '&&'].includes(this.operator)) {\n        return 'bool';\n      } else if (this.left.type === this.right.type) {\n        return this.left.type;\n      } else if (isVectorType(this.left) && isFloatType(this.right)) {\n        return this.left.type;\n      } else if (isVectorType(this.right) && isFloatType(this.left)) {\n        return this.right.type;\n      } else if (isFloatType(this.left) && isIntType(this.right) || isIntType(this.left) && isFloatType(this.right)) {\n        return 'float';\n      } else {\n        throw new Error('Incompatible types for binary operator');\n      }\n    }\n    processOperand(operand, context) {\n      if (operand.temporaryVariable) {\n        return operand.temporaryVariable;\n      }\n      let code = operand.toGLSLBase(context);\n      if (isBinaryExpressionNode(operand) && !operand.temporaryVariable) {\n        code = `(${code})`;\n      }\n      if (this.type === 'float' && isIntType(operand)) {\n        code = `float(${code})`;\n      }\n      return code;\n    }\n    toGLSL(context) {\n      const a = this.processOperand(this.left, context);\n      const b = this.processOperand(this.right, context);\n      return `${a} ${this.operator} ${b}`;\n    }\n  }\n  class ModulusNode extends BinaryExpressionNode {\n    constructor(a, b, isInternal) {\n      super(a, b, isInternal);\n    }\n    toGLSL(context) {\n      // Switch on type between % or mod()\n      if (isVectorType(this) || isFloatType(this)) {\n        return `mod(${this.left.toGLSLBase(context)}, ${this.right.toGLSLBase(context)})`;\n      }\n      return `${this.processOperand(context, this.left)} % ${this.processOperand(context, this.right)}`;\n    }\n  }\n  class UnaryExpressionNode extends BaseNode {\n    constructor(node, operator, isInternal = false) {\n      super(isInternal, node.type);\n      this.node = node;\n      this.operator = operator;\n    }\n    toGLSL(context) {\n      let mainStr = this.node.toGLSLBase(context);\n      if (!isVariableNode(this.node) && !hasTemporaryVariable(this.node) && !isPrimitiveNode(this.node)) {\n        mainStr = `(${mainStr})`;\n      }\n      return `${this.operator}${mainStr}`;\n    }\n  }\n\n  // Conditions and logical modifiers\n  BaseNode.prototype.equalTo = function (other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '==');\n  };\n  BaseNode.prototype.greaterThan = function (other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '>');\n  };\n  BaseNode.prototype.greaterThanEqualTo = function (other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '>=');\n  };\n  BaseNode.prototype.lessThan = function (other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '<');\n  };\n  BaseNode.prototype.lessThanEqualTo = function (other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '<=');\n  };\n  BaseNode.prototype.not = function () {\n    return new UnaryExpressionNode(this.condition, '!', true);\n  };\n  BaseNode.prototype.or = function (other) {\n    return new binaryExpressionNodeConstructor(this, this.enforceType(other), '||', true);\n  };\n  BaseNode.prototype.and = function (other) {\n    return new binaryExpressionNodeConstructor(this, this.enforceType(other), '&&', true);\n  };\n  function branch(callback) {\n    const branch = new BranchNode();\n    callback();\n    BRANCH = null;\n    return branch;\n  }\n  class ConditionalNode {\n    constructor(condition, branchCallback) {\n      this.dependsOn = [];\n      this.usedIn = [];\n      this.dependsOnSatisfied = [];\n      this.usedInSatisfied = [];\n      this.states = [];\n      this.if(condition, branchCallback);\n      this.insertionPoint = -1;\n      this.elseIfs = [];\n      this.elseBranch = null;\n      GLOBAL_SHADER.context.ifs.push(this);\n    }\n    if(condition, branchCallback) {\n      this.condition = condition;\n      this.conditionString = condition.toGLSL(GLOBAL_SHADER.context);\n      this.ifBranch = branch(branchCallback);\n      this.ifBranch.parent = this;\n    }\n    elseIf(condition, branchCallback) {\n      let elseBranch = branch(branchCallback);\n      branchCallback.parent = this;\n      this.elseIfs.push({\n        condition,\n        elseBranch\n      });\n      return this;\n    }\n    else(branchCallback) {\n      this.elseBranch = branch(branchCallback);\n      this.elseBranch.parent = this;\n      return this;\n    }\n    thenDiscard() {\n      return new ConditionalDiscard(this.condition);\n    }\n    saveState(context, usedInSatisfied, dependsOnSatisfied) {\n      this.states.push({\n        line: context.declarations.length,\n        usedInSatisfied,\n        dependsOnSatisfied\n      });\n      this.insertionPoint = context.declarations.length - 1;\n    }\n    toGLSL(context) {\n      const oldLength = context.declarations.length;\n      this.dependsOn.forEach(dep => context.updateComponents(dep.node));\n      const newLength = context.declarations.length;\n      const diff = newLength - oldLength;\n      this.insertionPoint += diff;\n      let codelines = [`\\n  if (${this.conditionString}) {`, `\\n    ${this.ifBranch.toGLSL(context)}`, `\\n  }`];\n      if (this.elseIfs.length) {\n        this.elseIfs.forEach(elif => {\n          let {\n            condition,\n            elseBranch\n          } = elif;\n          codelines.push(` else if (${condition.toGLSL(context)}) {`);\n          codelines.push(`\\n    ${elseBranch.toGLSL(context)}`);\n          codelines.push(`\\n  }`);\n        });\n      }\n      if (this.elseBranch) {\n        codelines.push(` else {`);\n        codelines.push(`\\n    ${this.elseBranch.toGLSL(context)}`);\n        codelines.push(`\\n  }\\n`);\n      }\n      codelines.push('\\n');\n      return codelines.flat().join('');\n    }\n  }\n  fn.assign = function (node, value) {\n    if (!BRANCH) {\n      throw new error('assign() is supposed to be used inside of conditional branchs. Use the \"=\" operator as normal otherwise.');\n    }\n    BRANCH.assign(node, value);\n  };\n  class BranchNode {\n    constructor() {\n      BRANCH = this;\n      this.statements = [];\n      this.assignments = [];\n      this.dependsOn = [];\n      this.declarations = [];\n      let parent = null;\n      Object.defineProperty(this, 'parent', {\n        get() {\n          return parent;\n        },\n        set(newParent) {\n          newParent.dependsOn.push(...this.dependsOn);\n          parent = newParent;\n        }\n      });\n    }\n    assign(node, value) {\n      if (!isShaderNode(value) || value.type !== node.type) {\n        value = nodeConstructors[node.type](value);\n        this.declarations.push(value);\n        this.assignments.push({\n          node\n        });\n      } else {\n        this.assignments.push({\n          node,\n          value\n        });\n      }\n      node = node.parent ? node.parent : node;\n      value = value.parent ? value.parent : value;\n      if ([node, value].some(n => this.dependsOn.some(d => d.node === n))) {\n        return;\n      }\n      node.assertUsedInConditional(this);\n      this.dependsOn.push(makeDependencyObject(node));\n      if (value.shouldUseTemporaryVariable()) {\n        value.assertUsedInConditional(this);\n        this.dependsOn.push(makeDependencyObject(value));\n      }\n    }\n    toGLSL(context) {\n      let declarationsIndex = 0;\n      this.assignments.forEach(({\n        node,\n        value\n      }) => {\n        let statement;\n        let result;\n        if (!value) {\n          let decl = this.declarations[declarationsIndex];\n          declarationsIndex++;\n          decl.temporaryVariable = `temp_${context.getNextID()}`;\n          this.statements.push(`${decl.type} ${decl.temporaryVariable} = ${decl.toGLSL(context)};`);\n          result = decl.toGLSLBase(context);\n        } else {\n          result = value.toGLSLBase(context);\n        }\n        if (isVariableNode(node) || hasTemporaryVariable(node)) {\n          statement = `${node.toGLSLBase(context)} = ${result};`;\n        } else if (isFloatNode(node) && node.name) {\n          statement = `${node.parent.toGLSLBase(context)}.${node.name} = ${result};`;\n        } else {\n          node.temporaryVariable = `temp_${context.getNextID()}`;\n          statement = `${node.type} ${node.toGLSLBase(context)} = ${result};`;\n        }\n        this.statements.push(statement);\n      });\n      return this.statements.join(`\\n    `);\n    }\n  }\n  class ConditionalDiscard {\n    constructor(condition) {\n      this.condition = condition;\n    }\n    toGLSL(context) {\n      context.discardConditions.push(`if (${this.condition}{discard;})`);\n    }\n  }\n\n  // Node Helper functions\n  function getType(node) {\n    if (isShaderNode(node)) {\n      return node.type;\n    } else if (Array.isArray(node) && node.length > 1) {\n      return `vec${node.length}`;\n    } else if (typeof node === 'number' || Array.isArray(node) && node.length === 1) {\n      return 'float';\n    }\n    return undefined;\n  }\n  function computeVectorLength(values) {\n    let length = 0;\n    if (Array.isArray(values)) {\n      for (let val of values) {\n        if (isVectorType(val)) {\n          length += parseInt(val.type.slice(3));\n        } else length += 1;\n      }\n    } else if (isVectorType(values)) {\n      length += parseInt(val.type.slice(3));\n    }\n    if (![2, 3, 4].includes(length)) {\n      throw new Error(`You have attempted to construct a vector with ${length} values. Only vec2, vec3, and vec4 types are supported.`);\n    }\n    return length;\n  }\n  fn.dynamicNode = function (input) {\n    if (isShaderNode(input)) {\n      return input;\n    } else if (typeof input === 'number') {\n      return new FloatNode(input);\n    } else if (Array.isArray(input)) {\n      return nodeConstructors.dynamicVector(input);\n    }\n  };\n\n  // For replacing unary expressions\n  fn.unaryNode = function (input, sign) {\n    input = dynamicNode(input);\n    return dynamicAddSwizzleTrap(new UnaryExpressionNode(input, sign));\n  };\n  function isShaderNode(node) {\n    return node instanceof BaseNode;\n  }\n  function isIntType(node) {\n    return isShaderNode(node) && node.type === 'int';\n  }\n  function isFloatType(node) {\n    return isShaderNode(node) && node.type === 'float';\n  }\n  function isFloatNode(node) {\n    return node instanceof FloatNode;\n  }\n  function isVectorType(node) {\n    return isShaderNode(node) && (node.type === 'vec2' || node.type === 'vec3' || node.type === 'vec4');\n  }\n  function isBinaryExpressionNode(node) {\n    return node instanceof BinaryExpressionNode;\n  }\n  function isVariableNode(node) {\n    return node instanceof VariableNode || node instanceof ComponentNode;\n  }\n  function isConditionalNode(node) {\n    return node instanceof ConditionalNode || node instanceof BranchNode;\n  }\n  function hasTemporaryVariable(node) {\n    return node.temporaryVariable;\n  }\n  function isPrimitiveNode(node) {\n    return node instanceof FloatNode || node instanceof IntNode || node instanceof VectorNode;\n  }\n  function isFunctionCallNode(node) {\n    return node instanceof FunctionCallNode;\n  }\n  function isVectorNode(node) {\n    return node instanceof VectorNode;\n  }\n  function isUnaryExpressionNode(node) {\n    return node instanceof UnaryExpressionNode;\n  }\n\n  // Helper function to check if a type is a user defined struct or native type\n  function isGLSLNativeType(typeName) {\n    // Supported types for now\n    const glslNativeTypes = ['int', 'float', 'vec2', 'vec3', 'vec4', 'sampler2D'];\n    return glslNativeTypes.includes(typeName);\n  }\n\n  // Shader Generator\n  // This class is responsible for converting the nodes into an object containing GLSL code, to be used by p5.Shader.modify\n\n  class ShaderGenerator {\n    constructor(userCallback, originalShader, srcLocations) {\n      GLOBAL_SHADER = this;\n      this.userCallback = userCallback;\n      this.srcLocations = srcLocations;\n      this.cleanup = () => {};\n      this.generateHookOverrides(originalShader);\n      this.output = {\n        vertexDeclarations: new Set(),\n        fragmentDeclarations: new Set(),\n        uniforms: {}\n      };\n      this.uniformNodes = [];\n      this.resetGLSLContext();\n      this.isGenerating = false;\n    }\n    generate() {\n      const prevFESDisabled = p5.disableFriendlyErrors;\n      // We need a custom error handling system within shader generation\n      p5.disableFriendlyErrors = true;\n      this.isGenerating = true;\n      this.userCallback();\n      this.output.vertexDeclarations = [...this.output.vertexDeclarations].join('\\n');\n      this.output.fragmentDeclarations = [...this.output.fragmentDeclarations].join('\\n');\n      this.isGenerating = false;\n      this.cleanup();\n      p5.disableFriendlyErrors = prevFESDisabled;\n      return this.output;\n    }\n\n    // This method generates the hook overrides which the user calls in their modify function.\n    generateHookOverrides(originalShader) {\n      const availableHooks = {\n        ...originalShader.hooks.vertex,\n        ...originalShader.hooks.fragment\n      };\n      const windowOverrides = {};\n      Object.keys(availableHooks).forEach(hookName => {\n        const hookTypes = originalShader.hookTypes(hookName);\n\n        // These functions are where the user code is executed\n        this[hookTypes.name] = function (userCallback) {\n          // Create the initial nodes which are passed to the user callback\n          // Also generate a string of the arguments for the code generation\n          const argNodes = [];\n          const argsArray = [];\n          hookTypes.parameters.forEach(parameter => {\n            // For hooks with structs as input we should pass an object populated with variable nodes\n            if (!isGLSLNativeType(parameter.type.typeName)) {\n              const structArg = {};\n              parameter.type.properties.forEach(property => {\n                structArg[property.name] = variableConstructor(`${parameter.name}.${property.name}`, property.type.typeName, true);\n              });\n              argNodes.push(structArg);\n            } else {\n              argNodes.push(variableConstructor(parameter.name, parameter.type.typeName, true));\n            }\n            const qualifiers = parameter.type.qualifiers.length > 0 ? parameter.type.qualifiers.join(' ') : '';\n            argsArray.push(`${qualifiers} ${parameter.type.typeName} ${parameter.name}`.trim());\n          });\n          let returnedValue = userCallback(...argNodes);\n          const expectedReturnType = hookTypes.returnType;\n          const toGLSLResults = {};\n\n          // If the expected return type is a struct we need to evaluate each of its properties\n          if (!isGLSLNativeType(expectedReturnType.typeName)) {\n            Object.entries(returnedValue).forEach(([propertyName, propertyNode]) => {\n              propertyNode = dynamicNode(propertyNode);\n              toGLSLResults[propertyName] = propertyNode.toGLSLBase(this.context);\n              this.context.updateComponents(propertyNode);\n            });\n          } else {\n            if (!isShaderNode(returnedValue)) {\n              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);\n            } else if (isFloatType(returnedValue) && expectedReturnType.typeName.startsWith('vec')) {\n              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);\n            }\n            toGLSLResults['notAProperty'] = returnedValue.toGLSLBase(this.context);\n            this.context.updateComponents(returnedValue);\n          }\n          this.context.ifs.forEach(statement => {\n            if (statement.usedIn.length === 0) {\n              return;\n            }\n            const lines = statement.toGLSL(this.context);\n            this.context.declarations.splice(statement.insertionPoint, 0, lines);\n          });\n          // Build the final GLSL string.\n          // The order of this code is a bit confusing, we need to call toGLSLBase\n          let codeLines = [`(${argsArray.join(', ')}) {`, ...this.context.declarations, `\\n  ${hookTypes.returnType.typeName} finalReturnValue;`];\n          Object.entries(toGLSLResults).forEach(([propertyName, result]) => {\n            const propString = expectedReturnType.properties ? `.${propertyName}` : '';\n            codeLines.push(`  finalReturnValue${propString} = ${result};`);\n          });\n          this.context.declarations = [];\n          for (let key in this.context.varyings) {\n            const declArray = this.context.varyings[key];\n            const finalVaryingAssignments = [];\n            declArray.forEach(obj => {\n              const {\n                node,\n                value\n              } = obj;\n              finalVaryingAssignments.push(`  ${node.name} = ${value.toGLSLBase(this.context)};`);\n              finalVaryingAssignments.unshift(...this.context.declarations);\n              node.timesChanged = 0;\n            });\n            codeLines.push(...finalVaryingAssignments);\n          }\n          codeLines.push('  return finalReturnValue;', '}');\n          this.output[hookName] = codeLines.join('\\n');\n          this.resetGLSLContext();\n        };\n        windowOverrides[hookTypes.name] = window[hookTypes.name];\n\n        // Expose the Functions to global scope for users to use\n        window[hookTypes.name] = function (userOverride) {\n          GLOBAL_SHADER[hookTypes.name](userOverride);\n        };\n      });\n      this.cleanup = () => {\n        for (const key in windowOverrides) {\n          window[key] = windowOverrides[key];\n        }\n      };\n    }\n    registerVarying(node, value) {\n      if (!Array.isArray(this.context.varyings[node.name])) {\n        this.context.varyings[node.name] = [];\n      }\n      this.context.varyings[node.name].push({\n        node,\n        value\n      });\n      this.output.vertexDeclarations.add(`OUT ${node.type} ${node.name};`);\n      this.output.fragmentDeclarations.add(`IN ${node.type} ${node.name};`);\n    }\n    resetGLSLContext() {\n      this.uniformNodes.forEach(node => {\n        node.usedIn = [];\n        node.temporaryVariable = undefined;\n      });\n      this.context = {\n        id: 0,\n        getNextID() {\n          return this.id++;\n        },\n        declarations: [],\n        varyings: [],\n        ifs: [],\n        updateComponents: function (node, _emplaceAt, _changedComponents) {\n          if (node.componentsChanged) {\n            if (!_changedComponents) {\n              _changedComponents = node.componentNames.map(() => true);\n            }\n            const lines = [];\n            if (isVectorNode(node)) {\n              node.componentNames.forEach((name, i) => {\n                if (!_changedComponents[i]) return;\n                if (node[name] !== node.originalValues[i]) {\n                  const replacement = nodeConstructors['float'](node[name]);\n                  const line = `  ${node.temporaryVariable}.${name} = ${replacement.toGLSLBase(this)};`;\n                  lines.push(line);\n                }\n              });\n            } else {\n              const components = node.componentNames.map(name => {\n                return node[name];\n              });\n              const replacement = nodeConstructors[node.type](components);\n              const line = `  ${node.temporaryVariable} = ${replacement.toGLSLBase(this)};`;\n              lines.push(line);\n            }\n            if (_emplaceAt) {\n              this.declarations.splice(_emplaceAt, 0, ...lines);\n            } else {\n              this.declarations.push(...lines);\n            }\n            node.componentsChanged = false;\n          }\n        }\n      };\n      this.uniformNodes = [];\n    }\n  }\n\n  // User function helpers\n  function makeDependencyObject(dep) {\n    if (isVectorType(dep)) {\n      return {\n        node: dep,\n        isVector: true,\n        originalComponents: [...dep.componentNames.map(name => dep[name])],\n        get currentComponents() {\n          return dep.componentNames.map(name => dep[name]);\n        }\n      };\n    } else {\n      return {\n        node: dep,\n        isVector: false\n      };\n    }\n  }\n  function makeDependencyArray(dependencies) {\n    return dependencies.map(dep => makeDependencyObject(dep));\n  }\n  function conformVectorParameters(value, vectorDimensions) {\n    // Allow arguments as arrays or otherwise. The following are all equivalent:\n    // ([0,0,0,0]) (0,0,0,0) (0) ([0])\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n    value = value.flat();\n    value = value.map(val => {\n      if (isVectorType(val)) {\n        const componentArray = val.componentNames.map(comp => val[comp]);\n        return componentArray;\n      } else {\n        return val;\n      }\n    }).flat();\n    // Populate arguments so uniformVector3(0) becomes [0,0,0]\n    if (value.length === 1 && !isVectorNode(value[0])) {\n      value = Array(vectorDimensions).fill(value[0]);\n    }\n    return value;\n  }\n  function swizzleTrap(size) {\n    const swizzleSets = [['x', 'y', 'z', 'w'], ['r', 'g', 'b', 'a'], ['s', 't', 'p', 'q']].map(s => s.slice(0, size));\n    return {\n      get(target, property, receiver) {\n        if (property in target) {\n          return Reflect.get(...arguments);\n        } else {\n          for (const set of swizzleSets) {\n            if ([...property].every(char => set.includes(char))) {\n              if (property.length === 1) {\n                return target[swizzleSets[0][set.indexOf(property[0])]];\n              }\n              const components = [...property].map(char => {\n                const index = set.indexOf(char);\n                const mappedChar = swizzleSets[0][index];\n                return target[mappedChar];\n              });\n              const type = `vec${property.length}`;\n              return nodeConstructors[type](components);\n            }\n          }\n        }\n      },\n      set(target, property, value, receiver) {\n        for (const set of swizzleSets) {\n          const propertyCharArray = [...property];\n          if (propertyCharArray.every(char => set.includes(char))) {\n            const newValues = Array.isArray(value) ? value : Array(property.length).fill(value);\n            propertyCharArray.forEach((char, i) => {\n              const index = set.indexOf(char);\n              const realProperty = swizzleSets[0][index];\n              Reflect.set(target, realProperty, newValues[i], receiver);\n            });\n            return true;\n          }\n        }\n        return Reflect.set(...arguments);\n      }\n    };\n  }\n\n  // User functions\n  fn.If = function (condition, branch) {\n    return new ConditionalNode(condition, branch);\n  };\n  fn.instanceID = function () {\n    return variableConstructor('gl_InstanceID', 'int');\n  };\n  fn.getTexture = function (...userArgs) {\n    const props = {\n      args: ['sampler2D', 'vec2'],\n      returnType: 'vec4',\n      isp5Function: true\n    };\n    return fnNodeConstructor('getTexture', userArgs, props);\n  };\n\n  // Generating uniformFloat, uniformVec, createFloat, etc functions\n  // Maps a GLSL type to the name suffix for method names\n  const GLSLTypesToIdentifiers = {\n    int: 'Int',\n    float: 'Float',\n    vec2: 'Vector2',\n    vec3: 'Vector3',\n    vec4: 'Vector4',\n    sampler2D: 'Texture'\n  };\n  function dynamicAddSwizzleTrap(node, _size) {\n    if (node.type.startsWith('vec') || _size) {\n      const size = parseInt(node.type.slice(3));\n      node = new Proxy(node, swizzleTrap(size));\n      node.addVectorComponents();\n    }\n    return node;\n  }\n  function binaryExpressionNodeConstructor(a, b, operator, isInternal) {\n    let node;\n    if (operator === '%') {\n      node = new ModulusNode(a, b);\n    } else {\n      node = new BinaryExpressionNode(a, b, operator, isInternal);\n    }\n    return dynamicAddSwizzleTrap(node);\n  }\n  function variableConstructor(name, type, isInternal) {\n    const node = new VariableNode(name, type, isInternal);\n    return dynamicAddSwizzleTrap(node);\n  }\n  function fnNodeConstructor(name, userArgs, properties, isInternal) {\n    let node = new FunctionCallNode(name, userArgs, properties, isInternal);\n    node = dynamicAddSwizzleTrap(node);\n    node.dependsOn = makeDependencyArray(node.args);\n    const dependsOnConditionals = node.args.map(arg => {\n      const conditionals = arg.usedIn.filter(n => isConditionalNode(n)).map(c => {\n        if (c instanceof BranchNode) {\n          return c.parent;\n        } else {\n          return c;\n        }\n      });\n      return conditionals;\n    }).flat();\n    dependsOnConditionals.forEach(conditional => conditional.usedIn.push(node));\n    return node;\n  }\n  const nodeConstructors = {\n    int: value => new IntNode(value),\n    float: value => new FloatNode(value),\n    vec2: value => dynamicAddSwizzleTrap(new VectorNode(value, 'vec2')),\n    vec3: value => dynamicAddSwizzleTrap(new VectorNode(value, 'vec3')),\n    vec4: value => dynamicAddSwizzleTrap(new VectorNode(value, 'vec4')),\n    dynamicVector: function (value) {\n      const size = computeVectorLength(value);\n      return this[`vec${size}`](value);\n    }\n  };\n  for (const glslType in GLSLTypesToIdentifiers) {\n    // Generate uniform*() Methods for creating uniforms\n    const typeIdentifier = GLSLTypesToIdentifiers[glslType];\n    const uniformMethodName = `uniform${typeIdentifier}`;\n    ShaderGenerator.prototype[uniformMethodName] = function (...args) {\n      let [name, ...defaultValue] = args;\n      if (glslType.startsWith('vec') && !(defaultValue[0] instanceof Function)) {\n        defaultValue = conformVectorParameters(defaultValue, parseInt(glslType.slice(3)));\n        this.output.uniforms[`${glslType} ${name}`] = defaultValue;\n      } else {\n        this.output.uniforms[`${glslType} ${name}`] = defaultValue[0];\n      }\n      const uniform = variableConstructor(name, glslType, false);\n      this.uniformNodes.push(uniform);\n      return uniform;\n    };\n    fn[uniformMethodName] = function (...args) {\n      return GLOBAL_SHADER[uniformMethodName](...args);\n    };\n\n    // We don't need a texture creation method.\n    if (glslType === 'sampler2D') {\n      continue;\n    }\n    const varyingMethodName = `varying${typeIdentifier}`;\n    ShaderGenerator.prototype[varyingMethodName] = function (name) {\n      return dynamicAddSwizzleTrap(new VaryingNode(name, glslType, false));\n    };\n    fn[varyingMethodName] = function (name) {\n      return GLOBAL_SHADER[varyingMethodName](name);\n    };\n\n    // Generate the creation methods for creating variables in shaders\n    const originalFn = fn[glslType];\n    fn[glslType] = function (...value) {\n      if (GLOBAL_SHADER?.isGenerating) {\n        if (glslType.startsWith('vec')) {\n          value = conformVectorParameters(value, parseInt(glslType.slice(3)));\n        } else {\n          value = value[0];\n        }\n        return nodeConstructors[glslType](value);\n      } else if (originalFn) {\n        return originalFn.apply(this, value);\n      } else {\n        p5._friendlyError(`It looks like you've called ${glslType} outside of a shader's modify() function.`);\n      }\n    };\n  }\n\n  // GLSL Built in functions\n  // Add a whole lot of these functions.\n  // https://docs.gl/el3/abs\n  const builtInGLSLFunctions = {\n    //////////// Trigonometry //////////\n    'acos': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'acosh': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'asin': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'asinh': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'atan': [{\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    }, {\n      args: ['genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    }],\n    'atanh': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'cos': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'cosh': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'degrees': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'radians': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'sin': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'sinh': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'tan': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'tanh': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    ////////// Mathematics //////////\n    'abs': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'ceil': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'clamp': {\n      args: ['genType', 'genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'dFdx': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'dFdy': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'exp': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'exp2': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'floor': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'fma': {\n      args: ['genType', 'genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'fract': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'fwidth': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'inversesqrt': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    // 'isinf': {},\n    // 'isnan': {},\n    'log': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'log2': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'max': [{\n      args: ['genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: true\n    }, {\n      args: ['genType', 'float'],\n      returnType: 'genType',\n      isp5Function: true\n    }],\n    'min': [{\n      args: ['genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: true\n    }, {\n      args: ['genType', 'float'],\n      returnType: 'genType',\n      isp5Function: true\n    }],\n    'mix': [{\n      args: ['genType', 'genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    }, {\n      args: ['genType', 'genType', 'float'],\n      returnType: 'genType',\n      isp5Function: false\n    }],\n    // 'mod': {},\n    // 'modf': {},\n    'pow': {\n      args: ['genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'round': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'roundEven': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    // 'sign': {},\n    'smoothstep': [{\n      args: ['genType', 'genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    }, {\n      args: ['float', 'float', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    }],\n    'sqrt': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    'step': {\n      args: ['genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'trunc': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    ////////// Vector //////////\n    'cross': {\n      args: ['vec3', 'vec3'],\n      returnType: 'vec3',\n      isp5Function: true\n    },\n    'distance': {\n      args: ['genType', 'genType'],\n      returnType: 'float',\n      isp5Function: true\n    },\n    'dot': {\n      args: ['genType', 'genType'],\n      returnType: 'float',\n      isp5Function: true\n    },\n    // 'equal': {},\n    'faceforward': {\n      args: ['genType', 'genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'length': {\n      args: ['genType'],\n      returnType: 'float',\n      isp5Function: false\n    },\n    'normalize': {\n      args: ['genType'],\n      returnType: 'genType',\n      isp5Function: true\n    },\n    // 'notEqual': {},\n    'reflect': {\n      args: ['genType', 'genType'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    'refract': {\n      args: ['genType', 'genType', 'float'],\n      returnType: 'genType',\n      isp5Function: false\n    },\n    ////////// Texture sampling //////////\n    'texture': {\n      args: ['sampler2D', 'vec2'],\n      returnType: 'vec4',\n      isp5Function: true\n    }\n  };\n  Object.entries(builtInGLSLFunctions).forEach(([functionName, properties]) => {\n    const isp5Function = Array.isArray(properties) ? properties[0].isp5Function : properties.isp5Function;\n    if (isp5Function) {\n      const originalFn = fn[functionName];\n      fn[functionName] = function (...args) {\n        if (GLOBAL_SHADER?.isGenerating) {\n          return fnNodeConstructor(functionName, args, properties);\n        } else {\n          return originalFn.apply(this, args);\n        }\n      };\n    } else {\n      fn[functionName] = function (...args) {\n        if (GLOBAL_SHADER?.isGenerating) {\n          return new fnNodeConstructor(functionName, args, properties);\n        } else {\n          p5._friendlyError(`It looks like you've called ${functionName} outside of a shader's modify() function.`);\n        }\n      };\n    }\n  });\n}\nif (typeof p5 !== 'undefined') {\n  p5.registerAddon(shadergenerator);\n}\nexport { shadergenerator as default };","map":{"version":3,"names":["parse","ancestor","escodegen","shadergenerator","p5","fn","GLOBAL_SHADER","BRANCH","oldModify","Shader","prototype","modify","shaderModifier","options","parser","srcLocations","Function","generatorFunction","sourceString","toString","ast","ecmaVersion","locations","ASTCallbacks","undefined","varyings","transpiledSource","generate","slice","indexOf","lastIndexOf","replaceAll","generator","ShaderGenerator","generatedModifyArgument","call","replaceBinaryOperator","codeSource","ancestorIsUniform","type","callee","name","startsWith","UnaryExpression","node","_state","_ancestors","some","signNode","value","operator","standardReplacement","arguments","argument","property","swizzleSets","isSwizzle","set","every","char","includes","object","VariableDeclarator","init","uniformNameLiteral","id","unshift","varyingNameLiteral","Identifier","a","left","expression","ArrayExpression","original","JSON","stringify","AssignmentExpression","methodName","replace","rightReplacementNode","right","BinaryExpression","unsafeTypes","leftReplacementNode","BaseNode","constructor","isInternal","new","target","TypeError","componentNames","componentsChanged","usedIn","dependsOn","srcLine","usedInConditional","Error","e","lines","stack","split","userSketchLineIndex","isBinaryExpressionNode","trim","addVectorComponents","vectorDimensions","parseInt","proxy","componentName","ComponentNode","Object","defineProperty","get","newValue","isUnaryExpressionNode","forceTemporaryVariable","isFloatNode","isVectorNode","parent","isVariableNode","useTemp","assertUsedInConditional","branch","push","isUsedInConditional","checkConditionalDependencies","context","ifs","forEach","statement","isUsedSatisfied","usedInSatisfied","length","isDepsSatisfied","dependsOnSatisfied","insertionPoint","d","saveState","toGLSLBase","result","shouldUseTemporaryVariable","oldLength","declarations","getTemporaryVariable","diff","dependency","isVector","dependencies","originalComponents","map","component","i","currentComponents","updateComponents","toGLSL","hasTemporaryVariable","isConditionalNode","score","isFunctionCallNode","isVectorType","temporaryVariable","getNextID","line","add","other","binaryExpressionNodeConstructor","enforceType","sub","mult","div","mod","isShaderNode","isGLSLNativeType","isFloatType","isIntType","FloatNode","IntNode","Array","isArray","nodeConstructors","dynamicVector","toFloat","x","code","Math","floor","_parent","toFixed","VectorNode","values","originalValues","conformVectorParameters","info","defined","oldName","glslArgs","_name","join","FunctionCallNode","userArgs","properties","functionSignature","determineFunctionSignature","props","genType","similarity","valid","userArg","userType","getType","expectedArgType","args","possibleOverloads","filter","o","argsLengthSet","Set","argsLengthArr","p","len","argsLengthStr","findBestOverload","best","current","reduce","argsStrJoin","arg","expectedArgsString","prop","providedArgsString","typeName","returnType","argumentTypes","deconstructArgs","argsString","argNode","VariableNode","parentName","VaryingNode","timesChanged","tempVars","getValue","splice","snapshot","val","tempName","dynamicAddSwizzleTrap","bridge","registerVarying","BinaryExpressionNode","operand","determineType","processOperand","b","ModulusNode","UnaryExpressionNode","mainStr","isPrimitiveNode","equalTo","greaterThan","greaterThanEqualTo","lessThan","lessThanEqualTo","not","condition","or","and","callback","BranchNode","ConditionalNode","branchCallback","states","if","elseIfs","elseBranch","conditionString","ifBranch","elseIf","else","thenDiscard","ConditionalDiscard","dep","newLength","codelines","elif","flat","assign","error","statements","assignments","newParent","n","makeDependencyObject","declarationsIndex","decl","discardConditions","computeVectorLength","dynamicNode","input","unaryNode","sign","glslNativeTypes","userCallback","originalShader","cleanup","generateHookOverrides","output","vertexDeclarations","fragmentDeclarations","uniforms","uniformNodes","resetGLSLContext","isGenerating","prevFESDisabled","disableFriendlyErrors","availableHooks","hooks","vertex","fragment","windowOverrides","keys","hookName","hookTypes","argNodes","argsArray","parameters","parameter","structArg","variableConstructor","qualifiers","returnedValue","expectedReturnType","toGLSLResults","entries","propertyName","propertyNode","codeLines","propString","key","declArray","finalVaryingAssignments","obj","window","userOverride","_emplaceAt","_changedComponents","replacement","components","makeDependencyArray","componentArray","comp","fill","swizzleTrap","size","s","receiver","Reflect","index","mappedChar","propertyCharArray","newValues","realProperty","If","instanceID","getTexture","isp5Function","fnNodeConstructor","GLSLTypesToIdentifiers","int","float","vec2","vec3","vec4","sampler2D","_size","Proxy","dependsOnConditionals","conditionals","c","conditional","glslType","typeIdentifier","uniformMethodName","defaultValue","uniform","varyingMethodName","originalFn","apply","_friendlyError","builtInGLSLFunctions","functionName","registerAddon","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/webgl/ShaderGenerator.js"],"sourcesContent":["import { parse } from 'acorn';\nimport { ancestor } from 'acorn-walk';\nimport escodegen from 'escodegen';\n\n/**\n* @module 3D\n* @submodule ShaderGenerator\n* @for p5\n* @requires core\n*/\n\nfunction shadergenerator(p5, fn) {\n  let GLOBAL_SHADER;\n  let BRANCH;\n\n  const oldModify = p5.Shader.prototype.modify;\n\n  p5.Shader.prototype.modify = function(shaderModifier, options = { parser: true, srcLocations: false }) {\n    if (shaderModifier instanceof Function) {\n      let generatorFunction;\n      if (options.parser) {\n        const sourceString = shaderModifier.toString();\n        const ast = parse(sourceString, {\n          ecmaVersion: 2021,\n          locations: options.srcLocations\n        });\n        ancestor(ast, ASTCallbacks, undefined, { varyings: {} });\n        const transpiledSource = escodegen.generate(ast);\n        generatorFunction = new Function(\n          transpiledSource\n          .slice(\n            transpiledSource.indexOf('{') + 1,\n            transpiledSource.lastIndexOf('}')\n          ).replaceAll(';', '')\n        );\n      } else {\n        generatorFunction = shaderModifier;\n      }\n      const generator = new ShaderGenerator(generatorFunction, this, options.srcLocations);\n      const generatedModifyArgument = generator.generate();\n      return oldModify.call(this, generatedModifyArgument);\n    }\n    else {\n      return oldModify.call(this, shaderModifier)\n    }\n  };\n\n  // AST Transpiler Callbacks and helper functions\n  function replaceBinaryOperator(codeSource) {\n    switch (codeSource) {\n      case '+': return 'add';\n      case '-': return 'sub';\n      case '*': return 'mult';\n      case '/': return 'div';\n      case '%': return 'mod';\n      case '==':\n      case '===': return 'equalTo';\n      case '>': return 'greaterThan';\n      case '>=': return 'greaterThanEqualTo';\n      case '<': return 'lessThan';\n      case '&&': return 'and';\n      case '||': return 'or';\n    }\n  }\n\n  function ancestorIsUniform(ancestor) {\n    return ancestor.type === 'CallExpression'\n      && ancestor.callee?.type === 'Identifier'\n      && ancestor.callee?.name.startsWith('uniform');\n  }\n\n  const ASTCallbacks = {\n    UnaryExpression(node, _state, _ancestors) {\n      if (_ancestors.some(ancestorIsUniform)) { return; }\n\n      const signNode = {\n        type: 'Literal',\n        value: node.operator,\n      };\n\n      const standardReplacement = (node) => {\n          node.type = 'CallExpression';\n          node.callee = {\n            type: 'Identifier',\n            name: 'unaryNode',\n          };\n          node.arguments = [node.argument, signNode];\n      };\n\n      if (node.type === 'MemberExpression') {\n        const property = node.argument.property.name;\n        const swizzleSets = [\n          ['x', 'y', 'z', 'w'],\n          ['r', 'g', 'b', 'a'],\n          ['s', 't', 'p', 'q']\n        ];\n\n        let isSwizzle = swizzleSets.some(set =>\n          [...property].every(char => set.includes(char))\n        ) && node.argument.type === 'MemberExpression';\n\n        if (isSwizzle) {\n          node.type = 'MemberExpression';\n          node.object = {\n            type: 'CallExpression',\n            callee: {\n              type: 'Identifier',\n              name: 'unaryNode'\n            },\n            arguments: [node.argument.object, signNode],\n          };\n          node.property = {\n            type: 'Identifier',\n            name: property\n          };\n        } else {\n          standardReplacement(node);\n        }\n      } else {\n        standardReplacement(node);\n      }\n      delete node.argument;\n      delete node.operator;\n    },\n    VariableDeclarator(node, _state, _ancestors) {\n      if (node.init.callee && node.init.callee.name?.startsWith('uniform')) {\n        const uniformNameLiteral = {\n          type: 'Literal',\n          value: node.id.name\n        };\n        node.init.arguments.unshift(uniformNameLiteral);\n      }\n      if (node.init.callee && node.init.callee.name?.startsWith('varying')) {\n        const varyingNameLiteral = {\n          type: 'Literal',\n          value: node.id.name\n        };\n        node.init.arguments.unshift(varyingNameLiteral);\n        _state.varyings[node.id.name] = varyingNameLiteral;\n      }\n    },\n    Identifier(node, _state, _ancestors) {\n      if (_state.varyings[node.name]\n          && !_ancestors.some(a => a.type === 'AssignmentExpression' && a.left === node)) {\n        node.type = 'ExpressionStatement';\n        node.expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: {\n              type: 'Identifier',\n              name: node.name\n            },\n            property: {\n              type: 'Identifier',\n              name: 'getValue'\n            },\n          },\n          arguments: [],\n        };\n      }\n    },\n    // The callbacks for AssignmentExpression and BinaryExpression handle\n    // operator overloading including +=, *= assignment expressions\n    ArrayExpression(node, _state, _ancestors) {\n      const original = JSON.parse(JSON.stringify(node));\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'Identifier',\n        name: 'dynamicNode',\n      };\n      node.arguments = [original];\n    },\n    AssignmentExpression(node, _state, _ancestors) {\n      if (node.operator !== '=') {\n        const methodName = replaceBinaryOperator(node.operator.replace('=',''));\n        const rightReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: node.left,\n            property: {\n              type: 'Identifier',\n              name: methodName,\n            },\n          },\n          arguments: [node.right]\n        };\n          node.operator = '=';\n          node.right = rightReplacementNode;\n        }\n        if (_state.varyings[node.left.name]) {\n          node.type = 'ExpressionStatement';\n          node.expression = {\n            type: 'CallExpression',\n            callee: {\n              type: 'MemberExpression',\n              object: {\n                type: 'Identifier',\n                name: node.left.name\n              },\n              property: {\n                type: 'Identifier',\n                name: 'bridge',\n              }\n            },\n            arguments: [node.right],\n          };\n        }\n      },\n    BinaryExpression(node, _state, _ancestors) {\n      // Don't convert uniform default values to node methods, as\n      // they should be evaluated at runtime, not compiled.\n      if (_ancestors.some(ancestorIsUniform)) { return; }\n      // If the left hand side of an expression is one of these types,\n      // we should construct a node from it.\n      const unsafeTypes = ['Literal', 'ArrayExpression', 'Identifier'];\n      if (unsafeTypes.includes(node.left.type)) {\n        const leftReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: 'dynamicNode',\n          },\n          arguments: [node.left]\n        };\n        node.left = leftReplacementNode;\n      }\n      // Replace the binary operator with a call expression\n      // in other words a call to BaseNode.mult(), .div() etc.\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'MemberExpression',\n        object: node.left,\n        property: {\n          type: 'Identifier',\n          name: replaceBinaryOperator(node.operator),\n        },\n      };\n      node.arguments = [node.right];\n    },\n  };\n\n  // Javascript Node API.\n  class BaseNode {\n    constructor(isInternal, type) {\n      if (new.target === BaseNode) {\n        throw new TypeError('Cannot construct BaseNode instances directly. This is an abstract class.');\n      }\n      this.type = type;\n      this.componentNames = [];\n      this.componentsChanged = false;\n      // For tracking recursion depth and creating temporary variables\n      this.isInternal = isInternal;\n      this.usedIn = [];\n      this.dependsOn = [];\n      this.srcLine = null;\n      this.usedInConditional = false;\n      // Stack Capture is used to get the original line of user code for Debug purposes\n      if (GLOBAL_SHADER.srcLocations === true && isInternal === false) {\n        try {\n          throw new Error('StackCapture');\n        } catch (e) {\n          const lines = e.stack.split('\\n');\n          let userSketchLineIndex = 5;\n          if (isBinaryExpressionNode(this)) { userSketchLineIndex--; }          this.srcLine = lines[userSketchLineIndex].trim();\n        }\n      }\n    }\n\n    addVectorComponents() {\n      if (this.type.startsWith('vec')) {\n        const vectorDimensions = parseInt(this.type.slice(3));\n        this.componentNames = ['x', 'y', 'z', 'w'].slice(0, vectorDimensions);\n        const proxy = this;\n        for (let componentName of this.componentNames) {\n          let value = new ComponentNode(proxy, componentName, 'float', true);\n          Object.defineProperty(this, componentName, {\n            get() {\n              return value;\n            },\n            set(newValue) {\n              this.componentsChanged = true;\n              if (isUnaryExpressionNode(this)) {\n                this.node.value = newValue;\n              } else {\n                value = newValue;\n              }\n            }\n          });\n        }\n      }\n    }\n\n    forceTemporaryVariable() {\n      if (!(isFloatNode(this) && isVectorNode(this.parent)) || !isVariableNode(this))\n      this.useTemp = true;\n    }\n\n    assertUsedInConditional(branch) {\n      this.usedInConditional = true;\n      this.usedIn.push(branch);\n      this.forceTemporaryVariable();\n    }\n\n    isUsedInConditional() {\n      return this.usedInConditional;\n    }\n\n    checkConditionalDependencies(context) {\n      context.ifs.forEach((statement) => {\n        const isUsedSatisfied = () => statement.usedInSatisfied.length >= 1;\n        const isDepsSatisfied = () => statement.dependsOn.length === statement.dependsOnSatisfied.length;\n        if (statement.insertionPoint > -1 || !statement.usedIn.length) return;\n        if (statement.dependsOn.some(d => d.node === this) && !statement.dependsOnSatisfied.includes(this)) {\n          statement.dependsOnSatisfied.push(this);\n        }\n        if (statement.usedIn.includes(this) && !statement.usedInSatisfied.includes(this)) {\n          statement.usedInSatisfied.push(this);\n        }\n        if (isDepsSatisfied() && isUsedSatisfied()) {\n          statement.saveState(context, isDepsSatisfied(), isUsedSatisfied());\n        }\n      });\n    }\n\n    // The base node implements a version of toGLSL which determines whether the generated code should be stored in a temporary variable.\n    toGLSLBase(context){\n      let result;\n      if (this.shouldUseTemporaryVariable()) {\n        let oldLength = context.declarations.length;\n        result = this.getTemporaryVariable(context);\n        let diff = context.declarations.length - 1 - oldLength;\n        diff = diff > 0 ? diff : undefined;\n        this.dependsOn.forEach(dependency => {\n          if (dependency.isVector) {\n            const dependencies = dependency.originalComponents.map((component, i) =>\n              component === dependency.currentComponents[i]\n            );\n            context.updateComponents(dependency.node, diff, dependencies);\n          } else {\n            context.updateComponents(dependency.node, diff);\n          }\n        });\n      } else {\n        result = this.toGLSL(context);\n      }\n      this.checkConditionalDependencies(context);\n      return result;\n    }\n\n    shouldUseTemporaryVariable() {\n      if (this.componentsChanged || hasTemporaryVariable(this) || this.useTemp) { return true; }\n      if (this.isInternal || isVariableNode(this) || isConditionalNode(this) || this.type === 'sampler2D') { return false; }\n\n      // return false;\n      // Swizzles must use temporary variables as otherwise they will not be registered\n      let score = 0;\n      score += isFunctionCallNode(this) * 2;\n      score += isBinaryExpressionNode(this) * 2;\n      score += isVectorType(this) * 3;\n      score += this.usedIn.length;\n      return score >= 4;\n    }\n\n    getTemporaryVariable(context) {\n      if (!this.temporaryVariable) {\n        this.temporaryVariable = `temp_${context.getNextID()}`;\n        let line = '';\n        if (this.srcLine) {\n          line += `\\n// From ${this.srcLine}\\n`;\n        }\n        line += '  ' + this.type + ' ' + this.temporaryVariable + ' = ' + this.toGLSL(context) + ';';\n        context.declarations.push(line);\n      }\n      return this.temporaryVariable;\n    };\n\n    // Binary Operators\n    add(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '+'); }\n    sub(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '-'); }\n    mult(other) { return binaryExpressionNodeConstructor(this, this.enforceType(other), '*'); }\n    div(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '/'); }\n    mod(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '%'); }\n\n    // Check that the types of the operands are compatible.\n    enforceType(other){\n      if (isShaderNode(other)){\n        if (!isGLSLNativeType(other.type)) {\n          throw new TypeError (`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`)\n        }\n        if (!isGLSLNativeType(other.type)) {\n          throw new TypeError (`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`)\n        }\n        if ((isFloatType(this) || isVectorType(this)) && isIntType(other)) {\n          return new FloatNode(other)\n        }\n        return other;\n      }\n      else if (typeof other === 'number') {\n        if (isIntType(this)) {\n          return new IntNode(other);\n        }\n        return new FloatNode(other);\n      }\n      else if (Array.isArray(other)) {\n        return nodeConstructors.dynamicVector(other);\n        // return nodeConstructors[`vec${other.length}`](other);\n      }\n      else {\n        return nodeConstructors[this.type](other);\n      }\n    }\n\n    toFloat() {\n      if (isFloatType(this)) {\n        return this;\n      } else if (isIntType(this)) {\n        return new FloatNode(this);\n      }\n    }\n\n    toGLSL(context){\n      throw new TypeError('Not supposed to call this function on BaseNode, which is an abstract class.');\n    }\n  }\n\n  // Primitive Types\n  class IntNode extends BaseNode {\n    constructor(x = 0, isInternal = false) {\n      super(isInternal, 'int');\n      this.x = x;\n    }\n\n    toGLSL(context) {\n      if (isShaderNode(this.x)) {\n        let code = this.x.toGLSLBase(context);\n        return isIntType(this.x.type) ? code : `int(${code})`;\n      }\n      else if (typeof this.x === 'number') {\n        return `${Math.floor(this.x)}`;\n      }\n      else {\n        return `int(${this.x})`;\n      }\n    }\n  }\n\n  class FloatNode extends BaseNode {\n    constructor(x = 0, isInternal = false, _parent = false){\n      super(isInternal, 'float');\n      if (Array.isArray(x)) {\n        x = x[0];\n      }\n      if (_parent) {\n        const { parent, name } = _parent;\n        this.name = name;\n        this.parent = parent;\n      }\n      this.x = x;\n    }\n\n    toGLSL(context) {\n      if (isShaderNode(this.x)) {\n        let code = this.x.toGLSLBase(context);\n        return isFloatType(this.x) ? code : `float(${code})`;\n      }\n      else if (typeof this.x === 'number') {\n        return `${this.x.toFixed(4)}`;\n      }\n      else {\n        return `float(${this.x})`;\n      }\n    }\n  }\n\n  class VectorNode extends BaseNode {\n    constructor(values, type, isInternal = false) {\n      super(isInternal, type);\n      this.originalValues = conformVectorParameters(values, parseInt(type.slice(3)));\n      this.componentNames = ['x', 'y', 'z', 'w'].slice(0, this.originalValues.length);\n    }\n\n    addVectorComponents() {\n      const values = this.originalValues;\n      this.componentsChanged = false;\n\n      this.componentNames.forEach((componentName, i) => {\n        const info = { name: componentName, parent: this };\n        let value = isFloatNode(values[i]) ? values[i] : new FloatNode(values[i], true, info);\n        Object.defineProperty(this, componentName, {\n          get() {\n            return value;\n          },\n          set(newValue) {\n            this.componentsChanged = true;\n            if (isUnaryExpressionNode(this)) {\n              this.node.value = newValue;\n            } else {\n              value = isFloatNode(newValue) ? newValue : new FloatNode(newValue, true, info);\n            }\n          }\n        });\n      });\n      this.originalValues = this.componentNames.map(name => this[name]);\n    }\n\n    toGLSL(context) {\n      if ((!this.componentsChanged || !this.defined) && !this.oldName) {\n        let glslArgs = this.componentNames.map((_name, i) => this.originalValues[i].toGLSLBase(context)).join(', ');\n        this.defined = true;\n        return `${this.type}(${glslArgs})`;\n      } else {\n        return this.temporaryVariable;\n      }\n    }\n  }\n\n  // Function Call Nodes\n  class FunctionCallNode extends BaseNode {\n    constructor(name, userArgs, properties, isInternal = false) {\n      let functionSignature;\n      const determineFunctionSignature = (props) => {\n        let genType;\n        let similarity = 0;\n\n        const valid = userArgs.every((userArg, i) => {\n          const userType = getType(userArg);\n          let expectedArgType = props.args[i];\n\n          if (expectedArgType === 'genType') {\n            // We allow conversions from float -> vec if one argument is a vector.\n            if (genType === undefined || (genType === 'float' && userType.startsWith('vec'))) {\n              genType = userType;\n            }            expectedArgType = genType;\n          }\n          similarity += (userType === expectedArgType);\n          return userType === expectedArgType || (userType === 'float' && expectedArgType.startsWith('vec'));\n        });\n\n        return { ...props, valid, similarity, genType }\n      };\n\n      if (Array.isArray(properties)) {\n        // Check if the right number of parameters were provided\n        let possibleOverloads = properties.filter(o => o.args.length === userArgs.length);\n        if (possibleOverloads.length === 0) {\n          const argsLengthSet = new Set();\n          const argsLengthArr = [];\n          properties.forEach((p) => argsLengthSet.add(p.args.length));\n          argsLengthSet.forEach((len) => argsLengthArr.push(`${len}`));\n          const argsLengthStr = argsLengthArr.join(' or ');\n          throw new Error(`Function '${name}' has ${properties.length} variants which expect ${argsLengthStr} arguments, but ${userArgs.length} arguments were provided.`);\n        }\n        const findBestOverload = function (best, current) {\n          current = determineFunctionSignature(current);\n          if (!current.valid) { return best; }\n          if (!best || current.similarity > best.similarity) {\n            best = current;\n          }\n          return best;\n        };\n        functionSignature = possibleOverloads.reduce(findBestOverload, null);\n      } else {\n        functionSignature = determineFunctionSignature(properties);\n      }\n\n      if (!functionSignature || !functionSignature.valid) {\n        const argsStrJoin = (args) => `(${args.map((arg) => arg).join(', ')})`;\n        const expectedArgsString = Array.isArray(properties) ?\n          properties.map(prop => argsStrJoin(prop.args)).join(' or ')\n          : argsStrJoin(properties.args);\n        const providedArgsString = argsStrJoin(userArgs.map((a)=>getType(a)));\n          throw new Error(`Function '${name}' was called with wrong arguments. Most likely, you provided mixed lengths vectors as arguments.\\nExpected argument types: ${expectedArgsString}\\nProvided argument types: ${providedArgsString}\\nAll of the arguments with expected type 'genType' should have a matching type. If one of those is different, try to find where it was created.\n        `);\n      }\n\n      if (userArgs.length !== functionSignature.args.length) {\n        throw new Error(`Function '${name}' expects ${functionSignature.args.length} arguments, but ${userArgs.length} were provided.`);\n      }\n\n      userArgs = userArgs.map((arg, i) => {\n        if (!isShaderNode(arg)) {\n          const typeName = functionSignature.args[i] === 'genType' ? functionSignature.genType : functionSignature.args[i];\n          arg = nodeConstructors[typeName](arg);\n        } else if (isFloatType(arg) && functionSignature.args[i] === 'genType' && functionSignature.genType !== 'float') {\n          arg = nodeConstructors[functionSignature.genType](arg);\n        }\n        return arg;\n      });\n\n      if (functionSignature.returnType === 'genType') {\n        functionSignature.returnType = functionSignature.genType;\n      }\n\n      super(isInternal, functionSignature.returnType);\n\n      this.name = name;\n      this.args = userArgs;\n      this.argumentTypes = functionSignature.args;\n    }\n\n    deconstructArgs(context) {\n      let argsString = this.args.map((argNode, i) => {\n        if (isIntType(argNode) && this.argumentTypes[i] != 'float') {\n          argNode = argNode.toFloat();\n        }\n        argNode.toGLSLBase(context);\n        return argNode.toGLSLBase(context);\n      }).join(', ');\n      return argsString;\n    }\n\n    toGLSL(context) {\n      return `${this.name}(${this.deconstructArgs(context)})`;\n    }\n  }\n\n  // Variables and member variable nodes\n  class VariableNode extends BaseNode {\n    constructor(name, type, isInternal = false) {\n      super(isInternal, type);\n      this.name = name;\n    }\n\n    toGLSL(context) {\n      return `${this.name}`;\n    }\n  }\n\n  class ComponentNode extends BaseNode {\n    constructor(parent, componentName, type, isInternal = false) {\n      super(isInternal, type);\n      this.parent = parent;\n      this.componentName = componentName;\n      this.type = type;\n    }\n    toGLSL(context) {\n      let parentName = this.parent.toGLSLBase(context);\n      if (!isVariableNode(this.parent) && !hasTemporaryVariable(this.parent)) {\n        parentName = `(${parentName})`;\n      }\n      return `${parentName}.${this.componentName}`;\n    }\n  }\n\n  //\n  class VaryingNode extends VariableNode {\n    constructor(name, type, isInternal = false) {\n      super(name, type, isInternal);\n      this.timesChanged = 0;\n      this.tempVars = 0;\n    }\n\n    getValue() {\n      const context = GLOBAL_SHADER.context;\n      if (!context.varyings[this.name] || !this.timesChanged) {\n        return this;\n      }\n\n      let values = context.varyings[this.name].splice(0, this.timesChanged);\n      let snapshot;\n      values.forEach((val, i) => {\n        let { value } = val;\n        context.declarations.push(`  ${this.name} = ${value.toGLSLBase(context)};`);\n        if (i === values.length - 1) {\n          const tempName = `${this.name}_${this.tempVars++}`;\n          snapshot = dynamicAddSwizzleTrap(new VariableNode(tempName, this.type, true));\n          context.declarations.push(`  ${this.type} ${tempName} = ${this.name};`);\n        }\n      });\n\n      this.timesChanged = 0;\n      return snapshot;\n    }\n\n    bridge(value) {\n      if (!isShaderNode(value) || this.type.startsWith('vec') && getType(value) === 'float') {\n        value = nodeConstructors[this.type](value);\n      }\n      GLOBAL_SHADER.registerVarying(this, value);\n      this.timesChanged += 1;\n    }\n  }\n\n  // Binary Operator Nodes\n  class BinaryExpressionNode extends BaseNode {\n    constructor(left, right, operator, isInternal = false) {\n      super(isInternal, null);\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      for (const operand of [left, right]) {\n        operand.usedIn.push(this);\n      }\n      this.type = this.determineType();\n    }\n\n    // We know that both this.left and this.right are nodes because of BaseNode.enforceType\n    determineType() {\n      if (['==', '>', '>=', '<', '<=', '||', '!', '&&'].includes(this.operator)) {\n        return 'bool';\n      }\n      else if (this.left.type === this.right.type) {\n        return this.left.type;\n      }\n      else if (isVectorType(this.left) && isFloatType(this.right)) {\n        return this.left.type;\n      }\n      else if (isVectorType(this.right) && isFloatType(this.left)) {\n        return this.right.type;\n      }\n      else if (isFloatType(this.left) && isIntType(this.right)\n        || isIntType(this.left) && isFloatType(this.right)\n      ) {\n        return 'float';\n      }\n      else {\n        throw new Error('Incompatible types for binary operator');\n      }\n    }\n\n    processOperand(operand, context) {\n      if (operand.temporaryVariable) { return operand.temporaryVariable; }\n      let code = operand.toGLSLBase(context);\n      if (isBinaryExpressionNode(operand) && !operand.temporaryVariable) {\n        code = `(${code})`;\n      }\n      if (this.type === 'float' && isIntType(operand)) {\n        code = `float(${code})`;\n      }\n      return code;\n    }\n\n    toGLSL(context) {\n      const a = this.processOperand(this.left, context);\n      const b = this.processOperand(this.right, context);\n      return `${a} ${this.operator} ${b}`;\n    }\n  }\n\n  class ModulusNode extends BinaryExpressionNode {\n    constructor(a, b, isInternal) {\n      super(a, b, isInternal);\n    }\n    toGLSL(context) {\n      // Switch on type between % or mod()\n      if (isVectorType(this) || isFloatType(this)) {\n        return `mod(${this.left.toGLSLBase(context)}, ${this.right.toGLSLBase(context)})`;\n      }\n      return `${this.processOperand(context, this.left)} % ${this.processOperand(context, this.right)}`;\n    }\n  }\n\n  class UnaryExpressionNode extends BaseNode {\n    constructor(node, operator, isInternal = false) {\n      super(isInternal, node.type);\n      this.node = node;\n      this.operator = operator;\n    }\n\n    toGLSL(context) {\n      let mainStr = this.node.toGLSLBase(context);\n      if (!isVariableNode(this.node) && !hasTemporaryVariable(this.node) && !isPrimitiveNode(this.node)) {\n        mainStr = `(${mainStr})`;\n      }\n      return `${this.operator}${mainStr}`\n    }\n  }\n\n  // Conditions and logical modifiers\n  BaseNode.prototype.equalTo = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '==');\n  };\n\n  BaseNode.prototype.greaterThan = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '>');\n  };\n\n  BaseNode.prototype.greaterThanEqualTo = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '>=');\n  };\n\n  BaseNode.prototype.lessThan = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '<');\n  };\n\n  BaseNode.prototype.lessThanEqualTo = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '<='); };\n\n  BaseNode.prototype.not = function() {\n     return new UnaryExpressionNode(this.condition, '!', true);\n  };\n\n  BaseNode.prototype.or = function(other) {\n    return new binaryExpressionNodeConstructor(this, this.enforceType(other), '||', true);\n  };\n\n  BaseNode.prototype.and = function(other) {\n    return new binaryExpressionNodeConstructor(this, this.enforceType(other), '&&', true);\n  };\n\n  function branch(callback) {\n    const branch = new BranchNode();\n    callback();\n    BRANCH = null;\n    return branch;\n  }\n\n  class ConditionalNode {\n    constructor(condition, branchCallback) {\n      this.dependsOn = [];\n      this.usedIn = [];\n      this.dependsOnSatisfied = [];\n      this.usedInSatisfied = [];\n      this.states = [];\n      this.if(condition, branchCallback);\n      this.insertionPoint = -1;\n      this.elseIfs = [];\n      this.elseBranch = null;\n      GLOBAL_SHADER.context.ifs.push(this);\n    }\n\n    if(condition, branchCallback) {\n      this.condition = condition;\n      this.conditionString = condition.toGLSL(GLOBAL_SHADER.context);\n      this.ifBranch = branch(branchCallback);\n      this.ifBranch.parent = this;\n    }\n\n    elseIf(condition, branchCallback) {\n      let elseBranch = branch(branchCallback);\n      branchCallback.parent = this;\n      this.elseIfs.push({ condition, elseBranch });\n      return this;\n    }\n\n    else(branchCallback) {\n      this.elseBranch = branch(branchCallback);\n      this.elseBranch.parent = this;\n      return this;\n    }\n\n    thenDiscard() {\n      return new ConditionalDiscard(this.condition);\n    };\n\n    saveState(context, usedInSatisfied, dependsOnSatisfied) {\n      this.states.push({\n        line: context.declarations.length,\n        usedInSatisfied,\n        dependsOnSatisfied\n      });\n      this.insertionPoint = context.declarations.length - 1;\n    }\n\n    toGLSL(context) {\n      const oldLength = context.declarations.length;\n      this.dependsOn.forEach(dep => context.updateComponents(dep.node));\n      const newLength = context.declarations.length;\n      const diff = newLength - oldLength;\n      this.insertionPoint += diff;\n\n      let codelines = [\n        `\\n  if (${this.conditionString}) {`,\n        `\\n    ${this.ifBranch.toGLSL(context)}`,\n        `\\n  }`\n      ];\n\n      if (this.elseIfs.length) {\n        this.elseIfs.forEach((elif) => {\n          let { condition, elseBranch } = elif;\n          codelines.push(` else if (${condition.toGLSL(context)}) {`);\n          codelines.push(`\\n    ${elseBranch.toGLSL(context)}`);\n          codelines.push(`\\n  }`);\n        });\n      }\n\n      if (this.elseBranch) {\n        codelines.push(` else {`);\n        codelines.push(`\\n    ${this.elseBranch.toGLSL(context)}`);\n        codelines.push(`\\n  }\\n`);\n      }\n      codelines.push('\\n');\n      return codelines.flat().join('');\n    }\n  }\n  fn.assign = function(node, value) {\n    if (!BRANCH) {\n       throw new error('assign() is supposed to be used inside of conditional branchs. Use the \"=\" operator as normal otherwise.');\n    }\n    BRANCH.assign(node, value);\n  };\n\n  class BranchNode {\n    constructor() {\n      BRANCH = this;\n      this.statements = [];\n      this.assignments = [];\n      this.dependsOn = [];\n      this.declarations = [];\n      let parent = null;\n      Object.defineProperty(this, 'parent', {\n        get() {\n          return parent;\n        },\n        set(newParent) {\n          newParent.dependsOn.push(...this.dependsOn);\n          parent = newParent;\n        }\n      });\n    }\n\n    assign(node, value) {\n      if (!isShaderNode(value) || value.type !== node.type) {\n        value = nodeConstructors[node.type](value);\n        this.declarations.push(value);\n        this.assignments.push({ node });\n      } else {\n        this.assignments.push({ node, value });\n      }\n      node = node.parent ? node.parent : node;\n      value = value.parent ? value.parent : value;\n      if ([node, value].some(n => this.dependsOn.some(d=>d.node===n))) {\n        return;\n      }\n      node.assertUsedInConditional(this);\n      this.dependsOn.push(makeDependencyObject(node));\n      if (value.shouldUseTemporaryVariable()) {\n        value.assertUsedInConditional(this);\n        this.dependsOn.push(makeDependencyObject(value));\n      }\n    }\n\n    toGLSL(context) {\n      let declarationsIndex = 0;\n      this.assignments.forEach(({ node, value }) => {\n        let statement;\n        let result;\n\n        if (!value) {\n          let decl = this.declarations[declarationsIndex];\n          declarationsIndex++;\n          decl.temporaryVariable = `temp_${context.getNextID()}`;\n          this.statements.push(\n            `${decl.type} ${decl.temporaryVariable} = ${decl.toGLSL(context)};`\n          );\n          result = decl.toGLSLBase(context);\n        } else {\n          result = value.toGLSLBase(context);\n        }\n\n        if (isVariableNode(node) || hasTemporaryVariable(node)) {\n          statement = `${node.toGLSLBase(context)} = ${result};`;\n        }\n        else if (isFloatNode(node) && node.name) {\n            statement = `${node.parent.toGLSLBase(context)}.${node.name} = ${result};`;\n        }\n        else {\n          node.temporaryVariable = `temp_${context.getNextID()}`;\n          statement = `${node.type} ${node.toGLSLBase(context)} = ${result};`;\n        }\n\n        this.statements.push(statement);\n      });\n\n      return this.statements.join(`\\n    `);\n    }\n  }\n\n  class ConditionalDiscard {\n    constructor(condition){\n      this.condition = condition;\n    }\n    toGLSL(context) {\n      context.discardConditions.push(`if (${this.condition}{discard;})`);\n    }\n  }\n\n  // Node Helper functions\n  function getType(node) {\n    if (isShaderNode(node)) { return node.type; }\n    else if (Array.isArray(node) && node.length > 1) { return `vec${node.length}`; }\n    else if (typeof node === 'number' || (Array.isArray(node) && node.length === 1)) {\n      return 'float';\n    }\n    return undefined;\n  }\n\n  function computeVectorLength(values) {\n    let length = 0;\n    if (Array.isArray(values)) {\n      for(let val of values) {\n        if (isVectorType(val)) {\n          length += parseInt(val.type.slice(3));\n        }\n        else length += 1;\n      }\n    }\n    else if (isVectorType(values)) {\n      length += parseInt(val.type.slice(3));\n    }\n    if (![2, 3, 4].includes(length)) {\n      throw new Error(`You have attempted to construct a vector with ${length} values. Only vec2, vec3, and vec4 types are supported.`)\n    }\n    return length\n  }\n\n  fn.dynamicNode = function (input) {\n    if (isShaderNode(input)) {\n      return input;\n    }\n    else if (typeof input === 'number') {\n      return new FloatNode(input);\n    }\n    else if (Array.isArray(input)) {\n      return nodeConstructors.dynamicVector(input);\n    }\n  };\n\n  // For replacing unary expressions\n  fn.unaryNode = function(input, sign) {\n    input = dynamicNode(input);\n    return dynamicAddSwizzleTrap(new UnaryExpressionNode(input, sign));\n  };\n\n  function isShaderNode(node) {\n    return (node instanceof BaseNode);\n  }\n\n  function isIntType(node) {\n    return (isShaderNode(node) && (node.type === 'int'));\n  }\n\n  function isFloatType(node) {\n    return (isShaderNode(node) && (node.type === 'float'));\n  }\n\n  function isFloatNode(node) {\n    return (node instanceof FloatNode);\n  }\n\n  function isVectorType(node) {\n    return (isShaderNode(node) && (node.type === 'vec2'|| node.type === 'vec3' || node.type === 'vec4'));\n  }\n\n  function isBinaryExpressionNode(node) {\n    return (node instanceof BinaryExpressionNode);\n  }\n\n  function isVariableNode(node) {\n    return (node instanceof VariableNode || node instanceof ComponentNode);\n  }\n\n  function isConditionalNode(node) {\n    return (node instanceof ConditionalNode || node instanceof BranchNode)\n  }\n\n  function hasTemporaryVariable(node) {\n    return (node.temporaryVariable);\n  }\n\n  function isPrimitiveNode(node) {\n    return (node instanceof FloatNode || node instanceof IntNode || node instanceof VectorNode);\n  }\n\n  function isFunctionCallNode(node) {\n    return (node instanceof FunctionCallNode);\n  }\n\n  function isVectorNode(node) {\n    return (node instanceof VectorNode)\n  }\n\n  function isUnaryExpressionNode(node) {\n    return (node instanceof UnaryExpressionNode)\n  }\n\n  // Helper function to check if a type is a user defined struct or native type\n  function isGLSLNativeType(typeName) {\n    // Supported types for now\n    const glslNativeTypes = ['int', 'float', 'vec2', 'vec3', 'vec4', 'sampler2D'];\n    return glslNativeTypes.includes(typeName);\n  }\n\n  // Shader Generator\n  // This class is responsible for converting the nodes into an object containing GLSL code, to be used by p5.Shader.modify\n\n  class ShaderGenerator {\n    constructor(userCallback, originalShader, srcLocations) {\n      GLOBAL_SHADER = this;\n      this.userCallback = userCallback;\n      this.srcLocations = srcLocations;\n      this.cleanup = () => {};\n      this.generateHookOverrides(originalShader);\n      this.output = {\n        vertexDeclarations: new Set(),\n        fragmentDeclarations: new Set(),\n        uniforms: {},\n      };\n      this.uniformNodes = [];\n      this.resetGLSLContext();\n      this.isGenerating = false;\n    }\n\n    generate() {\n      const prevFESDisabled = p5.disableFriendlyErrors;\n      // We need a custom error handling system within shader generation\n      p5.disableFriendlyErrors = true;\n\n      this.isGenerating = true;\n      this.userCallback();\n      this.output.vertexDeclarations = [...this.output.vertexDeclarations].join('\\n');\n      this.output.fragmentDeclarations = [...this.output.fragmentDeclarations].join('\\n');\n      this.isGenerating = false;\n\n      this.cleanup();\n      p5.disableFriendlyErrors = prevFESDisabled;\n      return this.output;\n    }\n\n    // This method generates the hook overrides which the user calls in their modify function.\n    generateHookOverrides(originalShader) {\n      const availableHooks = {\n        ...originalShader.hooks.vertex,\n        ...originalShader.hooks.fragment,\n      };\n\n      const windowOverrides = {};\n\n      Object.keys(availableHooks).forEach((hookName) => {\n        const hookTypes = originalShader.hookTypes(hookName);\n\n        // These functions are where the user code is executed\n        this[hookTypes.name] = function(userCallback) {\n          // Create the initial nodes which are passed to the user callback\n          // Also generate a string of the arguments for the code generation\n          const argNodes = [];\n          const argsArray = [];\n\n          hookTypes.parameters.forEach((parameter) => {\n            // For hooks with structs as input we should pass an object populated with variable nodes\n            if (!isGLSLNativeType(parameter.type.typeName)) {\n              const structArg = {};\n              parameter.type.properties.forEach((property) => {\n                structArg[property.name] = variableConstructor(`${parameter.name}.${property.name}`, property.type.typeName, true);\n              });\n              argNodes.push(structArg);\n            } else {\n              argNodes.push(\n                variableConstructor(parameter.name, parameter.type.typeName, true)\n              );\n            }\n            const qualifiers = parameter.type.qualifiers.length > 0 ? parameter.type.qualifiers.join(' ') : '';\n            argsArray.push(`${qualifiers} ${parameter.type.typeName} ${parameter.name}`.trim());\n          });\n\n          let returnedValue = userCallback(...argNodes);\n          const expectedReturnType = hookTypes.returnType;\n          const toGLSLResults = {};\n\n          // If the expected return type is a struct we need to evaluate each of its properties\n          if (!isGLSLNativeType(expectedReturnType.typeName)) {\n            Object.entries(returnedValue).forEach(([propertyName, propertyNode]) => {\n              propertyNode = dynamicNode(propertyNode);\n              toGLSLResults[propertyName] = propertyNode.toGLSLBase(this.context);\n              this.context.updateComponents(propertyNode);\n            });\n          } else {\n            if (!isShaderNode(returnedValue)) {\n              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);\n            } else if (isFloatType(returnedValue) && expectedReturnType.typeName.startsWith('vec')) {\n              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);\n            }\n            toGLSLResults['notAProperty'] = returnedValue.toGLSLBase(this.context);\n            this.context.updateComponents(returnedValue);\n          }\n\n          this.context.ifs.forEach((statement) => {\n            if (statement.usedIn.length === 0) { return; }\n            const lines = statement.toGLSL(this.context);\n            this.context.declarations.splice(statement.insertionPoint, 0, lines);\n          });\n          // Build the final GLSL string.\n          // The order of this code is a bit confusing, we need to call toGLSLBase\n          let codeLines = [\n            `(${argsArray.join(', ')}) {`,\n            ...this.context.declarations,\n            `\\n  ${hookTypes.returnType.typeName} finalReturnValue;`\n          ];\n\n          Object.entries(toGLSLResults).forEach(([propertyName, result]) => {\n            const propString = expectedReturnType.properties ? `.${propertyName}` : '';\n            codeLines.push(`  finalReturnValue${propString} = ${result};`);\n          });\n\n          this.context.declarations = [];\n          for (let key in this.context.varyings) {\n            const declArray = this.context.varyings[key];\n            const finalVaryingAssignments = [];\n            declArray.forEach(obj => {\n              const { node, value } = obj;\n              finalVaryingAssignments.push(`  ${node.name} = ${value.toGLSLBase(this.context)};`);\n              finalVaryingAssignments.unshift(...this.context.declarations);\n              node.timesChanged = 0;\n            });\n            codeLines.push(...finalVaryingAssignments);\n          }\n\n          codeLines.push('  return finalReturnValue;', '}');\n          this.output[hookName] = codeLines.join('\\n');\n          this.resetGLSLContext();\n        };\n        windowOverrides[hookTypes.name] = window[hookTypes.name];\n\n        // Expose the Functions to global scope for users to use\n        window[hookTypes.name] = function(userOverride) {\n          GLOBAL_SHADER[hookTypes.name](userOverride);\n        };\n      });\n\n\n      this.cleanup = () => {\n        for (const key in windowOverrides) {\n          window[key] = windowOverrides[key];\n        }\n      };\n    }\n\n    registerVarying(node, value) {\n      if (!Array.isArray(this.context.varyings[node.name])) {\n        this.context.varyings[node.name] = [];\n      }\n      this.context.varyings[node.name].push({ node, value });\n      this.output.vertexDeclarations.add(`OUT ${node.type} ${node.name};`);\n      this.output.fragmentDeclarations.add(`IN ${node.type} ${node.name};`);\n    }\n\n    resetGLSLContext() {\n      this.uniformNodes.forEach((node) => {\n        node.usedIn = [];\n        node.temporaryVariable = undefined;\n      });\n      this.context = {\n        id: 0,\n        getNextID() { return this.id++ },\n        declarations: [],\n        varyings: [],\n        ifs: [],\n        updateComponents: function(node, _emplaceAt, _changedComponents) {\n          if (node.componentsChanged) {\n            if (!_changedComponents) {\n              _changedComponents = node.componentNames.map(() => true);\n            }\n            const lines = [];\n            if (isVectorNode(node)) {\n              node.componentNames.forEach((name, i) => {\n                if (!_changedComponents[i]) return;\n                if (node[name] !== node.originalValues[i]) {\n                  const replacement = nodeConstructors['float'](node[name]);\n                  const line = `  ${node.temporaryVariable}.${name} = ${replacement.toGLSLBase(this)};`;\n                  lines.push(line);\n                }\n              });\n            } else {\n              const components = node.componentNames.map((name) => {\n                return node[name]\n              });\n              const replacement = nodeConstructors[node.type](components);\n              const line = `  ${node.temporaryVariable} = ${replacement.toGLSLBase(this)};`;\n              lines.push(line);\n            }\n            if (_emplaceAt) {\n              this.declarations.splice(_emplaceAt, 0, ...lines);\n            } else {\n              this.declarations.push(...lines);\n            }\n            node.componentsChanged = false;\n          }\n        }\n      };\n      this.uniformNodes = [];\n    }\n  }\n\n  // User function helpers\n  function makeDependencyObject(dep) {\n    if (isVectorType(dep)) {\n      return {\n        node: dep,\n        isVector: true,\n        originalComponents: [...dep.componentNames.map(name => dep[name])],\n        get currentComponents() {\n          return dep.componentNames.map(name => dep[name]);\n        }\n      };\n    } else {\n      return {\n        node: dep,\n        isVector: false\n      };\n    }\n  }\n\n  function makeDependencyArray(dependencies) {\n    return dependencies.map(dep => makeDependencyObject(dep));\n  }\n\n  function conformVectorParameters(value, vectorDimensions) {\n    // Allow arguments as arrays or otherwise. The following are all equivalent:\n    // ([0,0,0,0]) (0,0,0,0) (0) ([0])\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n    value = value.flat();\n    value = value.map(val => {\n      if (isVectorType(val)) {\n        const componentArray = val.componentNames.map(comp => val[comp]);\n        return componentArray;\n      } else {\n        return val;\n      }\n    }).flat();\n    // Populate arguments so uniformVector3(0) becomes [0,0,0]\n    if (value.length === 1 && !isVectorNode(value[0])) {\n      value = Array(vectorDimensions).fill(value[0]);\n    }\n    return value;\n  }\n\n  function swizzleTrap(size) {\n    const swizzleSets = [\n      ['x', 'y', 'z', 'w'],\n      ['r', 'g', 'b', 'a'],\n      ['s', 't', 'p', 'q']\n    ].map(s => s.slice(0, size));\n    return {\n      get(target, property, receiver) {\n        if (property in target) {\n          return Reflect.get(...arguments);\n        } else {\n          for (const set of swizzleSets) {\n            if ([...property].every(char => set.includes(char))) {\n              if (property.length === 1) {\n                return target[swizzleSets[0][set.indexOf(property[0])]]\n              }\n              const components = [...property].map(char => {\n                const index = set.indexOf(char);\n                const mappedChar = swizzleSets[0][index];\n                return target[mappedChar];\n              });\n\n              const type = `vec${property.length}`;\n              return nodeConstructors[type](components);\n            }\n          }\n        }\n      },\n      set(target, property, value, receiver) {\n        for (const set of swizzleSets) {\n          const propertyCharArray = [...property];\n          if (propertyCharArray.every(char => set.includes(char))) {\n            const newValues = Array.isArray(value) ? value : Array(property.length).fill(value);\n            propertyCharArray.forEach((char, i) => {\n              const index = set.indexOf(char);\n              const realProperty = swizzleSets[0][index];\n              Reflect.set(target, realProperty, newValues[i], receiver);\n            });\n            return true;\n          }\n        }\n        return Reflect.set(...arguments);\n      }\n    }\n  }\n\n  // User functions\n  fn.If = function (condition, branch) {\n    return new ConditionalNode(condition, branch);\n  };\n\n  fn.instanceID = function() {\n    return variableConstructor('gl_InstanceID', 'int');\n  };\n\n  fn.getTexture = function(...userArgs) {\n    const props = { args: ['sampler2D', 'vec2'], returnType: 'vec4', isp5Function: true };\n    return fnNodeConstructor('getTexture', userArgs,  props);\n  };\n\n  // Generating uniformFloat, uniformVec, createFloat, etc functions\n  // Maps a GLSL type to the name suffix for method names\n  const GLSLTypesToIdentifiers = {\n    int:    'Int',\n    float:  'Float',\n    vec2:   'Vector2',\n    vec3:   'Vector3',\n    vec4:   'Vector4',\n    sampler2D: 'Texture',\n  };\n\n  function dynamicAddSwizzleTrap(node, _size) {\n    if (node.type.startsWith('vec') || _size) {\n      const size = parseInt(node.type.slice(3));\n      node =  new Proxy(node, swizzleTrap(size));\n      node.addVectorComponents();\n    }\n    return node;\n  }\n\n  function binaryExpressionNodeConstructor(a, b, operator, isInternal) {\n    let node;\n    if (operator === '%') {\n      node = new ModulusNode(a, b);\n    } else {\n      node = new BinaryExpressionNode(a, b, operator, isInternal);\n    }\n    return dynamicAddSwizzleTrap(node);\n  }\n\n  function variableConstructor(name, type, isInternal) {\n    const node = new VariableNode(name, type, isInternal);\n    return dynamicAddSwizzleTrap(node);\n  }\n\n  function fnNodeConstructor(name, userArgs, properties, isInternal) {\n    let node = new FunctionCallNode(name, userArgs, properties, isInternal);\n    node = dynamicAddSwizzleTrap(node);\n    node.dependsOn = makeDependencyArray(node.args);\n    const dependsOnConditionals = node.args.map(arg => {\n      const conditionals = arg.usedIn.filter(n => isConditionalNode(n)).map(c => {\n        if (c instanceof BranchNode) {\n          return c.parent;\n        } else {\n          return c;\n        }\n      });\n      return conditionals;\n    }).flat();\n    dependsOnConditionals.forEach(conditional => conditional.usedIn.push(node));\n\n    return node;\n  }\n\n  const nodeConstructors = {\n    int:   (value) => new IntNode(value),\n    float: (value) => new FloatNode(value),\n    vec2:  (value) => dynamicAddSwizzleTrap(new VectorNode(value, 'vec2')),\n    vec3:  (value) => dynamicAddSwizzleTrap(new VectorNode(value, 'vec3')),\n    vec4:  (value) => dynamicAddSwizzleTrap(new VectorNode(value, 'vec4')),\n    dynamicVector: function(value) {\n      const size = computeVectorLength(value);\n      return this[`vec${size}`](value);\n    },\n  };\n\n  for (const glslType in GLSLTypesToIdentifiers) {\n    // Generate uniform*() Methods for creating uniforms\n    const typeIdentifier = GLSLTypesToIdentifiers[glslType];\n    const uniformMethodName = `uniform${typeIdentifier}`;\n\n    ShaderGenerator.prototype[uniformMethodName] = function(...args) {\n      let [name, ...defaultValue] = args;\n      if (glslType.startsWith('vec') && !(defaultValue[0] instanceof Function)) {\n        defaultValue = conformVectorParameters(defaultValue, parseInt(glslType.slice(3)));\n        this.output.uniforms[`${glslType} ${name}`] = defaultValue;\n      }\n      else {\n        this.output.uniforms[`${glslType} ${name}`] = defaultValue[0];\n      }\n      const uniform = variableConstructor(name, glslType, false);\n      this.uniformNodes.push(uniform);\n      return uniform;\n    };\n\n    fn[uniformMethodName] = function (...args) {\n      return GLOBAL_SHADER[uniformMethodName](...args);\n    };\n\n\n    // We don't need a texture creation method.\n    if (glslType === 'sampler2D') { continue; }\n\n    const varyingMethodName = `varying${typeIdentifier}`;\n    ShaderGenerator.prototype[varyingMethodName] = function(name) {\n      return dynamicAddSwizzleTrap(new VaryingNode(name, glslType, false));\n    };\n\n    fn[varyingMethodName] = function (name) {\n      return GLOBAL_SHADER[varyingMethodName](name);\n    };\n\n    // Generate the creation methods for creating variables in shaders\n    const originalFn = fn[glslType];\n    fn[glslType] = function (...value) {\n      if (GLOBAL_SHADER?.isGenerating) {\n        if (glslType.startsWith('vec')) {\n          value = conformVectorParameters(value, parseInt(glslType.slice(3)));\n        } else {\n          value = value[0];\n        }\n        return nodeConstructors[glslType](value);\n      } else if (originalFn) {\n        return originalFn.apply(this, value);\n      } else {\n        p5._friendlyError(\n          `It looks like you've called ${glslType} outside of a shader's modify() function.`\n        );\n      }\n    };\n  }\n\n  // GLSL Built in functions\n  // Add a whole lot of these functions.\n  // https://docs.gl/el3/abs\n  const builtInGLSLFunctions = {\n    //////////// Trigonometry //////////\n    'acos': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'acosh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'asin': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'asinh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'atan': [\n      { args: ['genType'], returnType: 'genType', isp5Function: false},\n      { args: ['genType', 'genType'], returnType: 'genType', isp5Function: false},\n    ],\n    'atanh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'cos': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'cosh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'degrees': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'radians': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'sin': { args: ['genType'], returnType: 'genType' , isp5Function: true},\n    'sinh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'tan': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'tanh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n\n    ////////// Mathematics //////////\n    'abs': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'ceil': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'clamp': { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'dFdx': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'dFdy': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'exp': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'exp2': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'floor': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'fma': { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'fract': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'fwidth': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'inversesqrt': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    // 'isinf': {},\n    // 'isnan': {},\n    'log': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'log2': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'max': [\n      { args: ['genType', 'genType'], returnType: 'genType', isp5Function: true},\n      { args: ['genType', 'float'], returnType: 'genType', isp5Function: true},\n    ],\n    'min': [\n      { args: ['genType', 'genType'], returnType: 'genType', isp5Function: true},\n      { args: ['genType', 'float'], returnType: 'genType', isp5Function: true},\n    ],\n    'mix': [\n      { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n      { args: ['genType', 'genType', 'float'], returnType: 'genType', isp5Function: false},\n    ],\n    // 'mod': {},\n    // 'modf': {},\n    'pow': { args: ['genType', 'genType'], returnType: 'genType', isp5Function: true},\n    'round': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'roundEven': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    // 'sign': {},\n    'smoothstep': [\n      { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n      { args: ['float', 'float', 'genType'], returnType: 'genType', isp5Function: false},\n    ],\n    'sqrt': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'step': { args: ['genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'trunc': { args: ['genType'], returnType: 'genType', isp5Function: false},\n\n    ////////// Vector //////////\n    'cross': { args: ['vec3', 'vec3'], returnType: 'vec3', isp5Function: true},\n    'distance': { args: ['genType', 'genType'], returnType: 'float', isp5Function: true},\n    'dot': { args: ['genType', 'genType'], returnType: 'float', isp5Function: true},\n    // 'equal': {},\n    'faceforward': { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'length': { args: ['genType'], returnType: 'float', isp5Function: false},\n    'normalize': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    // 'notEqual': {},\n    'reflect': { args: ['genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'refract': { args: ['genType', 'genType', 'float'], returnType: 'genType', isp5Function: false},\n\n    ////////// Texture sampling //////////\n    'texture': {args: ['sampler2D', 'vec2'], returnType: 'vec4', isp5Function: true},\n  };\n\n  Object.entries(builtInGLSLFunctions).forEach(([functionName, properties]) => {\n    const isp5Function = Array.isArray(properties) ? properties[0].isp5Function : properties.isp5Function;\n    if (isp5Function) {\n      const originalFn = fn[functionName];\n      fn[functionName] = function (...args) {\n        if (GLOBAL_SHADER?.isGenerating) {\n          return fnNodeConstructor(functionName, args, properties)\n        } else {\n          return originalFn.apply(this, args);\n        }\n      };\n    } else {\n      fn[functionName] = function (...args) {\n        if (GLOBAL_SHADER?.isGenerating) {\n          return new fnNodeConstructor(functionName, args, properties);\n        } else {\n          p5._friendlyError(\n            `It looks like you've called ${functionName} outside of a shader's modify() function.`\n          );\n        }\n      };\n    }\n  });\n}\n\nif (typeof p5 !== 'undefined') {\n  p5.registerAddon(shadergenerator);\n}\n\nexport { shadergenerator as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}