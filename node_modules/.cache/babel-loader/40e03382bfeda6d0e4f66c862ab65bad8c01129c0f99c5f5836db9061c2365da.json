{"ast":null,"code":"import { e as CORNER, f as TWO_PI, g as HALF_PI, h as PI } from '../constants-BRcElHU3.js';\nimport canvas from '../core/helpers.js';\n\n/**\n * @module Shape\n * @submodule 2D Primitives\n * @for p5\n * @requires core\n * @requires constants\n */\n\nfunction primitives(p5, fn) {\n  /**\n   * This function does 3 things:\n   *\n   *   1. Bounds the desired start/stop angles for an arc (in radians) so that:\n   *\n   *          0 <= start < TWO_PI ;    start <= stop < start + TWO_PI\n   *\n   *      This means that the arc rendering functions don't have to be concerned\n   *      with what happens if stop is smaller than start, or if the arc 'goes\n   *      round more than once', etc.: they can just start at start and increase\n   *      until stop and the correct arc will be drawn.\n   *\n   *   2. Optionally adjusts the angles within each quadrant to counter the naive\n   *      scaling of the underlying ellipse up from the unit circle.  Without\n   *      this, the angles become arbitrary when width != height: 45 degrees\n   *      might be drawn at 5 degrees on a 'wide' ellipse, or at 85 degrees on\n   *      a 'tall' ellipse.\n   *\n   *   3. Flags up when start and stop correspond to the same place on the\n   *      underlying ellipse.  This is useful if you want to do something special\n   *      there (like rendering a whole ellipse instead).\n   */\n  fn._normalizeArcAngles = (start, stop, width, height, correctForScaling) => {\n    const epsilon = 0.00001; // Smallest visible angle on displays up to 4K.\n    let separation;\n\n    // The order of the steps is important here: each one builds upon the\n    // adjustments made in the steps that precede it.\n\n    // Constrain both start and stop to [0,TWO_PI).\n    start = start - TWO_PI * Math.floor(start / TWO_PI);\n    stop = stop - TWO_PI * Math.floor(stop / TWO_PI);\n\n    // Get the angular separation between the requested start and stop points.\n    //\n    // Technically this separation only matches what gets drawn if\n    // correctForScaling is enabled.  We could add a more complicated calculation\n    // for when the scaling is uncorrected (in which case the drawn points could\n    // end up pushed together or pulled apart quite dramatically relative to what\n    // was requested), but it would make things more opaque for little practical\n    // benefit.\n    //\n    // (If you do disable correctForScaling and find that correspondToSamePoint\n    // is set too aggressively, the easiest thing to do is probably to just make\n    // epsilon smaller...)\n    separation = Math.min(Math.abs(start - stop), TWO_PI - Math.abs(start - stop));\n\n    // Optionally adjust the angles to counter linear scaling.\n    if (correctForScaling) {\n      if (start <= HALF_PI) {\n        start = Math.atan(width / height * Math.tan(start));\n      } else if (start > HALF_PI && start <= 3 * HALF_PI) {\n        start = Math.atan(width / height * Math.tan(start)) + PI;\n      } else {\n        start = Math.atan(width / height * Math.tan(start)) + TWO_PI;\n      }\n      if (stop <= HALF_PI) {\n        stop = Math.atan(width / height * Math.tan(stop));\n      } else if (stop > HALF_PI && stop <= 3 * HALF_PI) {\n        stop = Math.atan(width / height * Math.tan(stop)) + PI;\n      } else {\n        stop = Math.atan(width / height * Math.tan(stop)) + TWO_PI;\n      }\n    }\n\n    // Ensure that start <= stop < start + TWO_PI.\n    if (start > stop) {\n      stop += TWO_PI;\n    }\n    return {\n      start,\n      stop,\n      correspondToSamePoint: separation < epsilon\n    };\n  };\n\n  /**\n   * Draws an arc.\n   *\n   * An arc is a section of an ellipse defined by the `x`, `y`, `w`, and\n   * `h` parameters. `x` and `y` set the location of the arc's center. `w` and\n   * `h` set the arc's width and height. See\n   * <a href=\"#/p5/ellipse\">ellipse()</a> and\n   * <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for more details.\n   *\n   * The fifth and sixth parameters, `start` and `stop`, set the angles\n   * between which to draw the arc. Arcs are always drawn clockwise from\n   * `start` to `stop`. Angles are always given in radians.\n   *\n   * The seventh parameter, `mode`, is optional. It determines the arc's fill\n   * style. The fill modes are a semi-circle (`OPEN`), a closed semi-circle\n   * (`CHORD`), or a closed pie segment (`PIE`).\n   *\n   * The eighth parameter, `detail`, is also optional. It determines how many\n   * vertices are used to draw the arc in WebGL mode. The default value is 25.\n   *\n   * @method arc\n   * @param  {Number} x      x-coordinate of the arc's ellipse.\n   * @param  {Number} y      y-coordinate of the arc's ellipse.\n   * @param  {Number} w      width of the arc's ellipse by default.\n   * @param  {Number} h      height of the arc's ellipse by default.\n   * @param  {Number} start  angle to start the arc, specified in radians.\n   * @param  {Number} stop   angle to stop the arc, specified in radians.\n   * @param  {(CHORD|PIE|OPEN)} [mode] optional parameter to determine the way of drawing\n   *                         the arc. either CHORD, PIE, or OPEN.\n   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to\n   *                         specify the number of vertices that makes up the\n   *                         perimeter of the arc. Default value is 25. Won't\n   *                         draw a stroke for a detail of more than 50.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   arc(50, 50, 80, 80, 0, PI + HALF_PI);\n   *\n   *   describe('A white circle on a gray canvas. The top-right quarter of the circle is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   arc(50, 50, 80, 40, 0, PI + HALF_PI);\n   *\n   *   describe('A white ellipse on a gray canvas. The top-right quarter of the ellipse is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Bottom-right.\n   *   arc(50, 55, 50, 50, 0, HALF_PI);\n   *\n   *   noFill();\n   *\n   *   // Bottom-left.\n   *   arc(50, 55, 60, 60, HALF_PI, PI);\n   *\n   *   // Top-left.\n   *   arc(50, 55, 70, 70, PI, PI + QUARTER_PI);\n   *\n   *   // Top-right.\n   *   arc(50, 55, 80, 80, PI + QUARTER_PI, TWO_PI);\n   *\n   *   describe(\n   *     'A shattered outline of an circle with a quarter of a white circle at the bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Default fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI);\n   *\n   *   describe('A white circle with the top-right third missing. The bottom is outlined in black.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // OPEN fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, OPEN);\n   *\n   *   describe(\n   *     'A white circle missing a section from the top-right. The bottom is outlined in black.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // CHORD fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, CHORD);\n   *\n   *   describe('A white circle with a black outline missing a section from the top-right.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, PIE);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode.\n   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode with 5 vertices.\n   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE, 5);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A yellow circle on a black background. The circle opens and closes its mouth.');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Style the arc.\n   *   noStroke();\n   *   fill(255, 255, 0);\n   *\n   *   // Update start and stop angles.\n   *   let biteSize = PI / 16;\n   *   let startAngle = biteSize * sin(frameCount * 0.1) + biteSize;\n   *   let endAngle = TWO_PI - startAngle;\n   *\n   *   // Draw the arc.\n   *   arc(50, 50, 80, 80, startAngle, endAngle, PIE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.arc = function (x, y, w, h, start, stop, mode, detail) {\n    // this.validate(\"p5.arc\", arguments);\n    // p5._validateParameters('arc', arguments);\n\n    // if the current stroke and fill settings wouldn't result in something\n    // visible, exit immediately\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n    if (start === stop) {\n      return this;\n    }\n    start = this._toRadians(start);\n    stop = this._toRadians(stop);\n    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);\n    const angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);\n    if (angles.correspondToSamePoint) {\n      // If the arc starts and ends at (near enough) the same place, we choose to\n      // draw an ellipse instead.  This is preferable to faking an ellipse (by\n      // making stop ever-so-slightly less than start + TWO_PI) because the ends\n      // join up to each other rather than at a vertex at the centre (leaving\n      // an unwanted spike in the stroke/fill).\n      this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detail]);\n    } else {\n      this._renderer.arc(vals.x, vals.y, vals.w, vals.h, angles.start,\n      // [0, TWO_PI)\n      angles.stop,\n      // [start, start + TWO_PI)\n      mode, detail);\n\n      //accessible Outputs\n      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n        this._accsOutput('arc', [vals.x, vals.y, vals.w, vals.h, angles.start, angles.stop, mode]);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Draws an ellipse (oval).\n   *\n   * An ellipse is a round shape defined by the `x`, `y`, `w`, and\n   * `h` parameters. `x` and `y` set the location of its center. `w` and\n   * `h` set its width and height. See\n   * <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for other ways to set\n   * its position.\n   *\n   * If no height is set, the value of width is used for both the width and\n   * height. If a negative height or width is specified, the absolute value is\n   * taken.\n   *\n   * The fifth parameter, `detail`, is also optional. It determines how many\n   * vertices are used to draw the ellipse in WebGL mode. The default value is\n   * 25.\n   *\n   * @method ellipse\n   * @param  {Number} x x-coordinate of the center of the ellipse.\n   * @param  {Number} y y-coordinate of the center of the ellipse.\n   * @param  {Number} w width of the ellipse.\n   * @param  {Number} [h] height of the ellipse.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80, 80);\n   *\n   *   describe('A white circle on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80);\n   *\n   *   describe('A white circle on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80, 40);\n   *\n   *   describe('A white ellipse on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   ellipse(0, 0, 80, 40);\n   *\n   *   describe('A white ellipse on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Use 6 vertices.\n   *   ellipse(0, 0, 80, 40, 6);\n   *\n   *   describe('A white hexagon on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method ellipse\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} w\n   * @param  {Number} h\n   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to\n   *                         specify the number of vertices that makes up the\n   *                         perimeter of the ellipse. Default value is 25. Won't\n   *                         draw a stroke for a detail of more than 50.\n   */\n  fn.ellipse = function (x, y, w, h, detailX) {\n    // p5._validateParameters('ellipse', arguments);\n    return this._renderEllipse(...arguments);\n  };\n\n  /**\n   * Draws a circle.\n   *\n   * A circle is a round shape defined by the `x`, `y`, and `d` parameters.\n   * `x` and `y` set the location of its center. `d` sets its width and height (diameter).\n   * Every point on the circle's edge is the same distance, `0.5 * d`, from its center.\n   * `0.5 * d` (half the diameter) is the circle's radius.\n   * See <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for other ways to set its position.\n   *\n   * @method circle\n   * @param  {Number} x  x-coordinate of the center of the circle.\n   * @param  {Number} y  y-coordinate of the center of the circle.\n   * @param  {Number} d  diameter of the circle.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   circle(50, 50, 25);\n   *\n   *   describe('A white circle with black outline in the middle of a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   circle(0, 0, 25);\n   *\n   *   describe('A white circle with black outline in the middle of a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.circle = function (...args) {\n    // p5._validateParameters('circle', args);\n    const argss = args.slice(0, 2);\n    argss.push(args[2], args[2]);\n    return this._renderEllipse(...argss);\n  };\n\n  // internal method for drawing ellipses (without parameter validation)\n  fn._renderEllipse = function (x, y, w, h, detailX) {\n    // if the current stroke and fill settings wouldn't result in something\n    // visible, exit immediately\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n\n    // Duplicate 3rd argument if only 3 given.\n    if (typeof h === 'undefined') {\n      h = w;\n    }\n    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);\n    this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detailX]);\n\n    //accessible Outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('ellipse', [vals.x, vals.y, vals.w, vals.h]);\n    }\n    return this;\n  };\n\n  /**\n   * Draws a straight line between two points.\n   *\n   * A line's default width is one pixel. The version of `line()` with four\n   * parameters draws the line in 2D. To color a line, use the\n   * <a href=\"#/p5/stroke\">stroke()</a> function. To change its width, use the\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> function. A line\n   * can't be filled, so the <a href=\"#/p5/fill\">fill()</a> function won't\n   * affect the line's color.\n   *\n   * The version of `line()` with six parameters allows the line to be drawn in\n   * 3D space. Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * @method line\n   * @param  {Number} x1 the x-coordinate of the first point.\n   * @param  {Number} y1 the y-coordinate of the first point.\n   * @param  {Number} x2 the x-coordinate of the second point.\n   * @param  {Number} y2 the y-coordinate of the second point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   line(30, 20, 85, 75);\n   *\n   *   describe(\n   *     'A black line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the line.\n   *   stroke('magenta');\n   *   strokeWeight(5);\n   *\n   *   line(30, 20, 85, 75);\n   *\n   *   describe(\n   *     'A thick, magenta line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top.\n   *   line(30, 20, 85, 20);\n   *\n   *   // Right.\n   *   stroke(126);\n   *   line(85, 20, 85, 75);\n   *\n   *   // Bottom.\n   *   stroke(255);\n   *   line(85, 75, 30, 75);\n   *\n   *   describe(\n   *     'Three lines drawn in grayscale on a gray canvas. They form the top, right, and bottom sides of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   line(-20, -30, 35, 25);\n   *\n   *   describe(\n   *     'A black line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A black line connecting two spheres. The scene spins slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw a line.\n   *   line(0, 0, 0, 30, 20, -10);\n   *\n   *   // Draw the center sphere.\n   *   sphere(10);\n   *\n   *   // Translate to the second point.\n   *   translate(30, 20, -10);\n   *\n   *   // Draw the bottom-right sphere.\n   *   sphere(10);\n   * }\n   * </code>\n   * </div>\n   *\n   */\n\n  /**\n   * @method line\n   * @param  {Number} x1\n   * @param  {Number} y1\n   * @param  {Number} z1 the z-coordinate of the first point.\n   * @param  {Number} x2\n   * @param  {Number} y2\n   * @param  {Number} z2 the z-coordinate of the second point.\n   * @chainable\n   */\n  fn.line = function (...args) {\n    // p5._validateParameters('line', args);\n\n    if (this._renderer.states.strokeColor) {\n      this._renderer.line(...args);\n    }\n\n    //accessible Outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('line', args);\n    }\n    return this;\n  };\n\n  /**\n   * Draws a single point in space.\n   *\n   * A point's default width is one pixel. To color a point, use the\n   * <a href=\"#/p5/stroke\">stroke()</a> function. To change its width, use the\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> function. A point\n   * can't be filled, so the <a href=\"#/p5/fill\">fill()</a> function won't\n   * affect the point's color.\n   *\n   * The version of `point()` with two parameters allows the point's location to\n   * be set with its x- and y-coordinates, as in `point(10, 20)`.\n   *\n   * The version of `point()` with three parameters allows the point to be drawn\n   * in 3D space with x-, y-, and z-coordinates, as in `point(10, 20, 30)`.\n   * Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * The version of `point()` with one parameter allows the point's location to\n   * be set with a <a href=\"#/p5/p5.Vector\">p5.Vector</a> object.\n   *\n   * @method point\n   * @param  {Number} x the x-coordinate.\n   * @param  {Number} y the y-coordinate.\n   * @param  {Number} [z] the z-coordinate (for WebGL mode).\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   point(30, 20);\n   *\n   *   // Top-right.\n   *   point(85, 20);\n   *\n   *   // Bottom-right.\n   *   point(85, 75);\n   *\n   *   // Bottom-left.\n   *   point(30, 75);\n   *\n   *   describe(\n   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   point(30, 20);\n   *\n   *   // Top-right.\n   *   point(70, 20);\n   *\n   *   // Style the next points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Bottom-right.\n   *   point(70, 80);\n   *\n   *   // Bottom-left.\n   *   point(30, 80);\n   *\n   *   describe(\n   *     'Four points drawn on a gray canvas. Two are black and two are purple. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   let a = createVector(30, 20);\n   *   point(a);\n   *\n   *   // Top-right.\n   *   let b = createVector(70, 20);\n   *   point(b);\n   *\n   *   // Bottom-right.\n   *   let c = createVector(70, 80);\n   *   point(c);\n   *\n   *   // Bottom-left.\n   *   let d = createVector(30, 80);\n   *   point(d);\n   *\n   *   describe(\n   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('Two purple points drawn on a gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Style the points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Top-left.\n   *   point(-20, -30);\n   *\n   *   // Bottom-right.\n   *   point(20, 30);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('Two purple points drawn on a gray canvas. The scene spins slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Top-left.\n   *   point(-20, -30, 0);\n   *\n   *   // Bottom-right.\n   *   point(20, 30, -50);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method point\n   * @param {p5.Vector} coordinateVector the coordinate vector.\n   * @chainable\n   */\n  fn.point = function (...args) {\n    // p5._validateParameters('point', args);\n\n    if (this._renderer.states.strokeColor) {\n      if (args.length === 1 && args[0] instanceof p5.Vector) {\n        this._renderer.point.call(this._renderer, args[0].x, args[0].y, args[0].z);\n      } else {\n        this._renderer.point(...args);\n        //accessible Outputs\n        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n          this._accsOutput('point', args);\n        }\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Draws a quadrilateral (four-sided shape).\n   *\n   * Quadrilaterals include rectangles, squares, rhombuses, and trapezoids. The\n   * first pair of parameters `(x1, y1)` sets the quad's first point. The next\n   * three pairs of parameters set the coordinates for its next three points\n   * `(x2, y2)`, `(x3, y3)`, and `(x4, y4)`. Points should be added in either\n   * clockwise or counter-clockwise order.\n   *\n   * The version of `quad()` with twelve parameters allows the quad to be drawn\n   * in 3D space. Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * The thirteenth and fourteenth parameters are optional. In WebGL mode, they\n   * set the number of segments used to draw the quadrilateral in the x- and\n   * y-directions. They're both 2 by default.\n   *\n   * @method quad\n   * @param {Number} x1 the x-coordinate of the first point.\n   * @param {Number} y1 the y-coordinate of the first point.\n   * @param {Number} x2 the x-coordinate of the second point.\n   * @param {Number} y2 the y-coordinate of the second point.\n   * @param {Number} x3 the x-coordinate of the third point.\n   * @param {Number} y3 the y-coordinate of the third point.\n   * @param {Number} x4 the x-coordinate of the fourth point.\n   * @param {Number} y4 the y-coordinate of the fourth point.\n   * @param {Integer} [detailX] number of segments in the x-direction.\n   * @param {Integer} [detailY] number of segments in the y-direction.\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 20, 80, 20, 80, 80, 20, 80);\n   *\n   *   describe('A white square with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 30, 80, 30, 80, 70, 20, 70);\n   *\n   *   describe('A white rectangle with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(50, 62, 86, 50, 50, 38, 14, 50);\n   *\n   *   describe('A white rhombus with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 50, 80, 30, 80, 70, 20, 70);\n   *\n   *   describe('A white trapezoid with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   quad(-30, -30, 30, -30, 30, 30, -30, 30);\n   *\n   *   describe('A white square with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A wavy white surface spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the quad.\n   *   quad(-30, -30, 0, 30, -30, 0, 30, 30, 20, -30, 30, -20);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method quad\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} z1 the z-coordinate of the first point.\n   * @param {Number} x2\n   * @param {Number} y2\n   * @param {Number} z2 the z-coordinate of the second point.\n   * @param {Number} x3\n   * @param {Number} y3\n   * @param {Number} z3 the z-coordinate of the third point.\n   * @param {Number} x4\n   * @param {Number} y4\n   * @param {Number} z4 the z-coordinate of the fourth point.\n   * @param {Integer} [detailX]\n   * @param {Integer} [detailY]\n   * @chainable\n   */\n  fn.quad = function (...args) {\n    // p5._validateParameters('quad', args);\n\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      if (this._renderer.isP3D && args.length < 12) {\n        // if 3D and we weren't passed 12 args, assume Z is 0\n        this._renderer.quad.call(this._renderer, args[0], args[1], 0, args[2], args[3], 0, args[4], args[5], 0, args[6], args[7], 0, args[8], args[9]);\n      } else {\n        this._renderer.quad(...args);\n        //accessibile outputs\n        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n          this._accsOutput('quadrilateral', args);\n        }\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Draws a rectangle.\n   *\n   * A rectangle is a four-sided shape defined by the `x`, `y`, `w`, and `h`\n   * parameters. `x` and `y` set the location of its top-left corner. `w` sets\n   * its width and `h` sets its height. Every angle in the rectangle measures\n   * 90˚. See <a href=\"#/p5/rectMode\">rectMode()</a> for other ways to define\n   * rectangles.\n   *\n   * The version of `rect()` with five parameters creates a rounded rectangle. The\n   * fifth parameter sets the radius for all four corners.\n   *\n   * The version of `rect()` with eight parameters also creates a rounded\n   * rectangle. Each of the last four parameters set the radius of a corner. The\n   * radii start with the top-left corner and move clockwise around the\n   * rectangle. If any of these parameters are omitted, they are set to the\n   * value of the last radius that was set.\n   *\n   * @method rect\n   * @param  {Number} x  x-coordinate of the rectangle.\n   * @param  {Number} y  y-coordinate of the rectangle.\n   * @param  {Number} w  width of the rectangle.\n   * @param  {Number} [h]  height of the rectangle.\n   * @param  {Number} [tl] optional radius of top-left corner.\n   * @param  {Number} [tr] optional radius of top-right corner.\n   * @param  {Number} [br] optional radius of bottom-right corner.\n   * @param  {Number} [bl] optional radius of bottom-left corner.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rect(30, 20, 55, 55);\n   *\n   *   describe('A white square with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rect(30, 20, 55, 40);\n   *\n   *   describe('A white rectangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give all corners a radius of 20.\n   *   rect(30, 20, 55, 50, 20);\n   *\n   *   describe('A white rectangle with a black outline and round edges on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give each corner a unique radius.\n   *   rect(30, 20, 55, 50, 20, 15, 10, 5);\n   *\n   *   describe('A white rectangle with a black outline and round edges of different radii.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   rect(-20, -30, 55, 55);\n   *\n   *   describe('A white square with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the rectangle.\n   *   rect(-20, -30, 55, 55);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method rect\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} w\n   * @param  {Number} h\n   * @param  {Integer} [detailX] number of segments in the x-direction (for WebGL mode).\n   * @param  {Integer} [detailY] number of segments in the y-direction (for WebGL mode).\n   * @chainable\n   */\n  fn.rect = function (...args) {\n    // p5._validateParameters('rect', args);\n    return this._renderRect(...args);\n  };\n\n  /**\n   * Draws a square.\n   *\n   * A square is a four-sided shape defined by the `x`, `y`, and `s`\n   * parameters. `x` and `y` set the location of its top-left corner. `s` sets\n   * its width and height. Every angle in the square measures 90˚ and all its\n   * sides are the same length. See <a href=\"#/p5/rectMode\">rectMode()</a> for\n   * other ways to define squares.\n   *\n   * The version of `square()` with four parameters creates a rounded square.\n   * The fourth parameter sets the radius for all four corners.\n   *\n   * The version of `square()` with seven parameters also creates a rounded\n   * square. Each of the last four parameters set the radius of a corner. The\n   * radii start with the top-left corner and move clockwise around the\n   * square. If any of these parameters are omitted, they are set to the\n   * value of the last radius that was set.\n   *\n   * @method square\n   * @param  {Number} x  x-coordinate of the square.\n   * @param  {Number} y  y-coordinate of the square.\n   * @param  {Number} s  side size of the square.\n   * @param  {Number} [tl] optional radius of top-left corner.\n   * @param  {Number} [tr] optional radius of top-right corner.\n   * @param  {Number} [br] optional radius of bottom-right corner.\n   * @param  {Number} [bl] optional radius of bottom-left corner.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   square(30, 20, 55);\n   *\n   *   describe('A white square with a black outline in on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give all corners a radius of 20.\n   *   square(30, 20, 55, 20);\n   *\n   *   describe(\n   *     'A white square with a black outline and round edges on a gray canvas.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give each corner a unique radius.\n   *   square(30, 20, 55, 20, 15, 10, 5);\n   *\n   *   describe('A white square with a black outline and round edges of different radii.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   square(-20, -30, 55);\n   *\n   *   describe('A white square with a black outline in on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the square.\n   *   square(-20, -30, 55);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.square = function (x, y, s, tl, tr, br, bl) {\n    // p5._validateParameters('square', arguments);\n    // duplicate width for height in case of square\n    return this._renderRect.call(this, x, y, s, s, tl, tr, br, bl);\n  };\n\n  // internal method to have renderer draw a rectangle\n  fn._renderRect = function () {\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      // duplicate width for height in case only 3 arguments is provided\n      if (arguments.length === 3) {\n        arguments[3] = arguments[2];\n      }\n      const vals = canvas.modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this._renderer.states.rectMode);\n\n      // For the default rectMode (CORNER), restore a possible negative width/height\n      // removed by modeAdjust(). This results in flipped/mirrored rendering,\n      // which is especially noticable when using WEGBL rendering and texture().\n      // Note that this behavior only applies to rect(), NOT to ellipse() and arc().\n      if (this._renderer.states.rectMode === CORNER) {\n        vals.w = arguments[2];\n        vals.h = arguments[3];\n      }\n      const args = [vals.x, vals.y, vals.w, vals.h];\n      // append the additional arguments (either cornder radii, or\n      // segment details) to the argument list\n      for (let i = 4; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n      this._renderer.rect(args);\n\n      //accessible outputs\n      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n        this._accsOutput('rectangle', [vals.x, vals.y, vals.w, vals.h]);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Draws a triangle.\n   *\n   * A triangle is a three-sided shape defined by three points. The\n   * first two parameters specify the triangle's first point `(x1, y1)`. The\n   * middle two parameters specify its second point `(x2, y2)`. And the last two\n   * parameters specify its third point `(x3, y3)`.\n   *\n   * @method triangle\n   * @param  {Number} x1 x-coordinate of the first point.\n   * @param  {Number} y1 y-coordinate of the first point.\n   * @param  {Number} x2 x-coordinate of the second point.\n   * @param  {Number} y2 y-coordinate of the second point.\n   * @param  {Number} x3 x-coordinate of the third point.\n   * @param  {Number} y3 y-coordinate of the third point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   triangle(30, 75, 58, 20, 86, 75);\n   *\n   *   describe('A white triangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   triangle(-20, 25, 8, -30, 36, 25);\n   *\n   *   describe('A white triangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white triangle spins around on a gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the triangle.\n   *   triangle(-20, 25, 8, -30, 36, 25);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.triangle = function (...args) {\n    // p5._validateParameters('triangle', args);\n\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      this._renderer.triangle(args);\n    }\n\n    //accessible outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('triangle', args);\n    }\n    return this;\n  };\n}\nif (typeof p5 !== 'undefined') {\n  primitives(p5, p5.prototype);\n}\nexport { primitives as default };","map":{"version":3,"names":["e","CORNER","f","TWO_PI","g","HALF_PI","h","PI","canvas","primitives","p5","fn","_normalizeArcAngles","start","stop","width","height","correctForScaling","epsilon","separation","Math","floor","min","abs","atan","tan","correspondToSamePoint","arc","x","y","w","mode","detail","_renderer","states","strokeColor","fillColor","_toRadians","vals","modeAdjust","ellipseMode","angles","ellipse","_accessibleOutputs","grid","text","_accsOutput","detailX","_renderEllipse","arguments","circle","args","argss","slice","push","line","point","length","Vector","call","z","quad","isP3D","rect","_renderRect","square","s","tl","tr","br","bl","rectMode","i","triangle","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/shape/2d_primitives.js"],"sourcesContent":["import { e as CORNER, f as TWO_PI, g as HALF_PI, h as PI } from '../constants-BRcElHU3.js';\nimport canvas from '../core/helpers.js';\n\n/**\n * @module Shape\n * @submodule 2D Primitives\n * @for p5\n * @requires core\n * @requires constants\n */\n\n\nfunction primitives(p5, fn){\n  /**\n   * This function does 3 things:\n   *\n   *   1. Bounds the desired start/stop angles for an arc (in radians) so that:\n   *\n   *          0 <= start < TWO_PI ;    start <= stop < start + TWO_PI\n   *\n   *      This means that the arc rendering functions don't have to be concerned\n   *      with what happens if stop is smaller than start, or if the arc 'goes\n   *      round more than once', etc.: they can just start at start and increase\n   *      until stop and the correct arc will be drawn.\n   *\n   *   2. Optionally adjusts the angles within each quadrant to counter the naive\n   *      scaling of the underlying ellipse up from the unit circle.  Without\n   *      this, the angles become arbitrary when width != height: 45 degrees\n   *      might be drawn at 5 degrees on a 'wide' ellipse, or at 85 degrees on\n   *      a 'tall' ellipse.\n   *\n   *   3. Flags up when start and stop correspond to the same place on the\n   *      underlying ellipse.  This is useful if you want to do something special\n   *      there (like rendering a whole ellipse instead).\n   */\n  fn._normalizeArcAngles = (\n    start,\n    stop,\n    width,\n    height,\n    correctForScaling\n  ) => {\n    const epsilon = 0.00001; // Smallest visible angle on displays up to 4K.\n    let separation;\n\n    // The order of the steps is important here: each one builds upon the\n    // adjustments made in the steps that precede it.\n\n    // Constrain both start and stop to [0,TWO_PI).\n    start = start - TWO_PI * Math.floor(start / TWO_PI);\n    stop = stop - TWO_PI * Math.floor(stop / TWO_PI);\n\n    // Get the angular separation between the requested start and stop points.\n    //\n    // Technically this separation only matches what gets drawn if\n    // correctForScaling is enabled.  We could add a more complicated calculation\n    // for when the scaling is uncorrected (in which case the drawn points could\n    // end up pushed together or pulled apart quite dramatically relative to what\n    // was requested), but it would make things more opaque for little practical\n    // benefit.\n    //\n    // (If you do disable correctForScaling and find that correspondToSamePoint\n    // is set too aggressively, the easiest thing to do is probably to just make\n    // epsilon smaller...)\n    separation = Math.min(\n      Math.abs(start - stop),\n      TWO_PI - Math.abs(start - stop)\n    );\n\n    // Optionally adjust the angles to counter linear scaling.\n    if (correctForScaling) {\n      if (start <= HALF_PI) {\n        start = Math.atan(width / height * Math.tan(start));\n      } else if (start > HALF_PI && start <= 3 * HALF_PI) {\n        start = Math.atan(width / height * Math.tan(start)) + PI;\n      } else {\n        start = Math.atan(width / height * Math.tan(start)) + TWO_PI;\n      }\n      if (stop <= HALF_PI) {\n        stop = Math.atan(width / height * Math.tan(stop));\n      } else if (stop > HALF_PI && stop <= 3 * HALF_PI) {\n        stop = Math.atan(width / height * Math.tan(stop)) + PI;\n      } else {\n        stop = Math.atan(width / height * Math.tan(stop)) + TWO_PI;\n      }\n    }\n\n    // Ensure that start <= stop < start + TWO_PI.\n    if (start > stop) {\n      stop += TWO_PI;\n    }\n\n    return {\n      start,\n      stop,\n      correspondToSamePoint: separation < epsilon\n    };\n  };\n\n  /**\n   * Draws an arc.\n   *\n   * An arc is a section of an ellipse defined by the `x`, `y`, `w`, and\n   * `h` parameters. `x` and `y` set the location of the arc's center. `w` and\n   * `h` set the arc's width and height. See\n   * <a href=\"#/p5/ellipse\">ellipse()</a> and\n   * <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for more details.\n   *\n   * The fifth and sixth parameters, `start` and `stop`, set the angles\n   * between which to draw the arc. Arcs are always drawn clockwise from\n   * `start` to `stop`. Angles are always given in radians.\n   *\n   * The seventh parameter, `mode`, is optional. It determines the arc's fill\n   * style. The fill modes are a semi-circle (`OPEN`), a closed semi-circle\n   * (`CHORD`), or a closed pie segment (`PIE`).\n   *\n   * The eighth parameter, `detail`, is also optional. It determines how many\n   * vertices are used to draw the arc in WebGL mode. The default value is 25.\n   *\n   * @method arc\n   * @param  {Number} x      x-coordinate of the arc's ellipse.\n   * @param  {Number} y      y-coordinate of the arc's ellipse.\n   * @param  {Number} w      width of the arc's ellipse by default.\n   * @param  {Number} h      height of the arc's ellipse by default.\n   * @param  {Number} start  angle to start the arc, specified in radians.\n   * @param  {Number} stop   angle to stop the arc, specified in radians.\n   * @param  {(CHORD|PIE|OPEN)} [mode] optional parameter to determine the way of drawing\n   *                         the arc. either CHORD, PIE, or OPEN.\n   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to\n   *                         specify the number of vertices that makes up the\n   *                         perimeter of the arc. Default value is 25. Won't\n   *                         draw a stroke for a detail of more than 50.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   arc(50, 50, 80, 80, 0, PI + HALF_PI);\n   *\n   *   describe('A white circle on a gray canvas. The top-right quarter of the circle is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   arc(50, 50, 80, 40, 0, PI + HALF_PI);\n   *\n   *   describe('A white ellipse on a gray canvas. The top-right quarter of the ellipse is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Bottom-right.\n   *   arc(50, 55, 50, 50, 0, HALF_PI);\n   *\n   *   noFill();\n   *\n   *   // Bottom-left.\n   *   arc(50, 55, 60, 60, HALF_PI, PI);\n   *\n   *   // Top-left.\n   *   arc(50, 55, 70, 70, PI, PI + QUARTER_PI);\n   *\n   *   // Top-right.\n   *   arc(50, 55, 80, 80, PI + QUARTER_PI, TWO_PI);\n   *\n   *   describe(\n   *     'A shattered outline of an circle with a quarter of a white circle at the bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Default fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI);\n   *\n   *   describe('A white circle with the top-right third missing. The bottom is outlined in black.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // OPEN fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, OPEN);\n   *\n   *   describe(\n   *     'A white circle missing a section from the top-right. The bottom is outlined in black.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // CHORD fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, CHORD);\n   *\n   *   describe('A white circle with a black outline missing a section from the top-right.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, PIE);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode.\n   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode with 5 vertices.\n   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE, 5);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A yellow circle on a black background. The circle opens and closes its mouth.');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Style the arc.\n   *   noStroke();\n   *   fill(255, 255, 0);\n   *\n   *   // Update start and stop angles.\n   *   let biteSize = PI / 16;\n   *   let startAngle = biteSize * sin(frameCount * 0.1) + biteSize;\n   *   let endAngle = TWO_PI - startAngle;\n   *\n   *   // Draw the arc.\n   *   arc(50, 50, 80, 80, startAngle, endAngle, PIE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.arc = function(x, y, w, h, start, stop, mode, detail) {\n    // this.validate(\"p5.arc\", arguments);\n    // p5._validateParameters('arc', arguments);\n\n    // if the current stroke and fill settings wouldn't result in something\n    // visible, exit immediately\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n\n    if (start === stop) {\n      return this;\n    }\n\n    start = this._toRadians(start);\n    stop = this._toRadians(stop);\n\n    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);\n    const angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);\n\n    if (angles.correspondToSamePoint) {\n      // If the arc starts and ends at (near enough) the same place, we choose to\n      // draw an ellipse instead.  This is preferable to faking an ellipse (by\n      // making stop ever-so-slightly less than start + TWO_PI) because the ends\n      // join up to each other rather than at a vertex at the centre (leaving\n      // an unwanted spike in the stroke/fill).\n      this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detail]);\n    } else {\n      this._renderer.arc(\n        vals.x,\n        vals.y,\n        vals.w,\n        vals.h,\n        angles.start, // [0, TWO_PI)\n        angles.stop, // [start, start + TWO_PI)\n        mode,\n        detail\n      );\n\n      //accessible Outputs\n      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n        this._accsOutput('arc', [\n          vals.x,\n          vals.y,\n          vals.w,\n          vals.h,\n          angles.start,\n          angles.stop,\n          mode\n        ]);\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws an ellipse (oval).\n   *\n   * An ellipse is a round shape defined by the `x`, `y`, `w`, and\n   * `h` parameters. `x` and `y` set the location of its center. `w` and\n   * `h` set its width and height. See\n   * <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for other ways to set\n   * its position.\n   *\n   * If no height is set, the value of width is used for both the width and\n   * height. If a negative height or width is specified, the absolute value is\n   * taken.\n   *\n   * The fifth parameter, `detail`, is also optional. It determines how many\n   * vertices are used to draw the ellipse in WebGL mode. The default value is\n   * 25.\n   *\n   * @method ellipse\n   * @param  {Number} x x-coordinate of the center of the ellipse.\n   * @param  {Number} y y-coordinate of the center of the ellipse.\n   * @param  {Number} w width of the ellipse.\n   * @param  {Number} [h] height of the ellipse.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80, 80);\n   *\n   *   describe('A white circle on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80);\n   *\n   *   describe('A white circle on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80, 40);\n   *\n   *   describe('A white ellipse on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   ellipse(0, 0, 80, 40);\n   *\n   *   describe('A white ellipse on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Use 6 vertices.\n   *   ellipse(0, 0, 80, 40, 6);\n   *\n   *   describe('A white hexagon on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method ellipse\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} w\n   * @param  {Number} h\n   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to\n   *                         specify the number of vertices that makes up the\n   *                         perimeter of the ellipse. Default value is 25. Won't\n   *                         draw a stroke for a detail of more than 50.\n   */\n  fn.ellipse = function(x, y, w, h, detailX) {\n    // p5._validateParameters('ellipse', arguments);\n    return this._renderEllipse(...arguments);\n  };\n\n  /**\n   * Draws a circle.\n   *\n   * A circle is a round shape defined by the `x`, `y`, and `d` parameters.\n   * `x` and `y` set the location of its center. `d` sets its width and height (diameter).\n   * Every point on the circle's edge is the same distance, `0.5 * d`, from its center.\n   * `0.5 * d` (half the diameter) is the circle's radius.\n   * See <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for other ways to set its position.\n   *\n   * @method circle\n   * @param  {Number} x  x-coordinate of the center of the circle.\n   * @param  {Number} y  y-coordinate of the center of the circle.\n   * @param  {Number} d  diameter of the circle.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   circle(50, 50, 25);\n   *\n   *   describe('A white circle with black outline in the middle of a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   circle(0, 0, 25);\n   *\n   *   describe('A white circle with black outline in the middle of a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.circle = function(...args) {\n    // p5._validateParameters('circle', args);\n    const argss = args.slice( 0, 2);\n    argss.push(args[2], args[2]);\n    return this._renderEllipse(...argss);\n  };\n\n  // internal method for drawing ellipses (without parameter validation)\n  fn._renderEllipse = function(x, y, w, h, detailX) {\n    // if the current stroke and fill settings wouldn't result in something\n    // visible, exit immediately\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n\n    // Duplicate 3rd argument if only 3 given.\n    if (typeof h === 'undefined') {\n      h = w;\n    }\n\n    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);\n    this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detailX]);\n\n    //accessible Outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('ellipse', [vals.x, vals.y, vals.w, vals.h]);\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a straight line between two points.\n   *\n   * A line's default width is one pixel. The version of `line()` with four\n   * parameters draws the line in 2D. To color a line, use the\n   * <a href=\"#/p5/stroke\">stroke()</a> function. To change its width, use the\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> function. A line\n   * can't be filled, so the <a href=\"#/p5/fill\">fill()</a> function won't\n   * affect the line's color.\n   *\n   * The version of `line()` with six parameters allows the line to be drawn in\n   * 3D space. Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * @method line\n   * @param  {Number} x1 the x-coordinate of the first point.\n   * @param  {Number} y1 the y-coordinate of the first point.\n   * @param  {Number} x2 the x-coordinate of the second point.\n   * @param  {Number} y2 the y-coordinate of the second point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   line(30, 20, 85, 75);\n   *\n   *   describe(\n   *     'A black line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the line.\n   *   stroke('magenta');\n   *   strokeWeight(5);\n   *\n   *   line(30, 20, 85, 75);\n   *\n   *   describe(\n   *     'A thick, magenta line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top.\n   *   line(30, 20, 85, 20);\n   *\n   *   // Right.\n   *   stroke(126);\n   *   line(85, 20, 85, 75);\n   *\n   *   // Bottom.\n   *   stroke(255);\n   *   line(85, 75, 30, 75);\n   *\n   *   describe(\n   *     'Three lines drawn in grayscale on a gray canvas. They form the top, right, and bottom sides of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   line(-20, -30, 35, 25);\n   *\n   *   describe(\n   *     'A black line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A black line connecting two spheres. The scene spins slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw a line.\n   *   line(0, 0, 0, 30, 20, -10);\n   *\n   *   // Draw the center sphere.\n   *   sphere(10);\n   *\n   *   // Translate to the second point.\n   *   translate(30, 20, -10);\n   *\n   *   // Draw the bottom-right sphere.\n   *   sphere(10);\n   * }\n   * </code>\n   * </div>\n   *\n   */\n\n  /**\n   * @method line\n   * @param  {Number} x1\n   * @param  {Number} y1\n   * @param  {Number} z1 the z-coordinate of the first point.\n   * @param  {Number} x2\n   * @param  {Number} y2\n   * @param  {Number} z2 the z-coordinate of the second point.\n   * @chainable\n   */\n  fn.line = function(...args) {\n    // p5._validateParameters('line', args);\n\n    if (this._renderer.states.strokeColor) {\n      this._renderer.line(...args);\n    }\n\n    //accessible Outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('line', args);\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a single point in space.\n   *\n   * A point's default width is one pixel. To color a point, use the\n   * <a href=\"#/p5/stroke\">stroke()</a> function. To change its width, use the\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> function. A point\n   * can't be filled, so the <a href=\"#/p5/fill\">fill()</a> function won't\n   * affect the point's color.\n   *\n   * The version of `point()` with two parameters allows the point's location to\n   * be set with its x- and y-coordinates, as in `point(10, 20)`.\n   *\n   * The version of `point()` with three parameters allows the point to be drawn\n   * in 3D space with x-, y-, and z-coordinates, as in `point(10, 20, 30)`.\n   * Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * The version of `point()` with one parameter allows the point's location to\n   * be set with a <a href=\"#/p5/p5.Vector\">p5.Vector</a> object.\n   *\n   * @method point\n   * @param  {Number} x the x-coordinate.\n   * @param  {Number} y the y-coordinate.\n   * @param  {Number} [z] the z-coordinate (for WebGL mode).\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   point(30, 20);\n   *\n   *   // Top-right.\n   *   point(85, 20);\n   *\n   *   // Bottom-right.\n   *   point(85, 75);\n   *\n   *   // Bottom-left.\n   *   point(30, 75);\n   *\n   *   describe(\n   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   point(30, 20);\n   *\n   *   // Top-right.\n   *   point(70, 20);\n   *\n   *   // Style the next points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Bottom-right.\n   *   point(70, 80);\n   *\n   *   // Bottom-left.\n   *   point(30, 80);\n   *\n   *   describe(\n   *     'Four points drawn on a gray canvas. Two are black and two are purple. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   let a = createVector(30, 20);\n   *   point(a);\n   *\n   *   // Top-right.\n   *   let b = createVector(70, 20);\n   *   point(b);\n   *\n   *   // Bottom-right.\n   *   let c = createVector(70, 80);\n   *   point(c);\n   *\n   *   // Bottom-left.\n   *   let d = createVector(30, 80);\n   *   point(d);\n   *\n   *   describe(\n   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('Two purple points drawn on a gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Style the points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Top-left.\n   *   point(-20, -30);\n   *\n   *   // Bottom-right.\n   *   point(20, 30);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('Two purple points drawn on a gray canvas. The scene spins slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Top-left.\n   *   point(-20, -30, 0);\n   *\n   *   // Bottom-right.\n   *   point(20, 30, -50);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method point\n   * @param {p5.Vector} coordinateVector the coordinate vector.\n   * @chainable\n   */\n  fn.point = function(...args) {\n    // p5._validateParameters('point', args);\n\n    if (this._renderer.states.strokeColor) {\n      if (args.length === 1 && args[0] instanceof p5.Vector) {\n        this._renderer.point.call(\n          this._renderer,\n          args[0].x,\n          args[0].y,\n          args[0].z\n        );\n      } else {\n        this._renderer.point(...args);\n        //accessible Outputs\n        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n          this._accsOutput('point', args);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a quadrilateral (four-sided shape).\n   *\n   * Quadrilaterals include rectangles, squares, rhombuses, and trapezoids. The\n   * first pair of parameters `(x1, y1)` sets the quad's first point. The next\n   * three pairs of parameters set the coordinates for its next three points\n   * `(x2, y2)`, `(x3, y3)`, and `(x4, y4)`. Points should be added in either\n   * clockwise or counter-clockwise order.\n   *\n   * The version of `quad()` with twelve parameters allows the quad to be drawn\n   * in 3D space. Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * The thirteenth and fourteenth parameters are optional. In WebGL mode, they\n   * set the number of segments used to draw the quadrilateral in the x- and\n   * y-directions. They're both 2 by default.\n   *\n   * @method quad\n   * @param {Number} x1 the x-coordinate of the first point.\n   * @param {Number} y1 the y-coordinate of the first point.\n   * @param {Number} x2 the x-coordinate of the second point.\n   * @param {Number} y2 the y-coordinate of the second point.\n   * @param {Number} x3 the x-coordinate of the third point.\n   * @param {Number} y3 the y-coordinate of the third point.\n   * @param {Number} x4 the x-coordinate of the fourth point.\n   * @param {Number} y4 the y-coordinate of the fourth point.\n   * @param {Integer} [detailX] number of segments in the x-direction.\n   * @param {Integer} [detailY] number of segments in the y-direction.\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 20, 80, 20, 80, 80, 20, 80);\n   *\n   *   describe('A white square with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 30, 80, 30, 80, 70, 20, 70);\n   *\n   *   describe('A white rectangle with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(50, 62, 86, 50, 50, 38, 14, 50);\n   *\n   *   describe('A white rhombus with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 50, 80, 30, 80, 70, 20, 70);\n   *\n   *   describe('A white trapezoid with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   quad(-30, -30, 30, -30, 30, 30, -30, 30);\n   *\n   *   describe('A white square with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A wavy white surface spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the quad.\n   *   quad(-30, -30, 0, 30, -30, 0, 30, 30, 20, -30, 30, -20);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method quad\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} z1 the z-coordinate of the first point.\n   * @param {Number} x2\n   * @param {Number} y2\n   * @param {Number} z2 the z-coordinate of the second point.\n   * @param {Number} x3\n   * @param {Number} y3\n   * @param {Number} z3 the z-coordinate of the third point.\n   * @param {Number} x4\n   * @param {Number} y4\n   * @param {Number} z4 the z-coordinate of the fourth point.\n   * @param {Integer} [detailX]\n   * @param {Integer} [detailY]\n   * @chainable\n   */\n  fn.quad = function(...args) {\n    // p5._validateParameters('quad', args);\n\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      if (this._renderer.isP3D && args.length < 12) {\n        // if 3D and we weren't passed 12 args, assume Z is 0\n        this._renderer.quad.call(\n          this._renderer,\n          args[0], args[1], 0,\n          args[2], args[3], 0,\n          args[4], args[5], 0,\n          args[6], args[7], 0,\n          args[8], args[9]);\n      } else {\n        this._renderer.quad(...args);\n        //accessibile outputs\n        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n          this._accsOutput('quadrilateral', args);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a rectangle.\n   *\n   * A rectangle is a four-sided shape defined by the `x`, `y`, `w`, and `h`\n   * parameters. `x` and `y` set the location of its top-left corner. `w` sets\n   * its width and `h` sets its height. Every angle in the rectangle measures\n   * 90˚. See <a href=\"#/p5/rectMode\">rectMode()</a> for other ways to define\n   * rectangles.\n   *\n   * The version of `rect()` with five parameters creates a rounded rectangle. The\n   * fifth parameter sets the radius for all four corners.\n   *\n   * The version of `rect()` with eight parameters also creates a rounded\n   * rectangle. Each of the last four parameters set the radius of a corner. The\n   * radii start with the top-left corner and move clockwise around the\n   * rectangle. If any of these parameters are omitted, they are set to the\n   * value of the last radius that was set.\n   *\n   * @method rect\n   * @param  {Number} x  x-coordinate of the rectangle.\n   * @param  {Number} y  y-coordinate of the rectangle.\n   * @param  {Number} w  width of the rectangle.\n   * @param  {Number} [h]  height of the rectangle.\n   * @param  {Number} [tl] optional radius of top-left corner.\n   * @param  {Number} [tr] optional radius of top-right corner.\n   * @param  {Number} [br] optional radius of bottom-right corner.\n   * @param  {Number} [bl] optional radius of bottom-left corner.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rect(30, 20, 55, 55);\n   *\n   *   describe('A white square with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rect(30, 20, 55, 40);\n   *\n   *   describe('A white rectangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give all corners a radius of 20.\n   *   rect(30, 20, 55, 50, 20);\n   *\n   *   describe('A white rectangle with a black outline and round edges on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give each corner a unique radius.\n   *   rect(30, 20, 55, 50, 20, 15, 10, 5);\n   *\n   *   describe('A white rectangle with a black outline and round edges of different radii.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   rect(-20, -30, 55, 55);\n   *\n   *   describe('A white square with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the rectangle.\n   *   rect(-20, -30, 55, 55);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method rect\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} w\n   * @param  {Number} h\n   * @param  {Integer} [detailX] number of segments in the x-direction (for WebGL mode).\n   * @param  {Integer} [detailY] number of segments in the y-direction (for WebGL mode).\n   * @chainable\n   */\n  fn.rect = function(...args) {\n    // p5._validateParameters('rect', args);\n    return this._renderRect(...args);\n  };\n\n  /**\n   * Draws a square.\n   *\n   * A square is a four-sided shape defined by the `x`, `y`, and `s`\n   * parameters. `x` and `y` set the location of its top-left corner. `s` sets\n   * its width and height. Every angle in the square measures 90˚ and all its\n   * sides are the same length. See <a href=\"#/p5/rectMode\">rectMode()</a> for\n   * other ways to define squares.\n   *\n   * The version of `square()` with four parameters creates a rounded square.\n   * The fourth parameter sets the radius for all four corners.\n   *\n   * The version of `square()` with seven parameters also creates a rounded\n   * square. Each of the last four parameters set the radius of a corner. The\n   * radii start with the top-left corner and move clockwise around the\n   * square. If any of these parameters are omitted, they are set to the\n   * value of the last radius that was set.\n   *\n   * @method square\n   * @param  {Number} x  x-coordinate of the square.\n   * @param  {Number} y  y-coordinate of the square.\n   * @param  {Number} s  side size of the square.\n   * @param  {Number} [tl] optional radius of top-left corner.\n   * @param  {Number} [tr] optional radius of top-right corner.\n   * @param  {Number} [br] optional radius of bottom-right corner.\n   * @param  {Number} [bl] optional radius of bottom-left corner.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   square(30, 20, 55);\n   *\n   *   describe('A white square with a black outline in on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give all corners a radius of 20.\n   *   square(30, 20, 55, 20);\n   *\n   *   describe(\n   *     'A white square with a black outline and round edges on a gray canvas.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give each corner a unique radius.\n   *   square(30, 20, 55, 20, 15, 10, 5);\n   *\n   *   describe('A white square with a black outline and round edges of different radii.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   square(-20, -30, 55);\n   *\n   *   describe('A white square with a black outline in on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the square.\n   *   square(-20, -30, 55);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.square = function(x, y, s, tl, tr, br, bl) {\n    // p5._validateParameters('square', arguments);\n    // duplicate width for height in case of square\n    return this._renderRect.call(this, x, y, s, s, tl, tr, br, bl);\n  };\n\n  // internal method to have renderer draw a rectangle\n  fn._renderRect = function() {\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      // duplicate width for height in case only 3 arguments is provided\n      if (arguments.length === 3) {\n        arguments[3] = arguments[2];\n      }\n      const vals = canvas.modeAdjust(\n        arguments[0],\n        arguments[1],\n        arguments[2],\n        arguments[3],\n        this._renderer.states.rectMode\n      );\n\n      // For the default rectMode (CORNER), restore a possible negative width/height\n      // removed by modeAdjust(). This results in flipped/mirrored rendering,\n      // which is especially noticable when using WEGBL rendering and texture().\n      // Note that this behavior only applies to rect(), NOT to ellipse() and arc().\n      if (this._renderer.states.rectMode === CORNER) {\n        vals.w = arguments[2];\n        vals.h = arguments[3];\n      }\n\n      const args = [vals.x, vals.y, vals.w, vals.h];\n      // append the additional arguments (either cornder radii, or\n      // segment details) to the argument list\n      for (let i = 4; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n      this._renderer.rect(args);\n\n      //accessible outputs\n      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n        this._accsOutput('rectangle', [vals.x, vals.y, vals.w, vals.h]);\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a triangle.\n   *\n   * A triangle is a three-sided shape defined by three points. The\n   * first two parameters specify the triangle's first point `(x1, y1)`. The\n   * middle two parameters specify its second point `(x2, y2)`. And the last two\n   * parameters specify its third point `(x3, y3)`.\n   *\n   * @method triangle\n   * @param  {Number} x1 x-coordinate of the first point.\n   * @param  {Number} y1 y-coordinate of the first point.\n   * @param  {Number} x2 x-coordinate of the second point.\n   * @param  {Number} y2 y-coordinate of the second point.\n   * @param  {Number} x3 x-coordinate of the third point.\n   * @param  {Number} y3 y-coordinate of the third point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   triangle(30, 75, 58, 20, 86, 75);\n   *\n   *   describe('A white triangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   triangle(-20, 25, 8, -30, 36, 25);\n   *\n   *   describe('A white triangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white triangle spins around on a gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the triangle.\n   *   triangle(-20, 25, 8, -30, 36, 25);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.triangle = function(...args) {\n    // p5._validateParameters('triangle', args);\n\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      this._renderer.triangle(args);\n    }\n\n    //accessible outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('triangle', args);\n    }\n\n    return this;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  primitives(p5, p5.prototype);\n}\n\nexport { primitives as default };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,MAAM,EAAEC,CAAC,IAAIC,MAAM,EAAEC,CAAC,IAAIC,OAAO,EAAEC,CAAC,IAAIC,EAAE,QAAQ,0BAA0B;AAC1F,OAAOC,MAAM,MAAM,oBAAoB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASC,UAAUA,CAACC,EAAE,EAAEC,EAAE,EAAC;EACzB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEA,EAAE,CAACC,mBAAmB,GAAG,CACvBC,KAAK,EACLC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,iBAAiB,KACd;IACH,MAAMC,OAAO,GAAG,OAAO,CAAC,CAAC;IACzB,IAAIC,UAAU;;IAEd;IACA;;IAEA;IACAN,KAAK,GAAGA,KAAK,GAAGV,MAAM,GAAGiB,IAAI,CAACC,KAAK,CAACR,KAAK,GAAGV,MAAM,CAAC;IACnDW,IAAI,GAAGA,IAAI,GAAGX,MAAM,GAAGiB,IAAI,CAACC,KAAK,CAACP,IAAI,GAAGX,MAAM,CAAC;;IAEhD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAgB,UAAU,GAAGC,IAAI,CAACE,GAAG,CACnBF,IAAI,CAACG,GAAG,CAACV,KAAK,GAAGC,IAAI,CAAC,EACtBX,MAAM,GAAGiB,IAAI,CAACG,GAAG,CAACV,KAAK,GAAGC,IAAI,CAChC,CAAC;;IAED;IACA,IAAIG,iBAAiB,EAAE;MACrB,IAAIJ,KAAK,IAAIR,OAAO,EAAE;QACpBQ,KAAK,GAAGO,IAAI,CAACI,IAAI,CAACT,KAAK,GAAGC,MAAM,GAAGI,IAAI,CAACK,GAAG,CAACZ,KAAK,CAAC,CAAC;MACrD,CAAC,MAAM,IAAIA,KAAK,GAAGR,OAAO,IAAIQ,KAAK,IAAI,CAAC,GAAGR,OAAO,EAAE;QAClDQ,KAAK,GAAGO,IAAI,CAACI,IAAI,CAACT,KAAK,GAAGC,MAAM,GAAGI,IAAI,CAACK,GAAG,CAACZ,KAAK,CAAC,CAAC,GAAGN,EAAE;MAC1D,CAAC,MAAM;QACLM,KAAK,GAAGO,IAAI,CAACI,IAAI,CAACT,KAAK,GAAGC,MAAM,GAAGI,IAAI,CAACK,GAAG,CAACZ,KAAK,CAAC,CAAC,GAAGV,MAAM;MAC9D;MACA,IAAIW,IAAI,IAAIT,OAAO,EAAE;QACnBS,IAAI,GAAGM,IAAI,CAACI,IAAI,CAACT,KAAK,GAAGC,MAAM,GAAGI,IAAI,CAACK,GAAG,CAACX,IAAI,CAAC,CAAC;MACnD,CAAC,MAAM,IAAIA,IAAI,GAAGT,OAAO,IAAIS,IAAI,IAAI,CAAC,GAAGT,OAAO,EAAE;QAChDS,IAAI,GAAGM,IAAI,CAACI,IAAI,CAACT,KAAK,GAAGC,MAAM,GAAGI,IAAI,CAACK,GAAG,CAACX,IAAI,CAAC,CAAC,GAAGP,EAAE;MACxD,CAAC,MAAM;QACLO,IAAI,GAAGM,IAAI,CAACI,IAAI,CAACT,KAAK,GAAGC,MAAM,GAAGI,IAAI,CAACK,GAAG,CAACX,IAAI,CAAC,CAAC,GAAGX,MAAM;MAC5D;IACF;;IAEA;IACA,IAAIU,KAAK,GAAGC,IAAI,EAAE;MAChBA,IAAI,IAAIX,MAAM;IAChB;IAEA,OAAO;MACLU,KAAK;MACLC,IAAI;MACJY,qBAAqB,EAAEP,UAAU,GAAGD;IACtC,CAAC;EACH,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,EAAE,CAACgB,GAAG,GAAG,UAASC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAExB,CAAC,EAAEO,KAAK,EAAEC,IAAI,EAAEiB,IAAI,EAAEC,MAAM,EAAE;IACvD;IACA;;IAEA;IACA;IACA,IAAI,CAAC,IAAI,CAACC,SAAS,CAACC,MAAM,CAACC,WAAW,IAAI,CAAC,IAAI,CAACF,SAAS,CAACC,MAAM,CAACE,SAAS,EAAE;MAC1E,OAAO,IAAI;IACb;IAEA,IAAIvB,KAAK,KAAKC,IAAI,EAAE;MAClB,OAAO,IAAI;IACb;IAEAD,KAAK,GAAG,IAAI,CAACwB,UAAU,CAACxB,KAAK,CAAC;IAC9BC,IAAI,GAAG,IAAI,CAACuB,UAAU,CAACvB,IAAI,CAAC;IAE5B,MAAMwB,IAAI,GAAG9B,MAAM,CAAC+B,UAAU,CAACX,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAExB,CAAC,EAAE,IAAI,CAAC2B,SAAS,CAACC,MAAM,CAACM,WAAW,CAAC;IAC7E,MAAMC,MAAM,GAAG,IAAI,CAAC7B,mBAAmB,CAACC,KAAK,EAAEC,IAAI,EAAEwB,IAAI,CAACR,CAAC,EAAEQ,IAAI,CAAChC,CAAC,EAAE,IAAI,CAAC;IAE1E,IAAImC,MAAM,CAACf,qBAAqB,EAAE;MAChC;MACA;MACA;MACA;MACA;MACA,IAAI,CAACO,SAAS,CAACS,OAAO,CAAC,CAACJ,IAAI,CAACV,CAAC,EAAEU,IAAI,CAACT,CAAC,EAAES,IAAI,CAACR,CAAC,EAAEQ,IAAI,CAAChC,CAAC,EAAE0B,MAAM,CAAC,CAAC;IAClE,CAAC,MAAM;MACL,IAAI,CAACC,SAAS,CAACN,GAAG,CAChBW,IAAI,CAACV,CAAC,EACNU,IAAI,CAACT,CAAC,EACNS,IAAI,CAACR,CAAC,EACNQ,IAAI,CAAChC,CAAC,EACNmC,MAAM,CAAC5B,KAAK;MAAE;MACd4B,MAAM,CAAC3B,IAAI;MAAE;MACbiB,IAAI,EACJC,MACF,CAAC;;MAED;MACA,IAAI,IAAI,CAACW,kBAAkB,CAACC,IAAI,IAAI,IAAI,CAACD,kBAAkB,CAACE,IAAI,EAAE;QAChE,IAAI,CAACC,WAAW,CAAC,KAAK,EAAE,CACtBR,IAAI,CAACV,CAAC,EACNU,IAAI,CAACT,CAAC,EACNS,IAAI,CAACR,CAAC,EACNQ,IAAI,CAAChC,CAAC,EACNmC,MAAM,CAAC5B,KAAK,EACZ4B,MAAM,CAAC3B,IAAI,EACXiB,IAAI,CACL,CAAC;MACJ;IACF;IAEA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEpB,EAAE,CAAC+B,OAAO,GAAG,UAASd,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAExB,CAAC,EAAEyC,OAAO,EAAE;IACzC;IACA,OAAO,IAAI,CAACC,cAAc,CAAC,GAAGC,SAAS,CAAC;EAC1C,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEtC,EAAE,CAACuC,MAAM,GAAG,UAAS,GAAGC,IAAI,EAAE;IAC5B;IACA,MAAMC,KAAK,GAAGD,IAAI,CAACE,KAAK,CAAE,CAAC,EAAE,CAAC,CAAC;IAC/BD,KAAK,CAACE,IAAI,CAACH,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;IAC5B,OAAO,IAAI,CAACH,cAAc,CAAC,GAAGI,KAAK,CAAC;EACtC,CAAC;;EAED;EACAzC,EAAE,CAACqC,cAAc,GAAG,UAASpB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAExB,CAAC,EAAEyC,OAAO,EAAE;IAChD;IACA;IACA,IAAI,CAAC,IAAI,CAACd,SAAS,CAACC,MAAM,CAACC,WAAW,IAAI,CAAC,IAAI,CAACF,SAAS,CAACC,MAAM,CAACE,SAAS,EAAE;MAC1E,OAAO,IAAI;IACb;;IAEA;IACA,IAAI,OAAO9B,CAAC,KAAK,WAAW,EAAE;MAC5BA,CAAC,GAAGwB,CAAC;IACP;IAEA,MAAMQ,IAAI,GAAG9B,MAAM,CAAC+B,UAAU,CAACX,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAExB,CAAC,EAAE,IAAI,CAAC2B,SAAS,CAACC,MAAM,CAACM,WAAW,CAAC;IAC7E,IAAI,CAACP,SAAS,CAACS,OAAO,CAAC,CAACJ,IAAI,CAACV,CAAC,EAAEU,IAAI,CAACT,CAAC,EAAES,IAAI,CAACR,CAAC,EAAEQ,IAAI,CAAChC,CAAC,EAAEyC,OAAO,CAAC,CAAC;;IAEjE;IACA,IAAI,IAAI,CAACJ,kBAAkB,CAACC,IAAI,IAAI,IAAI,CAACD,kBAAkB,CAACE,IAAI,EAAE;MAChE,IAAI,CAACC,WAAW,CAAC,SAAS,EAAE,CAACR,IAAI,CAACV,CAAC,EAAEU,IAAI,CAACT,CAAC,EAAES,IAAI,CAACR,CAAC,EAAEQ,IAAI,CAAChC,CAAC,CAAC,CAAC;IAC/D;IAEA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,EAAE,CAAC4C,IAAI,GAAG,UAAS,GAAGJ,IAAI,EAAE;IAC1B;;IAEA,IAAI,IAAI,CAAClB,SAAS,CAACC,MAAM,CAACC,WAAW,EAAE;MACrC,IAAI,CAACF,SAAS,CAACsB,IAAI,CAAC,GAAGJ,IAAI,CAAC;IAC9B;;IAEA;IACA,IAAI,IAAI,CAACR,kBAAkB,CAACC,IAAI,IAAI,IAAI,CAACD,kBAAkB,CAACE,IAAI,EAAE;MAChE,IAAI,CAACC,WAAW,CAAC,MAAM,EAAEK,IAAI,CAAC;IAChC;IAEA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;EACExC,EAAE,CAAC6C,KAAK,GAAG,UAAS,GAAGL,IAAI,EAAE;IAC3B;;IAEA,IAAI,IAAI,CAAClB,SAAS,CAACC,MAAM,CAACC,WAAW,EAAE;MACrC,IAAIgB,IAAI,CAACM,MAAM,KAAK,CAAC,IAAIN,IAAI,CAAC,CAAC,CAAC,YAAYzC,EAAE,CAACgD,MAAM,EAAE;QACrD,IAAI,CAACzB,SAAS,CAACuB,KAAK,CAACG,IAAI,CACvB,IAAI,CAAC1B,SAAS,EACdkB,IAAI,CAAC,CAAC,CAAC,CAACvB,CAAC,EACTuB,IAAI,CAAC,CAAC,CAAC,CAACtB,CAAC,EACTsB,IAAI,CAAC,CAAC,CAAC,CAACS,CACV,CAAC;MACH,CAAC,MAAM;QACL,IAAI,CAAC3B,SAAS,CAACuB,KAAK,CAAC,GAAGL,IAAI,CAAC;QAC7B;QACA,IAAI,IAAI,CAACR,kBAAkB,CAACC,IAAI,IAAI,IAAI,CAACD,kBAAkB,CAACE,IAAI,EAAE;UAChE,IAAI,CAACC,WAAW,CAAC,OAAO,EAAEK,IAAI,CAAC;QACjC;MACF;IACF;IAEA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACExC,EAAE,CAACkD,IAAI,GAAG,UAAS,GAAGV,IAAI,EAAE;IAC1B;;IAEA,IAAI,IAAI,CAAClB,SAAS,CAACC,MAAM,CAACC,WAAW,IAAI,IAAI,CAACF,SAAS,CAACC,MAAM,CAACE,SAAS,EAAE;MACxE,IAAI,IAAI,CAACH,SAAS,CAAC6B,KAAK,IAAIX,IAAI,CAACM,MAAM,GAAG,EAAE,EAAE;QAC5C;QACA,IAAI,CAACxB,SAAS,CAAC4B,IAAI,CAACF,IAAI,CACtB,IAAI,CAAC1B,SAAS,EACdkB,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EACnBA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EACnBA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EACnBA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EACnBA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;MACrB,CAAC,MAAM;QACL,IAAI,CAAClB,SAAS,CAAC4B,IAAI,CAAC,GAAGV,IAAI,CAAC;QAC5B;QACA,IAAI,IAAI,CAACR,kBAAkB,CAACC,IAAI,IAAI,IAAI,CAACD,kBAAkB,CAACE,IAAI,EAAE;UAChE,IAAI,CAACC,WAAW,CAAC,eAAe,EAAEK,IAAI,CAAC;QACzC;MACF;IACF;IAEA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACExC,EAAE,CAACoD,IAAI,GAAG,UAAS,GAAGZ,IAAI,EAAE;IAC1B;IACA,OAAO,IAAI,CAACa,WAAW,CAAC,GAAGb,IAAI,CAAC;EAClC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACExC,EAAE,CAACsD,MAAM,GAAG,UAASrC,CAAC,EAAEC,CAAC,EAAEqC,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;IAC5C;IACA;IACA,OAAO,IAAI,CAACN,WAAW,CAACL,IAAI,CAAC,IAAI,EAAE/B,CAAC,EAAEC,CAAC,EAAEqC,CAAC,EAAEA,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;EAChE,CAAC;;EAED;EACA3D,EAAE,CAACqD,WAAW,GAAG,YAAW;IAC1B,IAAI,IAAI,CAAC/B,SAAS,CAACC,MAAM,CAACC,WAAW,IAAI,IAAI,CAACF,SAAS,CAACC,MAAM,CAACE,SAAS,EAAE;MACxE;MACA,IAAIa,SAAS,CAACQ,MAAM,KAAK,CAAC,EAAE;QAC1BR,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC;MAC7B;MACA,MAAMX,IAAI,GAAG9B,MAAM,CAAC+B,UAAU,CAC5BU,SAAS,CAAC,CAAC,CAAC,EACZA,SAAS,CAAC,CAAC,CAAC,EACZA,SAAS,CAAC,CAAC,CAAC,EACZA,SAAS,CAAC,CAAC,CAAC,EACZ,IAAI,CAAChB,SAAS,CAACC,MAAM,CAACqC,QACxB,CAAC;;MAED;MACA;MACA;MACA;MACA,IAAI,IAAI,CAACtC,SAAS,CAACC,MAAM,CAACqC,QAAQ,KAAKtE,MAAM,EAAE;QAC7CqC,IAAI,CAACR,CAAC,GAAGmB,SAAS,CAAC,CAAC,CAAC;QACrBX,IAAI,CAAChC,CAAC,GAAG2C,SAAS,CAAC,CAAC,CAAC;MACvB;MAEA,MAAME,IAAI,GAAG,CAACb,IAAI,CAACV,CAAC,EAAEU,IAAI,CAACT,CAAC,EAAES,IAAI,CAACR,CAAC,EAAEQ,IAAI,CAAChC,CAAC,CAAC;MAC7C;MACA;MACA,KAAK,IAAIkE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,SAAS,CAACQ,MAAM,EAAEe,CAAC,EAAE,EAAE;QACzCrB,IAAI,CAACqB,CAAC,CAAC,GAAGvB,SAAS,CAACuB,CAAC,CAAC;MACxB;MACA,IAAI,CAACvC,SAAS,CAAC8B,IAAI,CAACZ,IAAI,CAAC;;MAEzB;MACA,IAAI,IAAI,CAACR,kBAAkB,CAACC,IAAI,IAAI,IAAI,CAACD,kBAAkB,CAACE,IAAI,EAAE;QAChE,IAAI,CAACC,WAAW,CAAC,WAAW,EAAE,CAACR,IAAI,CAACV,CAAC,EAAEU,IAAI,CAACT,CAAC,EAAES,IAAI,CAACR,CAAC,EAAEQ,IAAI,CAAChC,CAAC,CAAC,CAAC;MACjE;IACF;IAEA,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,EAAE,CAAC8D,QAAQ,GAAG,UAAS,GAAGtB,IAAI,EAAE;IAC9B;;IAEA,IAAI,IAAI,CAAClB,SAAS,CAACC,MAAM,CAACC,WAAW,IAAI,IAAI,CAACF,SAAS,CAACC,MAAM,CAACE,SAAS,EAAE;MACxE,IAAI,CAACH,SAAS,CAACwC,QAAQ,CAACtB,IAAI,CAAC;IAC/B;;IAEA;IACA,IAAI,IAAI,CAACR,kBAAkB,CAACC,IAAI,IAAI,IAAI,CAACD,kBAAkB,CAACE,IAAI,EAAE;MAChE,IAAI,CAACC,WAAW,CAAC,UAAU,EAAEK,IAAI,CAAC;IACpC;IAEA,OAAO,IAAI;EACb,CAAC;AACH;AAEA,IAAG,OAAOzC,EAAE,KAAK,WAAW,EAAC;EAC3BD,UAAU,CAACC,EAAE,EAAEA,EAAE,CAACgE,SAAS,CAAC;AAC9B;AAEA,SAASjE,UAAU,IAAIkE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}