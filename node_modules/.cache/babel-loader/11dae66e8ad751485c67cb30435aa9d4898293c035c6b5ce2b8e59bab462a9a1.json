{"ast":null,"code":"import { T as TEXTURE } from '../constants-BRcElHU3.js';\nimport { R as RendererGL } from '../rendering-CvUVN-Vb.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { Geometry } from './p5.Geometry.js';\nimport { Font, arrayCommandsToObjects } from '../type/p5.Font.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../type/textCore.js';\nimport '@japont/unicode-range';\nimport '../type/unicodeRanges.js';\nimport '../type/lib/Typr.js';\nimport 'pako';\nimport '@davepagurek/bezier-path';\nfunction text(p5, fn) {\n  RendererGL.prototype.maxCachedGlyphs = function () {\n    // TODO: use more than vibes to find a good value for this\n    return 200;\n  };\n  Font.prototype._getFontInfo = function (axs) {\n    // For WebGL, a cache of font data to use on the GPU.\n    this._fontInfos = this._fontInfos || {};\n    const key = JSON.stringify(axs);\n    if (this._fontInfos[key]) {\n      const val = this._fontInfos[key];\n      return val;\n    } else {\n      const val = new FontInfo(this, {\n        axs\n      });\n      this._fontInfos[key] = val;\n      return val;\n    }\n  };\n\n  // Text/Typography (see src/type/textCore.js)\n  /*\n  RendererGL.prototype.textWidth = function(s) {\n    if (this._isOpenType()) {\n      return this.states.textFont.font._textWidth(s, this.states.textSize);\n    }\n     return 0; // TODO: error\n  };\n  */\n\n  // rendering constants\n\n  // the number of rows/columns dividing each glyph\n  const charGridWidth = 9;\n  const charGridHeight = charGridWidth;\n\n  // size of the image holding the bezier stroke info\n  const strokeImageWidth = 64;\n  const strokeImageHeight = 64;\n\n  // size of the image holding the stroke indices for each row/col\n  const gridImageWidth = 64;\n  const gridImageHeight = 64;\n\n  // size of the image holding the offset/length of each row/col stripe\n  const cellImageWidth = 64;\n  const cellImageHeight = 64;\n\n  /**\n   * @private\n   * @class ImageInfos\n   * @param {Integer} width\n   * @param {Integer} height\n   *\n   * the ImageInfos class holds a list of ImageDatas of a given size.\n   */\n  class ImageInfos {\n    constructor(width, height) {\n      this.width = width;\n      this.height = height;\n      this.infos = []; // the list of images\n    }\n    /**\n     *\n     * @param {Integer} space\n     * @return {Object} contains the ImageData, and pixel index into that\n     *                  ImageData where the free space was allocated.\n     *\n     * finds free space of a given size in the ImageData list\n     */\n    findImage(space) {\n      const imageSize = this.width * this.height;\n      if (space > imageSize) throw new Error(\"font is too complex to render in 3D\");\n\n      // search through the list of images, looking for one with\n      // anough unused space.\n      let imageInfo, imageData;\n      for (let ii = this.infos.length - 1; ii >= 0; --ii) {\n        const imageInfoTest = this.infos[ii];\n        if (imageInfoTest.index + space < imageSize) {\n          // found one\n          imageInfo = imageInfoTest;\n          imageData = imageInfoTest.imageData;\n          break;\n        }\n      }\n      if (!imageInfo) {\n        try {\n          // create a new image\n          imageData = new ImageData(this.width, this.height);\n        } catch (err) {\n          // for browsers that don't support ImageData constructors (ie IE11)\n          // create an ImageData using the old method\n          let canvas = document.getElementsByTagName(\"canvas\")[0];\n          const created = !canvas;\n          if (!canvas) {\n            // create a temporary canvas\n            canvas = document.createElement(\"canvas\");\n            canvas.style.display = \"none\";\n            document.body.appendChild(canvas);\n          }\n          const ctx = canvas.getContext(\"2d\");\n          if (ctx) {\n            imageData = ctx.createImageData(this.width, this.height);\n          }\n          if (created) {\n            // distroy the temporary canvas, if necessary\n            document.body.removeChild(canvas);\n          }\n        }\n        // construct & dd the new image info\n        imageInfo = {\n          index: 0,\n          imageData\n        };\n        this.infos.push(imageInfo);\n      }\n      const index = imageInfo.index;\n      imageInfo.index += space; // move to the start of the next image\n      imageData._dirty = true;\n      return {\n        imageData,\n        index\n      };\n    }\n  }\n\n  /**\n   * @function setPixel\n   * @param {Object} imageInfo\n   * @param {Number} r\n   * @param {Number} g\n   * @param {Number} b\n   * @param {Number} a\n   *\n   * writes the next pixel into an indexed ImageData\n   */\n  function setPixel(imageInfo, r, g, b, a) {\n    const imageData = imageInfo.imageData;\n    const pixels = imageData.data;\n    let index = imageInfo.index++ * 4;\n    pixels[index++] = r;\n    pixels[index++] = g;\n    pixels[index++] = b;\n    pixels[index++] = a;\n  }\n  const SQRT3 = Math.sqrt(3);\n\n  /**\n   * @private\n   * @class FontInfo\n   * @param {Object} font an opentype.js font object\n   *\n   * contains cached images and glyph information for an opentype font\n   */\n  class FontInfo {\n    constructor(font, {\n      axs\n    } = {}) {\n      this.font = font;\n      this.axs = axs;\n      // the bezier curve coordinates\n      this.strokeImageInfos = new ImageInfos(strokeImageWidth, strokeImageHeight);\n      // lists of curve indices for each row/column slice\n      this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      // the offset & length of each row/col slice in the glyph\n      this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n      this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n\n      // the cached information for each glyph\n      this.glyphInfos = {};\n    }\n    /**\n     * @param {Glyph} glyph the x positions of points in the curve\n     * @returns {Object} the glyphInfo for that glyph\n     *\n     * calculates rendering info for a glyph, including the curve information,\n     * row & column stripes compiled into textures.\n     */\n    getGlyphInfo(glyph) {\n      // check the cache\n      let gi = this.glyphInfos[glyph.index];\n      if (gi) return gi;\n      const axs = this.axs;\n      const {\n        glyph: {\n          path: {\n            commands\n          }\n        }\n      } = this.font._singleShapeToPath(glyph.shape, {\n        axs\n      });\n      let xMin = Infinity;\n      let xMax = -Infinity;\n      let yMin = Infinity;\n      let yMax = -Infinity;\n      for (const cmd of commands) {\n        for (let i = 1; i < cmd.length; i += 2) {\n          xMin = Math.min(xMin, cmd[i]);\n          xMax = Math.max(xMax, cmd[i]);\n          yMin = Math.min(yMin, cmd[i + 1]);\n          yMax = Math.max(yMax, cmd[i + 1]);\n        }\n      }\n\n      // don't bother rendering invisible glyphs\n      if (xMin >= xMax || yMin >= yMax || !commands.length) {\n        return this.glyphInfos[glyph.index] = {};\n      }\n      const gWidth = xMax - xMin;\n      const gHeight = yMax - yMin;\n\n      // Convert arrays to named objects\n      const cmds = arrayCommandsToObjects(commands);\n      let i;\n      const strokes = []; // the strokes in this glyph\n      const rows = []; // the indices of strokes in each row\n      const cols = []; // the indices of strokes in each column\n      for (i = charGridWidth - 1; i >= 0; --i) cols.push([]);\n      for (i = charGridHeight - 1; i >= 0; --i) rows.push([]);\n\n      /**\n       * @function push\n       * @param {Number[]} xs the x positions of points in the curve\n       * @param {Number[]} ys the y positions of points in the curve\n       * @param {Object} v    the curve information\n       *\n       * adds a curve to the rows & columns that it intersects with\n       */\n      function push(xs, ys, v) {\n        const index = strokes.length; // the index of this stroke\n        strokes.push(v); // add this stroke to the list\n\n        /**\n         * @function minMax\n         * @param {Number[]} rg the list of values to compare\n         * @param {Number} min the initial minimum value\n         * @param {Number} max the initial maximum value\n         *\n         * find the minimum & maximum value in a list of values\n         */\n        function minMax(rg, min, max) {\n          for (let i = rg.length; i-- > 0;) {\n            const v = rg[i];\n            if (min > v) min = v;\n            if (max < v) max = v;\n          }\n          return {\n            min,\n            max\n          };\n        }\n\n        // Expand the bounding box of the glyph by the number of cells below\n        // before rounding. Curves only partially through a cell won't be added\n        // to adjacent cells, but ones that are close will be. This helps fix\n        // small visual glitches that occur when curves are close to grid cell\n        // boundaries.\n        const cellOffset = 0.5;\n\n        // loop through the rows & columns that the curve intersects\n        // adding the curve to those slices\n        const mmX = minMax(xs, 1, 0);\n        const ixMin = Math.max(Math.floor(mmX.min * charGridWidth - cellOffset), 0);\n        const ixMax = Math.min(Math.ceil(mmX.max * charGridWidth + cellOffset), charGridWidth);\n        for (let iCol = ixMin; iCol < ixMax; ++iCol) cols[iCol].push(index);\n        const mmY = minMax(ys, 1, 0);\n        const iyMin = Math.max(Math.floor(mmY.min * charGridHeight - cellOffset), 0);\n        const iyMax = Math.min(Math.ceil(mmY.max * charGridHeight + cellOffset), charGridHeight);\n        for (let iRow = iyMin; iRow < iyMax; ++iRow) rows[iRow].push(index);\n      }\n\n      /**\n       * @function clamp\n       * @param {Number} v the value to clamp\n       * @param {Number} min the minimum value\n       * @param {Number} max the maxmimum value\n       *\n       * clamps a value between a minimum & maximum value\n       */\n      function clamp(v, min, max) {\n        if (v < min) return min;\n        if (v > max) return max;\n        return v;\n      }\n\n      /**\n       * @function byte\n       * @param {Number} v the value to scale\n       *\n       * converts a floating-point number in the range 0-1 to a byte 0-255\n       */\n      function byte(v) {\n        return clamp(255 * v, 0, 255);\n      }\n\n      /**\n       * @private\n       * @class Cubic\n       * @param {Number} p0 the start point of the curve\n       * @param {Number} c0 the first control point\n       * @param {Number} c1 the second control point\n       * @param {Number} p1 the end point\n       *\n       * a cubic curve\n       */\n      class Cubic {\n        constructor(p0, c0, c1, p1) {\n          this.p0 = p0;\n          this.c0 = c0;\n          this.c1 = c1;\n          this.p1 = p1;\n        }\n        /**\n         * @return {Object} the quadratic approximation\n         *\n         * converts the cubic to a quadtratic approximation by\n         * picking an appropriate quadratic control point\n         */\n        toQuadratic() {\n          return {\n            x: this.p0.x,\n            y: this.p0.y,\n            x1: this.p1.x,\n            y1: this.p1.y,\n            cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,\n            cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4\n          };\n        }\n\n        /**\n         * @return {Number} the error\n         *\n         * calculates the magnitude of error of this curve's\n         * quadratic approximation.\n         */\n        quadError() {\n          return Vector.sub(Vector.sub(this.p1, this.p0), Vector.mult(Vector.sub(this.c1, this.c0), 3)).mag() / 2;\n        }\n\n        /**\n         * @param {Number} t the value (0-1) at which to split\n         * @return {Cubic} the second part of the curve\n         *\n         * splits the cubic into two parts at a point 't' along the curve.\n         * this cubic keeps its start point and its end point becomes the\n         * point at 't'. the 'end half is returned.\n         */\n        split(t) {\n          const m1 = Vector.lerp(this.p0, this.c0, t);\n          const m2 = Vector.lerp(this.c0, this.c1, t);\n          const mm1 = Vector.lerp(m1, m2, t);\n          this.c1 = Vector.lerp(this.c1, this.p1, t);\n          this.c0 = Vector.lerp(m2, this.c1, t);\n          const pt = Vector.lerp(mm1, this.c0, t);\n          const part1 = new Cubic(this.p0, m1, mm1, pt);\n          this.p0 = pt;\n          return part1;\n        }\n\n        /**\n         * @return {Cubic[]} the non-inflecting pieces of this cubic\n         *\n         * returns an array containing 0, 1 or 2 cubics split resulting\n         * from splitting this cubic at its inflection points.\n         * this cubic is (potentially) altered and returned in the list.\n         */\n        splitInflections() {\n          const a = Vector.sub(this.c0, this.p0);\n          const b = Vector.sub(Vector.sub(this.c1, this.c0), a);\n          const c = Vector.sub(Vector.sub(Vector.sub(this.p1, this.c1), a), Vector.mult(b, 2));\n          const cubics = [];\n\n          // find the derivative coefficients\n          let A = b.x * c.y - b.y * c.x;\n          if (A !== 0) {\n            let B = a.x * c.y - a.y * c.x;\n            let C = a.x * b.y - a.y * b.x;\n            const disc = B * B - 4 * A * C;\n            if (disc >= 0) {\n              if (A < 0) {\n                A = -A;\n                B = -B;\n                C = -C;\n              }\n              const Q = Math.sqrt(disc);\n              const t0 = (-B - Q) / (2 * A); // the first inflection point\n              let t1 = (-B + Q) / (2 * A); // the second inflection point\n\n              // test if the first inflection point lies on the curve\n              if (t0 > 0 && t0 < 1) {\n                // split at the first inflection point\n                cubics.push(this.split(t0));\n                // scale t2 into the second part\n                t1 = 1 - (1 - t1) / (1 - t0);\n              }\n\n              // test if the second inflection point lies on the curve\n              if (t1 > 0 && t1 < 1) {\n                // split at the second inflection point\n                cubics.push(this.split(t1));\n              }\n            }\n          }\n          cubics.push(this);\n          return cubics;\n        }\n      }\n\n      /**\n       * @function cubicToQuadratics\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} cx0\n       * @param {Number} cy0\n       * @param {Number} cx1\n       * @param {Number} cy1\n       * @param {Number} x1\n       * @param {Number} y1\n       * @returns {Cubic[]} an array of cubics whose quadratic approximations\n       *                    closely match the civen cubic.\n       *\n       * converts a cubic curve to a list of quadratics.\n       */\n      function cubicToQuadratics(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\n        // create the Cubic object and split it at its inflections\n        const cubics = new Cubic(new Vector(x0, y0), new Vector(cx0, cy0), new Vector(cx1, cy1), new Vector(x1, y1)).splitInflections();\n        const qs = []; // the final list of quadratics\n        const precision = 30 / SQRT3;\n\n        // for each of the non-inflected pieces of the original cubic\n        for (let cubic of cubics) {\n          // the cubic is iteratively split in 3 pieces:\n          // the first piece is accumulated in 'qs', the result.\n          // the last piece is accumulated in 'tail', temporarily.\n          // the middle piece is repeatedly split again, while necessary.\n          const tail = [];\n          let t3;\n          for (;;) {\n            // calculate this cubic's precision\n            t3 = precision / cubic.quadError();\n            if (t3 >= 0.5 * 0.5 * 0.5) {\n              break; // not too bad, we're done\n            }\n\n            // find a split point based on the error\n            const t = Math.pow(t3, 1.0 / 3.0);\n            // split the cubic in 3\n            const start = cubic.split(t);\n            const middle = cubic.split(1 - t / (1 - t));\n            qs.push(start); // the first part\n            tail.push(cubic); // the last part\n            cubic = middle; // iterate on the middle piece\n          }\n          if (t3 < 1) {\n            // a little excess error, split the middle in two\n            qs.push(cubic.split(0.5));\n          }\n          // add the middle piece to the result\n          qs.push(cubic);\n\n          // finally add the tail, reversed, onto the result\n          Array.prototype.push.apply(qs, tail.reverse());\n        }\n        return qs;\n      }\n\n      /**\n       * @function pushLine\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       *\n       * add a straight line to the row/col grid of a glyph\n       */\n      function pushLine(x0, y0, x1, y1) {\n        const mx = (x0 + x1) / 2;\n        const my = (y0 + y1) / 2;\n        push([x0, x1], [y0, y1], {\n          x: x0,\n          y: y0,\n          cx: mx,\n          cy: my\n        });\n      }\n\n      /**\n       * @function samePoint\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       * @return {Boolean} true if the two points are sufficiently close\n       *\n       * tests if two points are close enough to be considered the same\n       */\n      function samePoint(x0, y0, x1, y1) {\n        return Math.abs(x1 - x0) < 0.00001 && Math.abs(y1 - y0) < 0.00001;\n      }\n      let x0, y0, xs, ys;\n      for (const cmd of cmds) {\n        // scale the coordinates to the range 0-1\n        const x1 = (cmd.x - xMin) / gWidth;\n        const y1 = (cmd.y - yMin) / gHeight;\n\n        // don't bother if this point is the same as the last\n        if (samePoint(x0, y0, x1, y1)) continue;\n        switch (cmd.type) {\n          case \"M\":\n            {\n              // move\n              xs = x1;\n              ys = y1;\n              break;\n            }\n          case \"L\":\n            {\n              // line\n              pushLine(x0, y0, x1, y1);\n              break;\n            }\n          case \"Q\":\n            {\n              // quadratic\n              const cx = (cmd.x1 - xMin) / gWidth;\n              const cy = (cmd.y1 - yMin) / gHeight;\n              push([x0, x1, cx], [y0, y1, cy], {\n                x: x0,\n                y: y0,\n                cx,\n                cy\n              });\n              break;\n            }\n          case \"Z\":\n            {\n              // end\n              if (!samePoint(x0, y0, xs, ys)) {\n                // add an extra line closing the loop, if necessary\n                pushLine(x0, y0, xs, ys);\n                strokes.push({\n                  x: xs,\n                  y: ys\n                });\n              } else {\n                strokes.push({\n                  x: x0,\n                  y: y0\n                });\n              }\n              break;\n            }\n          case \"C\":\n            {\n              // cubic\n              const cx1 = (cmd.x1 - xMin) / gWidth;\n              const cy1 = (cmd.y1 - yMin) / gHeight;\n              const cx2 = (cmd.x2 - xMin) / gWidth;\n              const cy2 = (cmd.y2 - yMin) / gHeight;\n              const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);\n              for (let iq = 0; iq < qs.length; iq++) {\n                const q = qs[iq].toQuadratic();\n                push([q.x, q.x1, q.cx], [q.y, q.y1, q.cy], q);\n              }\n              break;\n            }\n          default:\n            throw new Error(`unknown command type: ${cmd.type}`);\n        }\n        x0 = x1;\n        y0 = y1;\n      }\n\n      // allocate space for the strokes\n      const strokeCount = strokes.length;\n      const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);\n      const strokeOffset = strokeImageInfo.index;\n\n      // fill the stroke image\n      for (let il = 0; il < strokeCount; ++il) {\n        const s = strokes[il];\n        setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));\n      }\n\n      /**\n       * @function layout\n       * @param {Number[][]} dim\n       * @param {ImageInfo[]} dimImageInfos\n       * @param {ImageInfo[]} cellImageInfos\n       * @return {Object}\n       *\n       * lays out the curves in a dimension (row or col) into two\n       * images, one for the indices of the curves themselves, and\n       * one containing the offset and length of those index spans.\n       */\n      function layout(dim, dimImageInfos, cellImageInfos) {\n        const dimLength = dim.length; // the number of slices in this dimension\n        const dimImageInfo = dimImageInfos.findImage(dimLength);\n        const dimOffset = dimImageInfo.index;\n        // calculate the total number of stroke indices in this dimension\n        let totalStrokes = 0;\n        for (let id = 0; id < dimLength; ++id) {\n          totalStrokes += dim[id].length;\n        }\n\n        // allocate space for the stroke indices\n        const cellImageInfo = cellImageInfos.findImage(totalStrokes);\n\n        // for each slice in the glyph\n        for (let i = 0; i < dimLength; ++i) {\n          const strokeIndices = dim[i];\n          const strokeCount = strokeIndices.length;\n          const cellLineIndex = cellImageInfo.index;\n\n          // write the offset and count into the glyph slice image\n          setPixel(dimImageInfo, cellLineIndex >> 7, cellLineIndex & 0x7f, strokeCount >> 7, strokeCount & 0x7f);\n\n          // for each stroke index in that slice\n          for (let iil = 0; iil < strokeCount; ++iil) {\n            // write the stroke index into the slice's image\n            const strokeIndex = strokeIndices[iil] + strokeOffset;\n            setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 0x7f, 0, 0);\n          }\n        }\n        return {\n          cellImageInfo,\n          dimOffset,\n          dimImageInfo\n        };\n      }\n\n      // initialize the info for this glyph\n      gi = this.glyphInfos[glyph.index] = {\n        glyph,\n        uGlyphRect: [xMin, yMin, xMax, yMax],\n        strokeImageInfo,\n        strokes,\n        colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),\n        rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)\n      };\n      gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];\n      return gi;\n    }\n  }\n  RendererGL.prototype._renderText = function (line, x, y, maxY, minY) {\n    if (!this.states.textFont || typeof this.states.textFont === \"string\") {\n      console.log(\"WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.\");\n      return;\n    }\n    if (y >= maxY || !this.states.fillColor) {\n      return; // don't render lines beyond our maxY position\n    }\n    if (!p5.Font.hasGlyphData(this.states.textFont)) {\n      console.log(\"WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported\");\n      return;\n    }\n    this.push(); // fix to #803\n\n    // remember this state, so it can be restored later\n    const doStroke = this.states.strokeColor;\n    const drawMode = this.states.drawMode;\n    this.states.setValue(\"strokeColor\", null);\n    this.states.setValue(\"drawMode\", TEXTURE);\n\n    // get the cached FontInfo object\n    const {\n      font\n    } = this.states.textFont;\n    if (!font) {\n      throw new Error(\"In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.\");\n    }\n    const axs = font._currentAxes(this);\n    let fontInfo = font._getFontInfo(axs);\n\n    // calculate the alignment and move/scale the view accordingly\n    // TODO: check this\n    const pos = {\n      x,\n      y\n    }; // this.states.textFont._handleAlignment(this, line, x, y);\n    const fontSize = this.states.textSize;\n    const scale = fontSize / (font.data?.head?.unitsPerEm || 1000);\n    this.translate(pos.x, pos.y, 0);\n    this.scale(scale, scale, 1);\n\n    // initialize the font shader\n    const gl = this.GL;\n    const initializeShader = !this._defaultFontShader;\n    const sh = this._getFontShader();\n    sh.init();\n    sh.bindShader(); // first time around, bind the shader fully\n\n    if (initializeShader) {\n      // these are constants, really. just initialize them one-time.\n      sh.setUniform(\"uGridImageSize\", [gridImageWidth, gridImageHeight]);\n      sh.setUniform(\"uCellsImageSize\", [cellImageWidth, cellImageHeight]);\n      sh.setUniform(\"uStrokeImageSize\", [strokeImageWidth, strokeImageHeight]);\n      sh.setUniform(\"uGridSize\", [charGridWidth, charGridHeight]);\n    }\n    const curFillColor = this.states.fillSet ? this.states.curFillColor : [0, 0, 0, 255];\n    this._setGlobalUniforms(sh);\n    this._applyColorBlend(curFillColor);\n    let g = this.geometryBufferCache.getGeometryByID(\"glyph\");\n    if (!g) {\n      // create the geometry for rendering a quad\n      g = this._textGeom = new Geometry(1, 1, function () {\n        for (let i = 0; i <= 1; i++) {\n          for (let j = 0; j <= 1; j++) {\n            this.vertices.push(new Vector(j, i, 0));\n            this.uvs.push(j, i);\n          }\n        }\n      }, this);\n      g.gid = \"glyph\";\n      g.computeFaces().computeNormals();\n      this.geometryBufferCache.ensureCached(g);\n    }\n\n    // bind the shader buffers\n    for (const buff of this.buffers.text) {\n      buff._prepareBuffer(g, sh);\n    }\n    this._bindBuffer(this.geometryBufferCache.cache.glyph.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);\n\n    // this will have to do for now...\n    sh.setUniform(\"uMaterialColor\", curFillColor);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    this.glyphDataCache = this.glyphDataCache || new Set();\n    try {\n      // fetch the glyphs in the line of text\n      const glyphs = font._positionGlyphs(line);\n      for (const glyph of glyphs) {\n        const gi = fontInfo.getGlyphInfo(glyph);\n        if (gi.uGlyphRect) {\n          const rowInfo = gi.rowInfo;\n          const colInfo = gi.colInfo;\n\n          // Bump the resources for this glyph to the end of the cache list by deleting and re-adding\n          const glyphResources = [gi.strokeImageInfo.imageData, rowInfo.cellImageInfo.imageData, rowInfo.dimImageInfo.imageData, colInfo.cellImageInfo.imageData, colInfo.dimImageInfo.imageData];\n          for (const resource of glyphResources) {\n            this.glyphDataCache.delete(resource);\n            this.glyphDataCache.add(resource);\n          }\n\n          // If we have too many glyph textures, remove the least recently used\n          // ones from GPU memory. The data still exists on the CPU and will be\n          // re-uploaded if it gets actively used again.\n          while (this.glyphDataCache.size > this.maxCachedGlyphs()) {\n            const data = this.glyphDataCache.values().next().value;\n            this.glyphDataCache.delete(data);\n            const tex = this.textures.get(data);\n            if (tex) {\n              tex.remove();\n              this.textures.delete(data);\n            }\n          }\n          sh.setUniform(\"uSamplerStrokes\", gi.strokeImageInfo.imageData);\n          sh.setUniform(\"uSamplerRowStrokes\", rowInfo.cellImageInfo.imageData);\n          sh.setUniform(\"uSamplerRows\", rowInfo.dimImageInfo.imageData);\n          sh.setUniform(\"uSamplerColStrokes\", colInfo.cellImageInfo.imageData);\n          sh.setUniform(\"uSamplerCols\", colInfo.dimImageInfo.imageData);\n          sh.setUniform(\"uGridOffset\", gi.uGridOffset);\n          sh.setUniform(\"uGlyphRect\", gi.uGlyphRect);\n          sh.setUniform(\"uGlyphOffset\", glyph.x);\n          sh.bindTextures(); // afterwards, only textures need updating\n\n          // draw it\n          gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);\n        }\n      }\n    } finally {\n      // clean up\n      sh.unbindShader();\n      this.states.setValue(\"strokeColor\", doStroke);\n      this.states.setValue(\"drawMode\", drawMode);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n      this.pop();\n    }\n  };\n}\nexport { text as default };","map":{"version":3,"names":["T","TEXTURE","R","RendererGL","Vector","Geometry","Font","arrayCommandsToObjects","text","p5","fn","prototype","maxCachedGlyphs","_getFontInfo","axs","_fontInfos","key","JSON","stringify","val","FontInfo","charGridWidth","charGridHeight","strokeImageWidth","strokeImageHeight","gridImageWidth","gridImageHeight","cellImageWidth","cellImageHeight","ImageInfos","constructor","width","height","infos","findImage","space","imageSize","Error","imageInfo","imageData","ii","length","imageInfoTest","index","ImageData","err","canvas","document","getElementsByTagName","created","createElement","style","display","body","appendChild","ctx","getContext","createImageData","removeChild","push","_dirty","setPixel","r","g","b","a","pixels","data","SQRT3","Math","sqrt","font","strokeImageInfos","colDimImageInfos","rowDimImageInfos","colCellImageInfos","rowCellImageInfos","glyphInfos","getGlyphInfo","glyph","gi","path","commands","_singleShapeToPath","shape","xMin","Infinity","xMax","yMin","yMax","cmd","i","min","max","gWidth","gHeight","cmds","strokes","rows","cols","xs","ys","v","minMax","rg","cellOffset","mmX","ixMin","floor","ixMax","ceil","iCol","mmY","iyMin","iyMax","iRow","clamp","byte","Cubic","p0","c0","c1","p1","toQuadratic","x","y","x1","y1","cx","cy","quadError","sub","mult","mag","split","t","m1","lerp","m2","mm1","pt","part1","splitInflections","c","cubics","A","B","C","disc","Q","t0","t1","cubicToQuadratics","x0","y0","cx0","cy0","cx1","cy1","qs","precision","cubic","tail","t3","pow","start","middle","Array","apply","reverse","pushLine","mx","my","samePoint","abs","type","cx2","x2","cy2","y2","iq","q","strokeCount","strokeImageInfo","strokeOffset","il","s","layout","dim","dimImageInfos","cellImageInfos","dimLength","dimImageInfo","dimOffset","totalStrokes","id","cellImageInfo","strokeIndices","cellLineIndex","iil","strokeIndex","uGlyphRect","colInfo","rowInfo","uGridOffset","_renderText","line","maxY","minY","states","textFont","console","log","fillColor","hasGlyphData","doStroke","strokeColor","drawMode","setValue","_currentAxes","fontInfo","pos","fontSize","textSize","scale","head","unitsPerEm","translate","gl","GL","initializeShader","_defaultFontShader","sh","_getFontShader","init","bindShader","setUniform","curFillColor","fillSet","_setGlobalUniforms","_applyColorBlend","geometryBufferCache","getGeometryByID","_textGeom","j","vertices","uvs","gid","computeFaces","computeNormals","ensureCached","buff","buffers","_prepareBuffer","_bindBuffer","cache","indexBuffer","ELEMENT_ARRAY_BUFFER","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","glyphDataCache","Set","glyphs","_positionGlyphs","glyphResources","resource","delete","add","size","values","next","value","tex","textures","get","remove","bindTextures","drawElements","TRIANGLES","UNSIGNED_SHORT","unbindShader","pop","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/webgl/text.js"],"sourcesContent":["import { T as TEXTURE } from '../constants-BRcElHU3.js';\nimport { R as RendererGL } from '../rendering-CvUVN-Vb.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { Geometry } from './p5.Geometry.js';\nimport { Font, arrayCommandsToObjects } from '../type/p5.Font.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../type/textCore.js';\nimport '@japont/unicode-range';\nimport '../type/unicodeRanges.js';\nimport '../type/lib/Typr.js';\nimport 'pako';\nimport '@davepagurek/bezier-path';\n\nfunction text(p5, fn) {\n  RendererGL.prototype.maxCachedGlyphs = function() {\n    // TODO: use more than vibes to find a good value for this\n    return 200;\n  };\n\n  Font.prototype._getFontInfo = function(axs) {\n    // For WebGL, a cache of font data to use on the GPU.\n    this._fontInfos = this._fontInfos || {};\n\n    const key = JSON.stringify(axs);\n    if (this._fontInfos[key]) {\n      const val = this._fontInfos[key];\n      return val;\n    } else {\n      const val = new FontInfo(this, { axs });\n      this._fontInfos[key] = val;\n      return val;\n    }\n  };\n\n  // Text/Typography (see src/type/textCore.js)\n  /*\n  RendererGL.prototype.textWidth = function(s) {\n    if (this._isOpenType()) {\n      return this.states.textFont.font._textWidth(s, this.states.textSize);\n    }\n\n    return 0; // TODO: error\n  };\n  */\n\n  // rendering constants\n\n  // the number of rows/columns dividing each glyph\n  const charGridWidth = 9;\n  const charGridHeight = charGridWidth;\n\n  // size of the image holding the bezier stroke info\n  const strokeImageWidth = 64;\n  const strokeImageHeight = 64;\n\n  // size of the image holding the stroke indices for each row/col\n  const gridImageWidth = 64;\n  const gridImageHeight = 64;\n\n  // size of the image holding the offset/length of each row/col stripe\n  const cellImageWidth = 64;\n  const cellImageHeight = 64;\n\n  /**\n   * @private\n   * @class ImageInfos\n   * @param {Integer} width\n   * @param {Integer} height\n   *\n   * the ImageInfos class holds a list of ImageDatas of a given size.\n   */\n  class ImageInfos {\n    constructor(width, height) {\n      this.width = width;\n      this.height = height;\n      this.infos = []; // the list of images\n    }\n    /**\n     *\n     * @param {Integer} space\n     * @return {Object} contains the ImageData, and pixel index into that\n     *                  ImageData where the free space was allocated.\n     *\n     * finds free space of a given size in the ImageData list\n     */\n    findImage(space) {\n      const imageSize = this.width * this.height;\n      if (space > imageSize)\n        throw new Error(\"font is too complex to render in 3D\");\n\n      // search through the list of images, looking for one with\n      // anough unused space.\n      let imageInfo, imageData;\n      for (let ii = this.infos.length - 1; ii >= 0; --ii) {\n        const imageInfoTest = this.infos[ii];\n        if (imageInfoTest.index + space < imageSize) {\n          // found one\n          imageInfo = imageInfoTest;\n          imageData = imageInfoTest.imageData;\n          break;\n        }\n      }\n\n      if (!imageInfo) {\n        try {\n          // create a new image\n          imageData = new ImageData(this.width, this.height);\n        } catch (err) {\n          // for browsers that don't support ImageData constructors (ie IE11)\n          // create an ImageData using the old method\n          let canvas = document.getElementsByTagName(\"canvas\")[0];\n          const created = !canvas;\n          if (!canvas) {\n            // create a temporary canvas\n            canvas = document.createElement(\"canvas\");\n            canvas.style.display = \"none\";\n            document.body.appendChild(canvas);\n          }\n          const ctx = canvas.getContext(\"2d\");\n          if (ctx) {\n            imageData = ctx.createImageData(this.width, this.height);\n          }\n          if (created) {\n            // distroy the temporary canvas, if necessary\n            document.body.removeChild(canvas);\n          }\n        }\n        // construct & dd the new image info\n        imageInfo = { index: 0, imageData };\n        this.infos.push(imageInfo);\n      }\n\n      const index = imageInfo.index;\n      imageInfo.index += space; // move to the start of the next image\n      imageData._dirty = true;\n      return { imageData, index };\n    }\n  }\n\n  /**\n   * @function setPixel\n   * @param {Object} imageInfo\n   * @param {Number} r\n   * @param {Number} g\n   * @param {Number} b\n   * @param {Number} a\n   *\n   * writes the next pixel into an indexed ImageData\n   */\n  function setPixel(imageInfo, r, g, b, a) {\n    const imageData = imageInfo.imageData;\n    const pixels = imageData.data;\n    let index = imageInfo.index++ * 4;\n    pixels[index++] = r;\n    pixels[index++] = g;\n    pixels[index++] = b;\n    pixels[index++] = a;\n  }\n\n  const SQRT3 = Math.sqrt(3);\n\n  /**\n   * @private\n   * @class FontInfo\n   * @param {Object} font an opentype.js font object\n   *\n   * contains cached images and glyph information for an opentype font\n   */\n  class FontInfo {\n    constructor(font, { axs } = {}) {\n      this.font = font;\n      this.axs = axs;\n      // the bezier curve coordinates\n      this.strokeImageInfos = new ImageInfos(\n        strokeImageWidth,\n        strokeImageHeight,\n      );\n      // lists of curve indices for each row/column slice\n      this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      // the offset & length of each row/col slice in the glyph\n      this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n      this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n\n      // the cached information for each glyph\n      this.glyphInfos = {};\n    }\n    /**\n     * @param {Glyph} glyph the x positions of points in the curve\n     * @returns {Object} the glyphInfo for that glyph\n     *\n     * calculates rendering info for a glyph, including the curve information,\n     * row & column stripes compiled into textures.\n     */\n    getGlyphInfo(glyph) {\n      // check the cache\n      let gi = this.glyphInfos[glyph.index];\n      if (gi) return gi;\n\n      const axs = this.axs;\n      const {\n        glyph: {\n          path: { commands },\n        },\n      } = this.font._singleShapeToPath(glyph.shape, { axs });\n      let xMin = Infinity;\n      let xMax = -Infinity;\n      let yMin = Infinity;\n      let yMax = -Infinity;\n\n      for (const cmd of commands) {\n        for (let i = 1; i < cmd.length; i += 2) {\n          xMin = Math.min(xMin, cmd[i]);\n          xMax = Math.max(xMax, cmd[i]);\n          yMin = Math.min(yMin, cmd[i + 1]);\n          yMax = Math.max(yMax, cmd[i + 1]);\n        }\n      }\n\n      // don't bother rendering invisible glyphs\n      if (xMin >= xMax || yMin >= yMax || !commands.length) {\n        return (this.glyphInfos[glyph.index] = {});\n      }\n\n      const gWidth = xMax - xMin;\n      const gHeight = yMax - yMin;\n\n      // Convert arrays to named objects\n      const cmds = arrayCommandsToObjects(commands);\n\n      let i;\n      const strokes = []; // the strokes in this glyph\n      const rows = []; // the indices of strokes in each row\n      const cols = []; // the indices of strokes in each column\n      for (i = charGridWidth - 1; i >= 0; --i) cols.push([]);\n      for (i = charGridHeight - 1; i >= 0; --i) rows.push([]);\n\n      /**\n       * @function push\n       * @param {Number[]} xs the x positions of points in the curve\n       * @param {Number[]} ys the y positions of points in the curve\n       * @param {Object} v    the curve information\n       *\n       * adds a curve to the rows & columns that it intersects with\n       */\n      function push(xs, ys, v) {\n        const index = strokes.length; // the index of this stroke\n        strokes.push(v); // add this stroke to the list\n\n        /**\n         * @function minMax\n         * @param {Number[]} rg the list of values to compare\n         * @param {Number} min the initial minimum value\n         * @param {Number} max the initial maximum value\n         *\n         * find the minimum & maximum value in a list of values\n         */\n        function minMax(rg, min, max) {\n          for (let i = rg.length; i-- > 0; ) {\n            const v = rg[i];\n            if (min > v) min = v;\n            if (max < v) max = v;\n          }\n          return { min, max };\n        }\n\n        // Expand the bounding box of the glyph by the number of cells below\n        // before rounding. Curves only partially through a cell won't be added\n        // to adjacent cells, but ones that are close will be. This helps fix\n        // small visual glitches that occur when curves are close to grid cell\n        // boundaries.\n        const cellOffset = 0.5;\n\n        // loop through the rows & columns that the curve intersects\n        // adding the curve to those slices\n        const mmX = minMax(xs, 1, 0);\n        const ixMin = Math.max(\n          Math.floor(mmX.min * charGridWidth - cellOffset),\n          0,\n        );\n        const ixMax = Math.min(\n          Math.ceil(mmX.max * charGridWidth + cellOffset),\n          charGridWidth,\n        );\n        for (let iCol = ixMin; iCol < ixMax; ++iCol) cols[iCol].push(index);\n\n        const mmY = minMax(ys, 1, 0);\n        const iyMin = Math.max(\n          Math.floor(mmY.min * charGridHeight - cellOffset),\n          0,\n        );\n        const iyMax = Math.min(\n          Math.ceil(mmY.max * charGridHeight + cellOffset),\n          charGridHeight,\n        );\n        for (let iRow = iyMin; iRow < iyMax; ++iRow) rows[iRow].push(index);\n      }\n\n      /**\n       * @function clamp\n       * @param {Number} v the value to clamp\n       * @param {Number} min the minimum value\n       * @param {Number} max the maxmimum value\n       *\n       * clamps a value between a minimum & maximum value\n       */\n      function clamp(v, min, max) {\n        if (v < min) return min;\n        if (v > max) return max;\n        return v;\n      }\n\n      /**\n       * @function byte\n       * @param {Number} v the value to scale\n       *\n       * converts a floating-point number in the range 0-1 to a byte 0-255\n       */\n      function byte(v) {\n        return clamp(255 * v, 0, 255);\n      }\n\n      /**\n       * @private\n       * @class Cubic\n       * @param {Number} p0 the start point of the curve\n       * @param {Number} c0 the first control point\n       * @param {Number} c1 the second control point\n       * @param {Number} p1 the end point\n       *\n       * a cubic curve\n       */\n      class Cubic {\n        constructor(p0, c0, c1, p1) {\n          this.p0 = p0;\n          this.c0 = c0;\n          this.c1 = c1;\n          this.p1 = p1;\n        }\n        /**\n         * @return {Object} the quadratic approximation\n         *\n         * converts the cubic to a quadtratic approximation by\n         * picking an appropriate quadratic control point\n         */\n        toQuadratic() {\n          return {\n            x: this.p0.x,\n            y: this.p0.y,\n            x1: this.p1.x,\n            y1: this.p1.y,\n            cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,\n            cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4,\n          };\n        }\n\n        /**\n         * @return {Number} the error\n         *\n         * calculates the magnitude of error of this curve's\n         * quadratic approximation.\n         */\n        quadError() {\n          return (\n            Vector.sub(\n              Vector.sub(this.p1, this.p0),\n              Vector.mult(Vector.sub(this.c1, this.c0), 3),\n            ).mag() / 2\n          );\n        }\n\n        /**\n         * @param {Number} t the value (0-1) at which to split\n         * @return {Cubic} the second part of the curve\n         *\n         * splits the cubic into two parts at a point 't' along the curve.\n         * this cubic keeps its start point and its end point becomes the\n         * point at 't'. the 'end half is returned.\n         */\n        split(t) {\n          const m1 = Vector.lerp(this.p0, this.c0, t);\n          const m2 = Vector.lerp(this.c0, this.c1, t);\n          const mm1 = Vector.lerp(m1, m2, t);\n\n          this.c1 = Vector.lerp(this.c1, this.p1, t);\n          this.c0 = Vector.lerp(m2, this.c1, t);\n          const pt = Vector.lerp(mm1, this.c0, t);\n          const part1 = new Cubic(this.p0, m1, mm1, pt);\n          this.p0 = pt;\n          return part1;\n        }\n\n        /**\n         * @return {Cubic[]} the non-inflecting pieces of this cubic\n         *\n         * returns an array containing 0, 1 or 2 cubics split resulting\n         * from splitting this cubic at its inflection points.\n         * this cubic is (potentially) altered and returned in the list.\n         */\n        splitInflections() {\n          const a = Vector.sub(this.c0, this.p0);\n          const b = Vector.sub(Vector.sub(this.c1, this.c0), a);\n          const c = Vector.sub(\n            Vector.sub(Vector.sub(this.p1, this.c1), a),\n            Vector.mult(b, 2),\n          );\n\n          const cubics = [];\n\n          // find the derivative coefficients\n          let A = b.x * c.y - b.y * c.x;\n          if (A !== 0) {\n            let B = a.x * c.y - a.y * c.x;\n            let C = a.x * b.y - a.y * b.x;\n            const disc = B * B - 4 * A * C;\n            if (disc >= 0) {\n              if (A < 0) {\n                A = -A;\n                B = -B;\n                C = -C;\n              }\n\n              const Q = Math.sqrt(disc);\n              const t0 = (-B - Q) / (2 * A); // the first inflection point\n              let t1 = (-B + Q) / (2 * A); // the second inflection point\n\n              // test if the first inflection point lies on the curve\n              if (t0 > 0 && t0 < 1) {\n                // split at the first inflection point\n                cubics.push(this.split(t0));\n                // scale t2 into the second part\n                t1 = 1 - (1 - t1) / (1 - t0);\n              }\n\n              // test if the second inflection point lies on the curve\n              if (t1 > 0 && t1 < 1) {\n                // split at the second inflection point\n                cubics.push(this.split(t1));\n              }\n            }\n          }\n\n          cubics.push(this);\n          return cubics;\n        }\n      }\n\n      /**\n       * @function cubicToQuadratics\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} cx0\n       * @param {Number} cy0\n       * @param {Number} cx1\n       * @param {Number} cy1\n       * @param {Number} x1\n       * @param {Number} y1\n       * @returns {Cubic[]} an array of cubics whose quadratic approximations\n       *                    closely match the civen cubic.\n       *\n       * converts a cubic curve to a list of quadratics.\n       */\n      function cubicToQuadratics(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\n        // create the Cubic object and split it at its inflections\n        const cubics = new Cubic(\n          new Vector(x0, y0),\n          new Vector(cx0, cy0),\n          new Vector(cx1, cy1),\n          new Vector(x1, y1),\n        ).splitInflections();\n\n        const qs = []; // the final list of quadratics\n        const precision = 30 / SQRT3;\n\n        // for each of the non-inflected pieces of the original cubic\n        for (let cubic of cubics) {\n          // the cubic is iteratively split in 3 pieces:\n          // the first piece is accumulated in 'qs', the result.\n          // the last piece is accumulated in 'tail', temporarily.\n          // the middle piece is repeatedly split again, while necessary.\n          const tail = [];\n\n          let t3;\n          for (;;) {\n            // calculate this cubic's precision\n            t3 = precision / cubic.quadError();\n            if (t3 >= 0.5 * 0.5 * 0.5) {\n              break; // not too bad, we're done\n            }\n\n            // find a split point based on the error\n            const t = Math.pow(t3, 1.0 / 3.0);\n            // split the cubic in 3\n            const start = cubic.split(t);\n            const middle = cubic.split(1 - t / (1 - t));\n\n            qs.push(start); // the first part\n            tail.push(cubic); // the last part\n            cubic = middle; // iterate on the middle piece\n          }\n\n          if (t3 < 1) {\n            // a little excess error, split the middle in two\n            qs.push(cubic.split(0.5));\n          }\n          // add the middle piece to the result\n          qs.push(cubic);\n\n          // finally add the tail, reversed, onto the result\n          Array.prototype.push.apply(qs, tail.reverse());\n        }\n\n        return qs;\n      }\n\n      /**\n       * @function pushLine\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       *\n       * add a straight line to the row/col grid of a glyph\n       */\n      function pushLine(x0, y0, x1, y1) {\n        const mx = (x0 + x1) / 2;\n        const my = (y0 + y1) / 2;\n        push([x0, x1], [y0, y1], { x: x0, y: y0, cx: mx, cy: my });\n      }\n\n      /**\n       * @function samePoint\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       * @return {Boolean} true if the two points are sufficiently close\n       *\n       * tests if two points are close enough to be considered the same\n       */\n      function samePoint(x0, y0, x1, y1) {\n        return Math.abs(x1 - x0) < 0.00001 && Math.abs(y1 - y0) < 0.00001;\n      }\n\n      let x0, y0, xs, ys;\n\n      for (const cmd of cmds) {\n        // scale the coordinates to the range 0-1\n        const x1 = (cmd.x - xMin) / gWidth;\n        const y1 = (cmd.y - yMin) / gHeight;\n\n        // don't bother if this point is the same as the last\n        if (samePoint(x0, y0, x1, y1)) continue;\n\n        switch (cmd.type) {\n          case \"M\": {\n            // move\n            xs = x1;\n            ys = y1;\n            break;\n          }\n          case \"L\": {\n            // line\n            pushLine(x0, y0, x1, y1);\n            break;\n          }\n          case \"Q\": {\n            // quadratic\n            const cx = (cmd.x1 - xMin) / gWidth;\n            const cy = (cmd.y1 - yMin) / gHeight;\n            push([x0, x1, cx], [y0, y1, cy], { x: x0, y: y0, cx, cy });\n            break;\n          }\n          case \"Z\": {\n            // end\n            if (!samePoint(x0, y0, xs, ys)) {\n              // add an extra line closing the loop, if necessary\n              pushLine(x0, y0, xs, ys);\n              strokes.push({ x: xs, y: ys });\n            } else {\n              strokes.push({ x: x0, y: y0 });\n            }\n            break;\n          }\n          case \"C\": {\n            // cubic\n            const cx1 = (cmd.x1 - xMin) / gWidth;\n            const cy1 = (cmd.y1 - yMin) / gHeight;\n            const cx2 = (cmd.x2 - xMin) / gWidth;\n            const cy2 = (cmd.y2 - yMin) / gHeight;\n            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);\n            for (let iq = 0; iq < qs.length; iq++) {\n              const q = qs[iq].toQuadratic();\n              push([q.x, q.x1, q.cx], [q.y, q.y1, q.cy], q);\n            }\n            break;\n          }\n          default:\n            throw new Error(`unknown command type: ${cmd.type}`);\n        }\n        x0 = x1;\n        y0 = y1;\n      }\n\n      // allocate space for the strokes\n      const strokeCount = strokes.length;\n      const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);\n      const strokeOffset = strokeImageInfo.index;\n\n      // fill the stroke image\n      for (let il = 0; il < strokeCount; ++il) {\n        const s = strokes[il];\n        setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));\n      }\n\n      /**\n       * @function layout\n       * @param {Number[][]} dim\n       * @param {ImageInfo[]} dimImageInfos\n       * @param {ImageInfo[]} cellImageInfos\n       * @return {Object}\n       *\n       * lays out the curves in a dimension (row or col) into two\n       * images, one for the indices of the curves themselves, and\n       * one containing the offset and length of those index spans.\n       */\n      function layout(dim, dimImageInfos, cellImageInfos) {\n        const dimLength = dim.length; // the number of slices in this dimension\n        const dimImageInfo = dimImageInfos.findImage(dimLength);\n        const dimOffset = dimImageInfo.index;\n        // calculate the total number of stroke indices in this dimension\n        let totalStrokes = 0;\n        for (let id = 0; id < dimLength; ++id) {\n          totalStrokes += dim[id].length;\n        }\n\n        // allocate space for the stroke indices\n        const cellImageInfo = cellImageInfos.findImage(totalStrokes);\n\n        // for each slice in the glyph\n        for (let i = 0; i < dimLength; ++i) {\n          const strokeIndices = dim[i];\n          const strokeCount = strokeIndices.length;\n          const cellLineIndex = cellImageInfo.index;\n\n          // write the offset and count into the glyph slice image\n          setPixel(\n            dimImageInfo,\n            cellLineIndex >> 7,\n            cellLineIndex & 0x7f,\n            strokeCount >> 7,\n            strokeCount & 0x7f,\n          );\n\n          // for each stroke index in that slice\n          for (let iil = 0; iil < strokeCount; ++iil) {\n            // write the stroke index into the slice's image\n            const strokeIndex = strokeIndices[iil] + strokeOffset;\n            setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 0x7f, 0, 0);\n          }\n        }\n\n        return {\n          cellImageInfo,\n          dimOffset,\n          dimImageInfo,\n        };\n      }\n\n      // initialize the info for this glyph\n      gi = this.glyphInfos[glyph.index] = {\n        glyph,\n        uGlyphRect: [xMin, yMin, xMax, yMax],\n        strokeImageInfo,\n        strokes,\n        colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),\n        rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos),\n      };\n      gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];\n      return gi;\n    }\n  }\n\n  RendererGL.prototype._renderText = function (line, x, y, maxY, minY) {\n    if (!this.states.textFont || typeof this.states.textFont === \"string\") {\n      console.log(\n        \"WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.\",\n      );\n      return;\n    }\n    if (y >= maxY || !this.states.fillColor) {\n      return; // don't render lines beyond our maxY position\n    }\n\n    if (!p5.Font.hasGlyphData(this.states.textFont)) {\n      console.log(\n        \"WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported\",\n      );\n      return;\n    }\n\n    this.push(); // fix to #803\n\n    // remember this state, so it can be restored later\n    const doStroke = this.states.strokeColor;\n    const drawMode = this.states.drawMode;\n\n    this.states.setValue(\"strokeColor\", null);\n    this.states.setValue(\"drawMode\", TEXTURE);\n\n    // get the cached FontInfo object\n    const { font } = this.states.textFont;\n    if (!font) {\n      throw new Error(\n        \"In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.\",\n      );\n    }\n    const axs = font._currentAxes(this);\n    let fontInfo = font._getFontInfo(axs);\n\n    // calculate the alignment and move/scale the view accordingly\n    // TODO: check this\n    const pos = { x, y }; // this.states.textFont._handleAlignment(this, line, x, y);\n    const fontSize = this.states.textSize;\n    const scale = fontSize / (font.data?.head?.unitsPerEm || 1000);\n    this.translate(pos.x, pos.y, 0);\n    this.scale(scale, scale, 1);\n\n    // initialize the font shader\n    const gl = this.GL;\n    const initializeShader = !this._defaultFontShader;\n    const sh = this._getFontShader();\n    sh.init();\n    sh.bindShader(); // first time around, bind the shader fully\n\n    if (initializeShader) {\n      // these are constants, really. just initialize them one-time.\n      sh.setUniform(\"uGridImageSize\", [gridImageWidth, gridImageHeight]);\n      sh.setUniform(\"uCellsImageSize\", [cellImageWidth, cellImageHeight]);\n      sh.setUniform(\"uStrokeImageSize\", [strokeImageWidth, strokeImageHeight]);\n      sh.setUniform(\"uGridSize\", [charGridWidth, charGridHeight]);\n    }\n\n    const curFillColor = this.states.fillSet\n      ? this.states.curFillColor\n      : [0, 0, 0, 255];\n\n    this._setGlobalUniforms(sh);\n    this._applyColorBlend(curFillColor);\n\n    let g = this.geometryBufferCache.getGeometryByID(\"glyph\");\n    if (!g) {\n      // create the geometry for rendering a quad\n      g = this._textGeom = new Geometry(\n        1,\n        1,\n        function () {\n          for (let i = 0; i <= 1; i++) {\n            for (let j = 0; j <= 1; j++) {\n              this.vertices.push(new Vector(j, i, 0));\n              this.uvs.push(j, i);\n            }\n          }\n        },\n        this,\n      );\n      g.gid = \"glyph\";\n      g.computeFaces().computeNormals();\n      this.geometryBufferCache.ensureCached(g);\n    }\n\n    // bind the shader buffers\n    for (const buff of this.buffers.text) {\n      buff._prepareBuffer(g, sh);\n    }\n    this._bindBuffer(\n      this.geometryBufferCache.cache.glyph.indexBuffer,\n      gl.ELEMENT_ARRAY_BUFFER,\n    );\n\n    // this will have to do for now...\n    sh.setUniform(\"uMaterialColor\", curFillColor);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\n    this.glyphDataCache = this.glyphDataCache || new Set();\n\n    try {\n      // fetch the glyphs in the line of text\n      const glyphs = font._positionGlyphs(line);\n\n      for (const glyph of glyphs) {\n        const gi = fontInfo.getGlyphInfo(glyph);\n        if (gi.uGlyphRect) {\n          const rowInfo = gi.rowInfo;\n          const colInfo = gi.colInfo;\n\n          // Bump the resources for this glyph to the end of the cache list by deleting and re-adding\n          const glyphResources = [\n            gi.strokeImageInfo.imageData,\n            rowInfo.cellImageInfo.imageData,\n            rowInfo.dimImageInfo.imageData,\n            colInfo.cellImageInfo.imageData,\n            colInfo.dimImageInfo.imageData\n          ];\n          for (const resource of glyphResources) {\n            this.glyphDataCache.delete(resource);\n            this.glyphDataCache.add(resource);\n          }\n\n          // If we have too many glyph textures, remove the least recently used\n          // ones from GPU memory. The data still exists on the CPU and will be\n          // re-uploaded if it gets actively used again.\n          while (this.glyphDataCache.size > this.maxCachedGlyphs()) {\n            const data = this.glyphDataCache.values().next().value;\n            this.glyphDataCache.delete(data);\n            const tex = this.textures.get(data);\n            if (tex) {\n              tex.remove();\n              this.textures.delete(data);\n            }\n          }\n\n          sh.setUniform(\"uSamplerStrokes\", gi.strokeImageInfo.imageData);\n          sh.setUniform(\"uSamplerRowStrokes\", rowInfo.cellImageInfo.imageData);\n          sh.setUniform(\"uSamplerRows\", rowInfo.dimImageInfo.imageData);\n          sh.setUniform(\"uSamplerColStrokes\", colInfo.cellImageInfo.imageData);\n          sh.setUniform(\"uSamplerCols\", colInfo.dimImageInfo.imageData);\n          sh.setUniform(\"uGridOffset\", gi.uGridOffset);\n          sh.setUniform(\"uGlyphRect\", gi.uGlyphRect);\n          sh.setUniform(\"uGlyphOffset\", glyph.x);\n\n          sh.bindTextures(); // afterwards, only textures need updating\n\n          // draw it\n          gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);\n        }\n      }\n    } finally {\n      // clean up\n      sh.unbindShader();\n\n      this.states.setValue(\"strokeColor\", doStroke);\n      this.states.setValue(\"drawMode\", drawMode);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n      this.pop();\n    }\n  };\n}\n\nexport { text as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}