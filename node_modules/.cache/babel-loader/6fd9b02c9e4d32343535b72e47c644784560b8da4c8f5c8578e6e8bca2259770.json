{"ast":null,"code":"import * as util from \"./util.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\nimport deltaE2000 from \"./deltaE/deltaE2000.js\";\nimport deltaEOK from \"./deltaE/deltaEOK.js\";\nimport inGamut from \"./inGamut.js\";\nimport to from \"./to.js\";\nimport get from \"./get.js\";\nimport oklab from \"./spaces/oklab.js\";\nimport set from \"./set.js\";\nimport clone from \"./clone.js\";\nimport getColor from \"./getColor.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\nimport { WHITES } from \"./adapt.js\";\n\n/**\n * Calculate the epsilon to 2 degrees smaller than the specified JND.\n * @param {Number} jnd - The target \"just noticeable difference\".\n * @returns {Number}\n */\nfunction calcEpsilon(jnd) {\n  // Calculate the epsilon to 2 degrees smaller than the specified JND.\n\n  const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));\n  // Limit to an arbitrary value to ensure value is never too small and causes infinite loops.\n  return Math.max(parseFloat(`1e${order - 2}`), 1e-6);\n}\nconst GMAPPRESET = {\n  \"hct\": {\n    method: \"hct.c\",\n    jnd: 2,\n    deltaEMethod: \"hct\",\n    blackWhiteClamp: {}\n  },\n  \"hct-tonal\": {\n    method: \"hct.c\",\n    jnd: 0,\n    deltaEMethod: \"hct\",\n    blackWhiteClamp: {\n      channel: \"hct.t\",\n      min: 0,\n      max: 100\n    }\n  }\n};\n\n/**\n * Force coordinates to be in gamut of a certain color space.\n * Mutates the color it is passed.\n * @param {Object|string} options object or spaceId string\n * @param {string} options.method - How to force into gamut.\n *        If \"clip\", coordinates are just clipped to their reference range.\n *        If \"css\", coordinates are reduced according to the CSS 4 Gamut Mapping Algorithm.\n *        If in the form [colorSpaceId].[coordName], that coordinate is reduced\n *        until the color is in gamut. Please note that this may produce nonsensical\n *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.\n * @param {ColorSpace|string} options.space - The space whose gamut we want to map to\n * @param {string} options.deltaEMethod - The delta E method to use while performing gamut mapping.\n *        If no method is specified, delta E 2000 is used.\n * @param {Number} options.jnd - The \"just noticeable difference\" to target.\n * @param {Object} options.blackWhiteClamp - Used to configure SDR black and clamping.\n *        \"channel\" indicates the \"space.channel\" to use for determining when to clamp.\n *        \"min\" indicates the lower limit for black clamping and \"max\" indicates the upper\n *        limit for white clamping.\n */\n\nexport default function toGamut(color, {\n  method = defaults.gamut_mapping,\n  space = undefined,\n  deltaEMethod = \"\",\n  jnd = 2,\n  blackWhiteClamp = {}\n} = {}) {\n  color = getColor(color);\n  if (util.isString(arguments[1])) {\n    space = arguments[1];\n  } else if (!space) {\n    space = color.space;\n  }\n  space = ColorSpace.get(space);\n\n  // 3 spaces:\n  // color.space: current color space\n  // space: space whose gamut we are mapping to\n  // mapSpace: space with the coord we're reducing\n\n  if (inGamut(color, space, {\n    epsilon: 0\n  })) {\n    return color;\n  }\n  let spaceColor;\n  if (method === \"css\") {\n    spaceColor = toGamutCSS(color, {\n      space\n    });\n  } else {\n    if (method !== \"clip\" && !inGamut(color, space)) {\n      if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {\n        ({\n          method,\n          jnd,\n          deltaEMethod,\n          blackWhiteClamp\n        } = GMAPPRESET[method]);\n      }\n\n      // Get the correct delta E method\n      let de = deltaE2000;\n      if (deltaEMethod !== \"\") {\n        for (let m in deltaEMethods) {\n          if (\"deltae\" + deltaEMethod.toLowerCase() === m.toLowerCase()) {\n            de = deltaEMethods[m];\n            break;\n          }\n        }\n      }\n      let clipped = toGamut(to(color, space), {\n        method: \"clip\",\n        space\n      });\n      if (de(color, clipped) > jnd) {\n        // Clamp to SDR white and black if required\n        if (Object.keys(blackWhiteClamp).length === 3) {\n          let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);\n          let channel = get(to(color, channelMeta.space), channelMeta.id);\n          if (util.isNone(channel)) {\n            channel = 0;\n          }\n          if (channel >= blackWhiteClamp.max) {\n            return to({\n              space: \"xyz-d65\",\n              coords: WHITES[\"D65\"]\n            }, color.space);\n          } else if (channel <= blackWhiteClamp.min) {\n            return to({\n              space: \"xyz-d65\",\n              coords: [0, 0, 0]\n            }, color.space);\n          }\n        }\n\n        // Reduce a coordinate of a certain color space until the color is in gamut\n        let coordMeta = ColorSpace.resolveCoord(method);\n        let mapSpace = coordMeta.space;\n        let coordId = coordMeta.id;\n        let mappedColor = to(color, mapSpace);\n        // If we were already in the mapped color space, we need to resolve undefined channels\n        mappedColor.coords.forEach((c, i) => {\n          if (util.isNone(c)) {\n            mappedColor.coords[i] = 0;\n          }\n        });\n        let bounds = coordMeta.range || coordMeta.refRange;\n        let min = bounds[0];\n        let ε = calcEpsilon(jnd);\n        let low = min;\n        let high = get(mappedColor, coordId);\n        while (high - low > ε) {\n          let clipped = clone(mappedColor);\n          clipped = toGamut(clipped, {\n            space,\n            method: \"clip\"\n          });\n          let deltaE = de(mappedColor, clipped);\n          if (deltaE - jnd < ε) {\n            low = get(mappedColor, coordId);\n          } else {\n            high = get(mappedColor, coordId);\n          }\n          set(mappedColor, coordId, (low + high) / 2);\n        }\n        spaceColor = to(mappedColor, space);\n      } else {\n        spaceColor = clipped;\n      }\n    } else {\n      spaceColor = to(color, space);\n    }\n    if (method === \"clip\" // Dumb coord clipping\n    // finish off smarter gamut mapping with clip to get rid of ε, see #17\n    || !inGamut(spaceColor, space, {\n      epsilon: 0\n    })) {\n      let bounds = Object.values(space.coords).map(c => c.range || []);\n      spaceColor.coords = spaceColor.coords.map((c, i) => {\n        let [min, max] = bounds[i];\n        if (min !== undefined) {\n          c = Math.max(min, c);\n        }\n        if (max !== undefined) {\n          c = Math.min(c, max);\n        }\n        return c;\n      });\n    }\n  }\n  if (space !== color.space) {\n    spaceColor = to(spaceColor, color.space);\n  }\n  color.coords = spaceColor.coords;\n  return color;\n}\ntoGamut.returns = \"color\";\n\n// The reference colors to be used if lightness is out of the range 0-1 in the\n// `Oklch` space. These are created in the `Oklab` space, as it is used by the\n// DeltaEOK calculation, so it is guaranteed to be imported.\nconst COLORS = {\n  WHITE: {\n    space: oklab,\n    coords: [1, 0, 0]\n  },\n  BLACK: {\n    space: oklab,\n    coords: [0, 0, 0]\n  }\n};\n\n/**\n * Given a color `origin`, returns a new color that is in gamut using\n * the CSS Gamut Mapping Algorithm. If `space` is specified, it will be in gamut\n * in `space`, and returned in `space`. Otherwise, it will be in gamut and\n * returned in the color space of `origin`.\n * @param {Object} origin\n * @param {Object} options\n * @param {ColorSpace|string} options.space\n * @returns {Color}\n */\nexport function toGamutCSS(origin, {\n  space\n} = {}) {\n  const JND = 0.02;\n  const ε = 0.0001;\n  origin = getColor(origin);\n  if (!space) {\n    space = origin.space;\n  }\n  space = ColorSpace.get(space);\n  const oklchSpace = ColorSpace.get(\"oklch\");\n  if (space.isUnbounded) {\n    return to(origin, space);\n  }\n  const origin_OKLCH = to(origin, oklchSpace);\n  let L = origin_OKLCH.coords[0];\n\n  // return media white or black, if lightness is out of range\n  if (L >= 1) {\n    const white = to(COLORS.WHITE, space);\n    white.alpha = origin.alpha;\n    return to(white, space);\n  }\n  if (L <= 0) {\n    const black = to(COLORS.BLACK, space);\n    black.alpha = origin.alpha;\n    return to(black, space);\n  }\n  if (inGamut(origin_OKLCH, space, {\n    epsilon: 0\n  })) {\n    return to(origin_OKLCH, space);\n  }\n  function clip(_color) {\n    const destColor = to(_color, space);\n    const spaceCoords = Object.values(space.coords);\n    destColor.coords = destColor.coords.map((coord, index) => {\n      if (\"range\" in spaceCoords[index]) {\n        const [min, max] = spaceCoords[index].range;\n        return util.clamp(min, coord, max);\n      }\n      return coord;\n    });\n    return destColor;\n  }\n  let min = 0;\n  let max = origin_OKLCH.coords[1];\n  let min_inGamut = true;\n  let current = clone(origin_OKLCH);\n  let clipped = clip(current);\n  let E = deltaEOK(clipped, current);\n  if (E < JND) {\n    return clipped;\n  }\n  while (max - min > ε) {\n    const chroma = (min + max) / 2;\n    current.coords[1] = chroma;\n    if (min_inGamut && inGamut(current, space, {\n      epsilon: 0\n    })) {\n      min = chroma;\n    } else {\n      clipped = clip(current);\n      E = deltaEOK(clipped, current);\n      if (E < JND) {\n        if (JND - E < ε) {\n          break;\n        } else {\n          min_inGamut = false;\n          min = chroma;\n        }\n      } else {\n        max = chroma;\n      }\n    }\n  }\n  return clipped;\n}","map":{"version":3,"names":["util","ColorSpace","defaults","deltaE2000","deltaEOK","inGamut","to","get","oklab","set","clone","getColor","deltaEMethods","WHITES","calcEpsilon","jnd","order","Math","floor","log10","abs","max","parseFloat","GMAPPRESET","method","deltaEMethod","blackWhiteClamp","channel","min","toGamut","color","gamut_mapping","space","undefined","isString","arguments","epsilon","spaceColor","toGamutCSS","Object","prototype","hasOwnProperty","call","de","m","toLowerCase","clipped","keys","length","channelMeta","resolveCoord","id","isNone","coords","coordMeta","mapSpace","coordId","mappedColor","forEach","c","i","bounds","range","refRange","ε","low","high","deltaE","values","map","returns","COLORS","WHITE","BLACK","origin","JND","oklchSpace","isUnbounded","origin_OKLCH","L","white","alpha","black","clip","_color","destColor","spaceCoords","coord","index","clamp","min_inGamut","current","E","chroma"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/toGamut.js"],"sourcesContent":["import * as util from \"./util.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\nimport deltaE2000 from \"./deltaE/deltaE2000.js\";\nimport deltaEOK from \"./deltaE/deltaEOK.js\";\nimport inGamut from \"./inGamut.js\";\nimport to from \"./to.js\";\nimport get from \"./get.js\";\nimport oklab from \"./spaces/oklab.js\";\nimport set from \"./set.js\";\nimport clone from \"./clone.js\";\nimport getColor from \"./getColor.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\nimport {WHITES} from \"./adapt.js\";\n\n/**\n * Calculate the epsilon to 2 degrees smaller than the specified JND.\n * @param {Number} jnd - The target \"just noticeable difference\".\n * @returns {Number}\n */\nfunction calcEpsilon (jnd) {\n\t// Calculate the epsilon to 2 degrees smaller than the specified JND.\n\n\tconst order = (!jnd) ? 0 : Math.floor(Math.log10(Math.abs(jnd)));\n\t// Limit to an arbitrary value to ensure value is never too small and causes infinite loops.\n\treturn Math.max(parseFloat(`1e${order - 2}`), 1e-6);\n}\n\nconst GMAPPRESET = {\n\t\"hct\": {\n\t\tmethod: \"hct.c\",\n\t\tjnd: 2,\n\t\tdeltaEMethod: \"hct\",\n\t\tblackWhiteClamp: {},\n\t},\n\t\"hct-tonal\": {\n\t\tmethod: \"hct.c\",\n\t\tjnd: 0,\n\t\tdeltaEMethod: \"hct\",\n\t\tblackWhiteClamp: { channel: \"hct.t\", min: 0, max: 100 },\n\t},\n};\n\n/**\n * Force coordinates to be in gamut of a certain color space.\n * Mutates the color it is passed.\n * @param {Object|string} options object or spaceId string\n * @param {string} options.method - How to force into gamut.\n *        If \"clip\", coordinates are just clipped to their reference range.\n *        If \"css\", coordinates are reduced according to the CSS 4 Gamut Mapping Algorithm.\n *        If in the form [colorSpaceId].[coordName], that coordinate is reduced\n *        until the color is in gamut. Please note that this may produce nonsensical\n *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.\n * @param {ColorSpace|string} options.space - The space whose gamut we want to map to\n * @param {string} options.deltaEMethod - The delta E method to use while performing gamut mapping.\n *        If no method is specified, delta E 2000 is used.\n * @param {Number} options.jnd - The \"just noticeable difference\" to target.\n * @param {Object} options.blackWhiteClamp - Used to configure SDR black and clamping.\n *        \"channel\" indicates the \"space.channel\" to use for determining when to clamp.\n *        \"min\" indicates the lower limit for black clamping and \"max\" indicates the upper\n *        limit for white clamping.\n */\n\nexport default function toGamut (\n\tcolor,\n\t{\n\t\tmethod = defaults.gamut_mapping,\n\t\tspace = undefined,\n\t\tdeltaEMethod = \"\",\n\t\tjnd = 2,\n\t\tblackWhiteClamp = {},\n\t} = {},\n) {\n\tcolor = getColor(color);\n\n\tif (util.isString(arguments[1])) {\n\t\tspace = arguments[1];\n\t}\n\telse if (!space) {\n\t\tspace = color.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\n\t// 3 spaces:\n\t// color.space: current color space\n\t// space: space whose gamut we are mapping to\n\t// mapSpace: space with the coord we're reducing\n\n\tif (inGamut(color, space, { epsilon: 0 })) {\n\t\treturn color;\n\t}\n\n\tlet spaceColor;\n\tif (method === \"css\") {\n\t\tspaceColor = toGamutCSS(color, { space });\n\t}\n\telse {\n\t\tif (method !== \"clip\" && !inGamut(color, space)) {\n\n\t\t\tif (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {\n\t\t\t\t({method, jnd, deltaEMethod, blackWhiteClamp} = GMAPPRESET[method]);\n\t\t\t}\n\n\t\t\t// Get the correct delta E method\n\t\t\tlet de = deltaE2000;\n\t\t\tif (deltaEMethod !== \"\") {\n\t\t\t\tfor (let m in deltaEMethods) {\n\t\t\t\t\tif (\"deltae\" + deltaEMethod.toLowerCase() === m.toLowerCase()) {\n\t\t\t\t\t\tde = deltaEMethods[m];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet clipped = toGamut(to(color, space), { method: \"clip\", space });\n\t\t\tif (de(color, clipped) > jnd) {\n\n\t\t\t\t// Clamp to SDR white and black if required\n\t\t\t\tif (Object.keys(blackWhiteClamp).length === 3) {\n\t\t\t\t\tlet channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);\n\t\t\t\t\tlet channel = get(to(color, channelMeta.space), channelMeta.id);\n\t\t\t\t\tif (util.isNone(channel)) {\n\t\t\t\t\t\tchannel = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (channel >= blackWhiteClamp.max) {\n\t\t\t\t\t\treturn to({ space: \"xyz-d65\", coords: WHITES[\"D65\"] }, color.space);\n\t\t\t\t\t}\n\t\t\t\t\telse if (channel <= blackWhiteClamp.min) {\n\t\t\t\t\t\treturn to({ space: \"xyz-d65\", coords: [0, 0, 0] }, color.space);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Reduce a coordinate of a certain color space until the color is in gamut\n\t\t\t\tlet coordMeta = ColorSpace.resolveCoord(method);\n\t\t\t\tlet mapSpace = coordMeta.space;\n\t\t\t\tlet coordId = coordMeta.id;\n\n\t\t\t\tlet mappedColor = to(color, mapSpace);\n\t\t\t\t// If we were already in the mapped color space, we need to resolve undefined channels\n\t\t\t\tmappedColor.coords.forEach((c, i) => {\n\t\t\t\t\tif (util.isNone(c)) {\n\t\t\t\t\t\tmappedColor.coords[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet bounds = coordMeta.range || coordMeta.refRange;\n\t\t\t\tlet min = bounds[0];\n\t\t\t\tlet ε = calcEpsilon(jnd);\n\t\t\t\tlet low = min;\n\t\t\t\tlet high = get(mappedColor, coordId);\n\n\t\t\t\twhile (high - low > ε) {\n\t\t\t\t\tlet clipped = clone(mappedColor);\n\t\t\t\t\tclipped = toGamut(clipped, { space, method: \"clip\" });\n\t\t\t\t\tlet deltaE = de(mappedColor, clipped);\n\n\t\t\t\t\tif (deltaE - jnd < ε) {\n\t\t\t\t\t\tlow = get(mappedColor, coordId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thigh = get(mappedColor, coordId);\n\t\t\t\t\t}\n\n\t\t\t\t\tset(mappedColor, coordId, (low + high) / 2);\n\t\t\t\t}\n\n\t\t\t\tspaceColor = to(mappedColor, space);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tspaceColor = clipped;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tspaceColor = to(color, space);\n\t\t}\n\n\t\tif (method === \"clip\" // Dumb coord clipping\n\t\t\t// finish off smarter gamut mapping with clip to get rid of ε, see #17\n\t\t\t|| !inGamut(spaceColor, space, { epsilon: 0 })\n\t\t) {\n\t\t\tlet bounds = Object.values(space.coords).map(c => c.range || []);\n\n\t\t\tspaceColor.coords = spaceColor.coords.map((c, i) => {\n\t\t\t\tlet [min, max] = bounds[i];\n\n\t\t\t\tif (min !== undefined) {\n\t\t\t\t\tc = Math.max(min, c);\n\t\t\t\t}\n\n\t\t\t\tif (max !== undefined) {\n\t\t\t\t\tc = Math.min(c, max);\n\t\t\t\t}\n\n\t\t\t\treturn c;\n\t\t\t});\n\t\t}\n\t}\n\n\tif (space !== color.space) {\n\t\tspaceColor = to(spaceColor, color.space);\n\t}\n\n\tcolor.coords = spaceColor.coords;\n\treturn color;\n}\n\ntoGamut.returns = \"color\";\n\n// The reference colors to be used if lightness is out of the range 0-1 in the\n// `Oklch` space. These are created in the `Oklab` space, as it is used by the\n// DeltaEOK calculation, so it is guaranteed to be imported.\nconst COLORS = {\n\tWHITE: { space: oklab, coords: [1, 0, 0] },\n\tBLACK: { space: oklab, coords: [0, 0, 0] },\n};\n\n/**\n * Given a color `origin`, returns a new color that is in gamut using\n * the CSS Gamut Mapping Algorithm. If `space` is specified, it will be in gamut\n * in `space`, and returned in `space`. Otherwise, it will be in gamut and\n * returned in the color space of `origin`.\n * @param {Object} origin\n * @param {Object} options\n * @param {ColorSpace|string} options.space\n * @returns {Color}\n */\nexport function toGamutCSS (origin, {space} = {}) {\n\tconst JND = 0.02;\n\tconst ε = 0.0001;\n\n\torigin = getColor(origin);\n\n\tif (!space) {\n\t\tspace = origin.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\tconst oklchSpace = ColorSpace.get(\"oklch\");\n\n\tif (space.isUnbounded) {\n\t\treturn to(origin, space);\n\t}\n\n\tconst origin_OKLCH = to(origin, oklchSpace);\n\tlet L = origin_OKLCH.coords[0];\n\n\t// return media white or black, if lightness is out of range\n\tif (L >= 1) {\n\t\tconst white = to(COLORS.WHITE, space);\n\t\twhite.alpha = origin.alpha;\n\t\treturn to(white, space);\n\t}\n\tif (L <= 0) {\n\t\tconst black = to(COLORS.BLACK, space);\n\t\tblack.alpha = origin.alpha;\n\t\treturn to(black, space);\n\t}\n\n\tif (inGamut(origin_OKLCH, space, {epsilon: 0})) {\n\t\treturn to(origin_OKLCH, space);\n\t}\n\n\tfunction clip (_color) {\n\t\tconst destColor = to(_color, space);\n\t\tconst spaceCoords = Object.values(space.coords);\n\t\tdestColor.coords = destColor.coords.map((coord, index) => {\n\t\t\tif (\"range\" in spaceCoords[index]) {\n\t\t\t\tconst [min, max] =  spaceCoords[index].range;\n\t\t\t\treturn util.clamp(min, coord, max);\n\t\t\t}\n\t\t\treturn coord;\n\t\t});\n\t\treturn destColor;\n\t}\n\tlet min = 0;\n\tlet max = origin_OKLCH.coords[1];\n\tlet min_inGamut = true;\n\tlet current = clone(origin_OKLCH);\n\tlet clipped = clip(current);\n\n\tlet E = deltaEOK(clipped, current);\n\tif (E < JND) {\n\t\treturn clipped;\n\t}\n\n\twhile ((max - min) > ε) {\n\t\tconst chroma = (min + max) / 2;\n\t\tcurrent.coords[1] = chroma;\n\t\tif (min_inGamut && inGamut(current, space, {epsilon: 0})) {\n\t\t\tmin = chroma;\n\t\t}\n\t\telse {\n\t\t\tclipped = clip(current);\n\t\t\tE = deltaEOK(clipped, current);\n\t\t\tif (E < JND) {\n\t\t\t\tif ((JND - E < ε)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmin_inGamut = false;\n\t\t\t\t\tmin = chroma;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax = chroma;\n\t\t\t}\n\t\t}\n\t}\n\treturn clipped;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}