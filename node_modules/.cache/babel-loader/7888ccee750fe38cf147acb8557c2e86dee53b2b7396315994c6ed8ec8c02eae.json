{"ast":null,"code":"import { C as Color } from '../creating_reading-Cr8L2Jnm.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { I as INCLUDE, m as PATH, E as EMPTY_PATH, O as OPEN, n as CLOSE, o as POINTS, L as LINES, p as TRIANGLES, Q as QUADS, q as TRIANGLE_FAN, r as TRIANGLE_STRIP, s as QUAD_STRIP, t as EXCLUDE, J as JOIN } from '../constants-BRcElHU3.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\n\n/**\n * @module Shape\n * @submodule Custom Shapes\n * @for p5\n * @requires core\n * @requires constants\n */\n\n// ---- UTILITY FUNCTIONS ----\nfunction polylineLength(vertices) {\n  let length = 0;\n  for (let i = 1; i < vertices.length; i++) {\n    length += vertices[i - 1].position.dist(vertices[i].position);\n  }\n  return length;\n}\n\n// ---- GENERAL BUILDING BLOCKS ----\n\nclass Vertex {\n  constructor(properties) {\n    for (const [key, value] of Object.entries(properties)) {\n      this[key] = value;\n    }\n  }\n  /*\n  get array() {\n    // convert to 1D array\n    // call `toArray()` if value is an object with a toArray() method\n    // handle primitive values separately\n    // maybe handle object literals too, with Object.values()?\n    // probably donâ€™t need anything else for now?\n  }\n  */\n  // TODO: make sure name of array conversion method is\n  // consistent with any modifications to the names of corresponding\n  // properties of p5.Vector and p5.Color\n}\nclass ShapePrimitive {\n  vertices;\n  _shape = null;\n  _primitivesIndex = null;\n  _contoursIndex = null;\n  isClosing = false;\n  constructor(...vertices) {\n    if (this.constructor === ShapePrimitive) {\n      throw new Error('ShapePrimitive is an abstract class: it cannot be instantiated.');\n    }\n    if (vertices.length > 0) {\n      this.vertices = vertices;\n    } else {\n      throw new Error('At least one vertex must be passed to the constructor.');\n    }\n  }\n  get vertexCount() {\n    return this.vertices.length;\n  }\n  get vertexCapacity() {\n    throw new Error('Getter vertexCapacity must be implemented.');\n  }\n  get _firstInterpolatedVertex() {\n    return this.startVertex();\n  }\n  get canOverrideAnchor() {\n    return false;\n  }\n  accept(visitor) {\n    throw new Error('Method accept() must be implemented.');\n  }\n  addToShape(shape) {\n    /*\n    TODO:\n    Refactor?\n    Test this method once more primitives are implemented.\n    Test segments separately (Segment adds an extra step to this method).\n    */\n    let lastContour = shape.at(-1);\n    if (lastContour.primitives.length === 0) {\n      lastContour.primitives.push(this);\n    } else {\n      // last primitive in shape\n      let lastPrimitive = shape.at(-1, -1);\n      let hasSameType = lastPrimitive instanceof this.constructor;\n      let spareCapacity = lastPrimitive.vertexCapacity - lastPrimitive.vertexCount;\n\n      // this primitive\n      let pushableVertices;\n      let remainingVertices;\n      if (hasSameType && spareCapacity > 0) {\n        pushableVertices = this.vertices.splice(0, spareCapacity);\n        remainingVertices = this.vertices;\n        lastPrimitive.vertices.push(...pushableVertices);\n        if (remainingVertices.length > 0) {\n          lastContour.primitives.push(this);\n        }\n      } else {\n        lastContour.primitives.push(this);\n      }\n    }\n\n    // if primitive itself was added\n    // (i.e. its individual vertices weren't all added to an existing primitive)\n    // give it a reference to the shape and store its location within the shape\n    let addedToShape = this.vertices.length > 0;\n    if (addedToShape) {\n      let lastContour = shape.at(-1);\n      this._primitivesIndex = lastContour.primitives.length - 1;\n      this._contoursIndex = shape.contours.length - 1;\n      this._shape = shape;\n    }\n    return shape.at(-1, -1);\n  }\n  get _nextPrimitive() {\n    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex + 1) : null;\n  }\n  get _belongsToShape() {\n    return this._shape !== null;\n  }\n  handlesClose() {\n    return false;\n  }\n  close(vertex) {\n    throw new Error('Unimplemented!');\n  }\n}\nclass Contour {\n  #kind;\n  primitives;\n  constructor(kind = PATH) {\n    this.#kind = kind;\n    this.primitives = [];\n  }\n  get kind() {\n    const isEmpty = this.primitives.length === 0;\n    const isPath = this.#kind === PATH;\n    return isEmpty && isPath ? EMPTY_PATH : this.#kind;\n  }\n  accept(visitor) {\n    for (const primitive of this.primitives) {\n      primitive.accept(visitor);\n    }\n  }\n}\n\n// ---- PATH PRIMITIVES ----\n\nclass Anchor extends ShapePrimitive {\n  #vertexCapacity = 1;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitAnchor(this);\n  }\n  getEndVertex() {\n    return this.vertices[0];\n  }\n}\n\n// abstract class\nclass Segment extends ShapePrimitive {\n  constructor(...vertices) {\n    super(...vertices);\n    if (this.constructor === Segment) {\n      throw new Error('Segment is an abstract class: it cannot be instantiated.');\n    }\n  }\n\n  // segments in a shape always have a predecessor\n  // (either an anchor or another segment)\n  get _previousPrimitive() {\n    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex - 1) : null;\n  }\n  getStartVertex() {\n    return this._previousPrimitive.getEndVertex();\n  }\n  getEndVertex() {\n    return this.vertices.at(-1);\n  }\n}\nclass LineSegment extends Segment {\n  #vertexCapacity = 1;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitLineSegment(this);\n  }\n}\nclass BezierSegment extends Segment {\n  #order;\n  #vertexCapacity;\n  constructor(order, ...vertices) {\n    super(...vertices);\n\n    // Order m may sometimes be passed as an array [m], since arrays\n    // may be used elsewhere to store order of\n    // Bezier curves and surfaces in a common format\n\n    let numericalOrder = Array.isArray(order) ? order[0] : order;\n    this.#order = numericalOrder;\n    this.#vertexCapacity = numericalOrder;\n  }\n  get order() {\n    return this.#order;\n  }\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  #_hullLength;\n  hullLength() {\n    if (this.#_hullLength === undefined) {\n      this.#_hullLength = polylineLength([this.getStartVertex(), ...this.vertices]);\n    }\n    return this.#_hullLength;\n  }\n  accept(visitor) {\n    visitor.visitBezierSegment(this);\n  }\n}\n\n/*\nTo-do: Consider type and end modes -- see #6766\nmay want to use separate classes, but maybe not\n\nFor now, the implementation overrides\nsuper.getEndVertex() in order to preserve current p5\nendpoint behavior, but we're considering defaulting\nto interpolated endpoints (a breaking change)\n*/\nclass SplineSegment extends Segment {\n  #vertexCapacity = Infinity;\n  _splineProperties = {\n    ends: INCLUDE,\n    tightness: 0\n  };\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitSplineSegment(this);\n  }\n  get _comesAfterSegment() {\n    return this._previousPrimitive instanceof Segment;\n  }\n  get canOverrideAnchor() {\n    return this._splineProperties.ends === EXCLUDE;\n  }\n\n  // assuming for now that the first interpolated vertex is always\n  // the second vertex passed to splineVertex()\n  // if this spline segment doesn't follow another segment,\n  // the first vertex is in an anchor\n  get _firstInterpolatedVertex() {\n    if (this._splineProperties.ends === EXCLUDE) {\n      return this._comesAfterSegment ? this.vertices[1] : this.vertices[0];\n    } else {\n      return this.getStartVertex();\n    }\n  }\n  get _chainedToSegment() {\n    if (this._belongsToShape && this._comesAfterSegment) {\n      let interpolatedStartPosition = this._firstInterpolatedVertex.position;\n      let predecessorEndPosition = this.getStartVertex().position;\n      return predecessorEndPosition.equals(interpolatedStartPosition);\n    } else {\n      return false;\n    }\n  }\n\n  // extend addToShape() with a warning in case second vertex\n  // doesn't line up with end of last segment\n  addToShape(shape) {\n    const added = super.addToShape(shape);\n    this._splineProperties.ends = shape._splineProperties.ends;\n    this._splineProperties.tightness = shape._splineProperties.tightness;\n    if (this._splineProperties.ends !== EXCLUDE) return added;\n    let verticesPushed = !this._belongsToShape;\n    let lastPrimitive = shape.at(-1, -1);\n    let message = (array1, array2) => `Spline does not start where previous path segment ends:\n      second spline vertex at (${array1})\n      expected to be at (${array2}).`;\n    if (verticesPushed &&\n    // Only check once the first interpolated vertex has been added\n    lastPrimitive.vertices.length === 2 && lastPrimitive._comesAfterSegment && !lastPrimitive._chainedToSegment) {\n      let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;\n      let predecessorEnd = lastPrimitive.getStartVertex().position;\n      console.warn(message(interpolatedStart.array(), predecessorEnd.array()));\n    }\n\n    // Note: Could add a warning in an else-if case for when this spline segment\n    // is added directly to the shape instead of pushing its vertices to\n    // an existing spline segment. However, if we assume addToShape() is called by\n    // splineVertex(), it'd add a new spline segment with only one vertex in that case,\n    // and the check wouldn't be needed yet.\n\n    // TODO: Consider case where positions match but other vertex properties don't.\n    return added;\n  }\n\n  // override method on base class\n  getEndVertex() {\n    if (this._splineProperties.ends === INCLUDE) {\n      return super.getEndVertex();\n    } else if (this._splineProperties.ends === EXCLUDE) {\n      return this.vertices.at(-2);\n    } else {\n      return this.getStartVertex();\n    }\n  }\n  getControlPoints() {\n    let points = [];\n    if (this._comesAfterSegment) {\n      points.push(this.getStartVertex());\n    }\n    points.push(this.getStartVertex());\n    for (const vertex of this.vertices) {\n      points.push(vertex);\n    }\n    const prevVertex = this.getStartVertex();\n    if (this._splineProperties.ends === INCLUDE) {\n      points.unshift(prevVertex);\n      points.push(this.vertices.at(-1));\n    } else if (this._splineProperties.ends === JOIN) {\n      points.unshift(this.vertices.at(-1));\n      points.push(prevVertex, this.vertices.at(0));\n    }\n    return points;\n  }\n  handlesClose() {\n    if (!this._belongsToShape) return false;\n\n    // Only handle closing if the spline is the only thing in its contour after\n    // the anchor\n    const contour = this._shape.at(this._contoursIndex);\n    return contour.primitives.length === 2 && this._primitivesIndex === 1;\n  }\n  close() {\n    this._splineProperties.ends = JOIN;\n  }\n}\n\n// ---- ISOLATED PRIMITIVES ----\n\nclass Point extends ShapePrimitive {\n  #vertexCapacity = 1;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitPoint(this);\n  }\n}\nclass Line extends ShapePrimitive {\n  #vertexCapacity = 2;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitLine(this);\n  }\n}\nclass Triangle extends ShapePrimitive {\n  #vertexCapacity = 3;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitTriangle(this);\n  }\n}\nclass Quad extends ShapePrimitive {\n  #vertexCapacity = 4;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitQuad(this);\n  }\n}\n\n// ---- TESSELLATION PRIMITIVES ----\n\nclass TriangleFan extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitTriangleFan(this);\n  }\n}\nclass TriangleStrip extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitTriangleStrip(this);\n  }\n}\nclass QuadStrip extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n  accept(visitor) {\n    visitor.visitQuadStrip(this);\n  }\n}\n\n// ---- PRIMITIVE SHAPE CREATORS ----\n\nclass PrimitiveShapeCreators {\n  // TODO: make creators private?\n  // That'd probably be better, but for now, it may be convenient to use\n  // native Map properties like size, e.g. for testing, and it's simpler to\n  // not have to wrap all the properties that might be useful\n  creators;\n  constructor() {\n    let creators = new Map();\n\n    /* TODO: REFACTOR BASED ON THE CODE BELOW,\n       ONCE CONSTANTS ARE IMPLEMENTED AS SYMBOLS\n     // Store Symbols as strings for use in Map keys\n    const EMPTY_PATH = constants.EMPTY_PATH.description;\n    const PATH = constants.PATH.description;\n    //etc.\n     creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    // etc.\n     get(vertexKind, shapeKind) {\n      const key = `${vertexKind}-${shapeKind.description}`;\n      return this.creators.get(key);\n    }\n    // etc.\n    */\n\n    // vertex\n    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    creators.set(`vertex-${PATH}`, (...vertices) => new LineSegment(...vertices));\n    creators.set(`vertex-${POINTS}`, (...vertices) => new Point(...vertices));\n    creators.set(`vertex-${LINES}`, (...vertices) => new Line(...vertices));\n    creators.set(`vertex-${TRIANGLES}`, (...vertices) => new Triangle(...vertices));\n    creators.set(`vertex-${QUADS}`, (...vertices) => new Quad(...vertices));\n    creators.set(`vertex-${TRIANGLE_FAN}`, (...vertices) => new TriangleFan(...vertices));\n    creators.set(`vertex-${TRIANGLE_STRIP}`, (...vertices) => new TriangleStrip(...vertices));\n    creators.set(`vertex-${QUAD_STRIP}`, (...vertices) => new QuadStrip(...vertices));\n\n    // bezierVertex (constructors all take order and vertices so they can be called in a uniform way)\n    creators.set(`bezierVertex-${EMPTY_PATH}`, (order, ...vertices) => new Anchor(...vertices));\n    creators.set(`bezierVertex-${PATH}`, (order, ...vertices) => new BezierSegment(order, ...vertices));\n\n    // splineVertex\n    creators.set(`splineVertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    creators.set(`splineVertex-${PATH}`, (...vertices) => new SplineSegment(...vertices));\n    this.creators = creators;\n  }\n  get(vertexKind, shapeKind) {\n    const key = `${vertexKind}-${shapeKind}`;\n    return this.creators.get(key);\n  }\n  set(vertexKind, shapeKind, creator) {\n    const key = `${vertexKind}-${shapeKind}`;\n    this.creators.set(key, creator);\n  }\n  clear() {\n    this.creators.clear();\n  }\n}\n\n// ---- SHAPE ----\n\n/* Note: It's assumed that Shape instances are always built through\n * their beginShape()/endShape() methods. For example, this ensures\n * that a segment is never the first primitive in a contour (paths\n * always start with an anchor), which simplifies code elsewhere.\n */\nclass Shape {\n  #vertexProperties;\n  #initialVertexProperties;\n  #primitiveShapeCreators;\n  #bezierOrder = 3;\n  kind = null;\n  contours = [];\n  _splineProperties = {\n    tightness: 0,\n    ends: INCLUDE\n  };\n  userVertexProperties = null;\n  constructor(vertexProperties, primitiveShapeCreators = new PrimitiveShapeCreators()) {\n    this.#initialVertexProperties = vertexProperties;\n    this.#vertexProperties = vertexProperties;\n    this.#primitiveShapeCreators = primitiveShapeCreators;\n    for (const key in this.#vertexProperties) {\n      if (key !== 'position' && key !== 'textureCoordinates') {\n        this[key] = function (value) {\n          this.#vertexProperties[key] = value;\n        };\n      }\n    }\n  }\n  serializeToArray(val) {\n    if (val === null || val === undefined) {\n      return [];\n    }\n    if (val instanceof Number) {\n      return [val];\n    } else if (val instanceof Array) {\n      return val;\n    } else if (val.array instanceof Function) {\n      return val.array();\n    } else {\n      throw new Error(`Can't convert ${val} to array!`);\n    }\n  }\n  vertexToArray(vertex) {\n    const array = [];\n    for (const key in this.#vertexProperties) {\n      if (this.userVertexProperties && key in this.userVertexProperties) continue;\n      const val = vertex[key];\n      array.push(...this.serializeToArray(val));\n    }\n    for (const key in this.userVertexProperties) {\n      if (key in vertex) {\n        array.push(...this.serializeToArray(vertex[key]));\n      } else {\n        array.push(...new Array(this.userVertexProperties[key]).fill(0));\n      }\n    }\n    return array;\n  }\n  hydrateValue(queue, original) {\n    if (original === null) {\n      return null;\n    } else if (original instanceof Number) {\n      return queue.shift();\n    } else if (original instanceof Array) {\n      const array = [];\n      for (let i = 0; i < original.length; i++) {\n        array.push(queue.shift());\n      }\n      return array;\n    } else if (original instanceof Vector) {\n      return new Vector(queue.shift(), queue.shift(), queue.shift());\n    } else if (original instanceof Color) {\n      // NOTE: Not sure what intention here is, `Color` constructor signature\n      // has changed so needed to be reviewed\n      const array = [queue.shift(), queue.shift(), queue.shift(), queue.shift()];\n      return new Color(array);\n    }\n  }\n  arrayToVertex(array) {\n    const vertex = {};\n    const queue = [...array];\n    for (const key in this.#vertexProperties) {\n      if (this.userVertexProperties && key in this.userVertexProperties) continue;\n      const original = this.#vertexProperties[key];\n      vertex[key] = this.hydrateValue(queue, original);\n    }\n    for (const key in this.userVertexProperties) {\n      const original = this.#vertexProperties[key];\n      vertex[key] = this.hydrateValue(queue, original);\n    }\n    return vertex;\n  }\n  arrayScale(array, scale) {\n    return array.map(v => v * scale);\n  }\n  arraySum(first, ...rest) {\n    return first.map((v, i) => {\n      let result = v;\n      for (let j = 0; j < rest.length; j++) {\n        result += rest[j][i];\n      }\n      return result;\n    });\n  }\n  arrayMinus(a, b) {\n    return a.map((v, i) => v - b[i]);\n  }\n  evaluateCubicBezier([a, b, c, d], t) {\n    return this.arraySum(this.arrayScale(a, Math.pow(1 - t, 3)), this.arrayScale(b, 3 * Math.pow(1 - t, 2) * t), this.arrayScale(c, 3 * (1 - t) * Math.pow(t, 2)), this.arrayScale(d, Math.pow(t, 3)));\n  }\n  evaluateQuadraticBezier([a, b, c], t) {\n    return this.arraySum(this.arrayScale(a, Math.pow(1 - t, 2)), this.arrayScale(b, 2 * (1 - t) * t), this.arrayScale(c, t * t));\n  }\n\n  /*\n  catmullRomToBezier(vertices, tightness)\n   Abbreviated description:\n  Converts a Catmull-Rom spline to a sequence of Bezier curveTo points.\n   Parameters:\n  vertices -> Array [v0, v1, v2, v3, ...] of at least four vertices\n  tightness -> Number affecting shape of curve\n   Returns:\n  array of Bezier curveTo control points, each represented as [c1, c2, c3][]\n   TODO:\n  1. It seems p5 contains code for converting from Catmull-Rom to Bezier in at least two places:\n   catmullRomToBezier() is based on code in the legacy endShape() function:\n  https://github.com/processing/p5.js/blob/1b66f097761d3c2057c0cec4349247d6125f93ca/src/core/p5.Renderer2D.js#L859C1-L886C1\n   A different conversion can be found elsewhere in p5:\n  https://github.com/processing/p5.js/blob/17304ce9e9ef3f967bd828102a51b62a2d39d4f4/src/typography/p5.Font.js#L1179\n   A more careful review and comparison of both implementations would be helpful. They're different. I put\n  catmullRomToBezier() together quickly without checking the math/algorithm, when I made the proof of concept\n  for the refactor.\n   2. It may be possible to replace the code in p5.Font.js with the code here, to reduce duplication.\n  */\n  catmullRomToBezier(vertices, tightness) {\n    let s = 1 - tightness;\n    let bezArrays = [];\n    for (let i = 0; i + 3 < vertices.length; i++) {\n      const [a, b, c, d] = vertices.slice(i, i + 4);\n      const bezB = this.arraySum(b, this.arrayScale(this.arrayMinus(c, a), s / 6));\n      const bezC = this.arraySum(c, this.arrayScale(this.arrayMinus(b, d), s / 6));\n      const bezD = c;\n      bezArrays.push([bezB, bezC, bezD]);\n    }\n    return bezArrays;\n  }\n\n  // TODO for at() method:\n\n  // RENAME?\n  // -at() indicates it works like Array.prototype.at(), e.g. with negative indices\n  // -get() may work better if we want to add a corresponding set() method\n  // -a set() method could maybe check for problematic usage (e.g. inserting a Triangle into a PATH)\n  // -renaming or removing would necessitate changes at call sites (it's already in use)\n\n  // REFACTOR?\n\n  // TEST\n  at(contoursIndex, primitivesIndex, verticesIndex) {\n    let contour;\n    let primitive;\n    contour = this.contours.at(contoursIndex);\n    switch (arguments.length) {\n      case 1:\n        return contour;\n      case 2:\n        return contour.primitives.at(primitivesIndex);\n      case 3:\n        primitive = contour.primitives.at(primitivesIndex);\n        return primitive.vertices.at(verticesIndex);\n    }\n  }\n\n  // maybe call this clear() for consistency with PrimitiveShapeCreators.clear()?\n  // note: p5.Geometry has a reset() method, but also clearColors()\n  // looks like reset() isn't in the public reference, so maybe we can switch\n  // everything to clear()? Not sure if reset/clear is used in other classes,\n  // but it'd be good if geometries and shapes are consistent\n  reset() {\n    this.#vertexProperties = {\n      ...this.#initialVertexProperties\n    };\n    this.kind = null;\n    this.contours = [];\n    this.userVertexProperties = null;\n  }\n  vertexProperty(name, data) {\n    this.userVertexProperties = this.userVertexProperties || {};\n    const key = this.vertexPropertyKey(name);\n    const dataArray = Array.isArray(data) ? data : [data];\n    if (!this.userVertexProperties[key]) {\n      this.userVertexProperties[key] = dataArray.length;\n    }\n    this.#vertexProperties[key] = dataArray;\n  }\n  vertexPropertyName(key) {\n    return key.replace(/Src$/, '');\n  }\n  vertexPropertyKey(name) {\n    return name + 'Src';\n  }\n  bezierOrder(...order) {\n    this.#bezierOrder = order;\n  }\n  splineProperty(key, value) {\n    this._splineProperties[key] = value;\n  }\n  splineProperties(values) {\n    if (values) {\n      for (const key in values) {\n        this.splineProperty(key, values[key]);\n      }\n    } else {\n      return this._splineProperties;\n    }\n  }\n\n  /*\n  To-do: Maybe refactor #createVertex() since this has side effects that aren't advertised\n  in the method name?\n  */\n  #createVertex(position, textureCoordinates) {\n    this.#vertexProperties.position = position;\n    if (textureCoordinates !== undefined) {\n      this.#vertexProperties.textureCoordinates = textureCoordinates;\n    }\n    return new Vertex(this.#vertexProperties);\n  }\n  #createPrimitiveShape(vertexKind, shapeKind, ...vertices) {\n    let primitiveShapeCreator = this.#primitiveShapeCreators.get(vertexKind, shapeKind);\n    return vertexKind === 'bezierVertex' ? primitiveShapeCreator(this.#bezierOrder, ...vertices) : primitiveShapeCreator(...vertices);\n  }\n\n  /*\n    #generalVertex() is reused by the special vertex functions,\n    including vertex(), bezierVertex(), splineVertex(), and arcVertex():\n     It creates a vertex, builds a primitive including that\n    vertex, and has the primitive add itself to the shape.\n  */\n  #generalVertex(kind, position, textureCoordinates) {\n    let vertexKind = kind;\n    let lastContourKind = this.at(-1).kind;\n    let vertex = this.#createVertex(position, textureCoordinates);\n    let primitiveShape = this.#createPrimitiveShape(vertexKind, lastContourKind, vertex);\n    return primitiveShape.addToShape(this);\n  }\n  vertex(position, textureCoordinates, {\n    isClosing = false\n  } = {}) {\n    const added = this.#generalVertex('vertex', position, textureCoordinates);\n    added.isClosing = isClosing;\n  }\n  bezierVertex(position, textureCoordinates) {\n    this.#generalVertex('bezierVertex', position, textureCoordinates);\n  }\n  splineVertex(position, textureCoordinates) {\n    this.#generalVertex('splineVertex', position, textureCoordinates);\n  }\n  arcVertex(position, textureCoordinates) {\n    this.#generalVertex('arcVertex', position, textureCoordinates);\n  }\n  beginContour(shapeKind = PATH) {\n    if (this.at(-1)?.kind === EMPTY_PATH) {\n      this.contours.pop();\n    }\n    this.contours.push(new Contour(shapeKind));\n  }\n  endContour(closeMode = OPEN, _index = this.contours.length - 1) {\n    const contour = this.at(_index);\n    if (closeMode === CLOSE) {\n      // shape characteristics\n      const isPath = contour.kind === PATH;\n\n      // anchor characteristics\n      const anchorVertex = this.at(_index, 0, 0);\n      const anchorHasPosition = Object.hasOwn(anchorVertex, 'position');\n      const lastSegment = this.at(_index, -1);\n\n      // close path\n      if (isPath && anchorHasPosition) {\n        if (lastSegment.handlesClose()) {\n          lastSegment.close(anchorVertex);\n        } else {\n          // Temporarily remove contours after the current one so that we add to the original\n          // contour again\n          const rest = this.contours.splice(_index + 1, this.contours.length - _index - 1);\n          const prevVertexProperties = this.#vertexProperties;\n          this.#vertexProperties = {\n            ...prevVertexProperties\n          };\n          for (const key in anchorVertex) {\n            if (['position', 'textureCoordinates'].includes(key)) continue;\n            this.#vertexProperties[key] = anchorVertex[key];\n          }\n          this.vertex(anchorVertex.position, anchorVertex.textureCoordinates, {\n            isClosing: true\n          });\n          this.#vertexProperties = prevVertexProperties;\n          this.contours.push(...rest);\n        }\n      }\n    }\n  }\n  beginShape(shapeKind = PATH) {\n    this.kind = shapeKind;\n    // Implicitly start a contour\n    this.beginContour(shapeKind);\n  }\n  /* TO-DO:\n     Refactor?\n     - Might not need anchorHasPosition.\n     - Might combine conditions at top, and rely on shortcircuiting.\n     Does nothing if shape is not a path or has multiple contours. Might discuss this.\n  */\n  endShape(closeMode = OPEN) {\n    if (closeMode === CLOSE) {\n      // Close the first contour, the one implicitly used for shape data\n      // added without an explicit contour\n      this.endContour(closeMode, 0);\n    }\n  }\n  accept(visitor) {\n    for (const contour of this.contours) {\n      contour.accept(visitor);\n    }\n  }\n}\n\n// ---- PRIMITIVE VISITORS ----\n\n// abstract class\nclass PrimitiveVisitor {\n  constructor() {\n    if (this.constructor === PrimitiveVisitor) {\n      throw new Error('PrimitiveVisitor is an abstract class: it cannot be instantiated.');\n    }\n  }\n  // path primitives\n  visitAnchor(anchor) {\n    throw new Error('Method visitAnchor() has not been implemented.');\n  }\n  visitLineSegment(lineSegment) {\n    throw new Error('Method visitLineSegment() has not been implemented.');\n  }\n  visitBezierSegment(bezierSegment) {\n    throw new Error('Method visitBezierSegment() has not been implemented.');\n  }\n  visitSplineSegment(curveSegment) {\n    throw new Error('Method visitSplineSegment() has not been implemented.');\n  }\n  visitArcSegment(arcSegment) {\n    throw new Error('Method visitArcSegment() has not been implemented.');\n  }\n\n  // isolated primitives\n  visitPoint(point) {\n    throw new Error('Method visitPoint() has not been implemented.');\n  }\n  visitLine(line) {\n    throw new Error('Method visitLine() has not been implemented.');\n  }\n  visitTriangle(triangle) {\n    throw new Error('Method visitTriangle() has not been implemented.');\n  }\n  visitQuad(quad) {\n    throw new Error('Method visitQuad() has not been implemented.');\n  }\n\n  // tessellation primitives\n  visitTriangleFan(triangleFan) {\n    throw new Error('Method visitTriangleFan() has not been implemented.');\n  }\n  visitTriangleStrip(triangleStrip) {\n    throw new Error('Method visitTriangleStrip() has not been implemented.');\n  }\n  visitQuadStrip(quadStrip) {\n    throw new Error('Method visitQuadStrip() has not been implemented.');\n  }\n}\n\n// requires testing\nclass PrimitiveToPath2DConverter extends PrimitiveVisitor {\n  path = new Path2D();\n  strokeWeight;\n  constructor({\n    strokeWeight\n  }) {\n    super();\n    this.strokeWeight = strokeWeight;\n  }\n\n  // path primitives\n  visitAnchor(anchor) {\n    let vertex = anchor.getEndVertex();\n    this.path.moveTo(vertex.position.x, vertex.position.y);\n  }\n  visitLineSegment(lineSegment) {\n    if (lineSegment.isClosing) {\n      // The same as lineTo, but it adds a stroke join between this\n      // and the starting vertex rather than having two caps\n      this.path.closePath();\n    } else {\n      let vertex = lineSegment.getEndVertex();\n      this.path.lineTo(vertex.position.x, vertex.position.y);\n    }\n  }\n  visitBezierSegment(bezierSegment) {\n    let [v1, v2, v3] = bezierSegment.vertices;\n    switch (bezierSegment.order) {\n      case 2:\n        this.path.quadraticCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y);\n        break;\n      case 3:\n        this.path.bezierCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y, v3.position.x, v3.position.y);\n        break;\n    }\n  }\n  visitSplineSegment(splineSegment) {\n    const shape = splineSegment._shape;\n    if (splineSegment._splineProperties.ends === EXCLUDE && !splineSegment._comesAfterSegment) {\n      let startVertex = splineSegment._firstInterpolatedVertex;\n      this.path.moveTo(startVertex.position.x, startVertex.position.y);\n    }\n    const arrayVertices = splineSegment.getControlPoints().map(v => shape.vertexToArray(v));\n    let bezierArrays = shape.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness).map(arr => arr.map(vertArr => shape.arrayToVertex(vertArr)));\n    for (const array of bezierArrays) {\n      const points = array.flatMap(vert => [vert.position.x, vert.position.y]);\n      this.path.bezierCurveTo(...points);\n    }\n  }\n  visitPoint(point) {\n    const {\n      x,\n      y\n    } = point.vertices[0].position;\n    this.path.moveTo(x, y);\n    // Hack: to draw just strokes and not fills, draw a very very tiny line\n    this.path.lineTo(x + 0.00001, y);\n  }\n  visitLine(line) {\n    const {\n      x: x0,\n      y: y0\n    } = line.vertices[0].position;\n    const {\n      x: x1,\n      y: y1\n    } = line.vertices[1].position;\n    this.path.moveTo(x0, y0);\n    this.path.lineTo(x1, y1);\n  }\n  visitTriangle(triangle) {\n    const [v0, v1, v2] = triangle.vertices;\n    this.path.moveTo(v0.position.x, v0.position.y);\n    this.path.lineTo(v1.position.x, v1.position.y);\n    this.path.lineTo(v2.position.x, v2.position.y);\n    this.path.closePath();\n  }\n  visitQuad(quad) {\n    const [v0, v1, v2, v3] = quad.vertices;\n    this.path.moveTo(v0.position.x, v0.position.y);\n    this.path.lineTo(v1.position.x, v1.position.y);\n    this.path.lineTo(v2.position.x, v2.position.y);\n    this.path.lineTo(v3.position.x, v3.position.y);\n    this.path.closePath();\n  }\n  visitTriangleFan(triangleFan) {\n    const [v0, ...rest] = triangleFan.vertices;\n    for (let i = 0; i < rest.length - 1; i++) {\n      const v1 = rest[i];\n      const v2 = rest[i + 1];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n  visitTriangleStrip(triangleStrip) {\n    for (let i = 0; i < triangleStrip.vertices.length - 2; i++) {\n      const v0 = triangleStrip.vertices[i];\n      const v1 = triangleStrip.vertices[i + 1];\n      const v2 = triangleStrip.vertices[i + 2];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n  visitQuadStrip(quadStrip) {\n    for (let i = 0; i < quadStrip.vertices.length - 3; i += 2) {\n      const v0 = quadStrip.vertices[i];\n      const v1 = quadStrip.vertices[i + 1];\n      const v2 = quadStrip.vertices[i + 2];\n      const v3 = quadStrip.vertices[i + 3];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      // These are intentionally out of order to go around the quad\n      this.path.lineTo(v3.position.x, v3.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n}\nclass PrimitiveToVerticesConverter extends PrimitiveVisitor {\n  contours = [];\n  curveDetail;\n  constructor({\n    curveDetail = 1\n  } = {}) {\n    super();\n    this.curveDetail = curveDetail;\n  }\n  lastContour() {\n    return this.contours[this.contours.length - 1];\n  }\n  visitAnchor(anchor) {\n    this.contours.push([]);\n    // Weird edge case: if the next segment is a spline, we might\n    // need to jump to a different vertex.\n    const next = anchor._nextPrimitive;\n    if (next?.canOverrideAnchor) {\n      this.lastContour().push(next._firstInterpolatedVertex);\n    } else {\n      this.lastContour().push(anchor.getEndVertex());\n    }\n  }\n  visitLineSegment(lineSegment) {\n    this.lastContour().push(lineSegment.getEndVertex());\n  }\n  visitBezierSegment(bezierSegment) {\n    const contour = this.lastContour();\n    const numPoints = Math.max(1, Math.ceil(bezierSegment.hullLength() * this.curveDetail));\n    const vertexArrays = [bezierSegment.getStartVertex(), ...bezierSegment.vertices].map(v => bezierSegment._shape.vertexToArray(v));\n    for (let i = 0; i < numPoints; i++) {\n      const t = (i + 1) / numPoints;\n      contour.push(bezierSegment._shape.arrayToVertex(bezierSegment.order === 3 ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t) : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t)));\n    }\n  }\n  visitSplineSegment(splineSegment) {\n    const shape = splineSegment._shape;\n    const contour = this.lastContour();\n    const arrayVertices = splineSegment.getControlPoints().map(v => shape.vertexToArray(v));\n    let bezierArrays = shape.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness);\n    let startVertex = shape.vertexToArray(splineSegment._firstInterpolatedVertex);\n    for (const array of bezierArrays) {\n      const bezierControls = [startVertex, ...array];\n      const numPoints = Math.max(1, Math.ceil(polylineLength(bezierControls.map(v => shape.arrayToVertex(v))) * this.curveDetail));\n      for (let i = 0; i < numPoints; i++) {\n        const t = (i + 1) / numPoints;\n        contour.push(shape.arrayToVertex(shape.evaluateCubicBezier(bezierControls, t)));\n      }\n      startVertex = array[2];\n    }\n  }\n  visitPoint(point) {\n    this.contours.push(point.vertices.slice());\n  }\n  visitLine(line) {\n    this.contours.push(line.vertices.slice());\n  }\n  visitTriangle(triangle) {\n    this.contours.push(triangle.vertices.slice());\n  }\n  visitQuad(quad) {\n    this.contours.push(quad.vertices.slice());\n  }\n  visitTriangleFan(triangleFan) {\n    // WebGL itself interprets the vertices as a fan, no reformatting needed\n    this.contours.push(triangleFan.vertices.slice());\n  }\n  visitTriangleStrip(triangleStrip) {\n    // WebGL itself interprets the vertices as a strip, no reformatting needed\n    this.contours.push(triangleStrip.vertices.slice());\n  }\n  visitQuadStrip(quadStrip) {\n    // WebGL itself interprets the vertices as a strip, no reformatting needed\n    this.contours.push(quadStrip.vertices.slice());\n  }\n}\nclass PointAtLengthGetter extends PrimitiveVisitor {\n  constructor() {\n    super();\n  }\n}\nfunction customShapes(p5, fn) {\n  // ---- GENERAL CLASSES ----\n\n  /**\n     * @private\n     * A class to describe a custom shape made with `beginShape()`/`endShape()`.\n     *\n     * Every `Shape` has a `kind`. The kind takes any value that\n     * can be passed to <a href=\"#/p5/beginShape\">beginShape()</a>:\n     *\n     * - `PATH`\n     * - `POINTS`\n     * - `LINES`\n     * - `TRIANGLES`\n     * - `QUADS`\n     * - `TRIANGLE_FAN`\n     * - `TRIANGLE_STRIP`\n     * - `QUAD_STRIP`\n     *\n     * A `Shape` of any kind consists of `contours`, which can be thought of as\n     * subshapes (shapes inside another shape). Each `contour` is built from\n     * basic shapes called primitives, and each primitive consists of one or more vertices.\n     *\n     * For example, a square can be made from a single path contour with four line-segment\n     * primitives. Each line segment contains a vertex that indicates its endpoint. A square\n     * with a circular hole in it contains the circle in a separate contour.\n     *\n     * By default, each vertex only has a position, but a shape's vertices may have other\n     * properties such as texture coordinates, a normal vector, a fill color, and a stroke color.\n     * The properties every vertex should have may be customized by passing `vertexProperties` to\n     * `createShape()`.\n     *\n     * Once a shape is created and given a name like `myShape`, it can be built up with\n     * methods such as `myShape.beginShape()`, `myShape.vertex()`, and `myShape.endShape()`.\n     *\n     * Vertex functions such as `vertex()` or `bezierVertex()` are used to set the `position`\n     * property of vertices, as well as the `textureCoordinates` property if applicable. Those\n     * properties only apply to a single vertex.\n     *\n     * If `vertexProperties` includes other properties, they are each set by a method of the\n     * same name. For example, if vertices in `myShape` have a `fill`, then that is set with\n     * `myShape.fill()`. In the same way that a <a href=\"#/p5/fill\">fill()</a> may be applied\n     * to one or more shapes, `myShape.fill()` may be applied to one or more vertices.\n     *\n     * @class p5.Shape\n     * @param {Object} [vertexProperties={position: createVector(0, 0)}] vertex properties and their initial values.\n     */\n\n  p5.Shape = Shape;\n\n  /**\n     * @private\n     * A class to describe a contour made with `beginContour()`/`endContour()`.\n     *\n     * Contours may be thought of as shapes inside of other shapes.\n     * For example, a contour may be used to create a hole in a shape that is created\n     * with <a href=\"#/p5/beginShape\">beginShape()</a>/<a href=\"#/p5/endShape\">endShape()</a>.\n     * Multiple contours may be included inside a single shape.\n     *\n     * Contours can have any `kind` that a shape can have:\n     *\n     * - `PATH`\n     * - `POINTS`\n     * - `LINES`\n     * - `TRIANGLES`\n     * - `QUADS`\n     * - `TRIANGLE_FAN`\n     * - `TRIANGLE_STRIP`\n     * - `QUAD_STRIP`\n     *\n     * By default, a contour has the same kind as the shape that contains it, but this\n     * may be changed by passing a different `kind` to <a href=\"#/p5/beginContour\">beginContour()</a>.\n     *\n     * A `Contour` of any kind consists of `primitives`, which are the most basic\n     * shapes that can be drawn. For example, if a contour is a hexagon, then\n     * it's made from six line-segment primitives.\n     *\n     * @class p5.Contour\n     */\n\n  p5.Contour = Contour;\n\n  /**\n     * @private\n     * A base class to describe a shape primitive (a basic shape drawn with\n     * `beginShape()`/`endShape()`).\n     *\n     * Shape primitives are the most basic shapes that can be drawn with\n     * <a href=\"#/p5/beginShape\">beginShape()</a>/<a href=\"#/p5/endShape\">endShape()</a>:\n     *\n     * - segment primitives: line segments, bezier segments, spline segments, and arc segments\n     * - isolated primitives: points, lines, triangles, and quads\n     * - tessellation primitives: triangle fans, triangle strips, and quad strips\n     *\n     * More complex shapes may be created by combining many primitives, possibly of different kinds,\n     * into a single shape.\n     *\n     * In a similar way, every shape primitive is built from one or more vertices.\n     * For example, a point consists of a single vertex, while a triangle consists of three vertices.\n     * Each type of shape primitive has a `vertexCapacity`, which may be `Infinity` (for example, a\n     * spline may consist of any number of vertices). A primitive's `vertexCount` is the number of\n     * vertices it currently contains.\n     *\n     * Each primitive can add itself to a shape with an `addToShape()` method.\n     *\n     * It can also accept visitor objects with an `accept()` method. When a primitive accepts a visitor,\n     * it gives the visitor access to its vertex data. For example, one visitor to a segment might turn\n     * the data into 2D drawing instructions. Another might find a point at a given distance\n     * along the segment.\n     *\n     * @class p5.ShapePrimitive\n     * @abstract\n     */\n\n  p5.ShapePrimitive = ShapePrimitive;\n\n  /**\n     * @private\n     * A class to describe a vertex (a point on a shape), in 2D or 3D.\n     *\n     * Vertices are the basic building blocks of all `p5.Shape` objects, including\n     * shapes made with <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/arcVertex\">arcVertex()</a>,\n     * <a href=\"#/p5/bezierVertex\">bezierVertex()</a>, and <a href=\"#/p5/splineVertex\">splineVertex()</a>.\n     *\n     * Like a point on an object in the real world, a vertex may have different properties.\n     * These may include coordinate properties such as `position`, `textureCoordinates`, and `normal`,\n     * color properties such as `fill` and `stroke`, and more.\n     *\n     * A vertex called `myVertex` with position coordinates `(2, 3, 5)` and a green stroke may be created\n     * like this:\n     *\n     * ```js\n     * let myVertex = new p5.Vertex({\n     *   position: createVector(2, 3, 5),\n     *   stroke: color('green')\n     * });\n     * ```\n     *\n     * Any property names may be used. The `p5.Shape` class assumes that if a vertex has a\n     * position or texture coordinates, they are stored in `position` and `textureCoordinates`\n     * properties.\n     *\n     * Property values may be any\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">JavaScript primitive</a>, any\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer\">object literal</a>,\n     * or any object with an `array` property.\n     *\n     * For example, if a position is stored as a `p5.Vector` object and a stroke is stored as a `p5.Color` object,\n     * then the `array` properties of those objects will be used by the vertex's own `array` property, which provides\n     * all the vertex data in a single array.\n     *\n     * @class p5.Vertex\n     * @param {Object} [properties={position: createVector(0, 0)}] vertex properties.\n     */\n\n  p5.Vertex = Vertex;\n\n  // ---- PATH PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.Anchor\n     * @extends p5.ShapePrimitive\n     * @param {p5.Vertex} vertex the vertex to include in the anchor.\n     */\n\n  p5.Anchor = Anchor;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * Note: When a segment is added to a shape, it's attached to an anchor or another segment.\n     * Adding it to another shape may result in unexpected behavior.\n     *\n     * @class p5.Segment\n     * @extends p5.ShapePrimitive\n     * @param {...p5.Vertex} vertices the vertices to include in the segment.\n     */\n\n  p5.Segment = Segment;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.LineSegment\n     * @param {p5.Vertex} vertex the vertex to include in the anchor.\n     */\n\n  p5.LineSegment = LineSegment;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.BezierSegment = BezierSegment;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.SplineSegment = SplineSegment;\n\n  // ---- ISOLATED PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Point = Point;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.Line\n     * @param {...p5.Vertex} vertices the vertices to include in the line.\n     */\n\n  p5.Line = Line;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Triangle = Triangle;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Quad = Quad;\n\n  // ---- TESSELLATION PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.TriangleFan = TriangleFan;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.TriangleStrip = TriangleStrip;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.QuadStrip = QuadStrip;\n\n  // ---- PRIMITIVE VISITORS ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PrimitiveVisitor = PrimitiveVisitor;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * Notes:\n     * 1. Assumes vertex positions are stored as p5.Vector instances.\n     * 2. Currently only supports position properties of vectors.\n     */\n\n  p5.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PointAtLengthGetter = PointAtLengthGetter;\n\n  // ---- FUNCTIONS ----\n\n  /**\n   * Influences the shape of the BÃ©zier curve segment in a custom shape.\n   * By default, this is 3; the other possible parameter is 2. This\n   * results in quadratic BÃ©zier curves.\n   *\n   * `bezierVertex()` adds a curved segment to custom shapes. The BÃ©zier curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/bezier\">bezier()</a> function. `bezierVertex()` must be\n   * called between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions. There must be at least\n   * one call to <a href=\"#/p5/vertex\">bezierVertex()</a>, before\n   * a number of `bezierVertex()` calls that is a multiple of the parameter\n   * set by <a href=\"#/p5/bezierOrder\">bezierOrder(...)</a> (default 3).\n   * \n   * Each curve of order 3 requires three calls to `bezierVertex`, so\n   * 2 curves would need 7 calls to `bezierVertex()`:\n   * (1 one initial anchor point, two sets of 3 curves describing the curves)\n   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2. \n   *\n   * BÃ©zier curves can also be drawn in 3D using WebGL mode.\n   *\n   * Note: `bezierVertex()` wonâ€™t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method bezierOrder\n   * @param {Number} order The new order to set. Can be either 2 or 3, by default 3\n   * \n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   * \n   *   // set the order to 2 for a quadratic BÃ©zier curve\n   *   bezierOrder(2);\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the BÃ©zier vertex.\n   *   bezierVertex(80, 20);\n   *   bezierVertex(50, 50);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A black curve drawn on a gray square. The curve starts at the top-left corner and ends at the center.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method bezierOrder\n   * @returns {Number} The current BÃ©zier order.\n   */\n  fn.bezierOrder = function (order) {\n    return this._renderer.bezierOrder(order);\n  };\n\n  /**\n     * Adds a spline curve segment to a custom shape.\n     *\n     * `splineVertex()` adds a curved segment to custom shapes. The spline curves\n     * it creates are defined like those made by the\n     * <a href=\"#/p5/curve\">curve()</a> function. `splineVertex()` must be called\n     * between the <a href=\"#/p5/beginShape\">beginShape()</a> and\n     * <a href=\"#/p5/endShape\">endShape()</a> functions.\n     *\n     * Spline curves can form shapes and curves that slope gently. Theyâ€™re like\n     * cables that are attached to a set of points. Splines are defined by two\n     * anchor points and two control points. `splineVertex()` must be called at\n     * least four times between\n     * <a href=\"#/p5/beginShape\">beginShape()</a> and\n     * <a href=\"#/p5/endShape\">endShape()</a> in order to draw a curve:\n     *\n     * ```js\n     * beginShape();\n     *\n     * // Add the first control point.\n     * splineVertex(84, 91);\n     *\n     * // Add the anchor points to draw between.\n     * splineVertex(68, 19);\n     * splineVertex(21, 17);\n     *\n     * // Add the second control point.\n     * splineVertex(32, 91);\n     *\n     * endShape();\n     * ```\n     *\n     * The code snippet above would only draw the curve between the anchor points,\n     * similar to the <a href=\"#/p5/curve\">curve()</a> function. The segments\n     * between the control and anchor points can be drawn by calling\n     * `splineVertex()` with the coordinates of the control points:\n     *\n     * ```js\n     * beginShape();\n     *\n     * // Add the first control point and draw a segment to it.\n     * splineVertex(84, 91);\n     * splineVertex(84, 91);\n     *\n     * // Add the anchor points to draw between.\n     * splineVertex(68, 19);\n     * splineVertex(21, 17);\n     *\n     * // Add the second control point.\n     * splineVertex(32, 91);\n     *\n     * // Uncomment the next line to draw the segment to the second control point.\n     * // splineVertex(32, 91);\n     *\n     * endShape();\n     * ```\n     *\n     * The first two parameters, `x` and `y`, set the vertexâ€™s location. For\n     * example, calling `splineVertex(10, 10)` adds a point to the curve at\n     * `(10, 10)`.\n     *\n     * Spline curves can also be drawn in 3D using WebGL mode. The 3D version of\n     * `splineVertex()` has three arguments because each point has x-, y-, and\n     * z-coordinates. By default, the vertexâ€™s z-coordinate is set to 0.\n     *\n     * Note: `splineVertex()` wonâ€™t work when an argument is passed to\n     * <a href=\"#/p5/beginShape\">beginShape()</a>.\n     *\n     * @method splineVertex\n     * @param {Number} x x-coordinate of the vertex\n     * @param {Number} y y-coordinate of the vertex\n     * @chainable\n     *\n     * @example\n     * <div>\n     * <code>\n     * function setup() {\n     *   createCanvas(100, 100);\n     *\n     *   background(200);\n     *\n     *   // Style the shape.\n     *   noFill();\n     *   strokeWeight(1);\n     *\n     *   // Start drawing the shape.\n     *   beginShape();\n     *\n     *   // Add the first control point.\n     *   splineVertex(32, 91);\n     *\n     *   // Add the anchor points.\n     *   splineVertex(21, 17);\n     *   splineVertex(68, 19);\n     *\n     *   // Add the second control point.\n     *   splineVertex(84, 91);\n     *\n     *   // Stop drawing the shape.\n     *   endShape();\n     *\n     *   // Style the anchor and control points.\n     *   strokeWeight(5);\n     *\n     *   // Draw the anchor points in black.\n     *   stroke(0);\n     *   point(21, 17);\n     *   point(68, 19);\n     *\n     *   // Draw the control points in red.\n     *   stroke(255, 0, 0);\n     *   point(32, 91);\n     *   point(84, 91);\n     *\n     *   describe(\n     *     'A black curve drawn on a gray background. The curve has black dots at its ends. Two red dots appear near the bottom of the canvas.'\n     *   );\n     * }\n     * </code>\n     * </div>\n     *\n     * <div>\n     * <code>\n     * function setup() {\n     *   createCanvas(100, 100);\n     *\n     *   background(200);\n     *\n     *   // Style the shape.\n     *   noFill();\n     *   strokeWeight(1);\n     *\n     *   // Start drawing the shape.\n     *   beginShape();\n     *\n     *   // Add the first control point and draw a segment to it.\n     *   splineVertex(32, 91);\n     *   splineVertex(32, 91);\n     *\n     *   // Add the anchor points.\n     *   splineVertex(21, 17);\n     *   splineVertex(68, 19);\n     *\n     *   // Add the second control point.\n     *   splineVertex(84, 91);\n     *\n     *   // Stop drawing the shape.\n     *   endShape();\n     *\n     *   // Style the anchor and control points.\n     *   strokeWeight(5);\n     *\n     *   // Draw the anchor points in black.\n     *   stroke(0);\n     *   point(21, 17);\n     *   point(68, 19);\n     *\n     *   // Draw the control points in red.\n     *   stroke(255, 0, 0);\n     *   point(32, 91);\n     *   point(84, 91);\n     *\n     *   describe(\n     *     'A black curve drawn on a gray background. The curve passes through one red dot and two black dots. Another red dot appears near the bottom of the canvas.'\n     *   );\n     * }\n     * </code>\n     * </div>\n     *\n     * <div>\n     * <code>\n     * function setup() {\n     *   createCanvas(100, 100);\n     *\n     *   background(200);\n     *\n     *   // Style the shape.\n     *   noFill();\n     *   strokeWeight(1);\n     *\n     *   // Start drawing the shape.\n     *   beginShape();\n     *\n     *   // Add the first control point and draw a segment to it.\n     *   splineVertex(32, 91);\n     *   splineVertex(32, 91);\n     *\n     *   // Add the anchor points.\n     *   splineVertex(21, 17);\n     *   splineVertex(68, 19);\n     *\n     *   // Add the second control point and draw a segment to it.\n     *   splineVertex(84, 91);\n     *   splineVertex(84, 91);\n     *\n     *   // Stop drawing the shape.\n     *   endShape();\n     *\n     *   // Style the anchor and control points.\n     *   strokeWeight(5);\n     *\n     *   // Draw the anchor points in black.\n     *   stroke(0);\n     *   point(21, 17);\n     *   point(68, 19);\n     *\n     *   // Draw the control points in red.\n     *   stroke(255, 0, 0);\n     *   point(32, 91);\n     *   point(84, 91);\n     *\n     *   describe(\n     *     'A black U curve drawn upside down on a gray background. The curve passes from one red dot through two black dots and ends at another red dot.'\n     *   );\n     * }\n     * </code>\n     * </div>\n     *\n     * <div>\n     * <code>\n     * // Click the mouse near the red dot in the bottom-left corner\n     * // and drag to change the curve's shape.\n     *\n     * let x1 = 32;\n     * let y1 = 91;\n     * let isChanging = false;\n     *\n     * function setup() {\n     *   createCanvas(100, 100);\n     *\n     *   describe(\n     *     'A black U curve drawn upside down on a gray background. The curve passes from one red dot through two black dots and ends at another red dot.'\n     *   );\n     * }\n     *\n     * function draw() {\n     *   background(200);\n     *\n     *   // Style the shape.\n     *   noFill();\n     *   stroke(0);\n     *   strokeWeight(1);\n     *\n     *   // Start drawing the shape.\n     *   beginShape();\n     *\n     *   // Add the first control point and draw a segment to it.\n     *   splineVertex(x1, y1);\n     *   splineVertex(x1, y1);\n     *\n     *   // Add the anchor points.\n     *   splineVertex(21, 17);\n     *   splineVertex(68, 19);\n     *\n     *   // Add the second control point and draw a segment to it.\n     *   splineVertex(84, 91);\n     *   splineVertex(84, 91);\n     *\n     *   // Stop drawing the shape.\n     *   endShape();\n     *\n     *   // Style the anchor and control points.\n     *   strokeWeight(5);\n     *\n     *   // Draw the anchor points in black.\n     *   stroke(0);\n     *   point(21, 17);\n     *   point(68, 19);\n     *\n     *   // Draw the control points in red.\n     *   stroke(255, 0, 0);\n     *   point(x1, y1);\n     *   point(84, 91);\n     * }\n     *\n     * // Start changing the first control point if the user clicks near it.\n     * function mousePressed() {\n     *   if (dist(mouseX, mouseY, x1, y1) < 20) {\n     *     isChanging = true;\n     *   }\n     * }\n     *\n     * // Stop changing the first control point when the user releases the mouse.\n     * function mouseReleased() {\n     *   isChanging = false;\n     * }\n     *\n     * // Update the first control point while the user drags the mouse.\n     * function mouseDragged() {\n     *   if (isChanging === true) {\n     *     x1 = mouseX;\n     *     y1 = mouseY;\n     *   }\n     * }\n     * </code>\n     * </div>\n     *\n     * <div>\n     * <code>\n     * function setup() {\n     *   createCanvas(100, 100);\n     *\n     *   background(200);\n     *\n     *   // Start drawing the shape.\n     *   beginShape();\n     *\n     *   // Add the first control point and draw a segment to it.\n     *   splineVertex(32, 91);\n     *   splineVertex(32, 91);\n     *\n     *   // Add the anchor points.\n     *   splineVertex(21, 17);\n     *   splineVertex(68, 19);\n     *\n     *   // Add the second control point.\n     *   splineVertex(84, 91);\n     *   splineVertex(84, 91);\n     *\n     *   // Stop drawing the shape.\n     *   endShape();\n     *\n     *   describe('A ghost shape drawn in white on a gray background.');\n     * }\n     * </code>\n     * </div>\n     */\n\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} [z] z-coordinate of the vertex.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A ghost shape drawn in white on a blue background. When the user drags the mouse, the scene rotates to reveal the outline of a second ghost.');\n   * }\n   *\n   * function draw() {\n   *   background('midnightblue');\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the first ghost.\n   *   noStroke();\n   *   fill('ghostwhite');\n   *\n   *   beginShape();\n   *   splineVertex(-28, 41, 0);\n   *   splineVertex(-28, 41, 0);\n   *   splineVertex(-29, -33, 0);\n   *   splineVertex(18, -31, 0);\n   *   splineVertex(34, 41, 0);\n   *   splineVertex(34, 41, 0);\n   *   endShape();\n   *\n   *   // Draw the second ghost.\n   *   noFill();\n   *   stroke('ghostwhite');\n   *\n   *   beginShape();\n   *   splineVertex(-28, 41, -20);\n   *   splineVertex(-28, 41, -20);\n   *   splineVertex(-29, -33, -20);\n   *   splineVertex(18, -31, -20);\n   *   splineVertex(34, 41, -20);\n   *   splineVertex(34, 41, -20);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} [u=0]\n   * @param {Number} [v=0]\n   */\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} z\n   * @param {Number} [u=0]\n   * @param {Number} [v=0]\n   */\n  fn.splineVertex = function (...args) {\n    let x = 0,\n      y = 0,\n      z = 0,\n      u = 0,\n      v = 0;\n    if (args.length === 2) {\n      [x, y] = args;\n    } else if (args.length === 4) {\n      [x, y, u, v] = args;\n    } else if (args.length === 3) {\n      [x, y, z] = args;\n    } else if (args.length === 5) {\n      [x, y, z, u, v] = args;\n    }\n    this._renderer.splineVertex(x, y, z, u, v);\n  };\n\n  /**\n   * Sets the property of a curve.\n   * \n   * For example, set tightness,\n   * use `splineProperty('tightness', t)`, with `t` between 0 and 1,\n   * at 0 as default.\n   * \n   * Spline curves are like cables that are attached to a set of points.\n   * Adjusting tightness adjusts how tightly the cable is\n   * attached to the points. The parameter, tightness, determines\n   * how the curve fits to the vertex points. By default,\n   * tightness is set to 0. Setting tightness to 1, as in\n   * `splineProperty('tightness', 1)`, connects the curve's points\n   * using straight lines. Values in the range from â€“5 to 5\n   * deform curves while leaving them recognizable.\n   * \n   * This function can also be used to set 'ends' property\n   * (see also: the <a href=\"#/p5/curveDetail\">curveDetail()</a> example),\n   * such as: `splineProperty('ends', EXCLUDE)` to exclude\n   * vertices, or `splineProperty('ends', INCLUDE)` to include them.\n   * \n   * @method splineProperty\n   * @param {String} property\n   * @param value Value to set the given property to.\n   * \n   * @example\n   * <div>\n   * <code>\n   * // Move the mouse left and right to see the curve change.\n   * \n   * function setup() {\n   *   createCanvas(100, 100);\n   *   describe('A black curve forms a sideways U shape. The curve deforms as the user moves the mouse from left to right');\n   * }\n   * \n   * function draw() {\n   *   background(200);\n   * \n   *   // Set the curve's tightness using the mouse.\n   *   let t = map(mouseX, 0, 100, -5, 5, true);\n   *   splineProperty('tightness', t);\n   * \n   *   // Draw the curve.\n   *   noFill();\n   *   beginShape();\n   *   splineVertex(10, 26);\n   *   splineVertex(10, 26);\n   *   splineVertex(83, 24);\n   *   splineVertex(83, 61);\n   *   splineVertex(25, 65);\n   *   splineVertex(25, 65);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method splineProperty\n   * @param {String} property\n   * @returns The current value for the given property.\n   */\n  fn.splineProperty = function (property, value) {\n    return this._renderer.splineProperty(property, value);\n  };\n\n  /**\n   * Get or set multiple spline properties at once.\n   * \n   * Similar to <a href=\"#/p5/splineProperty\">splineProperty()</a>:\n   * `splineProperty('tightness', t)` is the same as\n   * `splineProperties({'tightness': t})`\n   * \n   * @method splineProperties\n   * @param {Object} properties An object containing key-value pairs to set.\n   */\n  /**\n   * @method splineProperties\n   * @returns {Object} The current spline properties.\n   */\n  fn.splineProperties = function (values) {\n    return this._renderer.splineProperties(values);\n  };\n\n  /**\n   * Adds a vertex to a custom shape.\n   *\n   * `vertex()` sets the coordinates of vertices drawn between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   *\n   * The first two parameters, `x` and `y`, set the x- and y-coordinates of the\n   * vertex.\n   *\n   * The third parameter, `z`, is optional. It sets the z-coordinate of the\n   * vertex in WebGL mode. By default, `z` is 0.\n   *\n   * The fourth and fifth parameters, `u` and `v`, are also optional. They set\n   * the u- and v-coordinates for the vertexâ€™s texture when used with\n   * <a href=\"#/p5/endShape\">endShape()</a>. By default, `u` and `v` are both 0.\n   *\n   * @method vertex\n   * @param  {Number} x x-coordinate of the vertex.\n   * @param  {Number} y y-coordinate of the vertex.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   strokeWeight(3);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw the vertices.\n   *   beginShape(POINTS);\n   *\n   *   // Add the vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four black dots that form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0);\n   *   vertex(35, -30, 0);\n   *   vertex(35, 25, 0);\n   *   vertex(-20, 25, 0);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around slowly on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0);\n   *   vertex(35, -30, 0);\n   *   vertex(35, 25, 0);\n   *   vertex(-20, 25, 0);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load an image to apply as a texture.\n   *   img = await loadImage('assets/laDefense.jpg');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A photograph of a ceiling rotates slowly against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *\n   *   // Apply the texture.\n   *   texture(img);\n   *   textureMode(NORMAL);\n   *\n   *   // Start drawing the shape\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0, 0, 0);\n   *   vertex(35, -30, 0, 1, 0);\n   *   vertex(35, 25, 0, 1, 1);\n   *   vertex(-20, 25, 0, 0, 1);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   * \n   * <div>\n   * <code>\n   * let vid;\n   * function setup() {\n   *   // Load a video and create a p5.MediaElement object.\n   *   vid = createVideo('/assets/fingers.mov');\n   *   createCanvas(100, 100, WEBGL);\n   * \n   *   // Hide the video.\n   *   vid.hide();\n   * \n   *   // Set the video to loop.\n   *   vid.loop();\n   * \n   *   describe('A rectangle with video as texture');\n   * }\n   * \n   * function draw() {\n   *   background(0);\n   * \n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   * \n   *   // Set the texture mode.\n   *   textureMode(NORMAL);\n   * \n   *   // Apply the video as a texture.\n   *   texture(vid);\n   * \n   *   // Draw a custom shape using uv coordinates.\n   *   beginShape();\n   *   vertex(-40, -40, 0, 0);\n   *   vertex(40, -40, 1, 0);\n   *   vertex(40, 40, 1, 1);\n   *   vertex(-40, 40, 0, 1);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method vertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.\n   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.\n   */\n  /**\n   * @method vertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} z\n   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.\n   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.\n   */\n  fn.vertex = function (x, y) {\n    let z, u, v;\n\n    // default to (x, y) mode: all other arguments assumed to be 0.\n    z = u = v = 0;\n    if (arguments.length === 3) {\n      // (x, y, z) mode: (u, v) assumed to be 0.\n      z = arguments[2];\n    } else if (arguments.length === 4) {\n      // (x, y, u, v) mode: z assumed to be 0.\n      u = arguments[2];\n      v = arguments[3];\n    } else if (arguments.length === 5) {\n      // (x, y, z, u, v) mode\n      z = arguments[2];\n      u = arguments[3];\n      v = arguments[4];\n    }\n    this._renderer.vertex(x, y, z, u, v);\n    return;\n  };\n\n  /**\n   * Begins creating a hole within a flat shape.\n   *\n   * The `beginContour()` and <a href=\"#/p5/endContour\">endContour()</a>\n   * functions allow for creating negative space within custom shapes that are\n   * flat. `beginContour()` begins adding vertices to a negative space and\n   * <a href=\"#/p5/endContour\">endContour()</a> stops adding them.\n   * `beginContour()` and <a href=\"#/p5/endContour\">endContour()</a> must be\n   * called between <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and <a href=\"#/p5/scale\">scale()</a>\n   * don't work between `beginContour()` and\n   * <a href=\"#/p5/endContour\">endContour()</a>. It's also not possible to use\n   * other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between `beginContour()` and\n   * <a href=\"#/p5/endContour\">endContour()</a>.\n   *\n   * Note: The vertices that define a negative space must \"wind\" in the opposite\n   * direction from the outer shape. First, draw vertices for the outer shape\n   * clockwise order. Then, draw vertices for the negative space in\n   * counter-clockwise order.\n   *\n   * @method beginContour\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(10, 10);\n   *   vertex(90, 10);\n   *   vertex(90, 90);\n   *   vertex(10, 90);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(30, 30);\n   *   vertex(30, 70);\n   *   vertex(70, 70);\n   *   vertex(70, 30);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(-40, -40);\n   *   vertex(40, -40);\n   *   vertex(40, 40);\n   *   vertex(-40, 40);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(-20, -20);\n   *   vertex(-20, 20);\n   *   vertex(20, 20);\n   *   vertex(20, -20);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.beginContour = function (kind) {\n    this._renderer.beginContour(kind);\n  };\n\n  /**\n   * Stops creating a hole within a flat shape. \n   *\n   * The <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()`\n   * functions allow for creating negative space within custom shapes that are\n   * flat. <a href=\"#/p5/beginContour\">beginContour()</a> begins adding vertices\n   * to a negative space and `endContour()` stops adding them.\n   * <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()` must be\n   * called between <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   *  By default, \n   * the controur has an `OPEN` end, and to close it,\n   * call `endContour(CLOSE)`. The CLOSE contour mode closes splines smoothly.\n   * \n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and <a href=\"#/p5/scale\">scale()</a>\n   * don't work between <a href=\"#/p5/beginContour\">beginContour()</a> and\n   * `endContour()`. It's also not possible to use other shapes, such as\n   * <a href=\"#/p5/ellipse\">ellipse()</a> or <a href=\"#/p5/rect\">rect()</a>,\n   * between <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()`.\n   *\n   * Note: The vertices that define a negative space must \"wind\" in the opposite\n   * direction from the outer shape. First, draw vertices for the outer shape\n   * clockwise order. Then, draw vertices for the negative space in\n   * counter-clockwise order.\n   *\n   * @method endContour\n   * @param {OPEN|CLOSE} [mode=OPEN] By default, the value is OPEN\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(10, 10);\n   *   vertex(90, 10);\n   *   vertex(90, 90);\n   *   vertex(10, 90);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(30, 30);\n   *   vertex(30, 70);\n   *   vertex(70, 70);\n   *   vertex(70, 30);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(-40, -40);\n   *   vertex(40, -40);\n   *   vertex(40, 40);\n   *   vertex(-40, 40);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(-20, -20);\n   *   vertex(-20, 20);\n   *   vertex(20, 20);\n   *   vertex(20, -20);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.endContour = function (mode = OPEN) {\n    this._renderer.endContour(mode);\n  };\n}\nif (typeof p5 !== 'undefined') {\n  customShapes(p5, p5.prototype);\n}\nexport { Anchor, BezierSegment, Contour, Line, LineSegment, Point, PointAtLengthGetter, PrimitiveToPath2DConverter, PrimitiveToVerticesConverter, PrimitiveVisitor, Quad, QuadStrip, Segment, Shape, ShapePrimitive, SplineSegment, Triangle, TriangleFan, TriangleStrip, Vertex, customShapes as default };","map":{"version":3,"names":["C","Color","Vector","I","INCLUDE","m","PATH","E","EMPTY_PATH","O","OPEN","n","CLOSE","o","POINTS","L","LINES","p","TRIANGLES","Q","QUADS","q","TRIANGLE_FAN","r","TRIANGLE_STRIP","s","QUAD_STRIP","t","EXCLUDE","J","JOIN","polylineLength","vertices","length","i","position","dist","Vertex","constructor","properties","key","value","Object","entries","ShapePrimitive","_shape","_primitivesIndex","_contoursIndex","isClosing","Error","vertexCount","vertexCapacity","_firstInterpolatedVertex","startVertex","canOverrideAnchor","accept","visitor","addToShape","shape","lastContour","at","primitives","push","lastPrimitive","hasSameType","spareCapacity","pushableVertices","remainingVertices","splice","addedToShape","contours","_nextPrimitive","_belongsToShape","handlesClose","close","vertex","Contour","kind","isEmpty","isPath","primitive","Anchor","visitAnchor","getEndVertex","Segment","_previousPrimitive","getStartVertex","LineSegment","visitLineSegment","BezierSegment","order","numericalOrder","Array","isArray","_hullLength","hullLength","undefined","visitBezierSegment","SplineSegment","Infinity","_splineProperties","ends","tightness","visitSplineSegment","_comesAfterSegment","_chainedToSegment","interpolatedStartPosition","predecessorEndPosition","equals","added","verticesPushed","message","array1","array2","interpolatedStart","predecessorEnd","console","warn","array","getControlPoints","points","prevVertex","unshift","contour","Point","visitPoint","Line","visitLine","Triangle","visitTriangle","Quad","visitQuad","TriangleFan","visitTriangleFan","TriangleStrip","visitTriangleStrip","QuadStrip","visitQuadStrip","PrimitiveShapeCreators","creators","Map","set","get","vertexKind","shapeKind","creator","clear","Shape","vertexProperties","initialVertexProperties","primitiveShapeCreators","bezierOrder","userVertexProperties","serializeToArray","val","Number","Function","vertexToArray","fill","hydrateValue","queue","original","shift","arrayToVertex","arrayScale","scale","map","v","arraySum","first","rest","result","j","arrayMinus","a","b","evaluateCubicBezier","c","d","Math","pow","evaluateQuadraticBezier","catmullRomToBezier","bezArrays","slice","bezB","bezC","bezD","contoursIndex","primitivesIndex","verticesIndex","arguments","reset","vertexProperty","name","data","vertexPropertyKey","dataArray","vertexPropertyName","replace","splineProperty","splineProperties","values","createVertex","#createVertex","textureCoordinates","createPrimitiveShape","#createPrimitiveShape","primitiveShapeCreator","generalVertex","#generalVertex","lastContourKind","primitiveShape","bezierVertex","splineVertex","arcVertex","beginContour","pop","endContour","closeMode","_index","anchorVertex","anchorHasPosition","hasOwn","lastSegment","prevVertexProperties","includes","beginShape","endShape","PrimitiveVisitor","anchor","lineSegment","bezierSegment","curveSegment","visitArcSegment","arcSegment","point","line","triangle","quad","triangleFan","triangleStrip","quadStrip","PrimitiveToPath2DConverter","path","Path2D","strokeWeight","moveTo","x","y","closePath","lineTo","v1","v2","v3","quadraticCurveTo","bezierCurveTo","splineSegment","arrayVertices","bezierArrays","arr","vertArr","flatMap","vert","x0","y0","x1","y1","v0","PrimitiveToVerticesConverter","curveDetail","next","numPoints","max","ceil","vertexArrays","bezierControls","PointAtLengthGetter","customShapes","p5","fn","_renderer","args","z","u","property","mode","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/shape/custom_shapes.js"],"sourcesContent":["import { C as Color } from '../creating_reading-Cr8L2Jnm.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { I as INCLUDE, m as PATH, E as EMPTY_PATH, O as OPEN, n as CLOSE, o as POINTS, L as LINES, p as TRIANGLES, Q as QUADS, q as TRIANGLE_FAN, r as TRIANGLE_STRIP, s as QUAD_STRIP, t as EXCLUDE, J as JOIN } from '../constants-BRcElHU3.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\n\n/**\n * @module Shape\n * @submodule Custom Shapes\n * @for p5\n * @requires core\n * @requires constants\n */\n\n\n// ---- UTILITY FUNCTIONS ----\nfunction polylineLength(vertices) {\n  let length = 0;\n  for (let i = 1; i < vertices.length; i++) {\n    length += vertices[i-1].position.dist(vertices[i].position);\n  }\n  return length;\n}\n\n// ---- GENERAL BUILDING BLOCKS ----\n\nclass Vertex {\n  constructor(properties) {\n    for (const [key, value] of Object.entries(properties)) {\n      this[key] = value;\n    }\n  }\n  /*\n  get array() {\n    // convert to 1D array\n    // call `toArray()` if value is an object with a toArray() method\n    // handle primitive values separately\n    // maybe handle object literals too, with Object.values()?\n    // probably donâ€™t need anything else for now?\n  }\n  */\n  // TODO: make sure name of array conversion method is\n  // consistent with any modifications to the names of corresponding\n  // properties of p5.Vector and p5.Color\n}\n\nclass ShapePrimitive {\n  vertices;\n  _shape = null;\n  _primitivesIndex = null;\n  _contoursIndex = null;\n  isClosing = false;\n\n  constructor(...vertices) {\n    if (this.constructor === ShapePrimitive) {\n      throw new Error('ShapePrimitive is an abstract class: it cannot be instantiated.');\n    }\n    if (vertices.length > 0) {\n      this.vertices = vertices;\n    }\n    else {\n      throw new Error('At least one vertex must be passed to the constructor.');\n    }\n  }\n\n  get vertexCount() {\n    return this.vertices.length;\n  }\n\n  get vertexCapacity() {\n    throw new Error('Getter vertexCapacity must be implemented.');\n  }\n\n  get _firstInterpolatedVertex() {\n    return this.startVertex();\n  }\n\n  get canOverrideAnchor() {\n    return false;\n  }\n\n  accept(visitor) {\n    throw new Error('Method accept() must be implemented.');\n  }\n\n  addToShape(shape) {\n    /*\n    TODO:\n    Refactor?\n    Test this method once more primitives are implemented.\n    Test segments separately (Segment adds an extra step to this method).\n    */\n    let lastContour = shape.at(-1);\n\n    if (lastContour.primitives.length === 0) {\n      lastContour.primitives.push(this);\n    } else {\n      // last primitive in shape\n      let lastPrimitive = shape.at(-1, -1);\n      let hasSameType = lastPrimitive instanceof this.constructor;\n      let spareCapacity = lastPrimitive.vertexCapacity -\n                          lastPrimitive.vertexCount;\n\n      // this primitive\n      let pushableVertices;\n      let remainingVertices;\n\n      if (hasSameType && spareCapacity > 0) {\n\n        pushableVertices = this.vertices.splice(0, spareCapacity);\n        remainingVertices = this.vertices;\n        lastPrimitive.vertices.push(...pushableVertices);\n\n        if (remainingVertices.length > 0) {\n          lastContour.primitives.push(this);\n        }\n      }\n      else {\n        lastContour.primitives.push(this);\n      }\n    }\n\n    // if primitive itself was added\n    // (i.e. its individual vertices weren't all added to an existing primitive)\n    // give it a reference to the shape and store its location within the shape\n    let addedToShape = this.vertices.length > 0;\n    if (addedToShape) {\n      let lastContour = shape.at(-1);\n      this._primitivesIndex = lastContour.primitives.length - 1;\n      this._contoursIndex = shape.contours.length - 1;\n      this._shape = shape;\n    }\n\n    return shape.at(-1, -1);\n  }\n\n  get _nextPrimitive() {\n    return this._belongsToShape ?\n      this._shape.at(this._contoursIndex, this._primitivesIndex + 1) :\n      null;\n  }\n\n  get _belongsToShape() {\n    return this._shape !== null;\n  }\n\n  handlesClose() {\n    return false;\n  }\n\n  close(vertex) {\n    throw new Error('Unimplemented!');\n  }\n}\n\nclass Contour {\n  #kind;\n  primitives;\n\n  constructor(kind = PATH) {\n    this.#kind = kind;\n    this.primitives = [];\n  }\n\n  get kind() {\n    const isEmpty = this.primitives.length === 0;\n    const isPath = this.#kind === PATH;\n    return isEmpty && isPath ? EMPTY_PATH : this.#kind;\n  }\n\n  accept(visitor) {\n    for (const primitive of this.primitives) {\n      primitive.accept(visitor);\n    }\n  }\n}\n\n// ---- PATH PRIMITIVES ----\n\nclass Anchor extends ShapePrimitive {\n  #vertexCapacity = 1;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitAnchor(this);\n  }\n\n  getEndVertex() {\n    return this.vertices[0];\n  }\n}\n\n// abstract class\nclass Segment extends ShapePrimitive {\n  constructor(...vertices) {\n    super(...vertices);\n    if (this.constructor === Segment) {\n      throw new Error('Segment is an abstract class: it cannot be instantiated.');\n    }\n  }\n\n  // segments in a shape always have a predecessor\n  // (either an anchor or another segment)\n  get _previousPrimitive() {\n    return this._belongsToShape ?\n      this._shape.at(this._contoursIndex, this._primitivesIndex - 1) :\n      null;\n  }\n\n  getStartVertex() {\n    return this._previousPrimitive.getEndVertex();\n  }\n\n  getEndVertex() {\n    return this.vertices.at(-1);\n  }\n}\n\nclass LineSegment extends Segment {\n  #vertexCapacity = 1;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitLineSegment(this);\n  }\n}\n\nclass BezierSegment extends Segment {\n  #order;\n  #vertexCapacity;\n\n  constructor(order, ...vertices) {\n    super(...vertices);\n\n    // Order m may sometimes be passed as an array [m], since arrays\n    // may be used elsewhere to store order of\n    // Bezier curves and surfaces in a common format\n\n    let numericalOrder = Array.isArray(order) ? order[0] : order;\n    this.#order = numericalOrder;\n    this.#vertexCapacity = numericalOrder;\n  }\n\n  get order() {\n    return this.#order;\n  }\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  #_hullLength;\n  hullLength() {\n    if (this.#_hullLength === undefined) {\n      this.#_hullLength = polylineLength([\n        this.getStartVertex(),\n        ...this.vertices\n      ]);\n    }\n    return this.#_hullLength;\n  }\n\n  accept(visitor) {\n    visitor.visitBezierSegment(this);\n  }\n}\n\n/*\nTo-do: Consider type and end modes -- see #6766\nmay want to use separate classes, but maybe not\n\nFor now, the implementation overrides\nsuper.getEndVertex() in order to preserve current p5\nendpoint behavior, but we're considering defaulting\nto interpolated endpoints (a breaking change)\n*/\nclass SplineSegment extends Segment {\n  #vertexCapacity = Infinity;\n  _splineProperties = {\n    ends: INCLUDE,\n    tightness: 0\n  };\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitSplineSegment(this);\n  }\n\n  get _comesAfterSegment() {\n    return this._previousPrimitive instanceof Segment;\n  }\n\n  get canOverrideAnchor() {\n    return this._splineProperties.ends === EXCLUDE;\n  }\n\n  // assuming for now that the first interpolated vertex is always\n  // the second vertex passed to splineVertex()\n  // if this spline segment doesn't follow another segment,\n  // the first vertex is in an anchor\n  get _firstInterpolatedVertex() {\n    if (this._splineProperties.ends === EXCLUDE) {\n      return this._comesAfterSegment ?\n        this.vertices[1] :\n        this.vertices[0];\n    } else {\n      return this.getStartVertex()\n    }\n  }\n\n  get _chainedToSegment() {\n    if (this._belongsToShape && this._comesAfterSegment) {\n      let interpolatedStartPosition = this._firstInterpolatedVertex.position;\n      let predecessorEndPosition = this.getStartVertex().position;\n      return predecessorEndPosition.equals(interpolatedStartPosition);\n    }\n    else {\n      return false;\n    }\n  }\n\n  // extend addToShape() with a warning in case second vertex\n  // doesn't line up with end of last segment\n  addToShape(shape) {\n    const added = super.addToShape(shape);\n    this._splineProperties.ends = shape._splineProperties.ends;\n    this._splineProperties.tightness = shape._splineProperties.tightness;\n\n    if (this._splineProperties.ends !== EXCLUDE) return added;\n\n    let verticesPushed = !this._belongsToShape;\n    let lastPrimitive = shape.at(-1, -1);\n\n    let message = (array1, array2) =>\n      `Spline does not start where previous path segment ends:\n      second spline vertex at (${array1})\n      expected to be at (${array2}).`;\n\n    if (verticesPushed &&\n      // Only check once the first interpolated vertex has been added\n      lastPrimitive.vertices.length === 2 &&\n      lastPrimitive._comesAfterSegment &&\n      !lastPrimitive._chainedToSegment\n    ) {\n      let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;\n      let predecessorEnd = lastPrimitive.getStartVertex().position;\n\n      console.warn(\n        message(interpolatedStart.array(), predecessorEnd.array())\n      );\n    }\n\n    // Note: Could add a warning in an else-if case for when this spline segment\n    // is added directly to the shape instead of pushing its vertices to\n    // an existing spline segment. However, if we assume addToShape() is called by\n    // splineVertex(), it'd add a new spline segment with only one vertex in that case,\n    // and the check wouldn't be needed yet.\n\n    // TODO: Consider case where positions match but other vertex properties don't.\n    return added;\n  }\n\n  // override method on base class\n  getEndVertex() {\n    if (this._splineProperties.ends === INCLUDE) {\n      return super.getEndVertex();\n    } else if (this._splineProperties.ends === EXCLUDE) {\n      return this.vertices.at(-2);\n    } else {\n      return this.getStartVertex();\n    }\n  }\n\n  getControlPoints() {\n    let points = [];\n\n    if (this._comesAfterSegment) {\n      points.push(this.getStartVertex());\n    }\n    points.push(this.getStartVertex());\n\n    for (const vertex of this.vertices) {\n      points.push(vertex);\n    }\n\n    const prevVertex = this.getStartVertex();\n    if (this._splineProperties.ends === INCLUDE) {\n      points.unshift(prevVertex);\n      points.push(this.vertices.at(-1));\n    } else if (this._splineProperties.ends === JOIN) {\n      points.unshift(this.vertices.at(-1));\n      points.push(prevVertex, this.vertices.at(0));\n    }\n\n    return points;\n  }\n\n  handlesClose() {\n    if (!this._belongsToShape) return false;\n\n    // Only handle closing if the spline is the only thing in its contour after\n    // the anchor\n    const contour = this._shape.at(this._contoursIndex);\n    return contour.primitives.length === 2 && this._primitivesIndex === 1;\n  }\n\n  close() {\n    this._splineProperties.ends = JOIN;\n  }\n}\n\n// ---- ISOLATED PRIMITIVES ----\n\nclass Point extends ShapePrimitive {\n  #vertexCapacity = 1;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitPoint(this);\n  }\n}\n\nclass Line extends ShapePrimitive {\n  #vertexCapacity = 2;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitLine(this);\n  }\n}\n\nclass Triangle extends ShapePrimitive {\n  #vertexCapacity = 3;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitTriangle(this);\n  }\n}\n\nclass Quad extends ShapePrimitive {\n  #vertexCapacity = 4;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitQuad(this);\n  }\n}\n\n// ---- TESSELLATION PRIMITIVES ----\n\nclass TriangleFan extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitTriangleFan(this);\n  }\n}\n\nclass TriangleStrip extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitTriangleStrip(this);\n  }\n}\n\nclass QuadStrip extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitQuadStrip(this);\n  }\n}\n\n// ---- PRIMITIVE SHAPE CREATORS ----\n\nclass PrimitiveShapeCreators {\n  // TODO: make creators private?\n  // That'd probably be better, but for now, it may be convenient to use\n  // native Map properties like size, e.g. for testing, and it's simpler to\n  // not have to wrap all the properties that might be useful\n  creators;\n\n  constructor() {\n    let creators = new Map();\n\n    /* TODO: REFACTOR BASED ON THE CODE BELOW,\n       ONCE CONSTANTS ARE IMPLEMENTED AS SYMBOLS\n\n    // Store Symbols as strings for use in Map keys\n    const EMPTY_PATH = constants.EMPTY_PATH.description;\n    const PATH = constants.PATH.description;\n    //etc.\n\n    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    // etc.\n\n    get(vertexKind, shapeKind) {\n      const key = `${vertexKind}-${shapeKind.description}`;\n      return this.creators.get(key);\n    }\n    // etc.\n    */\n\n    // vertex\n    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    creators.set(`vertex-${PATH}`, (...vertices) => new LineSegment(...vertices));\n    creators.set(`vertex-${POINTS}`, (...vertices) => new Point(...vertices));\n    creators.set(`vertex-${LINES}`, (...vertices) => new Line(...vertices));\n    creators.set(`vertex-${TRIANGLES}`, (...vertices) => new Triangle(...vertices));\n    creators.set(`vertex-${QUADS}`, (...vertices) => new Quad(...vertices));\n    creators.set(`vertex-${TRIANGLE_FAN}`, (...vertices) => new TriangleFan(...vertices));\n    creators.set(`vertex-${TRIANGLE_STRIP}`, (...vertices) => new TriangleStrip(...vertices));\n    creators.set(`vertex-${QUAD_STRIP}`, (...vertices) => new QuadStrip(...vertices));\n\n    // bezierVertex (constructors all take order and vertices so they can be called in a uniform way)\n    creators.set(`bezierVertex-${EMPTY_PATH}`, (order, ...vertices) => new Anchor(...vertices));\n    creators.set(`bezierVertex-${PATH}`, (order, ...vertices) => new BezierSegment(order, ...vertices));\n\n    // splineVertex\n    creators.set(`splineVertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    creators.set(`splineVertex-${PATH}`, (...vertices) => new SplineSegment(...vertices));\n\n    this.creators = creators;\n  }\n\n  get(vertexKind, shapeKind) {\n    const key = `${vertexKind}-${shapeKind}`;\n    return this.creators.get(key);\n  }\n\n  set(vertexKind, shapeKind, creator) {\n    const key = `${vertexKind}-${shapeKind}`;\n    this.creators.set(key, creator);\n  }\n\n  clear() {\n    this.creators.clear();\n  }\n}\n\n// ---- SHAPE ----\n\n/* Note: It's assumed that Shape instances are always built through\n * their beginShape()/endShape() methods. For example, this ensures\n * that a segment is never the first primitive in a contour (paths\n * always start with an anchor), which simplifies code elsewhere.\n */\nclass Shape {\n  #vertexProperties;\n  #initialVertexProperties;\n  #primitiveShapeCreators;\n  #bezierOrder = 3;\n  kind = null;\n  contours = [];\n  _splineProperties = {\n    tightness: 0,\n    ends: INCLUDE\n  };\n  userVertexProperties = null;\n\n  constructor(\n    vertexProperties,\n    primitiveShapeCreators = new PrimitiveShapeCreators()\n  ) {\n    this.#initialVertexProperties = vertexProperties;\n    this.#vertexProperties = vertexProperties;\n    this.#primitiveShapeCreators = primitiveShapeCreators;\n\n    for (const key in this.#vertexProperties) {\n      if (key !== 'position' && key !== 'textureCoordinates') {\n        this[key] = function(value) {\n          this.#vertexProperties[key] = value;\n        };\n      }\n    }\n  }\n\n  serializeToArray(val) {\n    if (val === null || val === undefined) {\n      return [];\n    } if (val instanceof Number) {\n      return [val];\n    } else if (val instanceof Array) {\n      return val;\n    } else if (val.array instanceof Function) {\n      return val.array();\n    } else {\n      throw new Error(`Can't convert ${val} to array!`);\n    }\n  }\n\n  vertexToArray(vertex) {\n    const array = [];\n    for (const key in this.#vertexProperties) {\n      if (this.userVertexProperties && key in this.userVertexProperties)\n        continue;\n      const val = vertex[key];\n      array.push(...this.serializeToArray(val));\n    }\n    for (const key in this.userVertexProperties) {\n      if (key in vertex) {\n        array.push(...this.serializeToArray(vertex[key]));\n      } else {\n        array.push(...new Array(this.userVertexProperties[key]).fill(0));\n      }\n    }\n    return array;\n  }\n\n  hydrateValue(queue, original) {\n    if (original === null) {\n      return null;\n    } else if (original instanceof Number) {\n      return queue.shift();\n    } else if (original instanceof Array) {\n      const array = [];\n      for (let i = 0; i < original.length; i++) {\n        array.push(queue.shift());\n      }\n      return array;\n    } else if (original instanceof Vector) {\n      return new Vector(queue.shift(), queue.shift(), queue.shift());\n    } else if (original instanceof Color) {\n      // NOTE: Not sure what intention here is, `Color` constructor signature\n      // has changed so needed to be reviewed\n      const array = [\n        queue.shift(),\n        queue.shift(),\n        queue.shift(),\n        queue.shift()\n      ];\n      return new Color(array);\n    }\n  }\n\n  arrayToVertex(array) {\n    const vertex = {};\n    const queue = [...array];\n\n    for (const key in this.#vertexProperties) {\n      if (this.userVertexProperties && key in this.userVertexProperties)\n        continue;\n      const original = this.#vertexProperties[key];\n      vertex[key] = this.hydrateValue(queue, original);\n    }\n    for (const key in this.userVertexProperties) {\n      const original = this.#vertexProperties[key];\n      vertex[key] = this.hydrateValue(queue, original);\n    }\n    return vertex;\n  }\n\n  arrayScale(array, scale) {\n    return array.map(v => v * scale);\n  }\n\n  arraySum(first, ...rest) {\n    return first.map((v, i) => {\n      let result = v;\n      for (let j = 0; j < rest.length; j++) {\n        result += rest[j][i];\n      }\n      return result;\n    });\n  }\n\n  arrayMinus(a, b) {\n    return a.map((v, i) => v - b[i]);\n  }\n\n  evaluateCubicBezier([a, b, c, d], t) {\n    return this.arraySum(\n      this.arrayScale(a, Math.pow(1 - t, 3)),\n      this.arrayScale(b, 3 * Math.pow(1 - t, 2) * t),\n      this.arrayScale(c, 3 * (1 - t) * Math.pow(t, 2)),\n      this.arrayScale(d, Math.pow(t, 3))\n    );\n  }\n\n  evaluateQuadraticBezier([a, b, c], t) {\n    return this.arraySum(\n      this.arrayScale(a, Math.pow(1 - t, 2)),\n      this.arrayScale(b, 2 * (1 - t) * t),\n      this.arrayScale(c, t * t)\n    );\n  }\n\n  /*\n  catmullRomToBezier(vertices, tightness)\n\n  Abbreviated description:\n  Converts a Catmull-Rom spline to a sequence of Bezier curveTo points.\n\n  Parameters:\n  vertices -> Array [v0, v1, v2, v3, ...] of at least four vertices\n  tightness -> Number affecting shape of curve\n\n  Returns:\n  array of Bezier curveTo control points, each represented as [c1, c2, c3][]\n\n  TODO:\n  1. It seems p5 contains code for converting from Catmull-Rom to Bezier in at least two places:\n\n  catmullRomToBezier() is based on code in the legacy endShape() function:\n  https://github.com/processing/p5.js/blob/1b66f097761d3c2057c0cec4349247d6125f93ca/src/core/p5.Renderer2D.js#L859C1-L886C1\n\n  A different conversion can be found elsewhere in p5:\n  https://github.com/processing/p5.js/blob/17304ce9e9ef3f967bd828102a51b62a2d39d4f4/src/typography/p5.Font.js#L1179\n\n  A more careful review and comparison of both implementations would be helpful. They're different. I put\n  catmullRomToBezier() together quickly without checking the math/algorithm, when I made the proof of concept\n  for the refactor.\n\n  2. It may be possible to replace the code in p5.Font.js with the code here, to reduce duplication.\n  */\n  catmullRomToBezier(vertices, tightness) {\n    let s = 1 - tightness;\n    let bezArrays = [];\n\n    for (let i = 0; i + 3 < vertices.length; i++) {\n      const [a, b, c, d] = vertices.slice(i, i + 4);\n      const bezB = this.arraySum(\n        b,\n        this.arrayScale(this.arrayMinus(c, a), s / 6)\n      );\n      const bezC = this.arraySum(\n        c,\n        this.arrayScale(this.arrayMinus(b, d), s / 6)\n      );\n      const bezD = c;\n\n      bezArrays.push([bezB, bezC, bezD]);\n    }\n    return bezArrays;\n  }\n\n  // TODO for at() method:\n\n  // RENAME?\n  // -at() indicates it works like Array.prototype.at(), e.g. with negative indices\n  // -get() may work better if we want to add a corresponding set() method\n  // -a set() method could maybe check for problematic usage (e.g. inserting a Triangle into a PATH)\n  // -renaming or removing would necessitate changes at call sites (it's already in use)\n\n  // REFACTOR?\n\n  // TEST\n  at(contoursIndex, primitivesIndex, verticesIndex) {\n    let contour;\n    let primitive;\n\n    contour = this.contours.at(contoursIndex);\n\n    switch(arguments.length) {\n      case 1:\n        return contour;\n      case 2:\n        return contour.primitives.at(primitivesIndex);\n      case 3:\n        primitive = contour.primitives.at(primitivesIndex);\n        return primitive.vertices.at(verticesIndex);\n    }\n  }\n\n  // maybe call this clear() for consistency with PrimitiveShapeCreators.clear()?\n  // note: p5.Geometry has a reset() method, but also clearColors()\n  // looks like reset() isn't in the public reference, so maybe we can switch\n  // everything to clear()? Not sure if reset/clear is used in other classes,\n  // but it'd be good if geometries and shapes are consistent\n  reset() {\n    this.#vertexProperties = { ...this.#initialVertexProperties };\n    this.kind = null;\n    this.contours = [];\n    this.userVertexProperties = null;\n  }\n\n  vertexProperty(name, data) {\n    this.userVertexProperties = this.userVertexProperties || {};\n    const key = this.vertexPropertyKey(name);\n\n    const dataArray = Array.isArray(data) ? data : [data];\n\n    if (!this.userVertexProperties[key]) {\n      this.userVertexProperties[key] = dataArray.length;\n    }\n    this.#vertexProperties[key] = dataArray;\n}\n  vertexPropertyName(key) {\n    return key.replace(/Src$/, '');\n  }\n  vertexPropertyKey(name) {\n    return name + 'Src';\n  }\n\n  bezierOrder(...order) {\n    this.#bezierOrder = order;\n  }\n\n  splineProperty(key, value) {\n    this._splineProperties[key] = value;\n  }\n\n  splineProperties(values) {\n    if (values) {\n      for (const key in values) {\n        this.splineProperty(key, values[key]);\n      }\n    } else {\n      return this._splineProperties;\n    }\n  }\n\n  /*\n  To-do: Maybe refactor #createVertex() since this has side effects that aren't advertised\n  in the method name?\n  */\n  #createVertex(position, textureCoordinates) {\n    this.#vertexProperties.position = position;\n\n    if (textureCoordinates !== undefined) {\n      this.#vertexProperties.textureCoordinates = textureCoordinates;\n    }\n\n    return new Vertex(this.#vertexProperties);\n  }\n\n  #createPrimitiveShape(vertexKind, shapeKind, ...vertices) {\n    let primitiveShapeCreator = this.#primitiveShapeCreators.get(\n      vertexKind, shapeKind\n    );\n\n    return  vertexKind === 'bezierVertex' ?\n      primitiveShapeCreator(this.#bezierOrder, ...vertices) :\n      primitiveShapeCreator(...vertices);\n  }\n\n  /*\n    #generalVertex() is reused by the special vertex functions,\n    including vertex(), bezierVertex(), splineVertex(), and arcVertex():\n\n    It creates a vertex, builds a primitive including that\n    vertex, and has the primitive add itself to the shape.\n  */\n  #generalVertex(kind, position, textureCoordinates) {\n    let vertexKind = kind;\n    let lastContourKind = this.at(-1).kind;\n    let vertex = this.#createVertex(position, textureCoordinates);\n\n    let primitiveShape = this.#createPrimitiveShape(\n      vertexKind,\n      lastContourKind,\n      vertex\n    );\n\n    return primitiveShape.addToShape(this);\n  }\n\n  vertex(position, textureCoordinates, { isClosing = false } = {}) {\n    const added = this.#generalVertex('vertex', position, textureCoordinates);\n    added.isClosing = isClosing;\n  }\n\n  bezierVertex(position, textureCoordinates) {\n    this.#generalVertex('bezierVertex', position, textureCoordinates);\n  }\n\n  splineVertex(position, textureCoordinates) {\n    this.#generalVertex('splineVertex', position, textureCoordinates);\n  }\n\n  arcVertex(position, textureCoordinates) {\n    this.#generalVertex('arcVertex', position, textureCoordinates);\n  }\n\n  beginContour(shapeKind = PATH) {\n    if (this.at(-1)?.kind === EMPTY_PATH) {\n      this.contours.pop();\n    }\n    this.contours.push(new Contour(shapeKind));\n  }\n\n  endContour(closeMode = OPEN, _index = this.contours.length - 1) {\n    const contour = this.at(_index);\n    if (closeMode === CLOSE) {\n      // shape characteristics\n      const isPath = contour.kind === PATH;\n\n      // anchor characteristics\n      const anchorVertex = this.at(_index, 0, 0);\n      const anchorHasPosition = Object.hasOwn(anchorVertex, 'position');\n      const lastSegment = this.at(_index, -1);\n\n      // close path\n      if (isPath && anchorHasPosition) {\n        if (lastSegment.handlesClose()) {\n          lastSegment.close(anchorVertex);\n        } else {\n          // Temporarily remove contours after the current one so that we add to the original\n          // contour again\n          const rest = this.contours.splice(\n            _index + 1,\n            this.contours.length - _index - 1\n          );\n          const prevVertexProperties = this.#vertexProperties;\n          this.#vertexProperties = { ...prevVertexProperties };\n          for (const key in anchorVertex) {\n            if (['position', 'textureCoordinates'].includes(key)) continue;\n            this.#vertexProperties[key] = anchorVertex[key];\n          }\n          this.vertex(\n            anchorVertex.position,\n            anchorVertex.textureCoordinates,\n            { isClosing: true }\n          );\n          this.#vertexProperties = prevVertexProperties;\n          this.contours.push(...rest);\n        }\n      }\n    }\n  }\n\n  beginShape(shapeKind = PATH) {\n    this.kind = shapeKind;\n    // Implicitly start a contour\n    this.beginContour(shapeKind);\n  }\n  /* TO-DO:\n     Refactor?\n     - Might not need anchorHasPosition.\n     - Might combine conditions at top, and rely on shortcircuiting.\n     Does nothing if shape is not a path or has multiple contours. Might discuss this.\n  */\n  endShape(closeMode = OPEN) {\n    if (closeMode === CLOSE) {\n      // Close the first contour, the one implicitly used for shape data\n      // added without an explicit contour\n      this.endContour(closeMode, 0);\n    }\n  }\n\n  accept(visitor) {\n    for (const contour of this.contours) {\n      contour.accept(visitor);\n    }\n  }\n}\n\n// ---- PRIMITIVE VISITORS ----\n\n// abstract class\nclass PrimitiveVisitor {\n  constructor() {\n    if (this.constructor === PrimitiveVisitor) {\n      throw new Error('PrimitiveVisitor is an abstract class: it cannot be instantiated.');\n    }\n  }\n  // path primitives\n  visitAnchor(anchor) {\n    throw new Error('Method visitAnchor() has not been implemented.');\n  }\n  visitLineSegment(lineSegment) {\n    throw new Error('Method visitLineSegment() has not been implemented.');\n  }\n  visitBezierSegment(bezierSegment) {\n    throw new Error('Method visitBezierSegment() has not been implemented.');\n  }\n  visitSplineSegment(curveSegment) {\n    throw new Error('Method visitSplineSegment() has not been implemented.');\n  }\n  visitArcSegment(arcSegment) {\n    throw new Error('Method visitArcSegment() has not been implemented.');\n  }\n\n  // isolated primitives\n  visitPoint(point) {\n    throw new Error('Method visitPoint() has not been implemented.');\n  }\n  visitLine(line) {\n    throw new Error('Method visitLine() has not been implemented.');\n  }\n  visitTriangle(triangle) {\n    throw new Error('Method visitTriangle() has not been implemented.');\n  }\n  visitQuad(quad) {\n    throw new Error('Method visitQuad() has not been implemented.');\n  }\n\n  // tessellation primitives\n  visitTriangleFan(triangleFan) {\n    throw new Error('Method visitTriangleFan() has not been implemented.');\n  }\n  visitTriangleStrip(triangleStrip) {\n    throw new Error('Method visitTriangleStrip() has not been implemented.');\n  }\n  visitQuadStrip(quadStrip) {\n    throw new Error('Method visitQuadStrip() has not been implemented.');\n  }\n}\n\n// requires testing\nclass PrimitiveToPath2DConverter extends PrimitiveVisitor {\n  path = new Path2D();\n  strokeWeight;\n\n  constructor({ strokeWeight }) {\n    super();\n    this.strokeWeight = strokeWeight;\n  }\n\n  // path primitives\n  visitAnchor(anchor) {\n    let vertex = anchor.getEndVertex();\n    this.path.moveTo(vertex.position.x, vertex.position.y);\n  }\n  visitLineSegment(lineSegment) {\n    if (lineSegment.isClosing) {\n      // The same as lineTo, but it adds a stroke join between this\n      // and the starting vertex rather than having two caps\n      this.path.closePath();\n    } else {\n      let vertex = lineSegment.getEndVertex();\n      this.path.lineTo(vertex.position.x, vertex.position.y);\n    }\n  }\n  visitBezierSegment(bezierSegment) {\n    let [v1, v2, v3] = bezierSegment.vertices;\n\n    switch (bezierSegment.order) {\n      case 2:\n        this.path.quadraticCurveTo(\n          v1.position.x,\n          v1.position.y,\n          v2.position.x,\n          v2.position.y\n        );\n        break;\n      case 3:\n        this.path.bezierCurveTo(\n          v1.position.x,\n          v1.position.y,\n          v2.position.x,\n          v2.position.y,\n          v3.position.x,\n          v3.position.y\n        );\n        break;\n    }\n  }\n  visitSplineSegment(splineSegment) {\n    const shape = splineSegment._shape;\n\n    if (\n      splineSegment._splineProperties.ends === EXCLUDE &&\n      !splineSegment._comesAfterSegment\n    ) {\n      let startVertex = splineSegment._firstInterpolatedVertex;\n      this.path.moveTo(startVertex.position.x, startVertex.position.y);\n    }\n\n    const arrayVertices = splineSegment.getControlPoints().map(\n      v => shape.vertexToArray(v)\n    );\n    let bezierArrays = shape.catmullRomToBezier(\n      arrayVertices,\n      splineSegment._splineProperties.tightness\n    ).map(arr => arr.map(vertArr => shape.arrayToVertex(vertArr)));\n    for (const array of bezierArrays) {\n      const points = array.flatMap(vert => [vert.position.x, vert.position.y]);\n      this.path.bezierCurveTo(...points);\n    }\n  }\n  visitPoint(point) {\n    const { x, y } = point.vertices[0].position;\n    this.path.moveTo(x, y);\n    // Hack: to draw just strokes and not fills, draw a very very tiny line\n    this.path.lineTo(x + 0.00001, y);\n  }\n  visitLine(line) {\n    const { x: x0, y: y0 } = line.vertices[0].position;\n    const { x: x1, y: y1 } = line.vertices[1].position;\n    this.path.moveTo(x0, y0);\n    this.path.lineTo(x1, y1);\n  }\n  visitTriangle(triangle) {\n    const [v0, v1, v2] = triangle.vertices;\n    this.path.moveTo(v0.position.x, v0.position.y);\n    this.path.lineTo(v1.position.x, v1.position.y);\n    this.path.lineTo(v2.position.x, v2.position.y);\n    this.path.closePath();\n  }\n  visitQuad(quad) {\n    const [v0, v1, v2, v3] = quad.vertices;\n    this.path.moveTo(v0.position.x, v0.position.y);\n    this.path.lineTo(v1.position.x, v1.position.y);\n    this.path.lineTo(v2.position.x, v2.position.y);\n    this.path.lineTo(v3.position.x, v3.position.y);\n    this.path.closePath();\n  }\n  visitTriangleFan(triangleFan) {\n    const [v0, ...rest] = triangleFan.vertices;\n    for (let i = 0; i < rest.length - 1; i++) {\n      const v1 = rest[i];\n      const v2 = rest[i + 1];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n  visitTriangleStrip(triangleStrip) {\n    for (let i = 0; i < triangleStrip.vertices.length - 2; i++) {\n      const v0 = triangleStrip.vertices[i];\n      const v1 = triangleStrip.vertices[i + 1];\n      const v2 = triangleStrip.vertices[i + 2];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n  visitQuadStrip(quadStrip) {\n    for (let i = 0; i < quadStrip.vertices.length - 3; i += 2) {\n      const v0 = quadStrip.vertices[i];\n      const v1 = quadStrip.vertices[i + 1];\n      const v2 = quadStrip.vertices[i + 2];\n      const v3 = quadStrip.vertices[i + 3];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      // These are intentionally out of order to go around the quad\n      this.path.lineTo(v3.position.x, v3.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n}\n\nclass PrimitiveToVerticesConverter extends PrimitiveVisitor {\n  contours = [];\n  curveDetail;\n\n  constructor({ curveDetail = 1 } = {}) {\n    super();\n    this.curveDetail = curveDetail;\n  }\n\n  lastContour() {\n    return this.contours[this.contours.length - 1];\n  }\n\n  visitAnchor(anchor) {\n    this.contours.push([]);\n    // Weird edge case: if the next segment is a spline, we might\n    // need to jump to a different vertex.\n    const next = anchor._nextPrimitive;\n    if (next?.canOverrideAnchor) {\n      this.lastContour().push(next._firstInterpolatedVertex);\n    } else {\n      this.lastContour().push(anchor.getEndVertex());\n    }\n  }\n  visitLineSegment(lineSegment) {\n    this.lastContour().push(lineSegment.getEndVertex());\n  }\n  visitBezierSegment(bezierSegment) {\n    const contour = this.lastContour();\n    const numPoints = Math.max(\n      1,\n      Math.ceil(bezierSegment.hullLength() * this.curveDetail)\n    );\n    const vertexArrays = [\n      bezierSegment.getStartVertex(),\n      ...bezierSegment.vertices\n    ].map(v => bezierSegment._shape.vertexToArray(v));\n    for (let i = 0; i < numPoints; i++) {\n      const t = (i + 1) / numPoints;\n      contour.push(\n        bezierSegment._shape.arrayToVertex(\n          bezierSegment.order === 3\n            ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t)\n            : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t)\n        )\n      );\n    }\n  }\n  visitSplineSegment(splineSegment) {\n    const shape = splineSegment._shape;\n    const contour = this.lastContour();\n\n    const arrayVertices = splineSegment.getControlPoints().map(\n      v => shape.vertexToArray(v)\n    );\n    let bezierArrays = shape.catmullRomToBezier(\n      arrayVertices,\n      splineSegment._splineProperties.tightness\n    );\n    let startVertex = shape.vertexToArray(splineSegment._firstInterpolatedVertex);\n    for (const array of bezierArrays) {\n      const bezierControls = [startVertex, ...array];\n      const numPoints = Math.max(\n        1,\n        Math.ceil(\n          polylineLength(bezierControls.map(v => shape.arrayToVertex(v))) *\n          this.curveDetail\n        )\n      );\n      for (let i = 0; i < numPoints; i++) {\n        const t = (i + 1) / numPoints;\n        contour.push(\n          shape.arrayToVertex(shape.evaluateCubicBezier(bezierControls, t))\n        );\n      }\n      startVertex = array[2];\n    }\n  }\n  visitPoint(point) {\n    this.contours.push(point.vertices.slice());\n  }\n  visitLine(line) {\n    this.contours.push(line.vertices.slice());\n  }\n  visitTriangle(triangle) {\n    this.contours.push(triangle.vertices.slice());\n  }\n  visitQuad(quad) {\n    this.contours.push(quad.vertices.slice());\n  }\n  visitTriangleFan(triangleFan) {\n    // WebGL itself interprets the vertices as a fan, no reformatting needed\n    this.contours.push(triangleFan.vertices.slice());\n  }\n  visitTriangleStrip(triangleStrip) {\n    // WebGL itself interprets the vertices as a strip, no reformatting needed\n    this.contours.push(triangleStrip.vertices.slice());\n  }\n  visitQuadStrip(quadStrip) {\n    // WebGL itself interprets the vertices as a strip, no reformatting needed\n    this.contours.push(quadStrip.vertices.slice());\n  }\n}\n\nclass PointAtLengthGetter extends PrimitiveVisitor {\n  constructor() {\n    super();\n  }\n}\n\nfunction customShapes(p5, fn) {\n  // ---- GENERAL CLASSES ----\n\n  /**\n     * @private\n     * A class to describe a custom shape made with `beginShape()`/`endShape()`.\n     *\n     * Every `Shape` has a `kind`. The kind takes any value that\n     * can be passed to <a href=\"#/p5/beginShape\">beginShape()</a>:\n     *\n     * - `PATH`\n     * - `POINTS`\n     * - `LINES`\n     * - `TRIANGLES`\n     * - `QUADS`\n     * - `TRIANGLE_FAN`\n     * - `TRIANGLE_STRIP`\n     * - `QUAD_STRIP`\n     *\n     * A `Shape` of any kind consists of `contours`, which can be thought of as\n     * subshapes (shapes inside another shape). Each `contour` is built from\n     * basic shapes called primitives, and each primitive consists of one or more vertices.\n     *\n     * For example, a square can be made from a single path contour with four line-segment\n     * primitives. Each line segment contains a vertex that indicates its endpoint. A square\n     * with a circular hole in it contains the circle in a separate contour.\n     *\n     * By default, each vertex only has a position, but a shape's vertices may have other\n     * properties such as texture coordinates, a normal vector, a fill color, and a stroke color.\n     * The properties every vertex should have may be customized by passing `vertexProperties` to\n     * `createShape()`.\n     *\n     * Once a shape is created and given a name like `myShape`, it can be built up with\n     * methods such as `myShape.beginShape()`, `myShape.vertex()`, and `myShape.endShape()`.\n     *\n     * Vertex functions such as `vertex()` or `bezierVertex()` are used to set the `position`\n     * property of vertices, as well as the `textureCoordinates` property if applicable. Those\n     * properties only apply to a single vertex.\n     *\n     * If `vertexProperties` includes other properties, they are each set by a method of the\n     * same name. For example, if vertices in `myShape` have a `fill`, then that is set with\n     * `myShape.fill()`. In the same way that a <a href=\"#/p5/fill\">fill()</a> may be applied\n     * to one or more shapes, `myShape.fill()` may be applied to one or more vertices.\n     *\n     * @class p5.Shape\n     * @param {Object} [vertexProperties={position: createVector(0, 0)}] vertex properties and their initial values.\n     */\n\n  p5.Shape = Shape;\n\n  /**\n     * @private\n     * A class to describe a contour made with `beginContour()`/`endContour()`.\n     *\n     * Contours may be thought of as shapes inside of other shapes.\n     * For example, a contour may be used to create a hole in a shape that is created\n     * with <a href=\"#/p5/beginShape\">beginShape()</a>/<a href=\"#/p5/endShape\">endShape()</a>.\n     * Multiple contours may be included inside a single shape.\n     *\n     * Contours can have any `kind` that a shape can have:\n     *\n     * - `PATH`\n     * - `POINTS`\n     * - `LINES`\n     * - `TRIANGLES`\n     * - `QUADS`\n     * - `TRIANGLE_FAN`\n     * - `TRIANGLE_STRIP`\n     * - `QUAD_STRIP`\n     *\n     * By default, a contour has the same kind as the shape that contains it, but this\n     * may be changed by passing a different `kind` to <a href=\"#/p5/beginContour\">beginContour()</a>.\n     *\n     * A `Contour` of any kind consists of `primitives`, which are the most basic\n     * shapes that can be drawn. For example, if a contour is a hexagon, then\n     * it's made from six line-segment primitives.\n     *\n     * @class p5.Contour\n     */\n\n  p5.Contour = Contour;\n\n  /**\n     * @private\n     * A base class to describe a shape primitive (a basic shape drawn with\n     * `beginShape()`/`endShape()`).\n     *\n     * Shape primitives are the most basic shapes that can be drawn with\n     * <a href=\"#/p5/beginShape\">beginShape()</a>/<a href=\"#/p5/endShape\">endShape()</a>:\n     *\n     * - segment primitives: line segments, bezier segments, spline segments, and arc segments\n     * - isolated primitives: points, lines, triangles, and quads\n     * - tessellation primitives: triangle fans, triangle strips, and quad strips\n     *\n     * More complex shapes may be created by combining many primitives, possibly of different kinds,\n     * into a single shape.\n     *\n     * In a similar way, every shape primitive is built from one or more vertices.\n     * For example, a point consists of a single vertex, while a triangle consists of three vertices.\n     * Each type of shape primitive has a `vertexCapacity`, which may be `Infinity` (for example, a\n     * spline may consist of any number of vertices). A primitive's `vertexCount` is the number of\n     * vertices it currently contains.\n     *\n     * Each primitive can add itself to a shape with an `addToShape()` method.\n     *\n     * It can also accept visitor objects with an `accept()` method. When a primitive accepts a visitor,\n     * it gives the visitor access to its vertex data. For example, one visitor to a segment might turn\n     * the data into 2D drawing instructions. Another might find a point at a given distance\n     * along the segment.\n     *\n     * @class p5.ShapePrimitive\n     * @abstract\n     */\n\n  p5.ShapePrimitive = ShapePrimitive;\n\n  /**\n     * @private\n     * A class to describe a vertex (a point on a shape), in 2D or 3D.\n     *\n     * Vertices are the basic building blocks of all `p5.Shape` objects, including\n     * shapes made with <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/arcVertex\">arcVertex()</a>,\n     * <a href=\"#/p5/bezierVertex\">bezierVertex()</a>, and <a href=\"#/p5/splineVertex\">splineVertex()</a>.\n     *\n     * Like a point on an object in the real world, a vertex may have different properties.\n     * These may include coordinate properties such as `position`, `textureCoordinates`, and `normal`,\n     * color properties such as `fill` and `stroke`, and more.\n     *\n     * A vertex called `myVertex` with position coordinates `(2, 3, 5)` and a green stroke may be created\n     * like this:\n     *\n     * ```js\n     * let myVertex = new p5.Vertex({\n     *   position: createVector(2, 3, 5),\n     *   stroke: color('green')\n     * });\n     * ```\n     *\n     * Any property names may be used. The `p5.Shape` class assumes that if a vertex has a\n     * position or texture coordinates, they are stored in `position` and `textureCoordinates`\n     * properties.\n     *\n     * Property values may be any\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">JavaScript primitive</a>, any\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer\">object literal</a>,\n     * or any object with an `array` property.\n     *\n     * For example, if a position is stored as a `p5.Vector` object and a stroke is stored as a `p5.Color` object,\n     * then the `array` properties of those objects will be used by the vertex's own `array` property, which provides\n     * all the vertex data in a single array.\n     *\n     * @class p5.Vertex\n     * @param {Object} [properties={position: createVector(0, 0)}] vertex properties.\n     */\n\n  p5.Vertex = Vertex;\n\n  // ---- PATH PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.Anchor\n     * @extends p5.ShapePrimitive\n     * @param {p5.Vertex} vertex the vertex to include in the anchor.\n     */\n\n  p5.Anchor = Anchor;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * Note: When a segment is added to a shape, it's attached to an anchor or another segment.\n     * Adding it to another shape may result in unexpected behavior.\n     *\n     * @class p5.Segment\n     * @extends p5.ShapePrimitive\n     * @param {...p5.Vertex} vertices the vertices to include in the segment.\n     */\n\n  p5.Segment = Segment;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.LineSegment\n     * @param {p5.Vertex} vertex the vertex to include in the anchor.\n     */\n\n  p5.LineSegment = LineSegment;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.BezierSegment = BezierSegment;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.SplineSegment = SplineSegment;\n\n  // ---- ISOLATED PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Point = Point;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.Line\n     * @param {...p5.Vertex} vertices the vertices to include in the line.\n     */\n\n  p5.Line = Line;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Triangle = Triangle;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Quad = Quad;\n\n  // ---- TESSELLATION PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.TriangleFan = TriangleFan;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.TriangleStrip = TriangleStrip;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.QuadStrip = QuadStrip;\n\n  // ---- PRIMITIVE VISITORS ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PrimitiveVisitor = PrimitiveVisitor;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * Notes:\n     * 1. Assumes vertex positions are stored as p5.Vector instances.\n     * 2. Currently only supports position properties of vectors.\n     */\n\n  p5.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PointAtLengthGetter = PointAtLengthGetter;\n\n  // ---- FUNCTIONS ----\n\n\n  /**\n   * Influences the shape of the BÃ©zier curve segment in a custom shape.\n   * By default, this is 3; the other possible parameter is 2. This\n   * results in quadratic BÃ©zier curves.\n   *\n   * `bezierVertex()` adds a curved segment to custom shapes. The BÃ©zier curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/bezier\">bezier()</a> function. `bezierVertex()` must be\n   * called between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions. There must be at least\n   * one call to <a href=\"#/p5/vertex\">bezierVertex()</a>, before\n   * a number of `bezierVertex()` calls that is a multiple of the parameter\n   * set by <a href=\"#/p5/bezierOrder\">bezierOrder(...)</a> (default 3).\n   * \n   * Each curve of order 3 requires three calls to `bezierVertex`, so\n   * 2 curves would need 7 calls to `bezierVertex()`:\n   * (1 one initial anchor point, two sets of 3 curves describing the curves)\n   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2. \n   *\n   * BÃ©zier curves can also be drawn in 3D using WebGL mode.\n   *\n   * Note: `bezierVertex()` wonâ€™t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method bezierOrder\n   * @param {Number} order The new order to set. Can be either 2 or 3, by default 3\n   * \n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   * \n   *   // set the order to 2 for a quadratic BÃ©zier curve\n   *   bezierOrder(2);\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the BÃ©zier vertex.\n   *   bezierVertex(80, 20);\n   *   bezierVertex(50, 50);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A black curve drawn on a gray square. The curve starts at the top-left corner and ends at the center.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method bezierOrder\n   * @returns {Number} The current BÃ©zier order.\n   */\n  fn.bezierOrder = function(order) {\n    return this._renderer.bezierOrder(order);\n  };\n\n\n/**\n   * Adds a spline curve segment to a custom shape.\n   *\n   * `splineVertex()` adds a curved segment to custom shapes. The spline curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/curve\">curve()</a> function. `splineVertex()` must be called\n   * between the <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   *\n   * Spline curves can form shapes and curves that slope gently. Theyâ€™re like\n   * cables that are attached to a set of points. Splines are defined by two\n   * anchor points and two control points. `splineVertex()` must be called at\n   * least four times between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> in order to draw a curve:\n   *\n   * ```js\n   * beginShape();\n   *\n   * // Add the first control point.\n   * splineVertex(84, 91);\n   *\n   * // Add the anchor points to draw between.\n   * splineVertex(68, 19);\n   * splineVertex(21, 17);\n   *\n   * // Add the second control point.\n   * splineVertex(32, 91);\n   *\n   * endShape();\n   * ```\n   *\n   * The code snippet above would only draw the curve between the anchor points,\n   * similar to the <a href=\"#/p5/curve\">curve()</a> function. The segments\n   * between the control and anchor points can be drawn by calling\n   * `splineVertex()` with the coordinates of the control points:\n   *\n   * ```js\n   * beginShape();\n   *\n   * // Add the first control point and draw a segment to it.\n   * splineVertex(84, 91);\n   * splineVertex(84, 91);\n   *\n   * // Add the anchor points to draw between.\n   * splineVertex(68, 19);\n   * splineVertex(21, 17);\n   *\n   * // Add the second control point.\n   * splineVertex(32, 91);\n   *\n   * // Uncomment the next line to draw the segment to the second control point.\n   * // splineVertex(32, 91);\n   *\n   * endShape();\n   * ```\n   *\n   * The first two parameters, `x` and `y`, set the vertexâ€™s location. For\n   * example, calling `splineVertex(10, 10)` adds a point to the curve at\n   * `(10, 10)`.\n   *\n   * Spline curves can also be drawn in 3D using WebGL mode. The 3D version of\n   * `splineVertex()` has three arguments because each point has x-, y-, and\n   * z-coordinates. By default, the vertexâ€™s z-coordinate is set to 0.\n   *\n   * Note: `splineVertex()` wonâ€™t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method splineVertex\n   * @param {Number} x x-coordinate of the vertex\n   * @param {Number} y y-coordinate of the vertex\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point.\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point.\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(32, 91);\n   *   point(84, 91);\n   *\n   *   describe(\n   *     'A black curve drawn on a gray background. The curve has black dots at its ends. Two red dots appear near the bottom of the canvas.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(32, 91);\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point.\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(32, 91);\n   *   point(84, 91);\n   *\n   *   describe(\n   *     'A black curve drawn on a gray background. The curve passes through one red dot and two black dots. Another red dot appears near the bottom of the canvas.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(32, 91);\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point and draw a segment to it.\n   *   splineVertex(84, 91);\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(32, 91);\n   *   point(84, 91);\n   *\n   *   describe(\n   *     'A black U curve drawn upside down on a gray background. The curve passes from one red dot through two black dots and ends at another red dot.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the mouse near the red dot in the bottom-left corner\n   * // and drag to change the curve's shape.\n   *\n   * let x1 = 32;\n   * let y1 = 91;\n   * let isChanging = false;\n   *\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe(\n   *     'A black U curve drawn upside down on a gray background. The curve passes from one red dot through two black dots and ends at another red dot.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(x1, y1);\n   *   splineVertex(x1, y1);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point and draw a segment to it.\n   *   splineVertex(84, 91);\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(x1, y1);\n   *   point(84, 91);\n   * }\n   *\n   * // Start changing the first control point if the user clicks near it.\n   * function mousePressed() {\n   *   if (dist(mouseX, mouseY, x1, y1) < 20) {\n   *     isChanging = true;\n   *   }\n   * }\n   *\n   * // Stop changing the first control point when the user releases the mouse.\n   * function mouseReleased() {\n   *   isChanging = false;\n   * }\n   *\n   * // Update the first control point while the user drags the mouse.\n   * function mouseDragged() {\n   *   if (isChanging === true) {\n   *     x1 = mouseX;\n   *     y1 = mouseY;\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(32, 91);\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point.\n   *   splineVertex(84, 91);\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A ghost shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} [z] z-coordinate of the vertex.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A ghost shape drawn in white on a blue background. When the user drags the mouse, the scene rotates to reveal the outline of a second ghost.');\n   * }\n   *\n   * function draw() {\n   *   background('midnightblue');\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the first ghost.\n   *   noStroke();\n   *   fill('ghostwhite');\n   *\n   *   beginShape();\n   *   splineVertex(-28, 41, 0);\n   *   splineVertex(-28, 41, 0);\n   *   splineVertex(-29, -33, 0);\n   *   splineVertex(18, -31, 0);\n   *   splineVertex(34, 41, 0);\n   *   splineVertex(34, 41, 0);\n   *   endShape();\n   *\n   *   // Draw the second ghost.\n   *   noFill();\n   *   stroke('ghostwhite');\n   *\n   *   beginShape();\n   *   splineVertex(-28, 41, -20);\n   *   splineVertex(-28, 41, -20);\n   *   splineVertex(-29, -33, -20);\n   *   splineVertex(18, -31, -20);\n   *   splineVertex(34, 41, -20);\n   *   splineVertex(34, 41, -20);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} [u=0]\n   * @param {Number} [v=0]\n   */\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} z\n   * @param {Number} [u=0]\n   * @param {Number} [v=0]\n   */\n  fn.splineVertex = function(...args) {\n    let x = 0, y = 0, z = 0, u = 0, v = 0;\n    if (args.length === 2) {\n      [x, y] = args;\n    } else if (args.length === 4) {\n      [x, y, u, v] = args;\n    } else if (args.length === 3) {\n      [x, y, z] = args;\n    } else if (args.length === 5) {\n      [x, y, z, u, v] = args;\n    }\n    this._renderer.splineVertex(x, y, z, u, v);\n  };\n\n  /**\n   * Sets the property of a curve.\n   * \n   * For example, set tightness,\n   * use `splineProperty('tightness', t)`, with `t` between 0 and 1,\n   * at 0 as default.\n   * \n   * Spline curves are like cables that are attached to a set of points.\n   * Adjusting tightness adjusts how tightly the cable is\n   * attached to the points. The parameter, tightness, determines\n   * how the curve fits to the vertex points. By default,\n   * tightness is set to 0. Setting tightness to 1, as in\n   * `splineProperty('tightness', 1)`, connects the curve's points\n   * using straight lines. Values in the range from â€“5 to 5\n   * deform curves while leaving them recognizable.\n   * \n   * This function can also be used to set 'ends' property\n   * (see also: the <a href=\"#/p5/curveDetail\">curveDetail()</a> example),\n   * such as: `splineProperty('ends', EXCLUDE)` to exclude\n   * vertices, or `splineProperty('ends', INCLUDE)` to include them.\n   * \n   * @method splineProperty\n   * @param {String} property\n   * @param value Value to set the given property to.\n   * \n   * @example\n   * <div>\n   * <code>\n   * // Move the mouse left and right to see the curve change.\n   * \n   * function setup() {\n   *   createCanvas(100, 100);\n   *   describe('A black curve forms a sideways U shape. The curve deforms as the user moves the mouse from left to right');\n   * }\n   * \n   * function draw() {\n   *   background(200);\n   * \n   *   // Set the curve's tightness using the mouse.\n   *   let t = map(mouseX, 0, 100, -5, 5, true);\n   *   splineProperty('tightness', t);\n   * \n   *   // Draw the curve.\n   *   noFill();\n   *   beginShape();\n   *   splineVertex(10, 26);\n   *   splineVertex(10, 26);\n   *   splineVertex(83, 24);\n   *   splineVertex(83, 61);\n   *   splineVertex(25, 65);\n   *   splineVertex(25, 65);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method splineProperty\n   * @param {String} property\n   * @returns The current value for the given property.\n   */\n  fn.splineProperty = function(property, value) {\n    return this._renderer.splineProperty(property, value);\n  };\n\n  /**\n   * Get or set multiple spline properties at once.\n   * \n   * Similar to <a href=\"#/p5/splineProperty\">splineProperty()</a>:\n   * `splineProperty('tightness', t)` is the same as\n   * `splineProperties({'tightness': t})`\n   * \n   * @method splineProperties\n   * @param {Object} properties An object containing key-value pairs to set.\n   */\n  /**\n   * @method splineProperties\n   * @returns {Object} The current spline properties.\n   */\n  fn.splineProperties = function(values) {\n    return this._renderer.splineProperties(values);\n  };\n\n  /**\n   * Adds a vertex to a custom shape.\n   *\n   * `vertex()` sets the coordinates of vertices drawn between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   *\n   * The first two parameters, `x` and `y`, set the x- and y-coordinates of the\n   * vertex.\n   *\n   * The third parameter, `z`, is optional. It sets the z-coordinate of the\n   * vertex in WebGL mode. By default, `z` is 0.\n   *\n   * The fourth and fifth parameters, `u` and `v`, are also optional. They set\n   * the u- and v-coordinates for the vertexâ€™s texture when used with\n   * <a href=\"#/p5/endShape\">endShape()</a>. By default, `u` and `v` are both 0.\n   *\n   * @method vertex\n   * @param  {Number} x x-coordinate of the vertex.\n   * @param  {Number} y y-coordinate of the vertex.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   strokeWeight(3);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw the vertices.\n   *   beginShape(POINTS);\n   *\n   *   // Add the vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four black dots that form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0);\n   *   vertex(35, -30, 0);\n   *   vertex(35, 25, 0);\n   *   vertex(-20, 25, 0);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around slowly on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0);\n   *   vertex(35, -30, 0);\n   *   vertex(35, 25, 0);\n   *   vertex(-20, 25, 0);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load an image to apply as a texture.\n   *   img = await loadImage('assets/laDefense.jpg');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A photograph of a ceiling rotates slowly against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *\n   *   // Apply the texture.\n   *   texture(img);\n   *   textureMode(NORMAL);\n   *\n   *   // Start drawing the shape\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0, 0, 0);\n   *   vertex(35, -30, 0, 1, 0);\n   *   vertex(35, 25, 0, 1, 1);\n   *   vertex(-20, 25, 0, 0, 1);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   * \n   * <div>\n   * <code>\n   * let vid;\n   * function setup() {\n   *   // Load a video and create a p5.MediaElement object.\n   *   vid = createVideo('/assets/fingers.mov');\n   *   createCanvas(100, 100, WEBGL);\n   * \n   *   // Hide the video.\n   *   vid.hide();\n   * \n   *   // Set the video to loop.\n   *   vid.loop();\n   * \n   *   describe('A rectangle with video as texture');\n   * }\n   * \n   * function draw() {\n   *   background(0);\n   * \n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   * \n   *   // Set the texture mode.\n   *   textureMode(NORMAL);\n   * \n   *   // Apply the video as a texture.\n   *   texture(vid);\n   * \n   *   // Draw a custom shape using uv coordinates.\n   *   beginShape();\n   *   vertex(-40, -40, 0, 0);\n   *   vertex(40, -40, 1, 0);\n   *   vertex(40, 40, 1, 1);\n   *   vertex(-40, 40, 0, 1);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method vertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.\n   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.\n   */\n  /**\n   * @method vertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} z\n   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.\n   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.\n   */\n  fn.vertex = function(x, y) {\n    let z, u, v;\n\n    // default to (x, y) mode: all other arguments assumed to be 0.\n    z = u = v = 0;\n\n    if (arguments.length === 3) {\n      // (x, y, z) mode: (u, v) assumed to be 0.\n      z = arguments[2];\n    } else if (arguments.length === 4) {\n      // (x, y, u, v) mode: z assumed to be 0.\n      u = arguments[2];\n      v = arguments[3];\n    } else if (arguments.length === 5) {\n      // (x, y, z, u, v) mode\n      z = arguments[2];\n      u = arguments[3];\n      v = arguments[4];\n    }\n    this._renderer.vertex(x, y, z, u, v);\n    return;\n  };\n\n  /**\n   * Begins creating a hole within a flat shape.\n   *\n   * The `beginContour()` and <a href=\"#/p5/endContour\">endContour()</a>\n   * functions allow for creating negative space within custom shapes that are\n   * flat. `beginContour()` begins adding vertices to a negative space and\n   * <a href=\"#/p5/endContour\">endContour()</a> stops adding them.\n   * `beginContour()` and <a href=\"#/p5/endContour\">endContour()</a> must be\n   * called between <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and <a href=\"#/p5/scale\">scale()</a>\n   * don't work between `beginContour()` and\n   * <a href=\"#/p5/endContour\">endContour()</a>. It's also not possible to use\n   * other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between `beginContour()` and\n   * <a href=\"#/p5/endContour\">endContour()</a>.\n   *\n   * Note: The vertices that define a negative space must \"wind\" in the opposite\n   * direction from the outer shape. First, draw vertices for the outer shape\n   * clockwise order. Then, draw vertices for the negative space in\n   * counter-clockwise order.\n   *\n   * @method beginContour\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(10, 10);\n   *   vertex(90, 10);\n   *   vertex(90, 90);\n   *   vertex(10, 90);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(30, 30);\n   *   vertex(30, 70);\n   *   vertex(70, 70);\n   *   vertex(70, 30);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(-40, -40);\n   *   vertex(40, -40);\n   *   vertex(40, 40);\n   *   vertex(-40, 40);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(-20, -20);\n   *   vertex(-20, 20);\n   *   vertex(20, 20);\n   *   vertex(20, -20);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.beginContour = function(kind) {\n    this._renderer.beginContour(kind);\n  };\n\n  /**\n   * Stops creating a hole within a flat shape. \n   *\n   * The <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()`\n   * functions allow for creating negative space within custom shapes that are\n   * flat. <a href=\"#/p5/beginContour\">beginContour()</a> begins adding vertices\n   * to a negative space and `endContour()` stops adding them.\n   * <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()` must be\n   * called between <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   *  By default, \n   * the controur has an `OPEN` end, and to close it,\n   * call `endContour(CLOSE)`. The CLOSE contour mode closes splines smoothly.\n   * \n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and <a href=\"#/p5/scale\">scale()</a>\n   * don't work between <a href=\"#/p5/beginContour\">beginContour()</a> and\n   * `endContour()`. It's also not possible to use other shapes, such as\n   * <a href=\"#/p5/ellipse\">ellipse()</a> or <a href=\"#/p5/rect\">rect()</a>,\n   * between <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()`.\n   *\n   * Note: The vertices that define a negative space must \"wind\" in the opposite\n   * direction from the outer shape. First, draw vertices for the outer shape\n   * clockwise order. Then, draw vertices for the negative space in\n   * counter-clockwise order.\n   *\n   * @method endContour\n   * @param {OPEN|CLOSE} [mode=OPEN] By default, the value is OPEN\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(10, 10);\n   *   vertex(90, 10);\n   *   vertex(90, 90);\n   *   vertex(10, 90);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(30, 30);\n   *   vertex(30, 70);\n   *   vertex(70, 70);\n   *   vertex(70, 30);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(-40, -40);\n   *   vertex(40, -40);\n   *   vertex(40, 40);\n   *   vertex(-40, 40);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(-20, -20);\n   *   vertex(-20, 20);\n   *   vertex(20, 20);\n   *   vertex(20, -20);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.endContour = function(mode = OPEN) {\n    this._renderer.endContour(mode);\n  };\n}\n\nif (typeof p5 !== 'undefined') {\n  customShapes(p5, p5.prototype);\n}\n\nexport { Anchor, BezierSegment, Contour, Line, LineSegment, Point, PointAtLengthGetter, PrimitiveToPath2DConverter, PrimitiveToVerticesConverter, PrimitiveVisitor, Quad, QuadStrip, Segment, Shape, ShapePrimitive, SplineSegment, Triangle, TriangleFan, TriangleStrip, Vertex, customShapes as default };\n"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEoI,EAAE,CAAC3M,OAAO,GAAGA,OAAO;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE2M,EAAE,CAAC3O,cAAc,GAAGA,cAAc;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE2O,EAAE,CAAClP,MAAM,GAAGA,MAAM;;EAElB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEkP,EAAE,CAACtM,MAAM,GAAGA,MAAM;;EAElB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEsM,EAAE,CAACnM,OAAO,GAAGA,OAAO;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;;EAEEmM,EAAE,CAAChM,WAAW,GAAGA,WAAW;;EAE5B;AACF;AACA;AACA;;EAEEgM,EAAE,CAAC9L,aAAa,GAAGA,aAAa;;EAEhC;AACF;AACA;AACA;;EAEE8L,EAAE,CAACrL,aAAa,GAAGA,aAAa;;EAEhC;;EAEA;AACF;AACA;AACA;;EAEEqL,EAAE,CAAC3J,KAAK,GAAGA,KAAK;;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE2J,EAAE,CAACzJ,IAAI,GAAGA,IAAI;;EAEd;AACF;AACA;AACA;;EAEEyJ,EAAE,CAACvJ,QAAQ,GAAGA,QAAQ;;EAEtB;AACF;AACA;AACA;;EAEEuJ,EAAE,CAACrJ,IAAI,GAAGA,IAAI;;EAEd;;EAEA;AACF;AACA;AACA;;EAEEqJ,EAAE,CAACnJ,WAAW,GAAGA,WAAW;;EAE5B;AACF;AACA;AACA;;EAEEmJ,EAAE,CAACjJ,aAAa,GAAGA,aAAa;;EAEhC;AACF;AACA;AACA;;EAEEiJ,EAAE,CAAC/I,SAAS,GAAGA,SAAS;;EAExB;;EAEA;AACF;AACA;AACA;;EAEE+I,EAAE,CAAClD,gBAAgB,GAAGA,gBAAgB;;EAEtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEkD,EAAE,CAACpC,0BAA0B,GAAGA,0BAA0B;;EAE1D;AACF;AACA;AACA;;EAEEoC,EAAE,CAACV,4BAA4B,GAAGA,4BAA4B;;EAE9D;AACF;AACA;AACA;;EAEEU,EAAE,CAACF,mBAAmB,GAAGA,mBAAmB;;EAE5C;;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;EACEG,EAAE,CAACjI,WAAW,GAAG,UAAS7D,KAAK,EAAE;IAC/B,OAAO,IAAI,CAAC+L,SAAS,CAAClI,WAAW,CAAC7D,KAAK,CAAC;EAC1C,CAAC;;EAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE8L,EAAE,CAAClE,YAAY,GAAG,UAAS,GAAGoE,IAAI,EAAE;IAClC,IAAIlC,CAAC,GAAG,CAAC;MAAEC,CAAC,GAAG,CAAC;MAAEkC,CAAC,GAAG,CAAC;MAAEC,CAAC,GAAG,CAAC;MAAErH,CAAC,GAAG,CAAC;IACrC,IAAImH,IAAI,CAACzP,MAAM,KAAK,CAAC,EAAE;MACrB,CAACuN,CAAC,EAAEC,CAAC,CAAC,GAAGiC,IAAI;IACf,CAAC,MAAM,IAAIA,IAAI,CAACzP,MAAM,KAAK,CAAC,EAAE;MAC5B,CAACuN,CAAC,EAAEC,CAAC,EAAEmC,CAAC,EAAErH,CAAC,CAAC,GAAGmH,IAAI;IACrB,CAAC,MAAM,IAAIA,IAAI,CAACzP,MAAM,KAAK,CAAC,EAAE;MAC5B,CAACuN,CAAC,EAAEC,CAAC,EAAEkC,CAAC,CAAC,GAAGD,IAAI;IAClB,CAAC,MAAM,IAAIA,IAAI,CAACzP,MAAM,KAAK,CAAC,EAAE;MAC5B,CAACuN,CAAC,EAAEC,CAAC,EAAEkC,CAAC,EAAEC,CAAC,EAAErH,CAAC,CAAC,GAAGmH,IAAI;IACxB;IACA,IAAI,CAACD,SAAS,CAACnE,YAAY,CAACkC,CAAC,EAAEC,CAAC,EAAEkC,CAAC,EAAEC,CAAC,EAAErH,CAAC,CAAC;EAC5C,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;EACEiH,EAAE,CAAChF,cAAc,GAAG,UAASqF,QAAQ,EAAEpP,KAAK,EAAE;IAC5C,OAAO,IAAI,CAACgP,SAAS,CAACjF,cAAc,CAACqF,QAAQ,EAAEpP,KAAK,CAAC;EACvD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;EACE+O,EAAE,CAAC/E,gBAAgB,GAAG,UAASC,MAAM,EAAE;IACrC,OAAO,IAAI,CAAC+E,SAAS,CAAChF,gBAAgB,CAACC,MAAM,CAAC;EAChD,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE8E,EAAE,CAAC7M,MAAM,GAAG,UAAS6K,CAAC,EAAEC,CAAC,EAAE;IACzB,IAAIkC,CAAC,EAAEC,CAAC,EAAErH,CAAC;;IAEX;IACAoH,CAAC,GAAGC,CAAC,GAAGrH,CAAC,GAAG,CAAC;IAEb,IAAIwB,SAAS,CAAC9J,MAAM,KAAK,CAAC,EAAE;MAC1B;MACA0P,CAAC,GAAG5F,SAAS,CAAC,CAAC,CAAC;IAClB,CAAC,MAAM,IAAIA,SAAS,CAAC9J,MAAM,KAAK,CAAC,EAAE;MACjC;MACA2P,CAAC,GAAG7F,SAAS,CAAC,CAAC,CAAC;MAChBxB,CAAC,GAAGwB,SAAS,CAAC,CAAC,CAAC;IAClB,CAAC,MAAM,IAAIA,SAAS,CAAC9J,MAAM,KAAK,CAAC,EAAE;MACjC;MACA0P,CAAC,GAAG5F,SAAS,CAAC,CAAC,CAAC;MAChB6F,CAAC,GAAG7F,SAAS,CAAC,CAAC,CAAC;MAChBxB,CAAC,GAAGwB,SAAS,CAAC,CAAC,CAAC;IAClB;IACA,IAAI,CAAC0F,SAAS,CAAC9M,MAAM,CAAC6K,CAAC,EAAEC,CAAC,EAAEkC,CAAC,EAAEC,CAAC,EAAErH,CAAC,CAAC;IACpC;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiH,EAAE,CAAChE,YAAY,GAAG,UAAS3I,IAAI,EAAE;IAC/B,IAAI,CAAC4M,SAAS,CAACjE,YAAY,CAAC3I,IAAI,CAAC;EACnC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2M,EAAE,CAAC9D,UAAU,GAAG,UAASoE,IAAI,GAAGpR,IAAI,EAAE;IACpC,IAAI,CAAC+Q,SAAS,CAAC/D,UAAU,CAACoE,IAAI,CAAC;EACjC,CAAC;AACH;AAEA,IAAI,OAAOP,EAAE,KAAK,WAAW,EAAE;EAC7BD,YAAY,CAACC,EAAE,EAAEA,EAAE,CAACQ,SAAS,CAAC;AAChC;AAEA,SAAS9M,MAAM,EAAEQ,aAAa,EAAEb,OAAO,EAAEkD,IAAI,EAAEvC,WAAW,EAAEqC,KAAK,EAAEyJ,mBAAmB,EAAElC,0BAA0B,EAAE0B,4BAA4B,EAAExC,gBAAgB,EAAEnG,IAAI,EAAEM,SAAS,EAAEpD,OAAO,EAAE+D,KAAK,EAAEvG,cAAc,EAAEsD,aAAa,EAAE8B,QAAQ,EAAEI,WAAW,EAAEE,aAAa,EAAEjG,MAAM,EAAEiP,YAAY,IAAIU,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}