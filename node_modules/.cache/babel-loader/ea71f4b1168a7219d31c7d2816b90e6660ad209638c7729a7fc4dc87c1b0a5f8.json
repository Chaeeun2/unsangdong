{"ast":null,"code":"/**\n * @module Environment\n * @submodule Environment\n * @for p5\n * @requires core\n */\n\nfunction gridOutput(p5, fn) {\n  //the functions in this file support updating the grid output\n\n  //updates gridOutput\n  fn._updateGridOutput = function (idT) {\n    //if html structure is not there yet\n    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {\n      return;\n    }\n    let current = this._accessibleOutputs[idT];\n    //create shape details list\n    let innerShapeDetails = _gridShapeDetails(idT, this.ingredients.shapes);\n    //create summary\n    let innerSummary = _gridSummary(innerShapeDetails.numShapes, this.ingredients.colors.background, this.width, this.height);\n    //create grid map\n    let innerMap = _gridMap(idT, this.ingredients.shapes);\n    //if it is different from current summary\n    if (innerSummary !== current.summary.innerHTML) {\n      //update\n      current.summary.innerHTML = innerSummary;\n    }\n    //if it is different from current map\n    if (innerMap !== current.map.innerHTML) {\n      //update\n      current.map.innerHTML = innerMap;\n    }\n    //if it is different from current shape details\n    if (innerShapeDetails.details !== current.shapeDetails.innerHTML) {\n      //update\n      current.shapeDetails.innerHTML = innerShapeDetails.details;\n    }\n    this._accessibleOutputs[idT] = current;\n  };\n\n  //creates spatial grid that maps the location of shapes\n  function _gridMap(idT, ingredients) {\n    let shapeNumber = 0;\n    let table = '';\n    //create an array of arrays 10*10 of empty cells\n    let cells = Array.from(Array(10), () => Array(10));\n    for (let x in ingredients) {\n      for (let y in ingredients[x]) {\n        let fill;\n        if (x !== 'line') {\n          fill = `<a href=\"#${idT}shape${shapeNumber}\">${ingredients[x][y].color} ${x}</a>`;\n        } else {\n          fill = `<a href=\"#${idT}shape${shapeNumber}\">${ingredients[x][y].color} ${x} midpoint</a>`;\n        }\n\n        // Check if shape is in canvas, skip if not\n        if (ingredients[x][y].loc.locY < cells.length && ingredients[x][y].loc.locX < cells[ingredients[x][y].loc.locY].length) {\n          //if empty cell of location of shape is undefined\n          if (!cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX]) {\n            //fill it with shape info\n            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = fill;\n            //if a shape is already in that location\n          } else {\n            //add it\n            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] + '  ' + fill;\n          }\n          shapeNumber++;\n        }\n      }\n    }\n    //make table based on array\n    for (let _r in cells) {\n      let row = '<tr>';\n      for (let c in cells[_r]) {\n        row = row + '<td>';\n        if (cells[_r][c] !== undefined) {\n          row = row + cells[_r][c];\n        }\n        row = row + '</td>';\n      }\n      table = table + row + '</tr>';\n    }\n    return table;\n  }\n\n  //creates grid summary\n  function _gridSummary(numShapes, background, width, height) {\n    let text = `${background} canvas, ${width} by ${height} pixels, contains ${numShapes[0]}`;\n    if (numShapes[0] === 1) {\n      text = `${text} shape: ${numShapes[1]}`;\n    } else {\n      text = `${text} shapes: ${numShapes[1]}`;\n    }\n    return text;\n  }\n\n  //creates list of shapes\n  function _gridShapeDetails(idT, ingredients) {\n    let shapeDetails = '';\n    let shapes = '';\n    let totalShapes = 0;\n    //goes trhough every shape type in ingredients\n    for (let x in ingredients) {\n      let shapeNum = 0;\n      for (let y in ingredients[x]) {\n        //it creates a line in a list\n        let line = `<li id=\"${idT}shape${totalShapes}\">${ingredients[x][y].color} ${x},`;\n        if (x === 'line') {\n          line = line + ` location = ${ingredients[x][y].pos}, length = ${ingredients[x][y].length} pixels`;\n        } else {\n          line = line + ` location = ${ingredients[x][y].pos}`;\n          if (x !== 'point') {\n            line = line + `, area = ${ingredients[x][y].area} %`;\n          }\n          line = line + '</li>';\n        }\n        shapeDetails = shapeDetails + line;\n        shapeNum++;\n        totalShapes++;\n      }\n      if (shapeNum > 1) {\n        shapes = `${shapes} ${shapeNum} ${x}s`;\n      } else {\n        shapes = `${shapes} ${shapeNum} ${x}`;\n      }\n    }\n    return {\n      numShapes: [totalShapes, shapes],\n      details: shapeDetails\n    };\n  }\n}\nif (typeof p5 !== 'undefined') {\n  gridOutput(p5, p5.prototype);\n}\nexport { gridOutput as default };","map":{"version":3,"names":["gridOutput","p5","fn","_updateGridOutput","idT","dummyDOM","querySelector","current","_accessibleOutputs","innerShapeDetails","_gridShapeDetails","ingredients","shapes","innerSummary","_gridSummary","numShapes","colors","background","width","height","innerMap","_gridMap","summary","innerHTML","map","details","shapeDetails","shapeNumber","table","cells","Array","from","x","y","fill","color","loc","locY","length","locX","_r","row","c","undefined","text","totalShapes","shapeNum","line","pos","area","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/accessibility/gridOutput.js"],"sourcesContent":["/**\n * @module Environment\n * @submodule Environment\n * @for p5\n * @requires core\n */\n\nfunction gridOutput(p5, fn){\n  //the functions in this file support updating the grid output\n\n  //updates gridOutput\n  fn._updateGridOutput = function(idT) {\n    //if html structure is not there yet\n    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {\n      return;\n    }\n    let current = this._accessibleOutputs[idT];\n    //create shape details list\n    let innerShapeDetails = _gridShapeDetails(idT, this.ingredients.shapes);\n    //create summary\n    let innerSummary = _gridSummary(\n      innerShapeDetails.numShapes,\n      this.ingredients.colors.background,\n      this.width,\n      this.height\n    );\n    //create grid map\n    let innerMap = _gridMap(idT, this.ingredients.shapes);\n    //if it is different from current summary\n    if (innerSummary !== current.summary.innerHTML) {\n      //update\n      current.summary.innerHTML = innerSummary;\n    }\n    //if it is different from current map\n    if (innerMap !== current.map.innerHTML) {\n      //update\n      current.map.innerHTML = innerMap;\n    }\n    //if it is different from current shape details\n    if (innerShapeDetails.details !== current.shapeDetails.innerHTML) {\n      //update\n      current.shapeDetails.innerHTML = innerShapeDetails.details;\n    }\n    this._accessibleOutputs[idT] = current;\n  };\n\n  //creates spatial grid that maps the location of shapes\n  function _gridMap(idT, ingredients) {\n    let shapeNumber = 0;\n    let table = '';\n    //create an array of arrays 10*10 of empty cells\n    let cells = Array.from(Array(10), () => Array(10));\n    for (let x in ingredients) {\n      for (let y in ingredients[x]) {\n        let fill;\n        if (x !== 'line') {\n          fill = `<a href=\"#${idT}shape${shapeNumber}\">${\n            ingredients[x][y].color\n          } ${x}</a>`;\n        } else {\n          fill = `<a href=\"#${idT}shape${shapeNumber}\">${\n            ingredients[x][y].color\n          } ${x} midpoint</a>`;\n        }\n\n        // Check if shape is in canvas, skip if not\n        if(\n          ingredients[x][y].loc.locY < cells.length &&\n          ingredients[x][y].loc.locX < cells[ingredients[x][y].loc.locY].length\n        ){\n          //if empty cell of location of shape is undefined\n          if (!cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX]) {\n            //fill it with shape info\n            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = fill;\n            //if a shape is already in that location\n          } else {\n            //add it\n            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] =\n              cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] +\n              '  ' +\n              fill;\n          }\n          shapeNumber++;\n        }\n      }\n    }\n    //make table based on array\n    for (let _r in cells) {\n      let row = '<tr>';\n      for (let c in cells[_r]) {\n        row = row + '<td>';\n        if (cells[_r][c] !== undefined) {\n          row = row + cells[_r][c];\n        }\n        row = row + '</td>';\n      }\n      table = table + row + '</tr>';\n    }\n    return table;\n  }\n\n  //creates grid summary\n  function _gridSummary(numShapes, background, width, height) {\n    let text = `${background} canvas, ${width} by ${height} pixels, contains ${\n      numShapes[0]\n    }`;\n    if (numShapes[0] === 1) {\n      text = `${text} shape: ${numShapes[1]}`;\n    } else {\n      text = `${text} shapes: ${numShapes[1]}`;\n    }\n    return text;\n  }\n\n  //creates list of shapes\n  function _gridShapeDetails(idT, ingredients) {\n    let shapeDetails = '';\n    let shapes = '';\n    let totalShapes = 0;\n    //goes trhough every shape type in ingredients\n    for (let x in ingredients) {\n      let shapeNum = 0;\n      for (let y in ingredients[x]) {\n        //it creates a line in a list\n        let line = `<li id=\"${idT}shape${totalShapes}\">${\n          ingredients[x][y].color\n        } ${x},`;\n        if (x === 'line') {\n          line =\n            line +\n            ` location = ${ingredients[x][y].pos}, length = ${\n              ingredients[x][y].length\n            } pixels`;\n        } else {\n          line = line + ` location = ${ingredients[x][y].pos}`;\n          if (x !== 'point') {\n            line = line + `, area = ${ingredients[x][y].area} %`;\n          }\n          line = line + '</li>';\n        }\n        shapeDetails = shapeDetails + line;\n        shapeNum++;\n        totalShapes++;\n      }\n      if (shapeNum > 1) {\n        shapes = `${shapes} ${shapeNum} ${x}s`;\n      } else {\n        shapes = `${shapes} ${shapeNum} ${x}`;\n      }\n    }\n    return { numShapes: [totalShapes, shapes], details: shapeDetails };\n  }\n}\n\nif(typeof p5 !== 'undefined'){\n  gridOutput(p5, p5.prototype);\n}\n\nexport { gridOutput as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}