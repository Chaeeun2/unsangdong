{"ast":null,"code":"import { p as p5 } from '../main-BKN5yFoS.js';\nimport '../constants-BRcElHU3.js';\nimport '../core/transform.js';\nimport '../core/structure.js';\nimport '../core/environment.js';\nimport '../math/p5.Vector.js';\nimport '../rendering-CvUVN-Vb.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport './color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport './setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../webgl/GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport '../webgl/p5.Geometry.js';\nimport '../webgl/p5.DataArray.js';\nimport '../webgl/p5.Quat.js';\nimport '../webgl/p5.RenderBuffer.js';\nimport '../webgl/ShapeBuilder.js';\nimport 'libtess';\nimport '../webgl/GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../image/filterRenderer2D.js';\n\n/**\n * @module Color\n * @submodule Color Conversion\n * @for p5\n * @requires core\n */\n\np5.ColorConversion = {\n  /**\n   * Convert an HSBA array to HSLA.\n   */\n  _hsbaToHSLA(hsba) {\n    const hue = hsba[0];\n    let sat = hsba[1];\n    const val = hsba[2];\n\n    // Calculate lightness.\n    const li = (2 - sat) * val / 2;\n\n    // Convert saturation.\n    if (li !== 0) {\n      if (li === 1) {\n        sat = 0;\n      } else if (li < 0.5) {\n        sat = sat / (2 - sat);\n      } else {\n        sat = sat * val / (2 - li * 2);\n      }\n    }\n\n    // Hue and alpha stay the same.\n    return [hue, sat, li, hsba[3]];\n  },\n  /**\n   * Convert an HSBA array to RGBA.\n   */\n  _hsbaToRGBA(hsba) {\n    const hue = hsba[0] * 6; // We will split hue into 6 sectors.\n    const sat = hsba[1];\n    const val = hsba[2];\n    let RGBA = [];\n    if (sat === 0) {\n      RGBA = [val, val, val, hsba[3]]; // Return early if grayscale.\n    } else {\n      const sector = Math.floor(hue);\n      const tint1 = val * (1 - sat);\n      const tint2 = val * (1 - sat * (hue - sector));\n      const tint3 = val * (1 - sat * (1 + sector - hue));\n      let red, green, blue;\n      if (sector === 1) {\n        // Yellow to green.\n        red = tint2;\n        green = val;\n        blue = tint1;\n      } else if (sector === 2) {\n        // Green to cyan.\n        red = tint1;\n        green = val;\n        blue = tint3;\n      } else if (sector === 3) {\n        // Cyan to blue.\n        red = tint1;\n        green = tint2;\n        blue = val;\n      } else if (sector === 4) {\n        // Blue to magenta.\n        red = tint3;\n        green = tint1;\n        blue = val;\n      } else if (sector === 5) {\n        // Magenta to red.\n        red = val;\n        green = tint1;\n        blue = tint2;\n      } else {\n        // Red to yellow (sector could be 0 or 6).\n        red = val;\n        green = tint3;\n        blue = tint1;\n      }\n      RGBA = [red, green, blue, hsba[3]];\n    }\n    return RGBA;\n  },\n  /**\n   * Convert an HSLA array to HSBA.\n   */\n  _hslaToHSBA(hsla) {\n    const hue = hsla[0];\n    let sat = hsla[1];\n    const li = hsla[2];\n\n    // Calculate brightness.\n    let val;\n    if (li < 0.5) {\n      val = (1 + sat) * li;\n    } else {\n      val = li + sat - li * sat;\n    }\n\n    // Convert saturation.\n    sat = 2 * (val - li) / val;\n\n    // Hue and alpha stay the same.\n    return [hue, sat, val, hsla[3]];\n  },\n  /**\n   * Convert an HSLA array to RGBA.\n   *\n   * We need to change basis from HSLA to something that can be more easily be\n   * projected onto RGBA. We will choose hue and brightness as our first two\n   * components, and pick a convenient third one ('zest') so that we don't need\n   * to calculate formal HSBA saturation.\n   */\n  _hslaToRGBA(hsla) {\n    const hue = hsla[0] * 6; // We will split hue into 6 sectors.\n    const sat = hsla[1];\n    const li = hsla[2];\n    let RGBA = [];\n    if (sat === 0) {\n      RGBA = [li, li, li, hsla[3]]; // Return early if grayscale.\n    } else {\n      // Calculate brightness.\n      let val;\n      if (li < 0.5) {\n        val = (1 + sat) * li;\n      } else {\n        val = li + sat - li * sat;\n      }\n\n      // Define zest.\n      const zest = 2 * li - val;\n\n      // Implement projection (project onto green by default).\n      const hzvToRGB = (hue, zest, val) => {\n        if (hue < 0) {\n          // Hue must wrap to allow projection onto red and blue.\n          hue += 6;\n        } else if (hue >= 6) {\n          hue -= 6;\n        }\n        if (hue < 1) {\n          // Red to yellow (increasing green).\n          return zest + (val - zest) * hue;\n        } else if (hue < 3) {\n          // Yellow to cyan (greatest green).\n          return val;\n        } else if (hue < 4) {\n          // Cyan to blue (decreasing green).\n          return zest + (val - zest) * (4 - hue);\n        } else {\n          // Blue to red (least green).\n          return zest;\n        }\n      };\n\n      // Perform projections, offsetting hue as necessary.\n      RGBA = [hzvToRGB(hue + 2, zest, val), hzvToRGB(hue, zest, val), hzvToRGB(hue - 2, zest, val), hsla[3]];\n    }\n    return RGBA;\n  },\n  /**\n   * Convert an RGBA array to HSBA.\n   */\n  _rgbaToHSBA(rgba) {\n    const red = rgba[0];\n    const green = rgba[1];\n    const blue = rgba[2];\n    const val = Math.max(red, green, blue);\n    const chroma = val - Math.min(red, green, blue);\n    let hue, sat;\n    if (chroma === 0) {\n      // Return early if grayscale.\n      hue = 0;\n      sat = 0;\n    } else {\n      sat = chroma / val;\n      if (red === val) {\n        // Magenta to yellow.\n        hue = (green - blue) / chroma;\n      } else if (green === val) {\n        // Yellow to cyan.\n        hue = 2 + (blue - red) / chroma;\n      } else if (blue === val) {\n        // Cyan to magenta.\n        hue = 4 + (red - green) / chroma;\n      }\n      if (hue < 0) {\n        // Confine hue to the interval [0, 1).\n        hue += 6;\n      } else if (hue >= 6) {\n        hue -= 6;\n      }\n    }\n    return [hue / 6, sat, val, rgba[3]];\n  },\n  /**\n   * Convert an RGBA array to HSLA.\n   */\n  _rgbaToHSLA(rgba) {\n    const red = rgba[0];\n    const green = rgba[1];\n    const blue = rgba[2];\n    const val = Math.max(red, green, blue);\n    const min = Math.min(red, green, blue);\n    const li = val + min; // We will halve this later.\n    const chroma = val - min;\n    let hue, sat;\n    if (chroma === 0) {\n      // Return early if grayscale.\n      hue = 0;\n      sat = 0;\n    } else {\n      if (li < 1) {\n        sat = chroma / li;\n      } else {\n        sat = chroma / (2 - li);\n      }\n      if (red === val) {\n        // Magenta to yellow.\n        hue = (green - blue) / chroma;\n      } else if (green === val) {\n        // Yellow to cyan.\n        hue = 2 + (blue - red) / chroma;\n      } else if (blue === val) {\n        // Cyan to magenta.\n        hue = 4 + (red - green) / chroma;\n      }\n      if (hue < 0) {\n        // Confine hue to the interval [0, 1).\n        hue += 6;\n      } else if (hue >= 6) {\n        hue -= 6;\n      }\n    }\n    return [hue / 6, sat, li / 2, rgba[3]];\n  }\n};\nvar color_conversion = p5.ColorConversion;\nexport { color_conversion as default };","map":{"version":3,"names":["p","p5","ColorConversion","_hsbaToHSLA","hsba","hue","sat","val","li","_hsbaToRGBA","RGBA","sector","Math","floor","tint1","tint2","tint3","red","green","blue","_hslaToHSBA","hsla","_hslaToRGBA","zest","hzvToRGB","_rgbaToHSBA","rgba","max","chroma","min","_rgbaToHSLA","color_conversion","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/color/color_conversion.js"],"sourcesContent":["import { p as p5 } from '../main-BKN5yFoS.js';\nimport '../constants-BRcElHU3.js';\nimport '../core/transform.js';\nimport '../core/structure.js';\nimport '../core/environment.js';\nimport '../math/p5.Vector.js';\nimport '../rendering-CvUVN-Vb.js';\nimport '../creating_reading-Cr8L2Jnm.js';\nimport 'colorjs.io/fn';\nimport './color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-R23xoC7s.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport './setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../webgl/GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport '../webgl/p5.Geometry.js';\nimport '../webgl/p5.DataArray.js';\nimport '../webgl/p5.Quat.js';\nimport '../webgl/p5.RenderBuffer.js';\nimport '../webgl/ShapeBuilder.js';\nimport 'libtess';\nimport '../webgl/GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../image/filterRenderer2D.js';\n\n/**\n * @module Color\n * @submodule Color Conversion\n * @for p5\n * @requires core\n */\n\np5.ColorConversion = {\n  /**\n   * Convert an HSBA array to HSLA.\n   */\n  _hsbaToHSLA(hsba) {\n    const hue = hsba[0];\n    let sat = hsba[1];\n    const val = hsba[2];\n\n    // Calculate lightness.\n    const li = (2 - sat) * val / 2;\n\n    // Convert saturation.\n    if (li !== 0) {\n      if (li === 1) {\n        sat = 0;\n      } else if (li < 0.5) {\n        sat = sat / (2 - sat);\n      } else {\n        sat = sat * val / (2 - li * 2);\n      }\n    }\n\n    // Hue and alpha stay the same.\n    return [hue, sat, li, hsba[3]];\n  },\n\n  /**\n   * Convert an HSBA array to RGBA.\n   */\n  _hsbaToRGBA(hsba) {\n    const hue = hsba[0] * 6; // We will split hue into 6 sectors.\n    const sat = hsba[1];\n    const val = hsba[2];\n\n    let RGBA = [];\n\n    if (sat === 0) {\n      RGBA = [val, val, val, hsba[3]]; // Return early if grayscale.\n    } else {\n      const sector = Math.floor(hue);\n      const tint1 = val * (1 - sat);\n      const tint2 = val * (1 - sat * (hue - sector));\n      const tint3 = val * (1 - sat * (1 + sector - hue));\n      let red, green, blue;\n      if (sector === 1) {\n        // Yellow to green.\n        red = tint2;\n        green = val;\n        blue = tint1;\n      } else if (sector === 2) {\n        // Green to cyan.\n        red = tint1;\n        green = val;\n        blue = tint3;\n      } else if (sector === 3) {\n        // Cyan to blue.\n        red = tint1;\n        green = tint2;\n        blue = val;\n      } else if (sector === 4) {\n        // Blue to magenta.\n        red = tint3;\n        green = tint1;\n        blue = val;\n      } else if (sector === 5) {\n        // Magenta to red.\n        red = val;\n        green = tint1;\n        blue = tint2;\n      } else {\n        // Red to yellow (sector could be 0 or 6).\n        red = val;\n        green = tint3;\n        blue = tint1;\n      }\n      RGBA = [red, green, blue, hsba[3]];\n    }\n\n    return RGBA;\n  },\n\n  /**\n   * Convert an HSLA array to HSBA.\n   */\n  _hslaToHSBA(hsla) {\n    const hue = hsla[0];\n    let sat = hsla[1];\n    const li = hsla[2];\n\n    // Calculate brightness.\n    let val;\n    if (li < 0.5) {\n      val = (1 + sat) * li;\n    } else {\n      val = li + sat - li * sat;\n    }\n\n    // Convert saturation.\n    sat = 2 * (val - li) / val;\n\n    // Hue and alpha stay the same.\n    return [hue, sat, val, hsla[3]];\n  },\n\n  /**\n   * Convert an HSLA array to RGBA.\n   *\n   * We need to change basis from HSLA to something that can be more easily be\n   * projected onto RGBA. We will choose hue and brightness as our first two\n   * components, and pick a convenient third one ('zest') so that we don't need\n   * to calculate formal HSBA saturation.\n   */\n  _hslaToRGBA(hsla) {\n    const hue = hsla[0] * 6; // We will split hue into 6 sectors.\n    const sat = hsla[1];\n    const li = hsla[2];\n\n    let RGBA = [];\n\n    if (sat === 0) {\n      RGBA = [li, li, li, hsla[3]]; // Return early if grayscale.\n    } else {\n      // Calculate brightness.\n      let val;\n      if (li < 0.5) {\n        val = (1 + sat) * li;\n      } else {\n        val = li + sat - li * sat;\n      }\n\n      // Define zest.\n      const zest = 2 * li - val;\n\n      // Implement projection (project onto green by default).\n      const hzvToRGB = (hue, zest, val) => {\n        if (hue < 0) {\n          // Hue must wrap to allow projection onto red and blue.\n          hue += 6;\n        } else if (hue >= 6) {\n          hue -= 6;\n        }\n        if (hue < 1) {\n          // Red to yellow (increasing green).\n          return zest + (val - zest) * hue;\n        } else if (hue < 3) {\n          // Yellow to cyan (greatest green).\n          return val;\n        } else if (hue < 4) {\n          // Cyan to blue (decreasing green).\n          return zest + (val - zest) * (4 - hue);\n        } else {\n          // Blue to red (least green).\n          return zest;\n        }\n      };\n\n      // Perform projections, offsetting hue as necessary.\n      RGBA = [\n        hzvToRGB(hue + 2, zest, val),\n        hzvToRGB(hue, zest, val),\n        hzvToRGB(hue - 2, zest, val),\n        hsla[3]\n      ];\n    }\n\n    return RGBA;\n  },\n\n  /**\n   * Convert an RGBA array to HSBA.\n   */\n  _rgbaToHSBA(rgba) {\n    const red = rgba[0];\n    const green = rgba[1];\n    const blue = rgba[2];\n\n    const val = Math.max(red, green, blue);\n    const chroma = val - Math.min(red, green, blue);\n\n    let hue, sat;\n    if (chroma === 0) {\n      // Return early if grayscale.\n      hue = 0;\n      sat = 0;\n    } else {\n      sat = chroma / val;\n      if (red === val) {\n        // Magenta to yellow.\n        hue = (green - blue) / chroma;\n      } else if (green === val) {\n        // Yellow to cyan.\n        hue = 2 + (blue - red) / chroma;\n      } else if (blue === val) {\n        // Cyan to magenta.\n        hue = 4 + (red - green) / chroma;\n      }\n      if (hue < 0) {\n        // Confine hue to the interval [0, 1).\n        hue += 6;\n      } else if (hue >= 6) {\n        hue -= 6;\n      }\n    }\n\n    return [hue / 6, sat, val, rgba[3]];\n  },\n\n  /**\n   * Convert an RGBA array to HSLA.\n   */\n  _rgbaToHSLA(rgba) {\n    const red = rgba[0];\n    const green = rgba[1];\n    const blue = rgba[2];\n\n    const val = Math.max(red, green, blue);\n    const min = Math.min(red, green, blue);\n    const li = val + min; // We will halve this later.\n    const chroma = val - min;\n\n    let hue, sat;\n    if (chroma === 0) {\n      // Return early if grayscale.\n      hue = 0;\n      sat = 0;\n    } else {\n      if (li < 1) {\n        sat = chroma / li;\n      } else {\n        sat = chroma / (2 - li);\n      }\n      if (red === val) {\n        // Magenta to yellow.\n        hue = (green - blue) / chroma;\n      } else if (green === val) {\n        // Yellow to cyan.\n        hue = 2 + (blue - red) / chroma;\n      } else if (blue === val) {\n        // Cyan to magenta.\n        hue = 4 + (red - green) / chroma;\n      }\n      if (hue < 0) {\n        // Confine hue to the interval [0, 1).\n        hue += 6;\n      } else if (hue >= 6) {\n        hue -= 6;\n      }\n    }\n\n    return [hue / 6, sat, li / 2, rgba[3]];\n  }\n};\nvar color_conversion = p5.ColorConversion;\n\nexport { color_conversion as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}