{"ast":null,"code":"let GLMAT_ARRAY_TYPE = Array;\nlet isMatrixArray = x => Array.isArray(x);\nif (typeof Float32Array !== \"undefined\") {\n  GLMAT_ARRAY_TYPE = Float32Array;\n  isMatrixArray = x => Array.isArray(x) || x instanceof Float32Array;\n}\nclass MatrixInterface {\n  // Private field to store the matrix\n  #matrix = null;\n  constructor(...args) {\n    if (this.constructor === MatrixInterface) {\n      throw new Error(\"Class is of abstract type and can't be instantiated\");\n    }\n    const methods = [\"add\", \"setElement\", \"reset\", \"set\", \"get\", \"copy\", \"clone\", \"diagonal\", \"row\", \"column\", \"transpose\", \"mult\", \"multiplyVec\", \"invert\", \"createSubMatrix3x3\", \"inverseTranspose4x4\", \"apply\", \"scale\", \"rotate4x4\", \"translate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"perspective\", \"ortho\", \"multiplyVec4\", \"multiplyPoint\", \"multiplyAndNormalizePoint\", \"multiplyDirection\", \"multiplyVec3\"];\n    methods.forEach(method => {\n      if (this[method] === undefined) {\n        throw new Error(`${method}() method must be implemented`);\n      }\n    });\n  }\n}\nexport { GLMAT_ARRAY_TYPE, MatrixInterface, isMatrixArray };","map":{"version":3,"names":["GLMAT_ARRAY_TYPE","Array","isMatrixArray","x","isArray","Float32Array","MatrixInterface","matrix","constructor","args","Error","methods","forEach","method","undefined"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/math/Matrices/MatrixInterface.js"],"sourcesContent":["let GLMAT_ARRAY_TYPE = Array;\nlet isMatrixArray = (x) => Array.isArray(x);\nif (typeof Float32Array !== \"undefined\") {\n  GLMAT_ARRAY_TYPE = Float32Array;\n  isMatrixArray = (x) => Array.isArray(x) || x instanceof Float32Array;\n}\nclass MatrixInterface {\n  // Private field to store the matrix\n  #matrix = null;\n  constructor(...args) {\n    if (this.constructor === MatrixInterface) {\n      throw new Error(\"Class is of abstract type and can't be instantiated\");\n    }\n    const methods = [\n      \"add\",\n      \"setElement\",\n      \"reset\",\n      \"set\",\n      \"get\",\n      \"copy\",\n      \"clone\",\n      \"diagonal\",\n      \"row\",\n      \"column\",\n      \"transpose\",\n      \"mult\",\n      \"multiplyVec\",\n      \"invert\",\n      \"createSubMatrix3x3\",\n      \"inverseTranspose4x4\",\n      \"apply\",\n      \"scale\",\n      \"rotate4x4\",\n      \"translate\",\n      \"rotateX\",\n      \"rotateY\",\n      \"rotateZ\",\n      \"perspective\",\n      \"ortho\",\n      \"multiplyVec4\",\n      \"multiplyPoint\",\n      \"multiplyAndNormalizePoint\",\n      \"multiplyDirection\",\n      \"multiplyVec3\",\n    ];\n\n    methods.forEach((method) => {\n      if (this[method] === undefined) {\n        throw new Error(`${method}() method must be implemented`);\n      }\n    });\n  }\n}\n\nexport { GLMAT_ARRAY_TYPE, MatrixInterface, isMatrixArray };\n"],"mappings":"AAAA,IAAIA,gBAAgB,GAAGC,KAAK;AAC5B,IAAIC,aAAa,GAAIC,CAAC,IAAKF,KAAK,CAACG,OAAO,CAACD,CAAC,CAAC;AAC3C,IAAI,OAAOE,YAAY,KAAK,WAAW,EAAE;EACvCL,gBAAgB,GAAGK,YAAY;EAC/BH,aAAa,GAAIC,CAAC,IAAKF,KAAK,CAACG,OAAO,CAACD,CAAC,CAAC,IAAIA,CAAC,YAAYE,YAAY;AACtE;AACA,MAAMC,eAAe,CAAC;EACpB;EACA,CAACC,MAAM,GAAG,IAAI;EACdC,WAAWA,CAAC,GAAGC,IAAI,EAAE;IACnB,IAAI,IAAI,CAACD,WAAW,KAAKF,eAAe,EAAE;MACxC,MAAM,IAAII,KAAK,CAAC,qDAAqD,CAAC;IACxE;IACA,MAAMC,OAAO,GAAG,CACd,KAAK,EACL,YAAY,EACZ,OAAO,EACP,KAAK,EACL,KAAK,EACL,MAAM,EACN,OAAO,EACP,UAAU,EACV,KAAK,EACL,QAAQ,EACR,WAAW,EACX,MAAM,EACN,aAAa,EACb,QAAQ,EACR,oBAAoB,EACpB,qBAAqB,EACrB,OAAO,EACP,OAAO,EACP,WAAW,EACX,WAAW,EACX,SAAS,EACT,SAAS,EACT,SAAS,EACT,aAAa,EACb,OAAO,EACP,cAAc,EACd,eAAe,EACf,2BAA2B,EAC3B,mBAAmB,EACnB,cAAc,CACf;IAEDA,OAAO,CAACC,OAAO,CAAEC,MAAM,IAAK;MAC1B,IAAI,IAAI,CAACA,MAAM,CAAC,KAAKC,SAAS,EAAE;QAC9B,MAAM,IAAIJ,KAAK,CAAC,GAAGG,MAAM,+BAA+B,CAAC;MAC3D;IACF,CAAC,CAAC;EACJ;AACF;AAEA,SAASb,gBAAgB,EAAEM,eAAe,EAAEJ,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}