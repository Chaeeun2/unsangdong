{"ast":null,"code":"/**\n * Various utility functions\n */\n\nexport { default as multiplyMatrices } from \"./multiply-matrices.js\";\n\n/**\n * Check if a value is a string (including a String object)\n * @param {*} str - Value to check\n * @returns {boolean}\n */\nexport function isString(str) {\n  return type(str) === \"string\";\n}\n\n/**\n * Determine the internal JavaScript [[Class]] of an object.\n * @param {*} o - Value to check\n * @returns {string}\n */\nexport function type(o) {\n  let str = Object.prototype.toString.call(o);\n  return (str.match(/^\\[object\\s+(.*?)\\]$/)[1] || \"\").toLowerCase();\n}\nexport function serializeNumber(n, {\n  precision,\n  unit\n}) {\n  if (isNone(n)) {\n    return \"none\";\n  }\n  return toPrecision(n, precision) + (unit ?? \"\");\n}\n\n/**\n * Check if a value corresponds to a none argument\n * @param {*} n - Value to check\n * @returns {boolean}\n */\nexport function isNone(n) {\n  return Number.isNaN(n) || n instanceof Number && n?.none;\n}\n\n/**\n * Replace none values with 0\n */\nexport function skipNone(n) {\n  return isNone(n) ? 0 : n;\n}\n\n/**\n * Round a number to a certain number of significant digits\n * @param {number} n - The number to round\n * @param {number} precision - Number of significant digits\n */\nexport function toPrecision(n, precision) {\n  if (n === 0) {\n    return 0;\n  }\n  let integer = ~~n;\n  let digits = 0;\n  if (integer && precision) {\n    digits = ~~Math.log10(Math.abs(integer)) + 1;\n  }\n  const multiplier = 10.0 ** (precision - digits);\n  return Math.floor(n * multiplier + 0.5) / multiplier;\n}\nconst angleFactor = {\n  deg: 1,\n  grad: 0.9,\n  rad: 180 / Math.PI,\n  turn: 360\n};\n\n/**\n* Parse a CSS function, regardless of its name and arguments\n* @param String str String to parse\n* @return {{name, args, rawArgs}}\n*/\nexport function parseFunction(str) {\n  if (!str) {\n    return;\n  }\n  str = str.trim();\n  const isFunctionRegex = /^([a-z]+)\\((.+?)\\)$/i;\n  const isNumberRegex = /^-?[\\d.]+$/;\n  const unitValueRegex = /%|deg|g?rad|turn$/;\n  const singleArgument = /\\/?\\s*(none|[-\\w.]+(?:%|deg|g?rad|turn)?)/g;\n  let parts = str.match(isFunctionRegex);\n  if (parts) {\n    // It is a function, parse args\n    let args = [];\n    parts[2].replace(singleArgument, ($0, rawArg) => {\n      let match = rawArg.match(unitValueRegex);\n      let arg = rawArg;\n      if (match) {\n        let unit = match[0];\n        // Drop unit from value\n        let unitlessArg = arg.slice(0, -unit.length);\n        if (unit === \"%\") {\n          // Convert percentages to 0-1 numbers\n          arg = new Number(unitlessArg / 100);\n          arg.type = \"<percentage>\";\n        } else {\n          // Multiply angle by appropriate factor for its unit\n          arg = new Number(unitlessArg * angleFactor[unit]);\n          arg.type = \"<angle>\";\n          arg.unit = unit;\n        }\n      } else if (isNumberRegex.test(arg)) {\n        // Convert numerical args to numbers\n        arg = new Number(arg);\n        arg.type = \"<number>\";\n      } else if (arg === \"none\") {\n        arg = new Number(NaN);\n        arg.none = true;\n      }\n      if ($0.startsWith(\"/\")) {\n        // It's alpha\n        arg = arg instanceof Number ? arg : new Number(arg);\n        arg.alpha = true;\n      }\n      if (typeof arg === \"object\" && arg instanceof Number) {\n        arg.raw = rawArg;\n      }\n      args.push(arg);\n    });\n    return {\n      name: parts[1].toLowerCase(),\n      rawName: parts[1],\n      rawArgs: parts[2],\n      // An argument could be (as of css-color-4):\n      // a number, percentage, degrees (hue), ident (in color())\n      args\n    };\n  }\n}\nexport function last(arr) {\n  return arr[arr.length - 1];\n}\nexport function interpolate(start, end, p) {\n  if (isNaN(start)) {\n    return end;\n  }\n  if (isNaN(end)) {\n    return start;\n  }\n  return start + (end - start) * p;\n}\nexport function interpolateInv(start, end, value) {\n  return (value - start) / (end - start);\n}\nexport function mapRange(from, to, value) {\n  return interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));\n}\nexport function parseCoordGrammar(coordGrammars) {\n  return coordGrammars.map(coordGrammar => {\n    return coordGrammar.split(\"|\").map(type => {\n      type = type.trim();\n      let range = type.match(/^(<[a-z]+>)\\[(-?[.\\d]+),\\s*(-?[.\\d]+)\\]?$/);\n      if (range) {\n        let ret = new String(range[1]);\n        ret.range = [+range[2], +range[3]];\n        return ret;\n      }\n      return type;\n    });\n  });\n}\n\n/**\n * Clamp value between the minimum and maximum\n * @param {number} min minimum value to return\n * @param {number} val the value to return if it is between min and max\n * @param {number} max maximum value to return\n * @returns number\n */\nexport function clamp(min, val, max) {\n  return Math.max(Math.min(max, val), min);\n}\n\n/**\n * Copy sign of one value to another.\n * @param {number} - to number to copy sign to\n * @param {number} - from number to copy sign from\n * @returns number\n */\nexport function copySign(to, from) {\n  return Math.sign(to) === Math.sign(from) ? to : -to;\n}\n\n/**\n * Perform pow on a signed number and copy sign to result\n * @param {number} - base the base number\n * @param {number} - exp the exponent\n * @returns number\n */\nexport function spow(base, exp) {\n  return copySign(Math.abs(base) ** exp, base);\n}\n\n/**\n * Perform a divide, but return zero if the numerator is zero\n * @param {number} n - the numerator\n * @param {number} d - the denominator\n * @returns number\n */\nexport function zdiv(n, d) {\n  return d === 0 ? 0 : n / d;\n}\n\n/**\n * Perform a bisect on a sorted list and locate the insertion point for\n * a value in arr to maintain sorted order.\n * @param {number[]} arr - array of sorted numbers\n * @param {number} value - value to find insertion point for\n * @param {number} lo - used to specify a the low end of a subset of the list\n * @param {number} hi - used to specify a the high end of a subset of the list\n * @returns number\n */\nexport function bisectLeft(arr, value, lo = 0, hi = arr.length) {\n  while (lo < hi) {\n    const mid = lo + hi >> 1;\n    if (arr[mid] < value) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n}","map":{"version":3,"names":["default","multiplyMatrices","isString","str","type","o","Object","prototype","toString","call","match","toLowerCase","serializeNumber","n","precision","unit","isNone","toPrecision","Number","isNaN","none","skipNone","integer","digits","Math","log10","abs","multiplier","floor","angleFactor","deg","grad","rad","PI","turn","parseFunction","trim","isFunctionRegex","isNumberRegex","unitValueRegex","singleArgument","parts","args","replace","$0","rawArg","arg","unitlessArg","slice","length","test","NaN","startsWith","alpha","raw","push","name","rawName","rawArgs","last","arr","interpolate","start","end","p","interpolateInv","value","mapRange","from","to","parseCoordGrammar","coordGrammars","map","coordGrammar","split","range","ret","String","clamp","min","val","max","copySign","sign","spow","base","exp","zdiv","d","bisectLeft","lo","hi","mid"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/util.js"],"sourcesContent":["/**\n * Various utility functions\n */\n\nexport {default as multiplyMatrices} from \"./multiply-matrices.js\";\n\n/**\n * Check if a value is a string (including a String object)\n * @param {*} str - Value to check\n * @returns {boolean}\n */\nexport function isString (str) {\n\treturn type(str) === \"string\";\n}\n\n/**\n * Determine the internal JavaScript [[Class]] of an object.\n * @param {*} o - Value to check\n * @returns {string}\n */\nexport function type (o) {\n\tlet str = Object.prototype.toString.call(o);\n\n\treturn (str.match(/^\\[object\\s+(.*?)\\]$/)[1] || \"\").toLowerCase();\n}\n\nexport function serializeNumber (n, {precision, unit }) {\n\tif (isNone(n)) {\n\t\treturn \"none\";\n\t}\n\n\treturn toPrecision(n, precision) + (unit ?? \"\");\n}\n\n/**\n * Check if a value corresponds to a none argument\n * @param {*} n - Value to check\n * @returns {boolean}\n */\nexport function isNone (n) {\n\treturn Number.isNaN(n) || (n instanceof Number && n?.none);\n}\n\n/**\n * Replace none values with 0\n */\nexport function skipNone (n) {\n\treturn isNone(n) ? 0 : n;\n}\n\n/**\n * Round a number to a certain number of significant digits\n * @param {number} n - The number to round\n * @param {number} precision - Number of significant digits\n */\nexport function toPrecision (n, precision) {\n\tif (n === 0) {\n\t\treturn 0;\n\t}\n\tlet integer = ~~n;\n\tlet digits = 0;\n\tif (integer && precision) {\n\t\tdigits = ~~Math.log10(Math.abs(integer)) + 1;\n\t}\n\tconst multiplier = 10.0 ** (precision - digits);\n\treturn Math.floor(n * multiplier + 0.5) / multiplier;\n}\n\nconst angleFactor = {\n\tdeg: 1,\n\tgrad: 0.9,\n\trad: 180 / Math.PI,\n\tturn: 360,\n};\n\n/**\n* Parse a CSS function, regardless of its name and arguments\n* @param String str String to parse\n* @return {{name, args, rawArgs}}\n*/\nexport function parseFunction (str) {\n\tif (!str) {\n\t\treturn;\n\t}\n\n\tstr = str.trim();\n\n\tconst isFunctionRegex = /^([a-z]+)\\((.+?)\\)$/i;\n\tconst isNumberRegex = /^-?[\\d.]+$/;\n\tconst unitValueRegex = /%|deg|g?rad|turn$/;\n\tconst singleArgument = /\\/?\\s*(none|[-\\w.]+(?:%|deg|g?rad|turn)?)/g;\n\tlet parts = str.match(isFunctionRegex);\n\n\tif (parts) {\n\t\t// It is a function, parse args\n\t\tlet args = [];\n\t\tparts[2].replace(singleArgument, ($0, rawArg) => {\n\t\t\tlet match = rawArg.match(unitValueRegex);\n\t\t\tlet arg = rawArg;\n\n\t\t\tif (match) {\n\t\t\t\tlet unit = match[0];\n\t\t\t\t// Drop unit from value\n\t\t\t\tlet unitlessArg = arg.slice(0, -unit.length);\n\n\t\t\t\tif (unit === \"%\") {\n\t\t\t\t\t// Convert percentages to 0-1 numbers\n\t\t\t\t\targ = new Number(unitlessArg / 100);\n\t\t\t\t\targ.type = \"<percentage>\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Multiply angle by appropriate factor for its unit\n\t\t\t\t\targ = new Number(unitlessArg * angleFactor[unit]);\n\t\t\t\t\targ.type = \"<angle>\";\n\t\t\t\t\targ.unit = unit;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isNumberRegex.test(arg)) {\n\t\t\t\t// Convert numerical args to numbers\n\t\t\t\targ = new Number(arg);\n\t\t\t\targ.type = \"<number>\";\n\t\t\t}\n\t\t\telse if (arg === \"none\") {\n\t\t\t\targ = new Number(NaN);\n\t\t\t\targ.none = true;\n\t\t\t}\n\n\t\t\tif ($0.startsWith(\"/\")) {\n\t\t\t\t// It's alpha\n\t\t\t\targ = arg instanceof Number ? arg : new Number(arg);\n\t\t\t\targ.alpha = true;\n\t\t\t}\n\n\t\t\tif (typeof arg === \"object\" && arg instanceof Number) {\n\t\t\t\targ.raw = rawArg;\n\t\t\t}\n\n\t\t\targs.push(arg);\n\t\t});\n\n\t\treturn {\n\t\t\tname: parts[1].toLowerCase(),\n\t\t\trawName: parts[1],\n\t\t\trawArgs: parts[2],\n\t\t\t// An argument could be (as of css-color-4):\n\t\t\t// a number, percentage, degrees (hue), ident (in color())\n\t\t\targs,\n\t\t};\n\t}\n}\n\nexport function last (arr) {\n\treturn arr[arr.length - 1];\n}\n\nexport function interpolate (start, end, p) {\n\tif (isNaN(start)) {\n\t\treturn end;\n\t}\n\n\tif (isNaN(end)) {\n\t\treturn start;\n\t}\n\n\treturn start + (end - start) * p;\n}\n\nexport function interpolateInv (start, end, value) {\n\treturn (value - start) / (end - start);\n}\n\nexport function mapRange (from, to, value) {\n\treturn interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));\n}\n\nexport function parseCoordGrammar (coordGrammars) {\n\treturn coordGrammars.map(coordGrammar => {\n\t\treturn coordGrammar.split(\"|\").map(type => {\n\t\t\ttype = type.trim();\n\t\t\tlet range = type.match(/^(<[a-z]+>)\\[(-?[.\\d]+),\\s*(-?[.\\d]+)\\]?$/);\n\n\t\t\tif (range) {\n\t\t\t\tlet ret = new String(range[1]);\n\t\t\t\tret.range = [+range[2], +range[3]];\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn type;\n\t\t});\n\t});\n}\n\n/**\n * Clamp value between the minimum and maximum\n * @param {number} min minimum value to return\n * @param {number} val the value to return if it is between min and max\n * @param {number} max maximum value to return\n * @returns number\n */\nexport function clamp (min, val, max) {\n\treturn Math.max(Math.min(max, val), min);\n}\n\n/**\n * Copy sign of one value to another.\n * @param {number} - to number to copy sign to\n * @param {number} - from number to copy sign from\n * @returns number\n */\nexport function copySign (to, from) {\n\treturn Math.sign(to) === Math.sign(from) ? to : -to;\n}\n\n/**\n * Perform pow on a signed number and copy sign to result\n * @param {number} - base the base number\n * @param {number} - exp the exponent\n * @returns number\n */\nexport function spow (base, exp) {\n\treturn copySign(Math.abs(base) ** exp, base);\n}\n\n/**\n * Perform a divide, but return zero if the numerator is zero\n * @param {number} n - the numerator\n * @param {number} d - the denominator\n * @returns number\n */\nexport function zdiv (n, d) {\n\treturn (d === 0) ? 0 : n / d;\n}\n\n/**\n * Perform a bisect on a sorted list and locate the insertion point for\n * a value in arr to maintain sorted order.\n * @param {number[]} arr - array of sorted numbers\n * @param {number} value - value to find insertion point for\n * @param {number} lo - used to specify a the low end of a subset of the list\n * @param {number} hi - used to specify a the high end of a subset of the list\n * @returns number\n */\nexport function bisectLeft (arr, value, lo = 0, hi = arr.length) {\n\twhile (lo < hi) {\n\t\tconst mid = (lo + hi) >> 1;\n\t\tif (arr[mid] < value) {\n\t\t\tlo = mid + 1;\n\t\t}\n\t\telse {\n\t\t\thi = mid;\n\t\t}\n\t}\n\treturn lo;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}