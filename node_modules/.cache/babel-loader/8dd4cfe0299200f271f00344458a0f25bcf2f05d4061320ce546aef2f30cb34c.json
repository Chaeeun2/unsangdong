{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/index.js\n__markAsModule(exports);\n__export(exports, {\n  GIFEncoder: () => GIFEncoder,\n  applyPalette: () => applyPalette,\n  default: () => src_default,\n  nearestColor: () => nearestColor,\n  nearestColorIndex: () => nearestColorIndex,\n  nearestColorIndexWithDistance: () => nearestColorIndexWithDistance,\n  prequantize: () => prequantize,\n  quantize: () => quantize,\n  snapColorsToPalette: () => snapColorsToPalette\n});\n\n// src/constants.js\nvar constants_default = {\n  signature: \"GIF\",\n  version: \"89a\",\n  trailer: 59,\n  extensionIntroducer: 33,\n  applicationExtensionLabel: 255,\n  graphicControlExtensionLabel: 249,\n  imageSeparator: 44,\n  signatureSize: 3,\n  versionSize: 3,\n  globalColorTableFlagMask: 128,\n  colorResolutionMask: 112,\n  sortFlagMask: 8,\n  globalColorTableSizeMask: 7,\n  applicationIdentifierSize: 8,\n  applicationAuthCodeSize: 3,\n  disposalMethodMask: 28,\n  userInputFlagMask: 2,\n  transparentColorFlagMask: 1,\n  localColorTableFlagMask: 128,\n  interlaceFlagMask: 64,\n  idSortFlagMask: 32,\n  localColorTableSizeMask: 7\n};\n\n// src/stream.js\nfunction createStream(initialCapacity = 256) {\n  let cursor = 0;\n  let contents = new Uint8Array(initialCapacity);\n  return {\n    get buffer() {\n      return contents.buffer;\n    },\n    reset() {\n      cursor = 0;\n    },\n    bytesView() {\n      return contents.subarray(0, cursor);\n    },\n    bytes() {\n      return contents.slice(0, cursor);\n    },\n    writeByte(byte) {\n      expand(cursor + 1);\n      contents[cursor] = byte;\n      cursor++;\n    },\n    writeBytes(data, offset = 0, byteLength = data.length) {\n      expand(cursor + byteLength);\n      for (let i = 0; i < byteLength; i++) {\n        contents[cursor++] = data[i + offset];\n      }\n    },\n    writeBytesView(data, offset = 0, byteLength = data.byteLength) {\n      expand(cursor + byteLength);\n      contents.set(data.subarray(offset, offset + byteLength), cursor);\n      cursor += byteLength;\n    }\n  };\n  function expand(newCapacity) {\n    var prevCapacity = contents.length;\n    if (prevCapacity >= newCapacity) return;\n    var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n    newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n    const oldContents = contents;\n    contents = new Uint8Array(newCapacity);\n    if (cursor > 0) contents.set(oldContents.subarray(0, cursor), 0);\n  }\n}\n\n// src/lzwEncode.js\nvar BITS = 12;\nvar DEFAULT_HSIZE = 5003;\nvar MASKS = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];\nfunction lzwEncode(width, height, pixels, colorDepth, outStream = createStream(512), accum = new Uint8Array(256), htab = new Int32Array(DEFAULT_HSIZE), codetab = new Int32Array(DEFAULT_HSIZE)) {\n  const hsize = htab.length;\n  const initCodeSize = Math.max(2, colorDepth);\n  accum.fill(0);\n  codetab.fill(0);\n  htab.fill(-1);\n  let cur_accum = 0;\n  let cur_bits = 0;\n  const init_bits = initCodeSize + 1;\n  const g_init_bits = init_bits;\n  let clear_flg = false;\n  let n_bits = g_init_bits;\n  let maxcode = (1 << n_bits) - 1;\n  const ClearCode = 1 << init_bits - 1;\n  const EOFCode = ClearCode + 1;\n  let free_ent = ClearCode + 2;\n  let a_count = 0;\n  let ent = pixels[0];\n  let hshift = 0;\n  for (let fcode = hsize; fcode < 65536; fcode *= 2) {\n    ++hshift;\n  }\n  hshift = 8 - hshift;\n  outStream.writeByte(initCodeSize);\n  output(ClearCode);\n  const length = pixels.length;\n  for (let idx = 1; idx < length; idx++) {\n    next_block: {\n      const c = pixels[idx];\n      const fcode = (c << BITS) + ent;\n      let i = c << hshift ^ ent;\n      if (htab[i] === fcode) {\n        ent = codetab[i];\n        break next_block;\n      }\n      const disp = i === 0 ? 1 : hsize - i;\n      while (htab[i] >= 0) {\n        i -= disp;\n        if (i < 0) i += hsize;\n        if (htab[i] === fcode) {\n          ent = codetab[i];\n          break next_block;\n        }\n      }\n      output(ent);\n      ent = c;\n      if (free_ent < 1 << BITS) {\n        codetab[i] = free_ent++;\n        htab[i] = fcode;\n      } else {\n        htab.fill(-1);\n        free_ent = ClearCode + 2;\n        clear_flg = true;\n        output(ClearCode);\n      }\n    }\n  }\n  output(ent);\n  output(EOFCode);\n  outStream.writeByte(0);\n  return outStream.bytesView();\n  function output(code) {\n    cur_accum &= MASKS[cur_bits];\n    if (cur_bits > 0) cur_accum |= code << cur_bits;else cur_accum = code;\n    cur_bits += n_bits;\n    while (cur_bits >= 8) {\n      accum[a_count++] = cur_accum & 255;\n      if (a_count >= 254) {\n        outStream.writeByte(a_count);\n        outStream.writeBytesView(accum, 0, a_count);\n        a_count = 0;\n      }\n      cur_accum >>= 8;\n      cur_bits -= 8;\n    }\n    if (free_ent > maxcode || clear_flg) {\n      if (clear_flg) {\n        n_bits = g_init_bits;\n        maxcode = (1 << n_bits) - 1;\n        clear_flg = false;\n      } else {\n        ++n_bits;\n        maxcode = n_bits === BITS ? 1 << n_bits : (1 << n_bits) - 1;\n      }\n    }\n    if (code == EOFCode) {\n      while (cur_bits > 0) {\n        accum[a_count++] = cur_accum & 255;\n        if (a_count >= 254) {\n          outStream.writeByte(a_count);\n          outStream.writeBytesView(accum, 0, a_count);\n          a_count = 0;\n        }\n        cur_accum >>= 8;\n        cur_bits -= 8;\n      }\n      if (a_count > 0) {\n        outStream.writeByte(a_count);\n        outStream.writeBytesView(accum, 0, a_count);\n        a_count = 0;\n      }\n    }\n  }\n}\nvar lzwEncode_default = lzwEncode;\n\n// src/rgb-packing.js\nfunction rgb888_to_rgb565(r, g, b) {\n  return r << 8 & 63488 | g << 2 & 992 | b >> 3;\n}\nfunction rgba8888_to_rgba4444(r, g, b, a) {\n  return r >> 4 | g & 240 | (b & 240) << 4 | (a & 240) << 8;\n}\nfunction rgb888_to_rgb444(r, g, b) {\n  return r >> 4 << 8 | g & 240 | b >> 4;\n}\n\n// src/pnnquant2.js\nfunction clamp(value, min, max) {\n  return value < min ? min : value > max ? max : value;\n}\nfunction sqr(value) {\n  return value * value;\n}\nfunction find_nn(bins, idx, hasAlpha) {\n  var nn = 0;\n  var err = 1e100;\n  const bin1 = bins[idx];\n  const n1 = bin1.cnt;\n  const wa = bin1.ac;\n  const wr = bin1.rc;\n  const wg = bin1.gc;\n  const wb = bin1.bc;\n  for (var i = bin1.fw; i != 0; i = bins[i].fw) {\n    const bin = bins[i];\n    const n2 = bin.cnt;\n    const nerr2 = n1 * n2 / (n1 + n2);\n    if (nerr2 >= err) continue;\n    var nerr = 0;\n    if (hasAlpha) {\n      nerr += nerr2 * sqr(bin.ac - wa);\n      if (nerr >= err) continue;\n    }\n    nerr += nerr2 * sqr(bin.rc - wr);\n    if (nerr >= err) continue;\n    nerr += nerr2 * sqr(bin.gc - wg);\n    if (nerr >= err) continue;\n    nerr += nerr2 * sqr(bin.bc - wb);\n    if (nerr >= err) continue;\n    err = nerr;\n    nn = i;\n  }\n  bin1.err = err;\n  bin1.nn = nn;\n}\nfunction create_bin() {\n  return {\n    ac: 0,\n    rc: 0,\n    gc: 0,\n    bc: 0,\n    cnt: 0,\n    nn: 0,\n    fw: 0,\n    bk: 0,\n    tm: 0,\n    mtm: 0,\n    err: 0\n  };\n}\nfunction create_bin_list(data, format) {\n  const bincount = format === \"rgb444\" ? 4096 : 65536;\n  const bins = new Array(bincount);\n  const size = data.length;\n  if (format === \"rgba4444\") {\n    for (let i = 0; i < size; ++i) {\n      const color = data[i];\n      const a = color >> 24 & 255;\n      const b = color >> 16 & 255;\n      const g = color >> 8 & 255;\n      const r = color & 255;\n      const index = rgba8888_to_rgba4444(r, g, b, a);\n      let bin = index in bins ? bins[index] : bins[index] = create_bin();\n      bin.rc += r;\n      bin.gc += g;\n      bin.bc += b;\n      bin.ac += a;\n      bin.cnt++;\n    }\n  } else if (format === \"rgb444\") {\n    for (let i = 0; i < size; ++i) {\n      const color = data[i];\n      const b = color >> 16 & 255;\n      const g = color >> 8 & 255;\n      const r = color & 255;\n      const index = rgb888_to_rgb444(r, g, b);\n      let bin = index in bins ? bins[index] : bins[index] = create_bin();\n      bin.rc += r;\n      bin.gc += g;\n      bin.bc += b;\n      bin.cnt++;\n    }\n  } else {\n    for (let i = 0; i < size; ++i) {\n      const color = data[i];\n      const b = color >> 16 & 255;\n      const g = color >> 8 & 255;\n      const r = color & 255;\n      const index = rgb888_to_rgb565(r, g, b);\n      let bin = index in bins ? bins[index] : bins[index] = create_bin();\n      bin.rc += r;\n      bin.gc += g;\n      bin.bc += b;\n      bin.cnt++;\n    }\n  }\n  return bins;\n}\nfunction quantize(rgba, maxColors, opts = {}) {\n  const {\n    format = \"rgb565\",\n    clearAlpha = true,\n    clearAlphaColor = 0,\n    clearAlphaThreshold = 0,\n    oneBitAlpha = false\n  } = opts;\n  if (!rgba || !rgba.buffer) {\n    throw new Error(\"quantize() expected RGBA Uint8Array data\");\n  }\n  if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) {\n    throw new Error(\"quantize() expected RGBA Uint8Array data\");\n  }\n  const data = new Uint32Array(rgba.buffer);\n  let useSqrt = opts.useSqrt !== false;\n  const hasAlpha = format === \"rgba4444\";\n  const bins = create_bin_list(data, format);\n  const bincount = bins.length;\n  const bincountMinusOne = bincount - 1;\n  const heap = new Uint32Array(bincount + 1);\n  var maxbins = 0;\n  for (var i = 0; i < bincount; ++i) {\n    const bin = bins[i];\n    if (bin != null) {\n      var d = 1 / bin.cnt;\n      if (hasAlpha) bin.ac *= d;\n      bin.rc *= d;\n      bin.gc *= d;\n      bin.bc *= d;\n      bins[maxbins++] = bin;\n    }\n  }\n  if (sqr(maxColors) / maxbins < 0.022) {\n    useSqrt = false;\n  }\n  var i = 0;\n  for (; i < maxbins - 1; ++i) {\n    bins[i].fw = i + 1;\n    bins[i + 1].bk = i;\n    if (useSqrt) bins[i].cnt = Math.sqrt(bins[i].cnt);\n  }\n  if (useSqrt) bins[i].cnt = Math.sqrt(bins[i].cnt);\n  var h, l, l2;\n  for (i = 0; i < maxbins; ++i) {\n    find_nn(bins, i, false);\n    var err = bins[i].err;\n    for (l = ++heap[0]; l > 1; l = l2) {\n      l2 = l >> 1;\n      if (bins[h = heap[l2]].err <= err) break;\n      heap[l] = h;\n    }\n    heap[l] = i;\n  }\n  var extbins = maxbins - maxColors;\n  for (i = 0; i < extbins;) {\n    var tb;\n    for (;;) {\n      var b1 = heap[1];\n      tb = bins[b1];\n      if (tb.tm >= tb.mtm && bins[tb.nn].mtm <= tb.tm) break;\n      if (tb.mtm == bincountMinusOne) b1 = heap[1] = heap[heap[0]--];else {\n        find_nn(bins, b1, false);\n        tb.tm = i;\n      }\n      var err = bins[b1].err;\n      for (l = 1; (l2 = l + l) <= heap[0]; l = l2) {\n        if (l2 < heap[0] && bins[heap[l2]].err > bins[heap[l2 + 1]].err) l2++;\n        if (err <= bins[h = heap[l2]].err) break;\n        heap[l] = h;\n      }\n      heap[l] = b1;\n    }\n    var nb = bins[tb.nn];\n    var n1 = tb.cnt;\n    var n2 = nb.cnt;\n    var d = 1 / (n1 + n2);\n    if (hasAlpha) tb.ac = d * (n1 * tb.ac + n2 * nb.ac);\n    tb.rc = d * (n1 * tb.rc + n2 * nb.rc);\n    tb.gc = d * (n1 * tb.gc + n2 * nb.gc);\n    tb.bc = d * (n1 * tb.bc + n2 * nb.bc);\n    tb.cnt += nb.cnt;\n    tb.mtm = ++i;\n    bins[nb.bk].fw = nb.fw;\n    bins[nb.fw].bk = nb.bk;\n    nb.mtm = bincountMinusOne;\n  }\n  let palette = [];\n  var k = 0;\n  for (i = 0;; ++k) {\n    let r = clamp(Math.round(bins[i].rc), 0, 255);\n    let g = clamp(Math.round(bins[i].gc), 0, 255);\n    let b = clamp(Math.round(bins[i].bc), 0, 255);\n    let a = 255;\n    if (hasAlpha) {\n      a = clamp(Math.round(bins[i].ac), 0, 255);\n      if (oneBitAlpha) {\n        const threshold = typeof oneBitAlpha === \"number\" ? oneBitAlpha : 127;\n        a = a <= threshold ? 0 : 255;\n      }\n      if (clearAlpha && a <= clearAlphaThreshold) {\n        r = g = b = clearAlphaColor;\n        a = 0;\n      }\n    }\n    const color = hasAlpha ? [r, g, b, a] : [r, g, b];\n    const exists = existsInPalette(palette, color);\n    if (!exists) palette.push(color);\n    if ((i = bins[i].fw) == 0) break;\n  }\n  return palette;\n}\nfunction existsInPalette(palette, color) {\n  for (let i = 0; i < palette.length; i++) {\n    const p = palette[i];\n    let matchesRGB = p[0] === color[0] && p[1] === color[1] && p[2] === color[2];\n    let matchesAlpha = p.length >= 4 && color.length >= 4 ? p[3] === color[3] : true;\n    if (matchesRGB && matchesAlpha) return true;\n  }\n  return false;\n}\n\n// src/color.js\nfunction euclideanDistanceSquared(a, b) {\n  var sum = 0;\n  var n;\n  for (n = 0; n < a.length; n++) {\n    const dx = a[n] - b[n];\n    sum += dx * dx;\n  }\n  return sum;\n}\n\n// src/palettize.js\nfunction roundStep(byte, step) {\n  return step > 1 ? Math.round(byte / step) * step : byte;\n}\nfunction prequantize(rgba, {\n  roundRGB = 5,\n  roundAlpha = 10,\n  oneBitAlpha = null\n} = {}) {\n  const data = new Uint32Array(rgba.buffer);\n  for (let i = 0; i < data.length; i++) {\n    const color = data[i];\n    let a = color >> 24 & 255;\n    let b = color >> 16 & 255;\n    let g = color >> 8 & 255;\n    let r = color & 255;\n    a = roundStep(a, roundAlpha);\n    if (oneBitAlpha) {\n      const threshold = typeof oneBitAlpha === \"number\" ? oneBitAlpha : 127;\n      a = a <= threshold ? 0 : 255;\n    }\n    r = roundStep(r, roundRGB);\n    g = roundStep(g, roundRGB);\n    b = roundStep(b, roundRGB);\n    data[i] = a << 24 | b << 16 | g << 8 | r << 0;\n  }\n}\nfunction applyPalette(rgba, palette, format = \"rgb565\") {\n  if (!rgba || !rgba.buffer) {\n    throw new Error(\"quantize() expected RGBA Uint8Array data\");\n  }\n  if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) {\n    throw new Error(\"quantize() expected RGBA Uint8Array data\");\n  }\n  if (palette.length > 256) {\n    throw new Error(\"applyPalette() only works with 256 colors or less\");\n  }\n  const data = new Uint32Array(rgba.buffer);\n  const length = data.length;\n  const bincount = format === \"rgb444\" ? 4096 : 65536;\n  const index = new Uint8Array(length);\n  const cache = new Array(bincount);\n  const hasAlpha = format === \"rgba4444\";\n  if (format === \"rgba4444\") {\n    for (let i = 0; i < length; i++) {\n      const color = data[i];\n      const a = color >> 24 & 255;\n      const b = color >> 16 & 255;\n      const g = color >> 8 & 255;\n      const r = color & 255;\n      const key = rgba8888_to_rgba4444(r, g, b, a);\n      const idx = key in cache ? cache[key] : cache[key] = nearestColorIndexRGBA(r, g, b, a, palette);\n      index[i] = idx;\n    }\n  } else {\n    const rgb888_to_key = format === \"rgb444\" ? rgb888_to_rgb444 : rgb888_to_rgb565;\n    for (let i = 0; i < length; i++) {\n      const color = data[i];\n      const b = color >> 16 & 255;\n      const g = color >> 8 & 255;\n      const r = color & 255;\n      const key = rgb888_to_key(r, g, b);\n      const idx = key in cache ? cache[key] : cache[key] = nearestColorIndexRGB(r, g, b, palette);\n      index[i] = idx;\n    }\n  }\n  return index;\n}\nfunction nearestColorIndexRGBA(r, g, b, a, palette) {\n  let k = 0;\n  let mindist = 1e100;\n  for (let i = 0; i < palette.length; i++) {\n    const px2 = palette[i];\n    const a2 = px2[3];\n    let curdist = sqr2(a2 - a);\n    if (curdist > mindist) continue;\n    const r2 = px2[0];\n    curdist += sqr2(r2 - r);\n    if (curdist > mindist) continue;\n    const g2 = px2[1];\n    curdist += sqr2(g2 - g);\n    if (curdist > mindist) continue;\n    const b2 = px2[2];\n    curdist += sqr2(b2 - b);\n    if (curdist > mindist) continue;\n    mindist = curdist;\n    k = i;\n  }\n  return k;\n}\nfunction nearestColorIndexRGB(r, g, b, palette) {\n  let k = 0;\n  let mindist = 1e100;\n  for (let i = 0; i < palette.length; i++) {\n    const px2 = palette[i];\n    const r2 = px2[0];\n    let curdist = sqr2(r2 - r);\n    if (curdist > mindist) continue;\n    const g2 = px2[1];\n    curdist += sqr2(g2 - g);\n    if (curdist > mindist) continue;\n    const b2 = px2[2];\n    curdist += sqr2(b2 - b);\n    if (curdist > mindist) continue;\n    mindist = curdist;\n    k = i;\n  }\n  return k;\n}\nfunction snapColorsToPalette(palette, knownColors, threshold = 5) {\n  if (!palette.length || !knownColors.length) return;\n  const paletteRGB = palette.map(p => p.slice(0, 3));\n  const thresholdSq = threshold * threshold;\n  const dim = palette[0].length;\n  for (let i = 0; i < knownColors.length; i++) {\n    let color = knownColors[i];\n    if (color.length < dim) {\n      color = [color[0], color[1], color[2], 255];\n    } else if (color.length > dim) {\n      color = color.slice(0, 3);\n    } else {\n      color = color.slice();\n    }\n    const r = nearestColorIndexWithDistance(paletteRGB, color.slice(0, 3), euclideanDistanceSquared);\n    const idx = r[0];\n    const distanceSq = r[1];\n    if (distanceSq > 0 && distanceSq <= thresholdSq) {\n      palette[idx] = color;\n    }\n  }\n}\nfunction sqr2(a) {\n  return a * a;\n}\nfunction nearestColorIndex(colors, pixel, distanceFn = euclideanDistanceSquared) {\n  let minDist = Infinity;\n  let minDistIndex = -1;\n  for (let j = 0; j < colors.length; j++) {\n    const paletteColor = colors[j];\n    const dist = distanceFn(pixel, paletteColor);\n    if (dist < minDist) {\n      minDist = dist;\n      minDistIndex = j;\n    }\n  }\n  return minDistIndex;\n}\nfunction nearestColorIndexWithDistance(colors, pixel, distanceFn = euclideanDistanceSquared) {\n  let minDist = Infinity;\n  let minDistIndex = -1;\n  for (let j = 0; j < colors.length; j++) {\n    const paletteColor = colors[j];\n    const dist = distanceFn(pixel, paletteColor);\n    if (dist < minDist) {\n      minDist = dist;\n      minDistIndex = j;\n    }\n  }\n  return [minDistIndex, minDist];\n}\nfunction nearestColor(colors, pixel, distanceFn = euclideanDistanceSquared) {\n  return colors[nearestColorIndex(colors, pixel, distanceFn)];\n}\n\n// src/index.js\nfunction GIFEncoder(opt = {}) {\n  const {\n    initialCapacity = 4096,\n    auto = true\n  } = opt;\n  const stream = createStream(initialCapacity);\n  const HSIZE = 5003;\n  const accum = new Uint8Array(256);\n  const htab = new Int32Array(HSIZE);\n  const codetab = new Int32Array(HSIZE);\n  let hasInit = false;\n  return {\n    reset() {\n      stream.reset();\n      hasInit = false;\n    },\n    finish() {\n      stream.writeByte(constants_default.trailer);\n    },\n    bytes() {\n      return stream.bytes();\n    },\n    bytesView() {\n      return stream.bytesView();\n    },\n    get buffer() {\n      return stream.buffer;\n    },\n    get stream() {\n      return stream;\n    },\n    writeHeader,\n    writeFrame(index, width, height, opts = {}) {\n      const {\n        transparent = false,\n        transparentIndex = 0,\n        delay = 0,\n        palette = null,\n        repeat = 0,\n        colorDepth = 8,\n        dispose = -1\n      } = opts;\n      let first = false;\n      if (auto) {\n        if (!hasInit) {\n          first = true;\n          writeHeader();\n          hasInit = true;\n        }\n      } else {\n        first = Boolean(opts.first);\n      }\n      width = Math.max(0, Math.floor(width));\n      height = Math.max(0, Math.floor(height));\n      if (first) {\n        if (!palette) {\n          throw new Error(\"First frame must include a { palette } option\");\n        }\n        encodeLogicalScreenDescriptor(stream, width, height, palette, colorDepth);\n        encodeColorTable(stream, palette);\n        if (repeat >= 0) {\n          encodeNetscapeExt(stream, repeat);\n        }\n      }\n      const delayTime = Math.round(delay / 10);\n      encodeGraphicControlExt(stream, dispose, delayTime, transparent, transparentIndex);\n      const useLocalColorTable = Boolean(palette) && !first;\n      encodeImageDescriptor(stream, width, height, useLocalColorTable ? palette : null);\n      if (useLocalColorTable) encodeColorTable(stream, palette);\n      encodePixels(stream, index, width, height, colorDepth, accum, htab, codetab);\n    }\n  };\n  function writeHeader() {\n    writeUTFBytes(stream, \"GIF89a\");\n  }\n}\nfunction encodeGraphicControlExt(stream, dispose, delay, transparent, transparentIndex) {\n  stream.writeByte(33);\n  stream.writeByte(249);\n  stream.writeByte(4);\n  if (transparentIndex < 0) {\n    transparentIndex = 0;\n    transparent = false;\n  }\n  var transp, disp;\n  if (!transparent) {\n    transp = 0;\n    disp = 0;\n  } else {\n    transp = 1;\n    disp = 2;\n  }\n  if (dispose >= 0) {\n    disp = dispose & 7;\n  }\n  disp <<= 2;\n  const userInput = 0;\n  stream.writeByte(0 | disp | userInput | transp);\n  writeUInt16(stream, delay);\n  stream.writeByte(transparentIndex || 0);\n  stream.writeByte(0);\n}\nfunction encodeLogicalScreenDescriptor(stream, width, height, palette, colorDepth = 8) {\n  const globalColorTableFlag = 1;\n  const sortFlag = 0;\n  const globalColorTableSize = colorTableSize(palette.length) - 1;\n  const fields = globalColorTableFlag << 7 | colorDepth - 1 << 4 | sortFlag << 3 | globalColorTableSize;\n  const backgroundColorIndex = 0;\n  const pixelAspectRatio = 0;\n  writeUInt16(stream, width);\n  writeUInt16(stream, height);\n  stream.writeBytes([fields, backgroundColorIndex, pixelAspectRatio]);\n}\nfunction encodeNetscapeExt(stream, repeat) {\n  stream.writeByte(33);\n  stream.writeByte(255);\n  stream.writeByte(11);\n  writeUTFBytes(stream, \"NETSCAPE2.0\");\n  stream.writeByte(3);\n  stream.writeByte(1);\n  writeUInt16(stream, repeat);\n  stream.writeByte(0);\n}\nfunction encodeColorTable(stream, palette) {\n  const colorTableLength = 1 << colorTableSize(palette.length);\n  for (let i = 0; i < colorTableLength; i++) {\n    let color = [0, 0, 0];\n    if (i < palette.length) {\n      color = palette[i];\n    }\n    stream.writeByte(color[0]);\n    stream.writeByte(color[1]);\n    stream.writeByte(color[2]);\n  }\n}\nfunction encodeImageDescriptor(stream, width, height, localPalette) {\n  stream.writeByte(44);\n  writeUInt16(stream, 0);\n  writeUInt16(stream, 0);\n  writeUInt16(stream, width);\n  writeUInt16(stream, height);\n  if (localPalette) {\n    const interlace = 0;\n    const sorted = 0;\n    const palSize = colorTableSize(localPalette.length) - 1;\n    stream.writeByte(128 | interlace | sorted | 0 | palSize);\n  } else {\n    stream.writeByte(0);\n  }\n}\nfunction encodePixels(stream, index, width, height, colorDepth = 8, accum, htab, codetab) {\n  lzwEncode_default(width, height, index, colorDepth, stream, accum, htab, codetab);\n}\nfunction writeUInt16(stream, short) {\n  stream.writeByte(short & 255);\n  stream.writeByte(short >> 8 & 255);\n}\nfunction writeUTFBytes(stream, text) {\n  for (var i = 0; i < text.length; i++) {\n    stream.writeByte(text.charCodeAt(i));\n  }\n}\nfunction colorTableSize(length) {\n  return Math.max(Math.ceil(Math.log2(length)), 1);\n}\nvar src_default = GIFEncoder;","map":{"version":3,"names":["__markAsModule","exports","__export","GIFEncoder","applyPalette","default","src_default","nearestColor","nearestColorIndex","nearestColorIndexWithDistance","prequantize","quantize","snapColorsToPalette","constants_default","signature","version","trailer","extensionIntroducer","applicationExtensionLabel","graphicControlExtensionLabel","imageSeparator","signatureSize","versionSize","globalColorTableFlagMask","colorResolutionMask","sortFlagMask","globalColorTableSizeMask","applicationIdentifierSize","applicationAuthCodeSize","disposalMethodMask","userInputFlagMask","transparentColorFlagMask","localColorTableFlagMask","interlaceFlagMask","idSortFlagMask","localColorTableSizeMask","createStream","initialCapacity","cursor","contents","Uint8Array","buffer","reset","bytesView","subarray","bytes","slice","writeByte","byte","expand","writeBytes","data","offset","byteLength","length","i","writeBytesView","set","newCapacity","prevCapacity","CAPACITY_DOUBLING_MAX","Math","max","oldContents","BITS","DEFAULT_HSIZE","MASKS","lzwEncode","width","height","pixels","colorDepth","outStream","accum","htab","Int32Array","codetab","hsize","initCodeSize","fill","cur_accum","cur_bits","init_bits","g_init_bits","clear_flg","n_bits","maxcode","ClearCode","EOFCode","free_ent","a_count","ent","hshift","fcode","output","idx","next_block","c","disp","code","lzwEncode_default","rgb888_to_rgb565","r","g","b","rgba8888_to_rgba4444","a","rgb888_to_rgb444","clamp","value","min","sqr","find_nn","bins","hasAlpha","nn","err","bin1","n1","cnt","wa","ac","wr","rc","wg","gc","wb","bc","fw","bin","n2","nerr2","nerr","create_bin","bk","tm","mtm","create_bin_list","format","bincount","Array","size","color","index","rgba","maxColors","opts","clearAlpha","clearAlphaColor","clearAlphaThreshold","oneBitAlpha","Error","Uint8ClampedArray","Uint32Array","useSqrt","bincountMinusOne","heap","maxbins","d","sqrt","h","l","l2","extbins","tb","b1","nb","palette","k","round","threshold","exists","existsInPalette","push","p","matchesRGB","matchesAlpha","euclideanDistanceSquared","sum","n","dx","roundStep","step","roundRGB","roundAlpha","cache","key","nearestColorIndexRGBA","rgb888_to_key","nearestColorIndexRGB","mindist","px2","a2","curdist","sqr2","r2","g2","b2","knownColors","paletteRGB","map","thresholdSq","dim","distanceSq","colors","pixel","distanceFn","minDist","Infinity","minDistIndex","j","paletteColor","dist","opt","auto","stream","HSIZE","hasInit","finish","writeHeader","writeFrame","transparent","transparentIndex","delay","repeat","dispose","first","Boolean","floor","encodeLogicalScreenDescriptor","encodeColorTable","encodeNetscapeExt","delayTime","encodeGraphicControlExt","useLocalColorTable","encodeImageDescriptor","encodePixels","writeUTFBytes","transp","userInput","writeUInt16","globalColorTableFlag","sortFlag","globalColorTableSize","colorTableSize","fields","backgroundColorIndex","pixelAspectRatio","colorTableLength","localPalette","interlace","sorted","palSize","short","text","charCodeAt","ceil","log2"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/index.js","/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/constants.js","/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/stream.js","/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/lzwEncode.js","/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/rgb-packing.js","/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/pnnquant2.js","/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/color.js","/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/gifenc/src/palettize.js"],"sourcesContent":["import constants from \"./constants.js\";\nimport lzwEncode from \"./lzwEncode.js\";\nimport createStream from \"./stream.js\";\nimport quantize from \"./pnnquant2.js\";\n\nimport {\n  prequantize,\n  applyPalette,\n  nearestColorIndex,\n  nearestColor,\n  nearestColorIndexWithDistance,\n  snapColorsToPalette,\n} from \"./palettize.js\";\n\nfunction GIFEncoder(opt = {}) {\n  const { initialCapacity = 4096, auto = true } = opt;\n\n  // Stream all encoded data into this buffer\n  const stream = createStream(initialCapacity);\n\n  // Shared array data across all frames\n  const HSIZE = 5003; // 80% occupancy\n  const accum = new Uint8Array(256);\n  const htab = new Int32Array(HSIZE);\n  const codetab = new Int32Array(HSIZE);\n\n  let hasInit = false;\n\n  return {\n    reset() {\n      stream.reset();\n      hasInit = false;\n    },\n    finish() {\n      stream.writeByte(constants.trailer);\n    },\n    bytes() {\n      return stream.bytes();\n    },\n    bytesView() {\n      return stream.bytesView();\n    },\n    get buffer() {\n      return stream.buffer;\n    },\n    get stream() {\n      return stream;\n    },\n    writeHeader,\n    writeFrame(index, width, height, opts = {}) {\n      const {\n        transparent = false,\n        transparentIndex = 0x00,\n        delay = 0,\n        palette = null,\n        repeat = 0, // -1=once, 0=forever, >0=count\n        colorDepth = 8,\n        dispose = -1,\n      } = opts;\n\n      let first = false;\n      if (auto) {\n        // In 'auto' mode, the first time we write a frame\n        // we will write LSD/GCT/EXT\n        if (!hasInit) {\n          // have not yet init, we can consider this our first frame\n          first = true;\n          // in 'auto' mode, we also encode a header on first frame\n          // this is different than manual mode where you must encode\n          // header yoursef (or perhaps not write header altogether)\n          writeHeader();\n          hasInit = true;\n        }\n      } else {\n        // in manual mode, the first frame is determined by the options only\n        first = Boolean(opts.first);\n      }\n\n      width = Math.max(0, Math.floor(width));\n      height = Math.max(0, Math.floor(height));\n\n      // Write pre-frame details such as repeat count and global palette\n      if (first) {\n        if (!palette) {\n          throw new Error(\"First frame must include a { palette } option\");\n        }\n        encodeLogicalScreenDescriptor(\n          stream,\n          width,\n          height,\n          palette,\n          colorDepth\n        );\n        encodeColorTable(stream, palette);\n        if (repeat >= 0) {\n          encodeNetscapeExt(stream, repeat);\n        }\n      }\n\n      const delayTime = Math.round(delay / 10);\n      encodeGraphicControlExt(\n        stream,\n        dispose,\n        delayTime,\n        transparent,\n        transparentIndex\n      );\n\n      const useLocalColorTable = Boolean(palette) && !first;\n      encodeImageDescriptor(\n        stream,\n        width,\n        height,\n        useLocalColorTable ? palette : null\n      );\n      if (useLocalColorTable) encodeColorTable(stream, palette);\n      encodePixels(\n        stream,\n        index,\n        width,\n        height,\n        colorDepth,\n        accum,\n        htab,\n        codetab\n      );\n    },\n  };\n\n  function writeHeader() {\n    writeUTFBytes(stream, \"GIF89a\");\n  }\n}\n\nfunction encodeGraphicControlExt(\n  stream,\n  dispose,\n  delay,\n  transparent,\n  transparentIndex\n) {\n  stream.writeByte(0x21); // extension introducer\n  stream.writeByte(0xf9); // GCE label\n  stream.writeByte(4); // data block size\n\n  if (transparentIndex < 0) {\n    transparentIndex = 0x00;\n    transparent = false;\n  }\n\n  var transp, disp;\n  if (!transparent) {\n    transp = 0;\n    disp = 0; // dispose = no action\n  } else {\n    transp = 1;\n    disp = 2; // force clear if using transparent color\n  }\n\n  if (dispose >= 0) {\n    disp = dispose & 7; // user override\n  }\n\n  disp <<= 2;\n\n  const userInput = 0;\n\n  // packed fields\n  stream.writeByte(\n    0 | // 1:3 reserved\n      disp | // 4:6 disposal\n      userInput | // 7 user input - 0 = none\n      transp // 8 transparency flag\n  );\n\n  writeUInt16(stream, delay); // delay x 1/100 sec\n  stream.writeByte(transparentIndex || 0x00); // transparent color index\n  stream.writeByte(0); // block terminator\n}\n\nfunction encodeLogicalScreenDescriptor(\n  stream,\n  width,\n  height,\n  palette,\n  colorDepth = 8\n) {\n  const globalColorTableFlag = 1;\n  const sortFlag = 0;\n  const globalColorTableSize = colorTableSize(palette.length) - 1;\n  const fields =\n    (globalColorTableFlag << 7) |\n    ((colorDepth - 1) << 4) |\n    (sortFlag << 3) |\n    globalColorTableSize;\n  const backgroundColorIndex = 0;\n  const pixelAspectRatio = 0;\n  writeUInt16(stream, width);\n  writeUInt16(stream, height);\n  stream.writeBytes([fields, backgroundColorIndex, pixelAspectRatio]);\n}\n\nfunction encodeNetscapeExt(stream, repeat) {\n  stream.writeByte(0x21); // extension introducer\n  stream.writeByte(0xff); // app extension label\n  stream.writeByte(11); // block size\n  writeUTFBytes(stream, \"NETSCAPE2.0\"); // app id + auth code\n  stream.writeByte(3); // sub-block size\n  stream.writeByte(1); // loop sub-block id\n  writeUInt16(stream, repeat); // loop count (extra iterations, 0=repeat forever)\n  stream.writeByte(0); // block terminator\n}\n\nfunction encodeColorTable(stream, palette) {\n  const colorTableLength = 1 << colorTableSize(palette.length);\n  for (let i = 0; i < colorTableLength; i++) {\n    let color = [0, 0, 0];\n    if (i < palette.length) {\n      color = palette[i];\n    }\n    stream.writeByte(color[0]);\n    stream.writeByte(color[1]);\n    stream.writeByte(color[2]);\n  }\n}\n\nfunction encodeImageDescriptor(stream, width, height, localPalette) {\n  stream.writeByte(0x2c); // image separator\n\n  writeUInt16(stream, 0); // x position\n  writeUInt16(stream, 0); // y position\n  writeUInt16(stream, width); // image size\n  writeUInt16(stream, height);\n\n  if (localPalette) {\n    const interlace = 0;\n    const sorted = 0;\n    const palSize = colorTableSize(localPalette.length) - 1;\n    // local palette\n    stream.writeByte(\n      0x80 | // 1 local color table 1=yes\n        interlace | // 2 interlace - 0=no\n        sorted | // 3 sorted - 0=no\n        0 | // 4-5 reserved\n        palSize // 6-8 size of color table\n    );\n  } else {\n    // global palette\n    stream.writeByte(0);\n  }\n}\n\nfunction encodePixels(\n  stream,\n  index,\n  width,\n  height,\n  colorDepth = 8,\n  accum,\n  htab,\n  codetab\n) {\n  lzwEncode(width, height, index, colorDepth, stream, accum, htab, codetab);\n}\n\n// Utilities\n\nfunction writeUInt16(stream, short) {\n  stream.writeByte(short & 0xff);\n  stream.writeByte((short >> 8) & 0xff);\n}\n\nfunction writeUTFBytes(stream, text) {\n  for (var i = 0; i < text.length; i++) {\n    stream.writeByte(text.charCodeAt(i));\n  }\n}\n\nfunction colorTableSize(length) {\n  return Math.max(Math.ceil(Math.log2(length)), 1);\n}\n\nexport {\n  GIFEncoder,\n  quantize,\n  prequantize,\n  applyPalette,\n  nearestColorIndex,\n  nearestColor,\n  nearestColorIndexWithDistance,\n  snapColorsToPalette,\n};\n\nexport default GIFEncoder;\n","export default {\n  signature: \"GIF\",\n  version: \"89a\",\n  trailer: 0x3B,\n  extensionIntroducer: 0x21,\n  applicationExtensionLabel: 0xFF,\n  graphicControlExtensionLabel: 0xF9,\n  imageSeparator: 0x2C,\n  // Header\n  signatureSize: 3,\n  versionSize: 3,\n  globalColorTableFlagMask: 0b10000000,\n  colorResolutionMask: 0b01110000,\n  sortFlagMask: 0b00001000,\n  globalColorTableSizeMask: 0b00000111,\n  // Application extension\n  applicationIdentifierSize: 8,\n  applicationAuthCodeSize: 3,\n  // Graphic control extension\n  disposalMethodMask: 0b00011100,\n  userInputFlagMask: 0b00000010,\n  transparentColorFlagMask: 0b00000001,\n  // Image descriptor\n  localColorTableFlagMask: 0b10000000,\n  interlaceFlagMask: 0b01000000,\n  idSortFlagMask: 0b00100000,\n  localColorTableSizeMask: 0b00000111\n}\n","export default function createStream(initialCapacity = 256) {\n  let cursor = 0;\n  let contents = new Uint8Array(initialCapacity);\n\n  return {\n    get buffer() {\n      return contents.buffer;\n    },\n    reset() {\n      cursor = 0;\n    },\n    bytesView() {\n      return contents.subarray(0, cursor);\n    },\n    bytes() {\n      return contents.slice(0, cursor);\n    },\n    writeByte(byte) {\n      expand(cursor + 1);\n      contents[cursor] = byte;\n      cursor++;\n    },\n    writeBytes(data, offset = 0, byteLength = data.length) {\n      expand(cursor + byteLength);\n      for (let i = 0; i < byteLength; i++) {\n        contents[cursor++] = data[i + offset];\n      }\n    },\n    writeBytesView(data, offset = 0, byteLength = data.byteLength) {\n      expand(cursor + byteLength);\n      contents.set(data.subarray(offset, offset + byteLength), cursor);\n      cursor += byteLength;\n    },\n  };\n\n  function expand(newCapacity) {\n    var prevCapacity = contents.length;\n    if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n    // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n    // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n    // avoid overshooting the allocation cap by a very large margin.\n    var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n    newCapacity = Math.max(\n      newCapacity,\n      (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>>\n        0\n    );\n    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n    const oldContents = contents;\n    contents = new Uint8Array(newCapacity); // Allocate new storage.\n    if (cursor > 0) contents.set(oldContents.subarray(0, cursor), 0);\n  }\n}\n","/*\n  LZWEncoder.js\n  Authors\n  Kevin Weiner (original Java version - kweiner@fmsware.com)\n  Thibault Imbert (AS3 version - bytearray.org)\n  Johan Nordberg (JS version - code@johan-nordberg.com)\n  Acknowledgements\n  GIFCOMPR.C - GIF Image compression routines\n  Lempel-Ziv compression based on 'compress'. GIF modifications by\n  David Rowley (mgardi@watdcsu.waterloo.edu)\n  GIF Image compression - modified 'compress'\n  Based on: compress.c - File compression ala IEEE Computer, June 1984.\n  By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n  Jim McKie (decvax!mcvax!jim)\n  Steve Davies (decvax!vax135!petsd!peora!srd)\n  Ken Turkowski (decvax!decwrl!turtlevax!ken)\n  James A. Woods (decvax!ihnp4!ames!jaw)\n  Joe Orost (decvax!vax135!petsd!joe)\n  Matt DesLauriers (@mattdesl - V8/JS optimizations)\n  Mathieu Henri (@p01 - JS optimization)\n*/\n\nimport createStream from \"./stream.js\";\n\nconst EOF = -1;\nconst BITS = 12;\nconst DEFAULT_HSIZE = 5003; // 80% occupancy\nconst MASKS = [\n  0x0000,\n  0x0001,\n  0x0003,\n  0x0007,\n  0x000f,\n  0x001f,\n  0x003f,\n  0x007f,\n  0x00ff,\n  0x01ff,\n  0x03ff,\n  0x07ff,\n  0x0fff,\n  0x1fff,\n  0x3fff,\n  0x7fff,\n  0xffff,\n];\n\nfunction lzwEncode(\n  width,\n  height,\n  pixels,\n  colorDepth,\n  outStream = createStream(512),\n  accum = new Uint8Array(256),\n  htab = new Int32Array(DEFAULT_HSIZE),\n  codetab = new Int32Array(DEFAULT_HSIZE)\n) {\n  const hsize = htab.length;\n  const initCodeSize = Math.max(2, colorDepth);\n\n  accum.fill(0);\n  codetab.fill(0);\n  htab.fill(-1);\n\n  let cur_accum = 0;\n  let cur_bits = 0;\n\n  // Algorithm: use open addressing double hashing (no chaining) on the\n  // prefix code / next character combination. We do a variant of Knuth's\n  // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n  // secondary probe. Here, the modular division first probe is gives way\n  // to a faster exclusive-or manipulation. Also do block compression with\n  // an adaptive reset, whereby the code table is cleared when the compression\n  // ratio decreases, but after the table fills. The variable-length output\n  // codes are re-sized at this point, and a special CLEAR code is generated\n  // for the decompressor. Late addition: construct the table according to\n  // file size for noticeable speed improvement on small files. Please direct\n  // questions about this implementation to ames!jaw.\n\n  // compress and write the pixel data\n  const init_bits = initCodeSize + 1;\n\n  // Set up the globals: g_init_bits - initial number of bits\n  const g_init_bits = init_bits;\n\n  // Set up the necessary values\n\n  // block compression parameters -- after all codes are used up,\n  // and compression rate changes, start over.\n  let clear_flg = false;\n  let n_bits = g_init_bits;\n  let maxcode = (1 << n_bits) - 1;\n\n  const ClearCode = 1 << (init_bits - 1);\n  const EOFCode = ClearCode + 1;\n  let free_ent = ClearCode + 2;\n  let a_count = 0; // clear packet\n\n  let ent = pixels[0];\n\n  let hshift = 0;\n  for (let fcode = hsize; fcode < 65536; fcode *= 2) {\n    ++hshift;\n  }\n  hshift = 8 - hshift; // set hash code range bound\n\n  outStream.writeByte(initCodeSize); // write \"initial code size\" byte\n\n  output(ClearCode);\n\n  const length = pixels.length;\n  for (let idx = 1; idx < length; idx++) {\n    next_block: {\n      const c = pixels[idx];\n      const fcode = (c << BITS) + ent;\n      let i = (c << hshift) ^ ent; // xor hashing\n      if (htab[i] === fcode) {\n        ent = codetab[i];\n        break next_block;\n      }\n\n      const disp = i === 0 ? 1 : hsize - i; // secondary hash (after G. Knott)\n      while (htab[i] >= 0) {\n        // non-empty slot\n        i -= disp;\n        if (i < 0) i += hsize;\n        if (htab[i] === fcode) {\n          ent = codetab[i];\n          break next_block;\n        }\n      }\n      output(ent);\n      ent = c;\n      if (free_ent < 1 << BITS) {\n        codetab[i] = free_ent++; // code -> hashtable\n        htab[i] = fcode;\n      } else {\n        // Clear out the hash table\n        // table clear for block compress\n        htab.fill(-1);\n        free_ent = ClearCode + 2;\n        clear_flg = true;\n        output(ClearCode);\n      }\n    }\n  }\n\n  // Put out the final code.\n  output(ent);\n  output(EOFCode);\n\n  outStream.writeByte(0); // write block terminator\n  return outStream.bytesView();\n\n  function output(code) {\n    cur_accum &= MASKS[cur_bits];\n\n    if (cur_bits > 0) cur_accum |= code << cur_bits;\n    else cur_accum = code;\n\n    cur_bits += n_bits;\n\n    while (cur_bits >= 8) {\n      // Add a character to the end of the current packet, and if it is 254\n      // characters, flush the packet to disk.\n      accum[a_count++] = cur_accum & 0xff;\n      if (a_count >= 254) {\n        outStream.writeByte(a_count);\n        outStream.writeBytesView(accum, 0, a_count);\n        a_count = 0;\n      }\n      cur_accum >>= 8;\n      cur_bits -= 8;\n    }\n\n    // If the next entry is going to be too big for the code size,\n    // then increase it, if possible.\n    if (free_ent > maxcode || clear_flg) {\n      if (clear_flg) {\n        n_bits = g_init_bits;\n        maxcode = (1 << n_bits) - 1;\n        clear_flg = false;\n      } else {\n        ++n_bits;\n        maxcode = n_bits === BITS ? (1 << n_bits) : (1 << n_bits) - 1;\n      }\n    }\n\n    if (code == EOFCode) {\n      // At EOF, write the rest of the buffer.\n      while (cur_bits > 0) {\n        // Add a character to the end of the current packet, and if it is 254\n        // characters, flush the packet to disk.\n        accum[a_count++] = cur_accum & 0xff;\n        if (a_count >= 254) {\n          outStream.writeByte(a_count);\n          outStream.writeBytesView(accum, 0, a_count);\n          a_count = 0;\n        }\n        cur_accum >>= 8;\n        cur_bits -= 8;\n      }\n      // Flush the packet to disk, and reset the accumulator\n      if (a_count > 0) {\n        outStream.writeByte(a_count);\n        outStream.writeBytesView(accum, 0, a_count);\n        a_count = 0;\n      }\n    }\n  }\n}\n\nexport default lzwEncode;\n","export function uint32_to_rgba(color) {\n  var a = (color >> 24) & 0xff;\n  var b = (color >> 16) & 0xff;\n  var g = (color >> 8) & 0xff;\n  var r = color & 0xff;\n  return [r, g, b, a];\n}\n\nexport function rgba_to_uint32(r, g, b, a) {\n  return (a << 24) | (b << 16) | (g << 8) | r;\n}\n\nexport function rgb888_to_rgb565(r, g, b) {\n  return ((r << 8) & 0xf800) | ((g << 2) & 0x03e0) | (b >> 3);\n}\n\nexport function rgba8888_to_rgba4444(r, g, b, a) {\n  return (r >> 4) | (g & 0xf0) | ((b & 0xf0) << 4) | ((a & 0xf0) << 8);\n}\n\nexport function rgb888_to_rgb444(r, g, b) {\n  return ((r >> 4) << 8) | (g & 0xf0) | (b >> 4);\n}\n\n// Alternative 565 ?\n// return ((r & 0xf8) << 8) + ((g & 0xfc) << 3) + (b >> 3);\n\n// Alternative 4444 ?\n// ((a & 0xf0) << 8) | ((r & 0xf0) << 4) | (g & 0xf0) | (b >> 4);\n","// Modified from:\n// https://github.com/mcychan/PnnQuant.js/blob/master/src/pnnquant.js\n\n/* Fast pairwise nearest neighbor based algorithm for multilevel thresholding\nCopyright (C) 2004-2019 Mark Tyler and Dmitry Groshev\nCopyright (c) 2018-2021 Miller Cy Chan\n* error measure; time used is proportional to number of bins squared - WJ */\n\nimport {\n  rgb888_to_rgb565,\n  rgb888_to_rgb444,\n  rgba8888_to_rgba4444,\n} from \"./rgb-packing.js\";\n\nfunction clamp(value, min, max) {\n  return value < min ? min : value > max ? max : value;\n}\n\nfunction sqr(value) {\n  return value * value;\n}\n\nfunction find_nn(bins, idx, hasAlpha) {\n  var nn = 0;\n  var err = 1e100;\n\n  const bin1 = bins[idx];\n  const n1 = bin1.cnt;\n  const wa = bin1.ac;\n  const wr = bin1.rc;\n  const wg = bin1.gc;\n  const wb = bin1.bc;\n  for (var i = bin1.fw; i != 0; i = bins[i].fw) {\n    const bin = bins[i];\n    const n2 = bin.cnt;\n    const nerr2 = (n1 * n2) / (n1 + n2);\n    if (nerr2 >= err) continue;\n\n    var nerr = 0;\n    if (hasAlpha) {\n      nerr += nerr2 * sqr(bin.ac - wa);\n      if (nerr >= err) continue;\n    }\n\n    nerr += nerr2 * sqr(bin.rc - wr);\n    if (nerr >= err) continue;\n\n    nerr += nerr2 * sqr(bin.gc - wg);\n    if (nerr >= err) continue;\n\n    nerr += nerr2 * sqr(bin.bc - wb);\n    if (nerr >= err) continue;\n    err = nerr;\n    nn = i;\n  }\n  bin1.err = err;\n  bin1.nn = nn;\n}\n\nfunction create_bin() {\n  return {\n    ac: 0,\n    rc: 0,\n    gc: 0,\n    bc: 0,\n    cnt: 0,\n    nn: 0,\n    fw: 0,\n    bk: 0,\n    tm: 0,\n    mtm: 0,\n    err: 0,\n  };\n}\n\nfunction bin_add_rgb(bin, r, g, b) {\n  bin.rc += r;\n  bin.gc += g;\n  bin.bc += b;\n  bin.cnt++;\n}\n\nfunction create_bin_list(data, format) {\n  const bincount = format === \"rgb444\" ? 4096 : 65536;\n  const bins = new Array(bincount);\n  const size = data.length;\n\n  /* Build histogram */\n  // Note: Instead of introducing branching/conditions\n  // within a very hot per-pixel iteration, we just duplicate the code\n  // for each new condition\n  if (format === \"rgba4444\") {\n    for (let i = 0; i < size; ++i) {\n      const color = data[i];\n      const a = (color >> 24) & 0xff;\n      const b = (color >> 16) & 0xff;\n      const g = (color >> 8) & 0xff;\n      const r = color & 0xff;\n\n      // reduce to rgb4444 16-bit uint\n      const index = rgba8888_to_rgba4444(r, g, b, a);\n      let bin = index in bins ? bins[index] : (bins[index] = create_bin());\n      bin.rc += r;\n      bin.gc += g;\n      bin.bc += b;\n      bin.ac += a;\n      bin.cnt++;\n    }\n  }\n  \n  else if (format === \"rgb444\") {\n    for (let i = 0; i < size; ++i) {\n      const color = data[i];\n      const b = (color >> 16) & 0xff;\n      const g = (color >> 8) & 0xff;\n      const r = color & 0xff;\n\n      // reduce to rgb444 12-bit uint\n      const index = rgb888_to_rgb444(r, g, b);\n      let bin = index in bins ? bins[index] : (bins[index] = create_bin());\n      bin.rc += r;\n      bin.gc += g;\n      bin.bc += b;\n      bin.cnt++;\n    }\n  } else {\n    for (let i = 0; i < size; ++i) {\n      const color = data[i];\n      const b = (color >> 16) & 0xff;\n      const g = (color >> 8) & 0xff;\n      const r = color & 0xff;\n\n      // reduce to rgb565 16-bit uint\n      const index = rgb888_to_rgb565(r, g, b);\n      let bin = index in bins ? bins[index] : (bins[index] = create_bin());\n      bin.rc += r;\n      bin.gc += g;\n      bin.bc += b;\n      bin.cnt++;\n    }\n  }\n  return bins;\n}\n\nexport default function quantize(rgba, maxColors, opts = {}) {\n  const {\n    format = \"rgb565\",\n    clearAlpha = true,\n    clearAlphaColor = 0x00,\n    clearAlphaThreshold = 0,\n    oneBitAlpha = false,\n  } = opts;\n\n  if (!rgba || !rgba.buffer) {\n    throw new Error('quantize() expected RGBA Uint8Array data');\n  }\n  if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) {\n    throw new Error('quantize() expected RGBA Uint8Array data');\n  }\n  \n  const data = new Uint32Array(rgba.buffer);\n\n  let useSqrt = opts.useSqrt !== false;\n\n  // format can be:\n  // rgb565 (default)\n  // rgb444\n  // rgba4444\n\n  const hasAlpha = format === \"rgba4444\";\n  const bins = create_bin_list(data, format);\n  const bincount = bins.length;\n  const bincountMinusOne = bincount - 1;\n  const heap = new Uint32Array(bincount + 1);\n\n  /* Cluster nonempty bins at one end of array */\n  var maxbins = 0;\n  for (var i = 0; i < bincount; ++i) {\n    const bin = bins[i];\n    if (bin != null) {\n      var d = 1.0 / bin.cnt;\n      if (hasAlpha) bin.ac *= d;\n      bin.rc *= d;\n      bin.gc *= d;\n      bin.bc *= d;\n      bins[maxbins++] = bin;\n    }\n  }\n\n  if (sqr(maxColors) / maxbins < 0.022) {\n    useSqrt = false;\n  }\n\n  var i = 0;\n  for (; i < maxbins - 1; ++i) {\n    bins[i].fw = i + 1;\n    bins[i + 1].bk = i;\n    if (useSqrt) bins[i].cnt = Math.sqrt(bins[i].cnt);\n  }\n  if (useSqrt) bins[i].cnt = Math.sqrt(bins[i].cnt);\n\n  var h, l, l2;\n  /* Initialize nearest neighbors and build heap of them */\n  for (i = 0; i < maxbins; ++i) {\n    find_nn(bins, i, false);\n    /* Push slot on heap */\n    var err = bins[i].err;\n    for (l = ++heap[0]; l > 1; l = l2) {\n      l2 = l >> 1;\n      if (bins[(h = heap[l2])].err <= err) break;\n      heap[l] = h;\n    }\n    heap[l] = i;\n  }\n\n  /* Merge bins which increase error the least */\n  var extbins = maxbins - maxColors;\n  for (i = 0; i < extbins; ) {\n    var tb;\n    /* Use heap to find which bins to merge */\n    for (;;) {\n      var b1 = heap[1];\n      tb = bins[b1]; /* One with least error */\n      /* Is stored error up to date? */\n      if (tb.tm >= tb.mtm && bins[tb.nn].mtm <= tb.tm) break;\n      if (tb.mtm == bincountMinusOne)\n        /* Deleted node */ b1 = heap[1] = heap[heap[0]--];\n      /* Too old error value */ else {\n        find_nn(bins, b1, false);\n        tb.tm = i;\n      }\n      /* Push slot down */\n      var err = bins[b1].err;\n      for (l = 1; (l2 = l + l) <= heap[0]; l = l2) {\n        if (l2 < heap[0] && bins[heap[l2]].err > bins[heap[l2 + 1]].err) l2++;\n        if (err <= bins[(h = heap[l2])].err) break;\n        heap[l] = h;\n      }\n      heap[l] = b1;\n    }\n\n    /* Do a merge */\n    var nb = bins[tb.nn];\n    var n1 = tb.cnt;\n    var n2 = nb.cnt;\n    var d = 1.0 / (n1 + n2);\n    if (hasAlpha) tb.ac = d * (n1 * tb.ac + n2 * nb.ac);\n    tb.rc = d * (n1 * tb.rc + n2 * nb.rc);\n    tb.gc = d * (n1 * tb.gc + n2 * nb.gc);\n    tb.bc = d * (n1 * tb.bc + n2 * nb.bc);\n    tb.cnt += nb.cnt;\n    tb.mtm = ++i;\n\n    /* Unchain deleted bin */\n    bins[nb.bk].fw = nb.fw;\n    bins[nb.fw].bk = nb.bk;\n    nb.mtm = bincountMinusOne;\n  }\n\n  // let palette = new Uint32Array(maxColors);\n  let palette = [];\n\n  /* Fill palette */\n  var k = 0;\n  for (i = 0; ; ++k) {\n    let r = clamp(Math.round(bins[i].rc), 0, 0xff);\n    let g = clamp(Math.round(bins[i].gc), 0, 0xff);\n    let b = clamp(Math.round(bins[i].bc), 0, 0xff);\n\n    let a = 0xff;\n    if (hasAlpha) {\n      a = clamp(Math.round(bins[i].ac), 0, 0xff);\n      if (oneBitAlpha) {\n        const threshold = typeof oneBitAlpha === \"number\" ? oneBitAlpha : 127;\n        a = a <= threshold ? 0x00 : 0xff;\n      }\n      if (clearAlpha && a <= clearAlphaThreshold) {\n        r = g = b = clearAlphaColor;\n        a = 0x00;\n      }\n    }\n\n    const color = hasAlpha ? [r, g, b, a] : [r, g, b];\n    const exists = existsInPalette(palette, color);\n    if (!exists) palette.push(color);\n    if ((i = bins[i].fw) == 0) break;\n  }\n\n  return palette;\n}\n\nfunction existsInPalette(palette, color) {\n  for (let i = 0; i < palette.length; i++) {\n    const p = palette[i];\n    let matchesRGB =\n      p[0] === color[0] && p[1] === color[1] && p[2] === color[2];\n    let matchesAlpha =\n      p.length >= 4 && color.length >= 4 ? p[3] === color[3] : true;\n    if (matchesRGB && matchesAlpha) return true;\n  }\n  return false;\n}\n\n// TODO: Further 'clean' palette by merging nearly-identical colors?\n","function rgb2y(r, g, b) {\n  return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;\n}\nfunction rgb2i(r, g, b) {\n  return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;\n}\nfunction rgb2q(r, g, b) {\n  return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;\n}\n\nexport function colorDifferenceYIQSquared(yiqA, yiqB) {\n  const y = yiqA[0] - yiqB[0];\n  const i = yiqA[1] - yiqB[1];\n  const q = yiqA[2] - yiqB[2];\n  const a = alpha(yiqA) - alpha(yiqB);\n  return y * y * 0.5053 + i * i * 0.299 + q * q * 0.1957 + a * a;\n}\n\nfunction alpha(array) {\n  return array[3] != null ? array[3] : 0xff;\n}\n\nexport function colorDifferenceYIQ(yiqA, yiqB) {\n  return Math.sqrt(colorDifferenceYIQSquared(yiqA, yiqB));\n}\n\nexport function colorDifferenceRGBToYIQSquared(rgb1, rgb2) {\n  const [r1, g1, b1] = rgb1;\n  const [r2, g2, b2] = rgb2;\n  const y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2),\n    i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2),\n    q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n  const a = alpha(rgb1) - alpha(rgb2);\n  return y * y * 0.5053 + i * i * 0.299 + q * q * 0.1957 + a * a;\n}\n\nexport function colorDifferenceRGBToYIQ(rgb1, rgb2) {\n  return Math.sqrt(colorDifferenceRGBToYIQSquared(rgb1, rgb2));\n}\n\nexport function euclideanDistanceSquared(a, b) {\n  var sum = 0;\n  var n;\n  for (n = 0; n < a.length; n++) {\n    const dx = a[n] - b[n];\n    sum += dx * dx;\n  }\n  return sum;\n}\n\nexport function euclideanDistance(a, b) {\n  return Math.sqrt(euclideanDistanceSquared(a, b));\n}\n","import {\n  rgb888_to_rgb444,\n  rgb888_to_rgb565,\n  rgba8888_to_rgba4444,\n} from \"./rgb-packing.js\";\n\nimport { euclideanDistanceSquared } from \"./color.js\";\n\nfunction roundStep(byte, step) {\n  return step > 1 ? Math.round(byte / step) * step : byte;\n}\n\nexport function prequantize(\n  rgba,\n  { roundRGB = 5, roundAlpha = 10, oneBitAlpha = null } = {}\n) {\n  const data = new Uint32Array(rgba.buffer);\n  for (let i = 0; i < data.length; i++) {\n    const color = data[i];\n    let a = (color >> 24) & 0xff;\n    let b = (color >> 16) & 0xff;\n    let g = (color >> 8) & 0xff;\n    let r = color & 0xff;\n\n    a = roundStep(a, roundAlpha);\n    if (oneBitAlpha) {\n      const threshold = typeof oneBitAlpha === \"number\" ? oneBitAlpha : 127;\n      a = a <= threshold ? 0x00 : 0xff;\n    }\n    r = roundStep(r, roundRGB);\n    g = roundStep(g, roundRGB);\n    b = roundStep(b, roundRGB);\n\n    data[i] = (a << 24) | (b << 16) | (g << 8) | (r << 0);\n  }\n}\n\nexport function applyPalette(rgba, palette, format = \"rgb565\") {\n  if (!rgba || !rgba.buffer) {\n    throw new Error('quantize() expected RGBA Uint8Array data');\n  }\n  if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) {\n    throw new Error('quantize() expected RGBA Uint8Array data');\n  }\n  if (palette.length > 256) {\n    throw new Error('applyPalette() only works with 256 colors or less');\n  }\n\n  const data = new Uint32Array(rgba.buffer);\n  const length = data.length;\n  const bincount = format === \"rgb444\" ? 4096 : 65536;\n  const index = new Uint8Array(length);\n  const cache = new Array(bincount);\n  const hasAlpha = format === \"rgba4444\";\n\n  // Some duplicate code below due to very hot code path\n  // Introducing branching/conditions shows some significant impact\n  if (format === \"rgba4444\") {\n    for (let i = 0; i < length; i++) {\n      const color = data[i];\n      const a = (color >> 24) & 0xff;\n      const b = (color >> 16) & 0xff;\n      const g = (color >> 8) & 0xff;\n      const r = color & 0xff;\n      const key = rgba8888_to_rgba4444(r, g, b, a);\n      const idx = key in cache ? cache[key] : (cache[key] = nearestColorIndexRGBA(r, g, b, a, palette));\n      index[i] = idx;\n    }\n  } else {\n    const rgb888_to_key = format === \"rgb444\" ? rgb888_to_rgb444 : rgb888_to_rgb565;\n    for (let i = 0; i < length; i++) {\n      const color = data[i];\n      const b = (color >> 16) & 0xff;\n      const g = (color >> 8) & 0xff;\n      const r = color & 0xff;\n      const key = rgb888_to_key(r, g, b);\n      const idx = key in cache ? cache[key] : (cache[key] = nearestColorIndexRGB(r, g, b, palette));\n      index[i] = idx;\n    }\n  }\n\n  return index;\n}\n\nfunction nearestColorIndexRGBA(r, g, b, a, palette) {\n  let k = 0;\n  let mindist = 1e100;\n  for (let i = 0; i < palette.length; i++) {\n    const px2 = palette[i];\n    const a2 = px2[3];\n    let curdist = sqr(a2 - a);\n    if (curdist > mindist) continue;\n    const r2 = px2[0];\n    curdist += sqr(r2 - r);\n    if (curdist > mindist) continue;\n    const g2 = px2[1];\n    curdist += sqr(g2 - g);\n    if (curdist > mindist) continue;\n    const b2 = px2[2];\n    curdist += sqr(b2 - b);\n    if (curdist > mindist) continue;\n    mindist = curdist;\n    k = i;\n  }\n  return k;\n}\n\nfunction nearestColorIndexRGB(r, g, b, palette) {\n  let k = 0;\n  let mindist = 1e100;\n  for (let i = 0; i < palette.length; i++) {\n    const px2 = palette[i];\n    const r2 = px2[0];\n    let curdist = sqr(r2 - r);\n    if (curdist > mindist) continue;\n    const g2 = px2[1];\n    curdist += sqr(g2 - g);\n    if (curdist > mindist) continue;\n    const b2 = px2[2];\n    curdist += sqr(b2 - b);\n    if (curdist > mindist) continue;\n    mindist = curdist;\n    k = i;\n  }\n  return k;\n}\n\nexport function snapColorsToPalette(palette, knownColors, threshold = 5) {\n  if (!palette.length || !knownColors.length) return;\n\n  const paletteRGB = palette.map((p) => p.slice(0, 3));\n  const thresholdSq = threshold * threshold;\n  const dim = palette[0].length;\n  for (let i = 0; i < knownColors.length; i++) {\n    let color = knownColors[i];\n    if (color.length < dim) {\n      // palette is RGBA, known is RGB\n      color = [color[0], color[1], color[2], 0xff];\n    } else if (color.length > dim) {\n      // palette is RGB, known is RGBA\n      color = color.slice(0, 3);\n    } else {\n      // make sure we always copy known colors\n      color = color.slice();\n    }\n    const r = nearestColorIndexWithDistance(\n      paletteRGB,\n      color.slice(0, 3),\n      euclideanDistanceSquared\n    );\n    const idx = r[0];\n    const distanceSq = r[1];\n    if (distanceSq > 0 && distanceSq <= thresholdSq) {\n      palette[idx] = color;\n    }\n  }\n}\n\nfunction sqr(a) {\n  return a * a;\n}\n\nexport function nearestColorIndex(\n  colors,\n  pixel,\n  distanceFn = euclideanDistanceSquared\n) {\n  let minDist = Infinity;\n  let minDistIndex = -1;\n  for (let j = 0; j < colors.length; j++) {\n    const paletteColor = colors[j];\n    const dist = distanceFn(pixel, paletteColor);\n    if (dist < minDist) {\n      minDist = dist;\n      minDistIndex = j;\n    }\n  }\n  return minDistIndex;\n}\n\nexport function nearestColorIndexWithDistance(\n  colors,\n  pixel,\n  distanceFn = euclideanDistanceSquared\n) {\n  let minDist = Infinity;\n  let minDistIndex = -1;\n  for (let j = 0; j < colors.length; j++) {\n    const paletteColor = colors[j];\n    const dist = distanceFn(pixel, paletteColor);\n    if (dist < minDist) {\n      minDist = dist;\n      minDistIndex = j;\n    }\n  }\n  return [minDistIndex, minDist];\n}\n\nexport function nearestColor(\n  colors,\n  pixel,\n  distanceFn = euclideanDistanceSquared\n) {\n  return colors[nearestColorIndex(colors, pixel, distanceFn)];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}