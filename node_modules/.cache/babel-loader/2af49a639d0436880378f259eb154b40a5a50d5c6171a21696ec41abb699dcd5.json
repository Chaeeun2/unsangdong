{"ast":null,"code":"//////////////////////////////////////////////////////////////\n\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/main/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\nfunction noise(p5, fn) {\n  const PERLIN_YWRAPB = 4;\n  const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\n  const PERLIN_ZWRAPB = 8;\n  const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\n  const PERLIN_SIZE = 4095;\n  let perlin_octaves = 4; // default to medium smooth\n  let perlin_amp_falloff = 0.5; // 50% reduction/octave\n\n  const scaled_cosine = i => 0.5 * (1.0 - Math.cos(i * Math.PI));\n  let perlin; // will be initialized lazily by noise() or noiseSeed()\n\n  /**\n   * Returns random numbers that can be tuned to feel organic.\n   *\n   * Values returned by <a href=\"#/p5/random\">random()</a> and\n   * <a href=\"#/p5/randomGaussian\">randomGaussian()</a> can change by large\n   * amounts between function calls. By contrast, values returned by `noise()`\n   * can be made \"smooth\". Calls to `noise()` with similar inputs will produce\n   * similar outputs. `noise()` is used to create textures, motion, shapes,\n   * terrains, and so on. Ken Perlin invented `noise()` while animating the\n   * original <em>Tron</em> film in the 1980s.\n   *\n   * `noise()` always returns values between 0 and 1. It returns the same value\n   * for a given input while a sketch is running. `noise()` produces different\n   * results each time a sketch runs. The\n   * <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function can be used to generate\n   * the same sequence of Perlin noise values each time a sketch runs.\n   *\n   * The character of the noise can be adjusted in two ways. The first way is to\n   * scale the inputs. `noise()` interprets inputs as coordinates. The sequence\n   * of noise values will be smoother when the input coordinates are closer. The\n   * second way is to use the <a href=\"#/p5/noiseDetail\">noiseDetail()</a>\n   * function.\n   *\n   * The version of `noise()` with one parameter computes noise values in one\n   * dimension. This dimension can be thought of as space, as in `noise(x)`, or\n   * time, as in `noise(t)`.\n   *\n   * The version of `noise()` with two parameters computes noise values in two\n   * dimensions. These dimensions can be thought of as space, as in\n   * `noise(x, y)`, or space and time, as in `noise(x, t)`.\n   *\n   * The version of `noise()` with three parameters computes noise values in\n   * three dimensions. These dimensions can be thought of as space, as in\n   * `noise(x, y, z)`, or space and time, as in `noise(x, y, t)`.\n   *\n   * @method noise\n   * @param  {Number} x   x-coordinate in noise space.\n   * @param  {Number} [y] y-coordinate in noise space.\n   * @param  {Number} [z] z-coordinate in noise space.\n   * @return {Number}     Perlin noise value at specified coordinates.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A black dot moves randomly on a gray square.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Calculate the coordinates.\n   *   let x = 100 * noise(0.005 * frameCount);\n   *   let y = 100 * noise(0.005 * frameCount + 10000);\n   *\n   *   // Draw the point.\n   *   strokeWeight(5);\n   *   point(x, y);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A black dot moves randomly on a gray square.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.005;\n   *\n   *   // Scale the input coordinate.\n   *   let nt = noiseScale * frameCount;\n   *\n   *   // Compute the noise values.\n   *   let x = noiseLevel * noise(nt);\n   *   let y = noiseLevel * noise(nt + 10000);\n   *\n   *   // Draw the point.\n   *   strokeWeight(5);\n   *   point(x, y);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A hilly terrain drawn in gray against a black sky.');\n   * }\n   *\n   * function draw() {\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.02;\n   *\n   *   // Scale the input coordinate.\n   *   let x = frameCount;\n   *   let nx = noiseScale * x;\n   *\n   *   // Compute the noise value.\n   *   let y = noiseLevel * noise(nx);\n   *\n   *   // Draw the line.\n   *   line(x, 0, x, y);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A calm sea drawn in gray against a black sky.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.002;\n   *\n   *   // Iterate from left to right.\n   *   for (let x = 0; x < 100; x += 1) {\n   *     // Scale the input coordinates.\n   *     let nx = noiseScale * x;\n   *     let nt = noiseScale * frameCount;\n   *\n   *     // Compute the noise value.\n   *     let y = noiseLevel * noise(nx, nt);\n   *\n   *     // Draw the line.\n   *     line(x, 0, x, y);\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 255;\n   *   let noiseScale = 0.01;\n   *\n   *   // Iterate from top to bottom.\n   *   for (let y = 0; y < 100; y += 1) {\n   *     // Iterate from left to right.\n   *     for (let x = 0; x < 100; x += 1) {\n   *       // Scale the input coordinates.\n   *       let nx = noiseScale * x;\n   *       let ny = noiseScale * y;\n   *\n   *       // Compute the noise value.\n   *       let c = noiseLevel * noise(nx, ny);\n   *\n   *       // Draw the point.\n   *       stroke(c);\n   *       point(x, y);\n   *     }\n   *   }\n   *\n   *   describe('A gray cloudy pattern.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A gray cloudy pattern that changes.');\n   * }\n   *\n   * function draw() {\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 255;\n   *   let noiseScale = 0.009;\n   *\n   *   // Iterate from top to bottom.\n   *   for (let y = 0; y < 100; y += 1) {\n   *     // Iterate from left to right.\n   *     for (let x = 0; x < width; x += 1) {\n   *       // Scale the input coordinates.\n   *       let nx = noiseScale * x;\n   *       let ny = noiseScale * y;\n   *       let nt = noiseScale * frameCount;\n   *\n   *       // Compute the noise value.\n   *       let c = noiseLevel * noise(nx, ny, nt);\n   *\n   *       // Draw the point.\n   *       stroke(c);\n   *       point(x, y);\n   *     }\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noise = function (x, y = 0, z = 0) {\n    if (perlin == null) {\n      perlin = new Array(PERLIN_SIZE + 1);\n      for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n        perlin[i] = Math.random();\n      }\n    }\n    if (x < 0) {\n      x = -x;\n    }\n    if (y < 0) {\n      y = -y;\n    }\n    if (z < 0) {\n      z = -z;\n    }\n    let xi = Math.floor(x),\n      yi = Math.floor(y),\n      zi = Math.floor(z);\n    let xf = x - xi;\n    let yf = y - yi;\n    let zf = z - zi;\n    let rxf, ryf;\n    let r = 0;\n    let ampl = 0.5;\n    let n1, n2, n3;\n    for (let o = 0; o < perlin_octaves; o++) {\n      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n      rxf = scaled_cosine(xf);\n      ryf = scaled_cosine(yf);\n      n1 = perlin[of & PERLIN_SIZE];\n      n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);\n      n2 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];\n      n2 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);\n      n1 += ryf * (n2 - n1);\n      of += PERLIN_ZWRAP;\n      n2 = perlin[of & PERLIN_SIZE];\n      n2 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n2);\n      n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];\n      n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);\n      n2 += ryf * (n3 - n2);\n      n1 += scaled_cosine(zf) * (n2 - n1);\n      r += n1 * ampl;\n      ampl *= perlin_amp_falloff;\n      xi <<= 1;\n      xf *= 2;\n      yi <<= 1;\n      yf *= 2;\n      zi <<= 1;\n      zf *= 2;\n      if (xf >= 1.0) {\n        xi++;\n        xf--;\n      }\n      if (yf >= 1.0) {\n        yi++;\n        yf--;\n      }\n      if (zf >= 1.0) {\n        zi++;\n        zf--;\n      }\n    }\n    return r;\n  };\n\n  /**\n   * Adjusts the character of the noise produced by the\n   * <a href=\"#/p5/noise\">noise()</a> function.\n   *\n   * Perlin noise values are created by adding layers of noise together. The\n   * noise layers, called octaves, are similar to harmonics in music. Lower\n   * octaves contribute more to the output signal. They define the overall\n   * intensity of the noise. Higher octaves create finer-grained details.\n   *\n   * By default, noise values are created by combining four octaves. Each higher\n   * octave contributes half as much (50% less) compared to its predecessor.\n   * `noiseDetail()` changes the number of octaves and the falloff amount. For\n   * example, calling `noiseDetail(6, 0.25)` ensures that\n   * <a href=\"#/p5/noise\">noise()</a> will use six octaves. Each higher octave\n   * will contribute 25% as much (75% less) compared to its predecessor. Falloff\n   * values between 0 and 1 are valid. However, falloff values greater than 0.5\n   * might result in noise values greater than 1.\n   *\n   * @method noiseDetail\n   * @param {Number} lod number of octaves to be used by the noise.\n   * @param {Number} falloff falloff factor for each octave.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 255;\n   *   let noiseScale = 0.02;\n   *\n   *   // Iterate from top to bottom.\n   *   for (let y = 0; y < 100; y += 1) {\n   *     // Iterate from left to right.\n   *     for (let x = 0; x < 50; x += 1) {\n   *       // Scale the input coordinates.\n   *       let nx = noiseScale * x;\n   *       let ny = noiseScale * y;\n   *\n   *       // Compute the noise value with six octaves\n   *       // and a low falloff factor.\n   *       noiseDetail(6, 0.25);\n   *       let c = noiseLevel * noise(nx, ny);\n   *\n   *       // Draw the left side.\n   *       stroke(c);\n   *       point(x, y);\n   *\n   *       // Compute the noise value with four octaves\n   *       // and a high falloff factor.\n   *       noiseDetail(4, 0.5);\n   *       c = noiseLevel * noise(nx, ny);\n   *\n   *       // Draw the right side.\n   *       stroke(c);\n   *       point(x + 50, y);\n   *     }\n   *   }\n   *\n   *   describe('Two gray cloudy patterns. The pattern on the right is cloudier than the pattern on the left.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noiseDetail = function (lod, falloff) {\n    if (lod > 0) {\n      perlin_octaves = lod;\n    }\n    if (falloff > 0) {\n      perlin_amp_falloff = falloff;\n    }\n  };\n\n  /**\n   * Sets the seed value for the <a href=\"#/p5/noise\">noise()</a> function.\n   *\n   * By default, <a href=\"#/p5/noise\">noise()</a> produces different results\n   * each time a sketch is run. Calling `noiseSeed()` with a constant argument,\n   * such as `noiseSeed(99)`, makes <a href=\"#/p5/noise\">noise()</a> produce the\n   * same results each time a sketch is run.\n   *\n   * @method noiseSeed\n   * @param {Number} seed   seed value.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the noise seed for consistent results.\n   *   noiseSeed(99);\n   *\n   *   describe('A black rectangle that grows randomly, first to the right and then to the left.');\n   * }\n   *\n   * function draw() {\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.005;\n   *\n   *   // Scale the input coordinate.\n   *   let nt = noiseScale * frameCount;\n   *\n   *   // Compute the noise value.\n   *   let x = noiseLevel * noise(nt);\n   *\n   *   // Draw the line.\n   *   line(x, 0, x, height);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noiseSeed = function (seed) {\n    // Linear Congruential Generator\n    // Variant of a Lehman Generator\n    const lcg = (() => {\n      // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n      // m is basically chosen to be large (as it is the max period)\n      // and for its relationships to a and c\n      const m = 4294967296;\n      // a - 1 should be divisible by m's prime factors\n      const a = 1664525;\n      // c and m should be co-prime\n      const c = 1013904223;\n      let seed, z;\n      return {\n        setSeed(val) {\n          // pick a random seed if val is undefined or null\n          // the >>> 0 casts the seed to an unsigned 32-bit integer\n          z = seed = (val == null ? Math.random() * m : val) >>> 0;\n        },\n        getSeed() {\n          return seed;\n        },\n        rand() {\n          // define the recurrence relationship\n          z = (a * z + c) % m;\n          // return a float in [0, 1)\n          // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n          return z / m;\n        }\n      };\n    })();\n    lcg.setSeed(seed);\n    perlin = new Array(PERLIN_SIZE + 1);\n    for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = lcg.rand();\n    }\n  };\n}\nif (typeof p5 !== 'undefined') {\n  noise(p5, p5.prototype);\n}\nexport { noise as default };","map":{"version":3,"names":["noise","p5","fn","PERLIN_YWRAPB","PERLIN_YWRAP","PERLIN_ZWRAPB","PERLIN_ZWRAP","PERLIN_SIZE","perlin_octaves","perlin_amp_falloff","scaled_cosine","i","Math","cos","PI","perlin","x","y","z","Array","random","xi","floor","yi","zi","xf","yf","zf","rxf","ryf","r","ampl","n1","n2","n3","o","of","noiseDetail","lod","falloff","noiseSeed","seed","lcg","m","a","c","setSeed","val","getSeed","rand","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/math/noise.js"],"sourcesContent":["//////////////////////////////////////////////////////////////\n\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/main/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\nfunction noise(p5, fn){\n  const PERLIN_YWRAPB = 4;\n  const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\n  const PERLIN_ZWRAPB = 8;\n  const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\n  const PERLIN_SIZE = 4095;\n\n  let perlin_octaves = 4; // default to medium smooth\n  let perlin_amp_falloff = 0.5; // 50% reduction/octave\n\n  const scaled_cosine = i => 0.5 * (1.0 - Math.cos(i * Math.PI));\n\n  let perlin; // will be initialized lazily by noise() or noiseSeed()\n\n  /**\n   * Returns random numbers that can be tuned to feel organic.\n   *\n   * Values returned by <a href=\"#/p5/random\">random()</a> and\n   * <a href=\"#/p5/randomGaussian\">randomGaussian()</a> can change by large\n   * amounts between function calls. By contrast, values returned by `noise()`\n   * can be made \"smooth\". Calls to `noise()` with similar inputs will produce\n   * similar outputs. `noise()` is used to create textures, motion, shapes,\n   * terrains, and so on. Ken Perlin invented `noise()` while animating the\n   * original <em>Tron</em> film in the 1980s.\n   *\n   * `noise()` always returns values between 0 and 1. It returns the same value\n   * for a given input while a sketch is running. `noise()` produces different\n   * results each time a sketch runs. The\n   * <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function can be used to generate\n   * the same sequence of Perlin noise values each time a sketch runs.\n   *\n   * The character of the noise can be adjusted in two ways. The first way is to\n   * scale the inputs. `noise()` interprets inputs as coordinates. The sequence\n   * of noise values will be smoother when the input coordinates are closer. The\n   * second way is to use the <a href=\"#/p5/noiseDetail\">noiseDetail()</a>\n   * function.\n   *\n   * The version of `noise()` with one parameter computes noise values in one\n   * dimension. This dimension can be thought of as space, as in `noise(x)`, or\n   * time, as in `noise(t)`.\n   *\n   * The version of `noise()` with two parameters computes noise values in two\n   * dimensions. These dimensions can be thought of as space, as in\n   * `noise(x, y)`, or space and time, as in `noise(x, t)`.\n   *\n   * The version of `noise()` with three parameters computes noise values in\n   * three dimensions. These dimensions can be thought of as space, as in\n   * `noise(x, y, z)`, or space and time, as in `noise(x, y, t)`.\n   *\n   * @method noise\n   * @param  {Number} x   x-coordinate in noise space.\n   * @param  {Number} [y] y-coordinate in noise space.\n   * @param  {Number} [z] z-coordinate in noise space.\n   * @return {Number}     Perlin noise value at specified coordinates.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A black dot moves randomly on a gray square.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Calculate the coordinates.\n   *   let x = 100 * noise(0.005 * frameCount);\n   *   let y = 100 * noise(0.005 * frameCount + 10000);\n   *\n   *   // Draw the point.\n   *   strokeWeight(5);\n   *   point(x, y);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A black dot moves randomly on a gray square.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.005;\n   *\n   *   // Scale the input coordinate.\n   *   let nt = noiseScale * frameCount;\n   *\n   *   // Compute the noise values.\n   *   let x = noiseLevel * noise(nt);\n   *   let y = noiseLevel * noise(nt + 10000);\n   *\n   *   // Draw the point.\n   *   strokeWeight(5);\n   *   point(x, y);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A hilly terrain drawn in gray against a black sky.');\n   * }\n   *\n   * function draw() {\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.02;\n   *\n   *   // Scale the input coordinate.\n   *   let x = frameCount;\n   *   let nx = noiseScale * x;\n   *\n   *   // Compute the noise value.\n   *   let y = noiseLevel * noise(nx);\n   *\n   *   // Draw the line.\n   *   line(x, 0, x, y);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A calm sea drawn in gray against a black sky.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.002;\n   *\n   *   // Iterate from left to right.\n   *   for (let x = 0; x < 100; x += 1) {\n   *     // Scale the input coordinates.\n   *     let nx = noiseScale * x;\n   *     let nt = noiseScale * frameCount;\n   *\n   *     // Compute the noise value.\n   *     let y = noiseLevel * noise(nx, nt);\n   *\n   *     // Draw the line.\n   *     line(x, 0, x, y);\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 255;\n   *   let noiseScale = 0.01;\n   *\n   *   // Iterate from top to bottom.\n   *   for (let y = 0; y < 100; y += 1) {\n   *     // Iterate from left to right.\n   *     for (let x = 0; x < 100; x += 1) {\n   *       // Scale the input coordinates.\n   *       let nx = noiseScale * x;\n   *       let ny = noiseScale * y;\n   *\n   *       // Compute the noise value.\n   *       let c = noiseLevel * noise(nx, ny);\n   *\n   *       // Draw the point.\n   *       stroke(c);\n   *       point(x, y);\n   *     }\n   *   }\n   *\n   *   describe('A gray cloudy pattern.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A gray cloudy pattern that changes.');\n   * }\n   *\n   * function draw() {\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 255;\n   *   let noiseScale = 0.009;\n   *\n   *   // Iterate from top to bottom.\n   *   for (let y = 0; y < 100; y += 1) {\n   *     // Iterate from left to right.\n   *     for (let x = 0; x < width; x += 1) {\n   *       // Scale the input coordinates.\n   *       let nx = noiseScale * x;\n   *       let ny = noiseScale * y;\n   *       let nt = noiseScale * frameCount;\n   *\n   *       // Compute the noise value.\n   *       let c = noiseLevel * noise(nx, ny, nt);\n   *\n   *       // Draw the point.\n   *       stroke(c);\n   *       point(x, y);\n   *     }\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noise = function(x, y = 0, z = 0) {\n    if (perlin == null) {\n      perlin = new Array(PERLIN_SIZE + 1);\n      for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n        perlin[i] = Math.random();\n      }\n    }\n\n    if (x < 0) {\n      x = -x;\n    }\n    if (y < 0) {\n      y = -y;\n    }\n    if (z < 0) {\n      z = -z;\n    }\n\n    let xi = Math.floor(x),\n      yi = Math.floor(y),\n      zi = Math.floor(z);\n    let xf = x - xi;\n    let yf = y - yi;\n    let zf = z - zi;\n    let rxf, ryf;\n    let r = 0;\n    let ampl = 0.5;\n    let n1, n2, n3;\n\n    for (let o = 0; o < perlin_octaves; o++) {\n      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n\n      rxf = scaled_cosine(xf);\n      ryf = scaled_cosine(yf);\n\n      n1 = perlin[of & PERLIN_SIZE];\n      n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);\n      n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n      n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n      n1 += ryf * (n2 - n1);\n\n      of += PERLIN_ZWRAP;\n      n2 = perlin[of & PERLIN_SIZE];\n      n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);\n      n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n      n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n      n2 += ryf * (n3 - n2);\n\n      n1 += scaled_cosine(zf) * (n2 - n1);\n\n      r += n1 * ampl;\n      ampl *= perlin_amp_falloff;\n      xi <<= 1;\n      xf *= 2;\n      yi <<= 1;\n      yf *= 2;\n      zi <<= 1;\n      zf *= 2;\n\n      if (xf >= 1.0) {\n        xi++;\n        xf--;\n      }\n      if (yf >= 1.0) {\n        yi++;\n        yf--;\n      }\n      if (zf >= 1.0) {\n        zi++;\n        zf--;\n      }\n    }\n    return r;\n  };\n\n  /**\n   * Adjusts the character of the noise produced by the\n   * <a href=\"#/p5/noise\">noise()</a> function.\n   *\n   * Perlin noise values are created by adding layers of noise together. The\n   * noise layers, called octaves, are similar to harmonics in music. Lower\n   * octaves contribute more to the output signal. They define the overall\n   * intensity of the noise. Higher octaves create finer-grained details.\n   *\n   * By default, noise values are created by combining four octaves. Each higher\n   * octave contributes half as much (50% less) compared to its predecessor.\n   * `noiseDetail()` changes the number of octaves and the falloff amount. For\n   * example, calling `noiseDetail(6, 0.25)` ensures that\n   * <a href=\"#/p5/noise\">noise()</a> will use six octaves. Each higher octave\n   * will contribute 25% as much (75% less) compared to its predecessor. Falloff\n   * values between 0 and 1 are valid. However, falloff values greater than 0.5\n   * might result in noise values greater than 1.\n   *\n   * @method noiseDetail\n   * @param {Number} lod number of octaves to be used by the noise.\n   * @param {Number} falloff falloff factor for each octave.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 255;\n   *   let noiseScale = 0.02;\n   *\n   *   // Iterate from top to bottom.\n   *   for (let y = 0; y < 100; y += 1) {\n   *     // Iterate from left to right.\n   *     for (let x = 0; x < 50; x += 1) {\n   *       // Scale the input coordinates.\n   *       let nx = noiseScale * x;\n   *       let ny = noiseScale * y;\n   *\n   *       // Compute the noise value with six octaves\n   *       // and a low falloff factor.\n   *       noiseDetail(6, 0.25);\n   *       let c = noiseLevel * noise(nx, ny);\n   *\n   *       // Draw the left side.\n   *       stroke(c);\n   *       point(x, y);\n   *\n   *       // Compute the noise value with four octaves\n   *       // and a high falloff factor.\n   *       noiseDetail(4, 0.5);\n   *       c = noiseLevel * noise(nx, ny);\n   *\n   *       // Draw the right side.\n   *       stroke(c);\n   *       point(x + 50, y);\n   *     }\n   *   }\n   *\n   *   describe('Two gray cloudy patterns. The pattern on the right is cloudier than the pattern on the left.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noiseDetail = function(lod, falloff) {\n    if (lod > 0) {\n      perlin_octaves = lod;\n    }\n    if (falloff > 0) {\n      perlin_amp_falloff = falloff;\n    }\n  };\n\n  /**\n   * Sets the seed value for the <a href=\"#/p5/noise\">noise()</a> function.\n   *\n   * By default, <a href=\"#/p5/noise\">noise()</a> produces different results\n   * each time a sketch is run. Calling `noiseSeed()` with a constant argument,\n   * such as `noiseSeed(99)`, makes <a href=\"#/p5/noise\">noise()</a> produce the\n   * same results each time a sketch is run.\n   *\n   * @method noiseSeed\n   * @param {Number} seed   seed value.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the noise seed for consistent results.\n   *   noiseSeed(99);\n   *\n   *   describe('A black rectangle that grows randomly, first to the right and then to the left.');\n   * }\n   *\n   * function draw() {\n   *   // Set the noise level and scale.\n   *   let noiseLevel = 100;\n   *   let noiseScale = 0.005;\n   *\n   *   // Scale the input coordinate.\n   *   let nt = noiseScale * frameCount;\n   *\n   *   // Compute the noise value.\n   *   let x = noiseLevel * noise(nt);\n   *\n   *   // Draw the line.\n   *   line(x, 0, x, height);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noiseSeed = function(seed) {\n    // Linear Congruential Generator\n    // Variant of a Lehman Generator\n    const lcg = (() => {\n      // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n      // m is basically chosen to be large (as it is the max period)\n      // and for its relationships to a and c\n      const m = 4294967296;\n      // a - 1 should be divisible by m's prime factors\n      const a = 1664525;\n      // c and m should be co-prime\n      const c = 1013904223;\n      let seed, z;\n      return {\n        setSeed(val) {\n          // pick a random seed if val is undefined or null\n          // the >>> 0 casts the seed to an unsigned 32-bit integer\n          z = seed = (val == null ? Math.random() * m : val) >>> 0;\n        },\n        getSeed() {\n          return seed;\n        },\n        rand() {\n          // define the recurrence relationship\n          z = (a * z + c) % m;\n          // return a float in [0, 1)\n          // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n          return z / m;\n        }\n      };\n    })();\n\n    lcg.setSeed(seed);\n    perlin = new Array(PERLIN_SIZE + 1);\n    for (let i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = lcg.rand();\n    }\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  noise(p5, p5.prototype);\n}\n\nexport { noise as default };\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,KAAKA,CAACC,EAAE,EAAEC,EAAE,EAAC;EACpB,MAAMC,aAAa,GAAG,CAAC;EACvB,MAAMC,YAAY,GAAG,CAAC,IAAID,aAAa;EACvC,MAAME,aAAa,GAAG,CAAC;EACvB,MAAMC,YAAY,GAAG,CAAC,IAAID,aAAa;EACvC,MAAME,WAAW,GAAG,IAAI;EAExB,IAAIC,cAAc,GAAG,CAAC,CAAC,CAAC;EACxB,IAAIC,kBAAkB,GAAG,GAAG,CAAC,CAAC;;EAE9B,MAAMC,aAAa,GAAGC,CAAC,IAAI,GAAG,IAAI,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACF,CAAC,GAAGC,IAAI,CAACE,EAAE,CAAC,CAAC;EAE9D,IAAIC,MAAM,CAAC,CAAC;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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AAkB;MAC1BY,EAAE,KAAK,CAAC;MACRI,EAAE,IAAI,CAAC;MACPF,EAAE,KAAK,CAAC;MACRG,EAAE,IAAI,CAAC;MACPF,EAAE,KAAK,CAAC;MACRG,EAAE,IAAI,CAAC;MAEP,IAAIF,EAAE,IAAI,GAAG,EAAE;QACbJ,EAAE,EAAE;QACJI,EAAE,EAAE;MACN;MACA,IAAIC,EAAE,IAAI,GAAG,EAAE;QACbH,EAAE,EAAE;QACJG,EAAE,EAAE;MACN;MACA,IAAIC,EAAE,IAAI,GAAG,EAAE;QACbH,EAAE,EAAE;QACJG,EAAE,EAAE;MACN;IACF;IACA,OAAOG,CAAC;EACV,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE5B,EAAE,CAACmC,WAAW,GAAG,UAASC,GAAG,EAAEC,OAAO,EAAE;IACtC,IAAID,GAAG,GAAG,CAAC,EAAE;MACX9B,cAAc,GAAG8B,GAAG;IACtB;IACA,IAAIC,OAAO,GAAG,CAAC,EAAE;MACf9B,kBAAkB,GAAG8B,OAAO;IAC9B;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErC,EAAE,CAACsC,SAAS,GAAG,UAASC,IAAI,EAAE;IAC5B;IACA;IACA,MAAMC,GAAG,GAAG,CAAC,MAAM;MACjB;MACA;MACA;MACA,MAAMC,CAAC,GAAG,UAAU;MACpB;MACA,MAAMC,CAAC,GAAG,OAAO;MACjB;MACA,MAAMC,CAAC,GAAG,UAAU;MACpB,IAAIJ,IAAI,EAAEvB,CAAC;MACX,OAAO;QACL4B,OAAOA,CAACC,GAAG,EAAE;UACX;UACA;UACA7B,CAAC,GAAGuB,IAAI,GAAG,CAACM,GAAG,IAAI,IAAI,GAAGnC,IAAI,CAACQ,MAAM,CAAC,CAAC,GAAGuB,CAAC,GAAGI,GAAG,MAAM,CAAC;QAC1D,CAAC;QACDC,OAAOA,CAAA,EAAG;UACR,OAAOP,IAAI;QACb,CAAC;QACDQ,IAAIA,CAAA,EAAG;UACL;UACA/B,CAAC,GAAG,CAAC0B,CAAC,GAAG1B,CAAC,GAAG2B,CAAC,IAAIF,CAAC;UACnB;UACA;UACA,OAAOzB,CAAC,GAAGyB,CAAC;QACd;MACF,CAAC;IACH,CAAC,EAAE,CAAC;IAEJD,GAAG,CAACI,OAAO,CAACL,IAAI,CAAC;IACjB1B,MAAM,GAAG,IAAII,KAAK,CAACZ,WAAW,GAAG,CAAC,CAAC;IACnC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAE;MACxCI,MAAM,CAACJ,CAAC,CAAC,GAAG+B,GAAG,CAACO,IAAI,CAAC,CAAC;IACxB;EACF,CAAC;AACH;AAEA,IAAG,OAAOhD,EAAE,KAAK,WAAW,EAAC;EAC3BD,KAAK,CAACC,EAAE,EAAEA,EAAE,CAACiD,SAAS,CAAC;AACzB;AAEA,SAASlD,KAAK,IAAImD,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}