{"ast":null,"code":"/**\n * @module Events\n * @submodule Acceleration\n * @for p5\n * @requires core\n * @main Events\n */\n\nfunction acceleration(p5, fn) {\n  /**\n   * The system variable deviceOrientation always contains the orientation of\n   * the device. The value of this variable will either be set 'landscape'\n   * or 'portrait'. If no data is available it will be set to 'undefined'.\n   * either LANDSCAPE or PORTRAIT.\n   *\n   * @property {(LANDSCAPE|PORTRAIT)} deviceOrientation\n   * @readOnly\n   */\n  fn.deviceOrientation = window.innerWidth / window.innerHeight > 1.0 ? 'landscape' : 'portrait';\n\n  /**\n   * The system variable accelerationX always contains the acceleration of the\n   * device along the x axis. Value is represented as meters per second squared.\n   *\n   * @property {Number} accelerationX\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * // Move a touchscreen device to register\n   * // acceleration changes.\n   * function draw() {\n   *   background(220, 50);\n   *   fill('magenta');\n   *   ellipse(width / 2, height / 2, accelerationX);\n   *   describe('Magnitude of device acceleration is displayed as ellipse size.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.accelerationX = 0;\n\n  /**\n   * The system variable accelerationY always contains the acceleration of the\n   * device along the y axis. Value is represented as meters per second squared.\n   *\n   * @property {Number} accelerationY\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * // Move a touchscreen device to register\n   * // acceleration changes.\n   * function draw() {\n   *   background(220, 50);\n   *   fill('magenta');\n   *   ellipse(width / 2, height / 2, accelerationY);\n   *   describe('Magnitude of device acceleration is displayed as ellipse size');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.accelerationY = 0;\n\n  /**\n   * The system variable accelerationZ always contains the acceleration of the\n   * device along the z axis. Value is represented as meters per second squared.\n   *\n   * @property {Number} accelerationZ\n   * @readOnly\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Move a touchscreen device to register\n   * // acceleration changes.\n   * function draw() {\n   *   background(220, 50);\n   *   fill('magenta');\n   *   ellipse(width / 2, height / 2, accelerationZ);\n   *   describe('Magnitude of device acceleration is displayed as ellipse size');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.accelerationZ = 0;\n\n  /**\n   * The system variable pAccelerationX always contains the acceleration of the\n   * device along the x axis in the frame previous to the current frame. Value\n   * is represented as meters per second squared.\n   *\n   * @property {Number} pAccelerationX\n   * @readOnly\n   */\n  fn.pAccelerationX = 0;\n\n  /**\n   * The system variable pAccelerationY always contains the acceleration of the\n   * device along the y axis in the frame previous to the current frame. Value\n   * is represented as meters per second squared.\n   *\n   * @property {Number} pAccelerationY\n   * @readOnly\n   */\n  fn.pAccelerationY = 0;\n\n  /**\n   * The system variable pAccelerationZ always contains the acceleration of the\n   * device along the z axis in the frame previous to the current frame. Value\n   * is represented as meters per second squared.\n   *\n   * @property {Number} pAccelerationZ\n   * @readOnly\n   */\n  fn.pAccelerationZ = 0;\n\n  /**\n   * _updatePAccelerations updates the pAcceleration values\n   *\n   * @private\n   */\n  fn._updatePAccelerations = function () {\n    this.pAccelerationX = this.accelerationX;\n    this.pAccelerationY = this.accelerationY;\n    this.pAccelerationZ = this.accelerationZ;\n  };\n\n  /**\n   * The system variable rotationX always contains the rotation of the\n   * device along the x axis. If the sketch <a href=\"#/p5/angleMode\">\n   * angleMode()</a> is set to DEGREES, the value will be -180 to 180. If\n   * it is set to RADIANS, the value will be -PI to PI.\n   *\n   * Note: The order the rotations are called is important, ie. if used\n   * together, it must be called in the order Z-X-Y or there might be\n   * unexpected behaviour.\n   *\n   * @property {Number} rotationX\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * let rotationX = 0;            // Angle in degrees\n   *\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas\n   * }\n   *\n   * function draw() {\n   *   background(220);                 // Set light gray background\n   *   rotateX(radians(rotationX));     // Rotate around X-axis\n   *   normalMaterial();                // Apply simple shaded material\n   *   box(60);                         // Draw 3D cube (60 units wide)\n   *   rotationX = (rotationX + 2) % 360; // Increment rotation (2° per frame)\n   * }\n   * </code>\n   * </div>\n   */\n  fn.rotationX = 0;\n\n  /**\n   * The system variable rotationY always contains the rotation of the\n   * device along the y axis. If the sketch <a href=\"#/p5/angleMode\">\n   * angleMode()</a> is set to DEGREES, the value will be -90 to 90. If\n   * it is set to RADIANS, the value will be -PI/2 to PI/2.\n   *\n   * Note: The order the rotations are called is important, ie. if used\n   * together, it must be called in the order Z-X-Y or there might be\n   * unexpected behaviour.\n   *\n   * @property {Number} rotationY\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * let rotationY = 0;            // Angle in degrees\n   *\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas\n   * }\n   *\n   * function draw() {\n   *   background(220);                 // Set light gray background\n   *   rotateY(radians(rotationY));     // Rotate around Y-axis (vertical)\n   *   normalMaterial();                // Apply simple shaded material\n   *   box(60);                         // Draw 3D cube (60 units wide)\n   *   rotationY = (rotationY + 2) % 360; // Increment rotation (2° per frame)\n   * }\n   * </code>\n   * </div>\n   */\n  fn.rotationY = 0;\n\n  /**\n   * The system variable rotationZ always contains the rotation of the\n   * device along the z axis. If the sketch <a href=\"#/p5/angleMode\">\n   * angleMode()</a> is set to DEGREES, the value will be 0 to 360. If\n   * it is set to RADIANS, the value will be 0 to 2*PI.\n   *\n   * Unlike rotationX and rotationY, this variable is available for devices\n   * with a built-in compass only.\n   *\n   * Note: The order the rotations are called is important, ie. if used\n   * together, it must be called in the order Z-X-Y or there might be\n   * unexpected behaviour.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let rotationZ = 0;          // Angle in degrees\n   *\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas\n   * }\n   *\n   * function draw() {\n   *   background(220);\n   *   rotateZ(radians(rotationZ));     // Rotate around Z-axis\n   *   normalMaterial();                // Apply simple shaded material\n   *   box(60);                         // Draw 3D cube\n   *   rotationZ = (rotationZ + 2) % 360; // Increment rotation angle\n   * }\n   * </code>\n   * </div>\n   *\n   * @property {Number} rotationZ\n   * @readOnly\n   */\n  fn.rotationZ = 0;\n\n  /**\n   * The system variable pRotationX always contains the rotation of the\n   * device along the x axis in the frame previous to the current frame.\n   * If the sketch <a href=\"#/p5/angleMode\"> angleMode()</a> is set to DEGREES,\n   * the value will be -180 to 180. If it is set to RADIANS, the value will\n   * be -PI to PI.\n   *\n   * pRotationX can also be used with rotationX to determine the rotate\n   * direction of the device along the X-axis.\n   * @example\n   * <div class='norender'>\n   * <code>\n   * // A simple if statement looking at whether\n   * // rotationX - pRotationX < 0 is true or not will be\n   * // sufficient for determining the rotate direction\n   * // in most cases.\n   *\n   * // Some extra logic is needed to account for cases where\n   * // the angles wrap around.\n   * let rotateDirection = 'clockwise';\n   *\n   * // Simple range conversion to make things simpler.\n   * // This is not absolutely necessary but the logic\n   * // will be different in that case.\n   *\n   * let rX = rotationX + 180;\n   * let pRX = pRotationX + 180;\n   *\n   * if ((rX - pRX > 0 && rX - pRX < 270) || rX - pRX < -270) {\n   *   rotateDirection = 'clockwise';\n   * } else if (rX - pRX < 0 || rX - pRX > 270) {\n   *   rotateDirection = 'counter-clockwise';\n   * }\n   *\n   * print(rotateDirection);\n   * describe('no image to display.');\n   * </code>\n   * </div>\n   *\n   * @property {Number} pRotationX\n   * @readOnly\n   */\n  fn.pRotationX = 0;\n\n  /**\n   * The system variable pRotationY always contains the rotation of the\n   * device along the y axis in the frame previous to the current frame.\n   * If the sketch <a href=\"#/p5/angleMode\"> angleMode()</a> is set to DEGREES,\n   * the value will be -90 to 90. If it is set to RADIANS, the value will\n   * be -PI/2 to PI/2.\n   *\n   * pRotationY can also be used with rotationY to determine the rotate\n   * direction of the device along the Y-axis.\n   * @example\n   * <div class='norender'>\n   * <code>\n   * // A simple if statement looking at whether\n   * // rotationY - pRotationY < 0 is true or not will be\n   * // sufficient for determining the rotate direction\n   * // in most cases.\n   *\n   * // Some extra logic is needed to account for cases where\n   * // the angles wrap around.\n   * let rotateDirection = 'clockwise';\n   *\n   * // Simple range conversion to make things simpler.\n   * // This is not absolutely necessary but the logic\n   * // will be different in that case.\n   *\n   * let rY = rotationY + 180;\n   * let pRY = pRotationY + 180;\n   *\n   * if ((rY - pRY > 0 && rY - pRY < 270) || rY - pRY < -270) {\n   *   rotateDirection = 'clockwise';\n   * } else if (rY - pRY < 0 || rY - pRY > 270) {\n   *   rotateDirection = 'counter-clockwise';\n   * }\n   * print(rotateDirection);\n   * describe('no image to display.');\n   * </code>\n   * </div>\n   *\n   * @property {Number} pRotationY\n   * @readOnly\n   */\n  fn.pRotationY = 0;\n\n  /**\n   * The system variable pRotationZ always contains the rotation of the\n   * device along the z axis in the frame previous to the current frame.\n   * If the sketch <a href=\"#/p5/angleMode\"> angleMode()</a> is set to DEGREES,\n   * the value will be 0 to 360. If it is set to RADIANS, the value will\n   * be 0 to 2*PI.\n   *\n   * pRotationZ can also be used with rotationZ to determine the rotate\n   * direction of the device along the Z-axis.\n   * @example\n   * <div class='norender'>\n   * <code>\n   * // A simple if statement looking at whether\n   * // rotationZ - pRotationZ < 0 is true or not will be\n   * // sufficient for determining the rotate direction\n   * // in most cases.\n   *\n   * // Some extra logic is needed to account for cases where\n   * // the angles wrap around.\n   * let rotateDirection = 'clockwise';\n   *\n   * if (\n   *   (rotationZ - pRotationZ > 0 && rotationZ - pRotationZ < 270) ||\n   *   rotationZ - pRotationZ < -270\n   * ) {\n   *   rotateDirection = 'clockwise';\n   * } else if (rotationZ - pRotationZ < 0 || rotationZ - pRotationZ > 270) {\n   *   rotateDirection = 'counter-clockwise';\n   * }\n   * print(rotateDirection);\n   * describe('no image to display.');\n   * </code>\n   * </div>\n   *\n   * @property {Number} pRotationZ\n   * @readOnly\n   */\n  fn.pRotationZ = 0;\n  let startAngleX = 0;\n  let startAngleY = 0;\n  let startAngleZ = 0;\n  let rotateDirectionX = 'clockwise';\n  let rotateDirectionY = 'clockwise';\n  let rotateDirectionZ = 'clockwise';\n  fn.pRotateDirectionX = undefined;\n  fn.pRotateDirectionY = undefined;\n  fn.pRotateDirectionZ = undefined;\n  fn._updatePRotations = function () {\n    this.pRotationX = this.rotationX;\n    this.pRotationY = this.rotationY;\n    this.pRotationZ = this.rotationZ;\n  };\n\n  /**\n   * When a device is rotated, the axis that triggers the <a href=\"#/p5/deviceTurned\">deviceTurned()</a>\n   * method is stored in the turnAxis variable. The turnAxis variable is only defined within\n   * the scope of deviceTurned().\n   * @property {String} turnAxis\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * // Run this example on a mobile device\n   * // Rotate the device by 90 degrees in the\n   * // X-axis to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device turns`);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when x-axis turns`);\n   * }\n   * function deviceTurned() {\n   *   if (turnAxis === 'X') {\n   *     if (value === 0) {\n   *       value = 255;\n   *     } else if (value === 255) {\n   *       value = 0;\n   *     }\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n  fn.turnAxis = undefined;\n  let move_threshold = 0.5;\n  let shake_threshold = 30;\n\n  /**\n   * The <a href=\"#/p5/setMoveThreshold\">setMoveThreshold()</a> function is used to set the movement threshold for\n   * the <a href=\"#/p5/deviceMoved\">deviceMoved()</a> function. The default threshold is set to 0.5.\n   *\n   * @method setMoveThreshold\n   * @param {Number} value The threshold value\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // You will need to move the device incrementally further\n   * // the closer the square's color gets to white in order to change the value.\n   *\n   * let value = 0;\n   * let threshold = 0.5;\n   * function setup() {\n   *   setMoveThreshold(threshold);\n   * }\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device moves`);\n   * }\n   * function deviceMoved() {\n   *   value = value + 5;\n   *   threshold = threshold + 0.1;\n   *   if (value > 255) {\n   *     value = 0;\n   *     threshold = 30;\n   *   }\n   *   setMoveThreshold(threshold);\n   * }\n   * </code>\n   * </div>\n   */\n\n  fn.setMoveThreshold = function (val) {\n    // p5._validateParameters('setMoveThreshold', arguments);\n    move_threshold = val;\n  };\n\n  /**\n   * The <a href=\"#/p5/setShakeThreshold\">setShakeThreshold()</a> function is used to set the movement threshold for\n   * the <a href=\"#/p5/deviceShaken\">deviceShaken()</a> function. The default threshold is set to 30.\n   *\n   * @method setShakeThreshold\n   * @param {Number} value The threshold value\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // You will need to shake the device more firmly\n   * // the closer the box's fill gets to white in order to change the value.\n   *\n   * let value = 0;\n   * let threshold = 30;\n   * function setup() {\n   *   setShakeThreshold(threshold);\n   * }\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device is being shaked`);\n   * }\n   * function deviceMoved() {\n   *   value = value + 5;\n   *   threshold = threshold + 5;\n   *   if (value > 255) {\n   *     value = 0;\n   *     threshold = 30;\n   *   }\n   *   setShakeThreshold(threshold);\n   * }\n   * </code>\n   * </div>\n   */\n\n  fn.setShakeThreshold = function (val) {\n    // p5._validateParameters('setShakeThreshold', arguments);\n    shake_threshold = val;\n  };\n\n  /**\n   * The <a href=\"#/p5/deviceMoved\">deviceMoved()</a> function is called when the device is moved by more than\n   * the threshold value along X, Y or Z axis. The default threshold is set to 0.5.\n   * The threshold value can be changed using <a href=\"https://p5js.org/reference/p5/setMoveThreshold\">setMoveThreshold()</a>.\n   *\n   * @method deviceMoved\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // Move the device around\n   * // to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device moves`);\n   * }\n   * function deviceMoved() {\n   *   value = value + 5;\n   *   if (value > 255) {\n   *     value = 0;\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * The <a href=\"#/p5/deviceTurned\">deviceTurned()</a> function is called when the device rotates by\n   * more than 90 degrees continuously.\n   *\n   * The axis that triggers the <a href=\"#/p5/deviceTurned\">deviceTurned()</a> method is stored in the turnAxis\n   * variable. The <a href=\"#/p5/deviceTurned\">deviceTurned()</a> method can be locked to trigger on any axis:\n   * X, Y or Z by comparing the turnAxis variable to 'X', 'Y' or 'Z'.\n   *\n   * @method deviceTurned\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // Rotate the device by 90 degrees\n   * // to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device turns`);\n   * }\n   * function deviceTurned() {\n   *   if (value === 0) {\n   *     value = 255;\n   *   } else if (value === 255) {\n   *     value = 0;\n   *   }\n   * }\n   * </code>\n   * </div>\n   * <div>\n   * <code>\n   * // Run this example on a mobile device\n   * // Rotate the device by 90 degrees in the\n   * // X-axis to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when x-axis turns`);\n   * }\n   * function deviceTurned() {\n   *   if (turnAxis === 'X') {\n   *     if (value === 0) {\n   *       value = 255;\n   *     } else if (value === 255) {\n   *       value = 0;\n   *     }\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * The <a href=\"#/p5/deviceShaken\">deviceShaken()</a> function is called when the device total acceleration\n   * changes of accelerationX and accelerationY values is more than\n   * the threshold value. The default threshold is set to 30.\n   * The threshold value can be changed using <a href=\"https://p5js.org/reference/p5/setShakeThreshold\">setShakeThreshold()</a>.\n   *\n   * @method deviceShaken\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // Shake the device to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device shakes`);\n   * }\n   * function deviceShaken() {\n   *   value = value + 5;\n   *   if (value > 255) {\n   *     value = 0;\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  fn._ondeviceorientation = function (e) {\n    this._updatePRotations();\n\n    // Convert from degrees into current angle mode\n    this.rotationX = this._fromDegrees(e.beta);\n    this.rotationY = this._fromDegrees(e.gamma);\n    this.rotationZ = this._fromDegrees(e.alpha);\n    this._handleMotion();\n  };\n  fn._ondevicemotion = function (e) {\n    this._updatePAccelerations();\n    this.accelerationX = e.acceleration.x * 2;\n    this.accelerationY = e.acceleration.y * 2;\n    this.accelerationZ = e.acceleration.z * 2;\n    this._handleMotion();\n  };\n  fn._handleMotion = function () {\n    if (window.orientation === 90 || window.orientation === -90) {\n      this.deviceOrientation = 'landscape';\n    } else if (window.orientation === 0) {\n      this.deviceOrientation = 'portrait';\n    } else if (window.orientation === undefined) {\n      this.deviceOrientation = 'undefined';\n    }\n    const context = this._isGlobal ? window : this;\n    if (typeof context.deviceMoved === 'function') {\n      if (Math.abs(this.accelerationX - this.pAccelerationX) > move_threshold || Math.abs(this.accelerationY - this.pAccelerationY) > move_threshold || Math.abs(this.accelerationZ - this.pAccelerationZ) > move_threshold) {\n        context.deviceMoved();\n      }\n    }\n    if (typeof context.deviceTurned === 'function') {\n      // The angles given by rotationX etc is from range [-180 to 180].\n      // The following will convert them to [0 to 360] for ease of calculation\n      // of cases when the angles wrapped around.\n      // _startAngleX will be converted back at the end and updated.\n\n      // Rotations are converted to degrees and all calculations are done in degrees\n      const wRX = this._toDegrees(this.rotationX) + 180;\n      const wPRX = this._toDegrees(this.pRotationX) + 180;\n      let wSAX = startAngleX + 180;\n      if (wRX - wPRX > 0 && wRX - wPRX < 270 || wRX - wPRX < -270) {\n        rotateDirectionX = 'clockwise';\n      } else if (wRX - wPRX < 0 || wRX - wPRX > 270) {\n        rotateDirectionX = 'counter-clockwise';\n      }\n      if (rotateDirectionX !== this.pRotateDirectionX) {\n        wSAX = wRX;\n      }\n      if (Math.abs(wRX - wSAX) > 90 && Math.abs(wRX - wSAX) < 270) {\n        wSAX = wRX;\n        this.turnAxis = 'X';\n        context.deviceTurned();\n      }\n      this.pRotateDirectionX = rotateDirectionX;\n      startAngleX = wSAX - 180;\n\n      // Y-axis is identical to X-axis except for changing some names.\n      const wRY = this._toDegrees(this.rotationY) + 180;\n      const wPRY = this._toDegrees(this.pRotationY) + 180;\n      let wSAY = startAngleY + 180;\n      if (wRY - wPRY > 0 && wRY - wPRY < 270 || wRY - wPRY < -270) {\n        rotateDirectionY = 'clockwise';\n      } else if (wRY - wPRY < 0 || wRY - this.pRotationY > 270) {\n        rotateDirectionY = 'counter-clockwise';\n      }\n      if (rotateDirectionY !== this.pRotateDirectionY) {\n        wSAY = wRY;\n      }\n      if (Math.abs(wRY - wSAY) > 90 && Math.abs(wRY - wSAY) < 270) {\n        wSAY = wRY;\n        this.turnAxis = 'Y';\n        context.deviceTurned();\n      }\n      this.pRotateDirectionY = rotateDirectionY;\n      startAngleY = wSAY - 180;\n\n      // Z-axis is already in the range 0 to 360\n      // so no conversion is needed.\n      const rotZ = this._toDegrees(this.rotationZ);\n      const pRotZ = this._toDegrees(this.pRotationZ);\n      if (rotZ - pRotZ > 0 && rotZ - pRotZ < 270 || rotZ - pRotZ < -270) {\n        rotateDirectionZ = 'clockwise';\n      } else if (rotZ - pRotZ < 0 || rotZ - pRotZ > 270) {\n        rotateDirectionZ = 'counter-clockwise';\n      }\n      if (rotateDirectionZ !== this.pRotateDirectionZ) {\n        startAngleZ = rotZ;\n      }\n      if (Math.abs(rotZ - startAngleZ) > 90 && Math.abs(rotZ - startAngleZ) < 270) {\n        startAngleZ = rotZ;\n        this.turnAxis = 'Z';\n        context.deviceTurned();\n      }\n      this.pRotateDirectionZ = rotateDirectionZ;\n      this.turnAxis = undefined;\n    }\n    if (typeof context.deviceShaken === 'function') {\n      let accelerationChangeX;\n      let accelerationChangeY;\n      // Add accelerationChangeZ if acceleration change on Z is needed\n      if (this.pAccelerationX !== null) {\n        accelerationChangeX = Math.abs(this.accelerationX - this.pAccelerationX);\n        accelerationChangeY = Math.abs(this.accelerationY - this.pAccelerationY);\n      }\n      if (accelerationChangeX + accelerationChangeY > shake_threshold) {\n        context.deviceShaken();\n      }\n    }\n  };\n}\nif (typeof p5 !== 'undefined') {\n  acceleration(p5, p5.prototype);\n}\nexport { acceleration as default };","map":{"version":3,"names":["acceleration","p5","fn","deviceOrientation","window","innerWidth","innerHeight","accelerationX","accelerationY","accelerationZ","pAccelerationX","pAccelerationY","pAccelerationZ","_updatePAccelerations","rotationX","rotationY","rotationZ","pRotationX","pRotationY","pRotationZ","startAngleX","startAngleY","startAngleZ","rotateDirectionX","rotateDirectionY","rotateDirectionZ","pRotateDirectionX","undefined","pRotateDirectionY","pRotateDirectionZ","_updatePRotations","turnAxis","move_threshold","shake_threshold","setMoveThreshold","val","setShakeThreshold","_ondeviceorientation","e","_fromDegrees","beta","gamma","alpha","_handleMotion","_ondevicemotion","x","y","z","orientation","context","_isGlobal","deviceMoved","Math","abs","deviceTurned","wRX","_toDegrees","wPRX","wSAX","wRY","wPRY","wSAY","rotZ","pRotZ","deviceShaken","accelerationChangeX","accelerationChangeY","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/events/acceleration.js"],"sourcesContent":["/**\n * @module Events\n * @submodule Acceleration\n * @for p5\n * @requires core\n * @main Events\n */\n\nfunction acceleration(p5, fn){\n  /**\n   * The system variable deviceOrientation always contains the orientation of\n   * the device. The value of this variable will either be set 'landscape'\n   * or 'portrait'. If no data is available it will be set to 'undefined'.\n   * either LANDSCAPE or PORTRAIT.\n   *\n   * @property {(LANDSCAPE|PORTRAIT)} deviceOrientation\n   * @readOnly\n   */\n  fn.deviceOrientation =\n    window.innerWidth / window.innerHeight > 1.0 ? 'landscape' : 'portrait';\n\n  /**\n   * The system variable accelerationX always contains the acceleration of the\n   * device along the x axis. Value is represented as meters per second squared.\n   *\n   * @property {Number} accelerationX\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * // Move a touchscreen device to register\n   * // acceleration changes.\n   * function draw() {\n   *   background(220, 50);\n   *   fill('magenta');\n   *   ellipse(width / 2, height / 2, accelerationX);\n   *   describe('Magnitude of device acceleration is displayed as ellipse size.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.accelerationX = 0;\n\n  /**\n   * The system variable accelerationY always contains the acceleration of the\n   * device along the y axis. Value is represented as meters per second squared.\n   *\n   * @property {Number} accelerationY\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * // Move a touchscreen device to register\n   * // acceleration changes.\n   * function draw() {\n   *   background(220, 50);\n   *   fill('magenta');\n   *   ellipse(width / 2, height / 2, accelerationY);\n   *   describe('Magnitude of device acceleration is displayed as ellipse size');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.accelerationY = 0;\n\n  /**\n   * The system variable accelerationZ always contains the acceleration of the\n   * device along the z axis. Value is represented as meters per second squared.\n   *\n   * @property {Number} accelerationZ\n   * @readOnly\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Move a touchscreen device to register\n   * // acceleration changes.\n   * function draw() {\n   *   background(220, 50);\n   *   fill('magenta');\n   *   ellipse(width / 2, height / 2, accelerationZ);\n   *   describe('Magnitude of device acceleration is displayed as ellipse size');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.accelerationZ = 0;\n\n  /**\n   * The system variable pAccelerationX always contains the acceleration of the\n   * device along the x axis in the frame previous to the current frame. Value\n   * is represented as meters per second squared.\n   *\n   * @property {Number} pAccelerationX\n   * @readOnly\n   */\n  fn.pAccelerationX = 0;\n\n  /**\n   * The system variable pAccelerationY always contains the acceleration of the\n   * device along the y axis in the frame previous to the current frame. Value\n   * is represented as meters per second squared.\n   *\n   * @property {Number} pAccelerationY\n   * @readOnly\n   */\n  fn.pAccelerationY = 0;\n\n  /**\n   * The system variable pAccelerationZ always contains the acceleration of the\n   * device along the z axis in the frame previous to the current frame. Value\n   * is represented as meters per second squared.\n   *\n   * @property {Number} pAccelerationZ\n   * @readOnly\n   */\n  fn.pAccelerationZ = 0;\n\n  /**\n   * _updatePAccelerations updates the pAcceleration values\n   *\n   * @private\n   */\n  fn._updatePAccelerations = function () {\n    this.pAccelerationX = this.accelerationX;\n    this.pAccelerationY = this.accelerationY;\n    this.pAccelerationZ = this.accelerationZ;\n  };\n\n  /**\n   * The system variable rotationX always contains the rotation of the\n   * device along the x axis. If the sketch <a href=\"#/p5/angleMode\">\n   * angleMode()</a> is set to DEGREES, the value will be -180 to 180. If\n   * it is set to RADIANS, the value will be -PI to PI.\n   *\n   * Note: The order the rotations are called is important, ie. if used\n   * together, it must be called in the order Z-X-Y or there might be\n   * unexpected behaviour.\n   *\n   * @property {Number} rotationX\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * let rotationX = 0;            // Angle in degrees\n   *\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas\n   * }\n   *\n   * function draw() {\n   *   background(220);                 // Set light gray background\n   *   rotateX(radians(rotationX));     // Rotate around X-axis\n   *   normalMaterial();                // Apply simple shaded material\n   *   box(60);                         // Draw 3D cube (60 units wide)\n   *   rotationX = (rotationX + 2) % 360; // Increment rotation (2° per frame)\n   * }\n   * </code>\n   * </div>\n   */\n  fn.rotationX = 0;\n\n  /**\n   * The system variable rotationY always contains the rotation of the\n   * device along the y axis. If the sketch <a href=\"#/p5/angleMode\">\n   * angleMode()</a> is set to DEGREES, the value will be -90 to 90. If\n   * it is set to RADIANS, the value will be -PI/2 to PI/2.\n   *\n   * Note: The order the rotations are called is important, ie. if used\n   * together, it must be called in the order Z-X-Y or there might be\n   * unexpected behaviour.\n   *\n   * @property {Number} rotationY\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * let rotationY = 0;            // Angle in degrees\n   *\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas\n   * }\n   *\n   * function draw() {\n   *   background(220);                 // Set light gray background\n   *   rotateY(radians(rotationY));     // Rotate around Y-axis (vertical)\n   *   normalMaterial();                // Apply simple shaded material\n   *   box(60);                         // Draw 3D cube (60 units wide)\n   *   rotationY = (rotationY + 2) % 360; // Increment rotation (2° per frame)\n   * }\n   * </code>\n   * </div>\n   */\n  fn.rotationY = 0;\n\n  /**\n   * The system variable rotationZ always contains the rotation of the\n   * device along the z axis. If the sketch <a href=\"#/p5/angleMode\">\n   * angleMode()</a> is set to DEGREES, the value will be 0 to 360. If\n   * it is set to RADIANS, the value will be 0 to 2*PI.\n   *\n   * Unlike rotationX and rotationY, this variable is available for devices\n   * with a built-in compass only.\n   *\n   * Note: The order the rotations are called is important, ie. if used\n   * together, it must be called in the order Z-X-Y or there might be\n   * unexpected behaviour.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let rotationZ = 0;          // Angle in degrees\n   *\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas\n   * }\n   *\n   * function draw() {\n   *   background(220);\n   *   rotateZ(radians(rotationZ));     // Rotate around Z-axis\n   *   normalMaterial();                // Apply simple shaded material\n   *   box(60);                         // Draw 3D cube\n   *   rotationZ = (rotationZ + 2) % 360; // Increment rotation angle\n   * }\n   * </code>\n   * </div>\n   *\n   * @property {Number} rotationZ\n   * @readOnly\n   */\n  fn.rotationZ = 0;\n\n  /**\n   * The system variable pRotationX always contains the rotation of the\n   * device along the x axis in the frame previous to the current frame.\n   * If the sketch <a href=\"#/p5/angleMode\"> angleMode()</a> is set to DEGREES,\n   * the value will be -180 to 180. If it is set to RADIANS, the value will\n   * be -PI to PI.\n   *\n   * pRotationX can also be used with rotationX to determine the rotate\n   * direction of the device along the X-axis.\n   * @example\n   * <div class='norender'>\n   * <code>\n   * // A simple if statement looking at whether\n   * // rotationX - pRotationX < 0 is true or not will be\n   * // sufficient for determining the rotate direction\n   * // in most cases.\n   *\n   * // Some extra logic is needed to account for cases where\n   * // the angles wrap around.\n   * let rotateDirection = 'clockwise';\n   *\n   * // Simple range conversion to make things simpler.\n   * // This is not absolutely necessary but the logic\n   * // will be different in that case.\n   *\n   * let rX = rotationX + 180;\n   * let pRX = pRotationX + 180;\n   *\n   * if ((rX - pRX > 0 && rX - pRX < 270) || rX - pRX < -270) {\n   *   rotateDirection = 'clockwise';\n   * } else if (rX - pRX < 0 || rX - pRX > 270) {\n   *   rotateDirection = 'counter-clockwise';\n   * }\n   *\n   * print(rotateDirection);\n   * describe('no image to display.');\n   * </code>\n   * </div>\n   *\n   * @property {Number} pRotationX\n   * @readOnly\n   */\n  fn.pRotationX = 0;\n\n  /**\n   * The system variable pRotationY always contains the rotation of the\n   * device along the y axis in the frame previous to the current frame.\n   * If the sketch <a href=\"#/p5/angleMode\"> angleMode()</a> is set to DEGREES,\n   * the value will be -90 to 90. If it is set to RADIANS, the value will\n   * be -PI/2 to PI/2.\n   *\n   * pRotationY can also be used with rotationY to determine the rotate\n   * direction of the device along the Y-axis.\n   * @example\n   * <div class='norender'>\n   * <code>\n   * // A simple if statement looking at whether\n   * // rotationY - pRotationY < 0 is true or not will be\n   * // sufficient for determining the rotate direction\n   * // in most cases.\n   *\n   * // Some extra logic is needed to account for cases where\n   * // the angles wrap around.\n   * let rotateDirection = 'clockwise';\n   *\n   * // Simple range conversion to make things simpler.\n   * // This is not absolutely necessary but the logic\n   * // will be different in that case.\n   *\n   * let rY = rotationY + 180;\n   * let pRY = pRotationY + 180;\n   *\n   * if ((rY - pRY > 0 && rY - pRY < 270) || rY - pRY < -270) {\n   *   rotateDirection = 'clockwise';\n   * } else if (rY - pRY < 0 || rY - pRY > 270) {\n   *   rotateDirection = 'counter-clockwise';\n   * }\n   * print(rotateDirection);\n   * describe('no image to display.');\n   * </code>\n   * </div>\n   *\n   * @property {Number} pRotationY\n   * @readOnly\n   */\n  fn.pRotationY = 0;\n\n  /**\n   * The system variable pRotationZ always contains the rotation of the\n   * device along the z axis in the frame previous to the current frame.\n   * If the sketch <a href=\"#/p5/angleMode\"> angleMode()</a> is set to DEGREES,\n   * the value will be 0 to 360. If it is set to RADIANS, the value will\n   * be 0 to 2*PI.\n   *\n   * pRotationZ can also be used with rotationZ to determine the rotate\n   * direction of the device along the Z-axis.\n   * @example\n   * <div class='norender'>\n   * <code>\n   * // A simple if statement looking at whether\n   * // rotationZ - pRotationZ < 0 is true or not will be\n   * // sufficient for determining the rotate direction\n   * // in most cases.\n   *\n   * // Some extra logic is needed to account for cases where\n   * // the angles wrap around.\n   * let rotateDirection = 'clockwise';\n   *\n   * if (\n   *   (rotationZ - pRotationZ > 0 && rotationZ - pRotationZ < 270) ||\n   *   rotationZ - pRotationZ < -270\n   * ) {\n   *   rotateDirection = 'clockwise';\n   * } else if (rotationZ - pRotationZ < 0 || rotationZ - pRotationZ > 270) {\n   *   rotateDirection = 'counter-clockwise';\n   * }\n   * print(rotateDirection);\n   * describe('no image to display.');\n   * </code>\n   * </div>\n   *\n   * @property {Number} pRotationZ\n   * @readOnly\n   */\n  fn.pRotationZ = 0;\n\n  let startAngleX = 0;\n  let startAngleY = 0;\n  let startAngleZ = 0;\n\n  let rotateDirectionX = 'clockwise';\n  let rotateDirectionY = 'clockwise';\n  let rotateDirectionZ = 'clockwise';\n\n  fn.pRotateDirectionX = undefined;\n  fn.pRotateDirectionY = undefined;\n  fn.pRotateDirectionZ = undefined;\n\n  fn._updatePRotations = function () {\n    this.pRotationX = this.rotationX;\n    this.pRotationY = this.rotationY;\n    this.pRotationZ = this.rotationZ;\n  };\n\n  /**\n   * When a device is rotated, the axis that triggers the <a href=\"#/p5/deviceTurned\">deviceTurned()</a>\n   * method is stored in the turnAxis variable. The turnAxis variable is only defined within\n   * the scope of deviceTurned().\n   * @property {String} turnAxis\n   * @readOnly\n   * @example\n   * <div>\n   * <code>\n   * // Run this example on a mobile device\n   * // Rotate the device by 90 degrees in the\n   * // X-axis to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device turns`);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when x-axis turns`);\n   * }\n   * function deviceTurned() {\n   *   if (turnAxis === 'X') {\n   *     if (value === 0) {\n   *       value = 255;\n   *     } else if (value === 255) {\n   *       value = 0;\n   *     }\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n  fn.turnAxis = undefined;\n\n  let move_threshold = 0.5;\n  let shake_threshold = 30;\n\n  /**\n   * The <a href=\"#/p5/setMoveThreshold\">setMoveThreshold()</a> function is used to set the movement threshold for\n   * the <a href=\"#/p5/deviceMoved\">deviceMoved()</a> function. The default threshold is set to 0.5.\n   *\n   * @method setMoveThreshold\n   * @param {Number} value The threshold value\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // You will need to move the device incrementally further\n   * // the closer the square's color gets to white in order to change the value.\n   *\n   * let value = 0;\n   * let threshold = 0.5;\n   * function setup() {\n   *   setMoveThreshold(threshold);\n   * }\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device moves`);\n   * }\n   * function deviceMoved() {\n   *   value = value + 5;\n   *   threshold = threshold + 0.1;\n   *   if (value > 255) {\n   *     value = 0;\n   *     threshold = 30;\n   *   }\n   *   setMoveThreshold(threshold);\n   * }\n   * </code>\n   * </div>\n   */\n\n  fn.setMoveThreshold = function (val) {\n    // p5._validateParameters('setMoveThreshold', arguments);\n    move_threshold = val;\n  };\n\n  /**\n   * The <a href=\"#/p5/setShakeThreshold\">setShakeThreshold()</a> function is used to set the movement threshold for\n   * the <a href=\"#/p5/deviceShaken\">deviceShaken()</a> function. The default threshold is set to 30.\n   *\n   * @method setShakeThreshold\n   * @param {Number} value The threshold value\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // You will need to shake the device more firmly\n   * // the closer the box's fill gets to white in order to change the value.\n   *\n   * let value = 0;\n   * let threshold = 30;\n   * function setup() {\n   *   setShakeThreshold(threshold);\n   * }\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device is being shaked`);\n   * }\n   * function deviceMoved() {\n   *   value = value + 5;\n   *   threshold = threshold + 5;\n   *   if (value > 255) {\n   *     value = 0;\n   *     threshold = 30;\n   *   }\n   *   setShakeThreshold(threshold);\n   * }\n   * </code>\n   * </div>\n   */\n\n  fn.setShakeThreshold = function (val) {\n    // p5._validateParameters('setShakeThreshold', arguments);\n    shake_threshold = val;\n  };\n\n  /**\n   * The <a href=\"#/p5/deviceMoved\">deviceMoved()</a> function is called when the device is moved by more than\n   * the threshold value along X, Y or Z axis. The default threshold is set to 0.5.\n   * The threshold value can be changed using <a href=\"https://p5js.org/reference/p5/setMoveThreshold\">setMoveThreshold()</a>.\n   *\n   * @method deviceMoved\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // Move the device around\n   * // to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device moves`);\n   * }\n   * function deviceMoved() {\n   *   value = value + 5;\n   *   if (value > 255) {\n   *     value = 0;\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * The <a href=\"#/p5/deviceTurned\">deviceTurned()</a> function is called when the device rotates by\n   * more than 90 degrees continuously.\n   *\n   * The axis that triggers the <a href=\"#/p5/deviceTurned\">deviceTurned()</a> method is stored in the turnAxis\n   * variable. The <a href=\"#/p5/deviceTurned\">deviceTurned()</a> method can be locked to trigger on any axis:\n   * X, Y or Z by comparing the turnAxis variable to 'X', 'Y' or 'Z'.\n   *\n   * @method deviceTurned\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // Rotate the device by 90 degrees\n   * // to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device turns`);\n   * }\n   * function deviceTurned() {\n   *   if (value === 0) {\n   *     value = 255;\n   *   } else if (value === 255) {\n   *     value = 0;\n   *   }\n   * }\n   * </code>\n   * </div>\n   * <div>\n   * <code>\n   * // Run this example on a mobile device\n   * // Rotate the device by 90 degrees in the\n   * // X-axis to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when x-axis turns`);\n   * }\n   * function deviceTurned() {\n   *   if (turnAxis === 'X') {\n   *     if (value === 0) {\n   *       value = 255;\n   *     } else if (value === 255) {\n   *       value = 0;\n   *     }\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * The <a href=\"#/p5/deviceShaken\">deviceShaken()</a> function is called when the device total acceleration\n   * changes of accelerationX and accelerationY values is more than\n   * the threshold value. The default threshold is set to 30.\n   * The threshold value can be changed using <a href=\"https://p5js.org/reference/p5/setShakeThreshold\">setShakeThreshold()</a>.\n   *\n   * @method deviceShaken\n   * @example\n   * <div class=\"norender\">\n   * <code>\n   * // Run this example on a mobile device\n   * // Shake the device to change the value.\n   *\n   * let value = 0;\n   * function draw() {\n   *   fill(value);\n   *   rect(25, 25, 50, 50);\n   *   describe(`50-by-50 black rect in center of canvas.\n   *     turns white on mobile when device shakes`);\n   * }\n   * function deviceShaken() {\n   *   value = value + 5;\n   *   if (value > 255) {\n   *     value = 0;\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  fn._ondeviceorientation = function (e) {\n    this._updatePRotations();\n\n    // Convert from degrees into current angle mode\n    this.rotationX = this._fromDegrees(e.beta);\n    this.rotationY = this._fromDegrees(e.gamma);\n    this.rotationZ = this._fromDegrees(e.alpha);\n    this._handleMotion();\n  };\n  fn._ondevicemotion = function (e) {\n    this._updatePAccelerations();\n    this.accelerationX = e.acceleration.x * 2;\n    this.accelerationY = e.acceleration.y * 2;\n    this.accelerationZ = e.acceleration.z * 2;\n    this._handleMotion();\n  };\n  fn._handleMotion = function () {\n    if (window.orientation === 90 || window.orientation === -90) {\n      this.deviceOrientation = 'landscape';\n    } else if (window.orientation === 0) {\n      this.deviceOrientation = 'portrait';\n    } else if (window.orientation === undefined) {\n      this.deviceOrientation = 'undefined';\n    }\n    const context = this._isGlobal ? window : this;\n    if (typeof context.deviceMoved === 'function') {\n      if (\n        Math.abs(this.accelerationX - this.pAccelerationX) > move_threshold ||\n        Math.abs(this.accelerationY - this.pAccelerationY) > move_threshold ||\n        Math.abs(this.accelerationZ - this.pAccelerationZ) > move_threshold\n      ) {\n        context.deviceMoved();\n      }\n    }\n\n    if (typeof context.deviceTurned === 'function') {\n      // The angles given by rotationX etc is from range [-180 to 180].\n      // The following will convert them to [0 to 360] for ease of calculation\n      // of cases when the angles wrapped around.\n      // _startAngleX will be converted back at the end and updated.\n\n      // Rotations are converted to degrees and all calculations are done in degrees\n      const wRX = this._toDegrees(this.rotationX) + 180;\n      const wPRX = this._toDegrees(this.pRotationX) + 180;\n      let wSAX = startAngleX + 180;\n      if ((wRX - wPRX > 0 && wRX - wPRX < 270) || wRX - wPRX < -270) {\n        rotateDirectionX = 'clockwise';\n      } else if (wRX - wPRX < 0 || wRX - wPRX > 270) {\n        rotateDirectionX = 'counter-clockwise';\n      }\n      if (rotateDirectionX !== this.pRotateDirectionX) {\n        wSAX = wRX;\n      }\n      if (Math.abs(wRX - wSAX) > 90 && Math.abs(wRX - wSAX) < 270) {\n        wSAX = wRX;\n        this.turnAxis = 'X';\n        context.deviceTurned();\n      }\n      this.pRotateDirectionX = rotateDirectionX;\n      startAngleX = wSAX - 180;\n\n      // Y-axis is identical to X-axis except for changing some names.\n      const wRY = this._toDegrees(this.rotationY) + 180;\n      const wPRY = this._toDegrees(this.pRotationY) + 180;\n      let wSAY = startAngleY + 180;\n      if ((wRY - wPRY > 0 && wRY - wPRY < 270) || wRY - wPRY < -270) {\n        rotateDirectionY = 'clockwise';\n      } else if (wRY - wPRY < 0 || wRY - this.pRotationY > 270) {\n        rotateDirectionY = 'counter-clockwise';\n      }\n      if (rotateDirectionY !== this.pRotateDirectionY) {\n        wSAY = wRY;\n      }\n      if (Math.abs(wRY - wSAY) > 90 && Math.abs(wRY - wSAY) < 270) {\n        wSAY = wRY;\n        this.turnAxis = 'Y';\n        context.deviceTurned();\n      }\n      this.pRotateDirectionY = rotateDirectionY;\n      startAngleY = wSAY - 180;\n\n      // Z-axis is already in the range 0 to 360\n      // so no conversion is needed.\n      const rotZ = this._toDegrees(this.rotationZ);\n      const pRotZ = this._toDegrees(this.pRotationZ);\n      if (\n        (rotZ - pRotZ > 0 && rotZ - pRotZ < 270) ||\n        rotZ - pRotZ < -270\n      ) {\n        rotateDirectionZ = 'clockwise';\n      } else if (\n        rotZ - pRotZ < 0 ||\n        rotZ - pRotZ > 270\n      ) {\n        rotateDirectionZ = 'counter-clockwise';\n      }\n      if (rotateDirectionZ !== this.pRotateDirectionZ) {\n        startAngleZ = rotZ;\n      }\n      if (\n        Math.abs(rotZ - startAngleZ) > 90 &&\n        Math.abs(rotZ - startAngleZ) < 270\n      ) {\n        startAngleZ = rotZ;\n        this.turnAxis = 'Z';\n        context.deviceTurned();\n      }\n      this.pRotateDirectionZ = rotateDirectionZ;\n      this.turnAxis = undefined;\n    }\n    if (typeof context.deviceShaken === 'function') {\n      let accelerationChangeX;\n      let accelerationChangeY;\n      // Add accelerationChangeZ if acceleration change on Z is needed\n      if (this.pAccelerationX !== null) {\n        accelerationChangeX = Math.abs(this.accelerationX - this.pAccelerationX);\n        accelerationChangeY = Math.abs(this.accelerationY - this.pAccelerationY);\n      }\n      if (accelerationChangeX + accelerationChangeY > shake_threshold) {\n        context.deviceShaken();\n      }\n    }\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  acceleration(p5, p5.prototype);\n}\n\nexport { acceleration as default };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,YAAYA,CAACC,EAAE,EAAEC,EAAE,EAAC;EAC3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEA,EAAE,CAACC,iBAAiB,GAClBC,MAAM,CAACC,UAAU,GAAGD,MAAM,CAACE,WAAW,GAAG,GAAG,GAAG,WAAW,GAAG,UAAU;;EAEzE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEJ,EAAE,CAACK,aAAa,GAAG,CAAC;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEL,EAAE,CAACM,aAAa,GAAG,CAAC;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEN,EAAE,CAACO,aAAa,GAAG,CAAC;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,EAAE,CAACQ,cAAc,GAAG,CAAC;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACER,EAAE,CAACS,cAAc,GAAG,CAAC;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACET,EAAE,CAACU,cAAc,GAAG,CAAC;;EAErB;AACF;AACA;AACA;AACA;EACEV,EAAE,CAACW,qBAAqB,GAAG,YAAY;IACrC,IAAI,CAACH,cAAc,GAAG,IAAI,CAACH,aAAa;IACxC,IAAI,CAACI,cAAc,GAAG,IAAI,CAACH,aAAa;IACxC,IAAI,CAACI,cAAc,GAAG,IAAI,CAACH,aAAa;EAC1C,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,EAAE,CAACY,SAAS,GAAG,CAAC;;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEZ,EAAE,CAACa,SAAS,GAAG,CAAC;;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEb,EAAE,CAACc,SAAS,GAAG,CAAC;;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEd,EAAE,CAACe,UAAU,GAAG,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEf,EAAE,CAACgB,UAAU,GAAG,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEhB,EAAE,CAACiB,UAAU,GAAG,CAAC;EAEjB,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,WAAW,GAAG,CAAC;EAEnB,IAAIC,gBAAgB,GAAG,WAAW;EAClC,IAAIC,gBAAgB,GAAG,WAAW;EAClC,IAAIC,gBAAgB,GAAG,WAAW;EAElCvB,EAAE,CAACwB,iBAAiB,GAAGC,SAAS;EAChCzB,EAAE,CAAC0B,iBAAiB,GAAGD,SAAS;EAChCzB,EAAE,CAAC2B,iBAAiB,GAAGF,SAAS;EAEhCzB,EAAE,CAAC4B,iBAAiB,GAAG,YAAY;IACjC,IAAI,CAACb,UAAU,GAAG,IAAI,CAACH,SAAS;IAChC,IAAI,CAACI,UAAU,GAAG,IAAI,CAACH,SAAS;IAChC,IAAI,CAACI,UAAU,GAAG,IAAI,CAACH,SAAS;EAClC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEd,EAAE,CAAC6B,QAAQ,GAAGJ,SAAS;EAEvB,IAAIK,cAAc,GAAG,GAAG;EACxB,IAAIC,eAAe,GAAG,EAAE;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE/B,EAAE,CAACgC,gBAAgB,GAAG,UAAUC,GAAG,EAAE;IACnC;IACAH,cAAc,GAAGG,GAAG;EACtB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEjC,EAAE,CAACkC,iBAAiB,GAAG,UAAUD,GAAG,EAAE;IACpC;IACAF,eAAe,GAAGE,GAAG;EACvB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEjC,EAAE,CAACmC,oBAAoB,GAAG,UAAUC,CAAC,EAAE;IACrC,IAAI,CAACR,iBAAiB,CAAC,CAAC;;IAExB;IACA,IAAI,CAAChB,SAAS,GAAG,IAAI,CAACyB,YAAY,CAACD,CAAC,CAACE,IAAI,CAAC;IAC1C,IAAI,CAACzB,SAAS,GAAG,IAAI,CAACwB,YAAY,CAACD,CAAC,CAACG,KAAK,CAAC;IAC3C,IAAI,CAACzB,SAAS,GAAG,IAAI,CAACuB,YAAY,CAACD,CAAC,CAACI,KAAK,CAAC;IAC3C,IAAI,CAACC,aAAa,CAAC,CAAC;EACtB,CAAC;EACDzC,EAAE,CAAC0C,eAAe,GAAG,UAAUN,CAAC,EAAE;IAChC,IAAI,CAACzB,qBAAqB,CAAC,CAAC;IAC5B,IAAI,CAACN,aAAa,GAAG+B,CAAC,CAACtC,YAAY,CAAC6C,CAAC,GAAG,CAAC;IACzC,IAAI,CAACrC,aAAa,GAAG8B,CAAC,CAACtC,YAAY,CAAC8C,CAAC,GAAG,CAAC;IACzC,IAAI,CAACrC,aAAa,GAAG6B,CAAC,CAACtC,YAAY,CAAC+C,CAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}