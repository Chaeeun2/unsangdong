{"ast":null,"code":"/**\n * @module Shape\n * @submodule Custom Shapes\n * @for p5\n * @requires core\n * @requires constants\n */\n\nfunction vertex(p5, fn) {\n  /**\n   * Begins adding vertices to a custom shape.\n   *\n   * The `beginShape()` and <a href=\"#/p5/endShape\">endShape()</a> functions\n   * allow for creating custom shapes in 2D or 3D. `beginShape()` begins adding\n   * vertices to a custom shape and <a href=\"#/p5/endShape\">endShape()</a> stops\n   * adding them.\n   *\n   * The parameter, `kind`, sets the kind of shape to make. The available kinds are:\n   *\n   * - `PATH` (the default) to draw shapes by tracing out the path along their edges.\n   * - `POINTS` to draw a series of points.\n   * - `LINES` to draw a series of unconnected line segments.\n   * - `TRIANGLES` to draw a series of separate triangles.\n   * - `TRIANGLE_FAN` to draw a series of connected triangles sharing the first vertex in a fan-like fashion.\n   * - `TRIANGLE_STRIP` to draw a series of connected triangles in strip fashion.\n   * - `QUADS` to draw a series of separate quadrilaterals (quads).\n   * - `QUAD_STRIP` to draw quad strip using adjacent edges to form the next quad.\n   *\n   * After calling `beginShape()`, shapes can be built by calling\n   * <a href=\"#/p5/vertex\">vertex()</a>,\n   * <a href=\"#/p5/bezierVertex\">bezierVertex()</a>, and/or\n   * <a href=\"#/p5/splineVertex\">splineVertex()</a>. Calling\n   * <a href=\"#/p5/endShape\">endShape()</a> will stop adding vertices to the\n   * shape. Each shape will be outlined with the current stroke color and filled\n   * with the current fill color.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and\n   * <a href=\"#/p5/scale\">scale()</a> don't work between `beginShape()` and\n   * <a href=\"#/p5/endShape\">endShape()</a>. It's also not possible to use\n   * other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between `beginShape()` and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * @method beginShape\n   * @param  {(POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH)} [kind=PATH] either POINTS, LINES, TRIANGLES, TRIANGLE_FAN\n   *                                TRIANGLE_STRIP, QUADS, QUAD_STRIP or PATH. Defaults to PATH.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw the vertices (points).\n   *   beginShape(POINTS);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four black dots that form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw lines between alternating pairs of vertices.\n   *   beginShape(LINES);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two horizontal black lines on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Three black lines form a sideways U shape on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   *\n   *   describe('A black outline of a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles.\n   *   beginShape(TRIANGLES);\n   *\n   *   // Left triangle.\n   *   vertex(30, 75);\n   *   vertex(40, 20);\n   *   vertex(50, 75);\n   *\n   *   // Right triangle.\n   *   vertex(60, 20);\n   *   vertex(70, 75);\n   *   vertex(80, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two white triangles drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles.\n   *   beginShape(TRIANGLE_STRIP);\n   *\n   *   // Add vertices.\n   *   vertex(30, 75);\n   *   vertex(40, 20);\n   *   vertex(50, 75);\n   *   vertex(60, 20);\n   *   vertex(70, 75);\n   *   vertex(80, 20);\n   *   vertex(90, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Five white triangles that are interleaved drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles that share their first vertex.\n   *   beginShape(TRIANGLE_FAN);\n   *\n   *   // Add vertices.\n   *   vertex(57.5, 50);\n   *   vertex(57.5, 15);\n   *   vertex(92, 50);\n   *   vertex(57.5, 85);\n   *   vertex(22, 50);\n   *   vertex(57.5, 15);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four white triangles form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(QUADS);\n   *\n   *   // Left rectangle.\n   *   vertex(30, 20);\n   *   vertex(30, 75);\n   *   vertex(50, 75);\n   *   vertex(50, 20);\n   *\n   *   // Right rectangle.\n   *   vertex(65, 20);\n   *   vertex(65, 75);\n   *   vertex(85, 75);\n   *   vertex(85, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two white rectangles drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(QUAD_STRIP);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(30, 75);\n   *   vertex(50, 20);\n   *   vertex(50, 75);\n   *   vertex(65, 20);\n   *   vertex(65, 75);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Three white rectangles that share edges are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(PATH);\n   *\n   *   // Add the vertices.\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, -10, 0);\n   *   vertex(-10, -10, 0);\n   *   vertex(-10, 10, 0);\n   *   vertex(30, 10, 0);\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   *\n   *   describe('A blocky C shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag with the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A blocky C shape drawn in red, blue, and green on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(PATH);\n   *\n   *   // Add the vertices.\n   *   fill('red');\n   *   stroke('red');\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, -10, 0);\n   *   fill('green');\n   *   stroke('green');\n   *   vertex(-10, -10, 0);\n   *   vertex(-10, 10, 0);\n   *   vertex(30, 10, 0);\n   *   fill('blue');\n   *   stroke('blue');\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.beginShape = function (kind) {\n    // p5._validateParameters('beginShape', arguments);\n    this._renderer.beginShape(...arguments);\n  };\n\n  /**\n   * Adds a Bézier curve segment to a custom shape.\n   *\n   * `bezierVertex()` adds a curved segment to custom shapes. The Bézier curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/bezier\">bezier()</a> function. `bezierVertex()` must be\n   * called between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   * Bézier need a starting point. Building a shape\n   * only with Bézier curves needs one initial\n   * call to <a href=\"#/p5/vertex\">bezierVertex()</a>, before\n   * a number of `bezierVertex()` calls that is a multiple of the parameter\n   * set by <a href=\"#/p5/bezierOrder\">bezierOrder(...)</a> (default 3).\n   * But shapes can mix different types of vertices, so if there\n   * are some previous vertices, then the initial anchor is not needed, \n   * only the multiples of 3 (or the Bézier order) calls to \n   *  `bezierVertex` for each curve.\n   * \n   * Each curve of order 3 requires three calls to `bezierVertex`, so\n   * 2 curves would need 7 calls to `bezierVertex()`:\n   * (1 one initial anchor point, two sets of 3 curves describing the curves)\n   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2. \n   *\n   * Bézier curves can also be drawn in 3D using WebGL mode.\n   *\n   * Note: `bezierVertex()` won’t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method bezierVertex\n   * @param  {Number} x x-coordinate of the first control point.\n   * @param  {Number} y y-coordinate of the first control point.\n   * @param  {Number} [u]\n   * @param  {Number} [v]\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertex.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A black C curve on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(30, 20);\n   *   point(30, 75);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(80, 0);\n   *   point(80, 75);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertex.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(30, 20, 80, 0);\n   *   line(30, 75, 80, 75);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the mouse near the red dot in the top-right corner\n   * // and drag to change the curve's shape.\n   *\n   * let x2 = 80;\n   * let y2 = 0;\n   * let isChanging = false;\n   *\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(30, 20);\n   *   point(30, 75);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(x2, y2);\n   *   point(80, 75);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertex.\n   *   bezierVertex(x2, y2);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(30, 20, x2, y2);\n   *   line(30, 75, 80, 75);\n   * }\n   *\n   * // Start changing the first control point if the user clicks near it.\n   * function mousePressed() {\n   *   if (dist(mouseX, mouseY, x2, y2) < 20) {\n   *     isChanging = true;\n   *   }\n   * }\n   *\n   * // Stop changing the first control point when the user releases the mouse.\n   * function mouseReleased() {\n   *   isChanging = false;\n   * }\n   *\n   * // Update the first control point while the user drags the mouse.\n   * function mouseDragged() {\n   *   if (isChanging === true) {\n   *     x2 = mouseX;\n   *     y2 = mouseY;\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertices.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   * \n   *   bezierVertex(50, 80);\n   *   bezierVertex(60, 25);\n   *   bezierVertex(30, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A crescent moon shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A crescent moon shape drawn in white on a blue background. When the user drags the mouse, the scene rotates and a second moon is revealed.');\n   * }\n   *\n   * function draw() {\n   *   background('midnightblue');\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the moons.\n   *   noStroke();\n   *   fill('lemonchiffon');\n   *\n   *   // Draw the first moon.\n   *   beginShape();\n   *   bezierVertex(-20, -30, 0);\n   * \n   *   bezierVertex(30, -50, 0);\n   *   bezierVertex(30, 25, 0);\n   *   bezierVertex(-20, 25, 0);\n   * \n   *   bezierVertex(0, 30, 0);\n   *   bezierVertex(10, -25, 0);\n   *   bezierVertex(-20, -30, 0);\n   *   endShape();\n   *\n   *   // Draw the second moon.\n   *   beginShape();\n   * \n   *   bezierVertex(-20, -30, -20);\n   * \n   *   bezierVertex(30, -50, -20);\n   *   bezierVertex(30, 25, -20);\n   *   bezierVertex(-20, 25, -20);\n   * \n   *   bezierVertex(0, 30, -20);\n   *   bezierVertex(10, -25, -20);\n   *   bezierVertex(-20, -30, -20);\n   * \n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method bezierVertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} z\n   * @param  {Number} [u]\n   * @param  {Number} [v]\n   */\n  fn.bezierVertex = function (...args) {\n    this._renderer.bezierVertex(...args);\n  };\n\n  /**\n   * Concludes the vertices of a custom shape. \n   * \n   * The <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()` functions\n   * allow for creating custom shapes in 2D or 3D.\n   * <a href=\"#/p5/beginShape\">beginShape()</a> begins adding vertices to a\n   * custom shape and `endShape()` stops adding them.\n   *\n   * The first parameter, `mode`, is optional. By default, the first and last\n   * vertices of a shape aren't connected. If the constant `CLOSE` is passed, as\n   * in `endShape(CLOSE)`, then the first and last vertices will be connected.\n   * When CLOSE mode is used for splines (with `splineVeertex()`), the shape is ended smoothly.\n   *\n   * \n   * The second parameter, `count`, is also optional. In WebGL mode, it’s more\n   * efficient to draw many copies of the same shape using a technique called\n   * <a href=\"https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html\" target=\"_blank\">instancing</a>.\n   * The `count` parameter tells WebGL mode how many copies to draw. For\n   * example, calling `endShape(CLOSE, 400)` after drawing a custom shape will\n   * make it efficient to draw 400 copies. This feature requires\n   * <a href=\"https://p5js.org/tutorials/intro-to-shaders/\" target=\"_blank\">writing a custom shader</a>.\n   *\n   * After calling <a href=\"#/p5/beginShape\">beginShape()</a>, shapes can be\n   * built by calling <a href=\"#/p5/vertex\">vertex()</a>,\n   * <a href=\"#/p5/bezierVertex\">bezierVertex()</a> and/or\n   * <a href=\"#/p5/splineVertex\">splineVertex()</a>. Calling\n   * `endShape()` will stop adding vertices to the\n   * shape. Each shape will be outlined with the current stroke color and filled\n   * with the current fill color.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and\n   * <a href=\"#/p5/scale\">scale()</a> don't work between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()`. It's also not\n   * possible to use other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()`.\n   *\n   * @method endShape\n   * @param  {CLOSE} [mode] use CLOSE to close the shape\n   * @param  {Integer} [count] number of times you want to draw/instance the shape (for WebGL mode).\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shapes.\n   *   noFill();\n   *\n   *   // Left triangle.\n   *   beginShape();\n   *   vertex(20, 20);\n   *   vertex(45, 20);\n   *   vertex(45, 80);\n   *   endShape(CLOSE);\n   *\n   *   // Right triangle.\n   *   beginShape();\n   *   vertex(50, 20);\n   *   vertex(75, 20);\n   *   vertex(75, 80);\n   *   endShape();\n   *\n   *   describe(\n   *     'Two sets of black lines drawn on a gray background. The three lines on the left form a right triangle. The two lines on the right form a right angle.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   * \n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   * \n   *   beginShape();\n   * \n   *   splineVertex(32, 91);\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *   splineVertex(82, 91);\n   * \n   *   endShape(CLOSE);\n   * \n   *   describe(\n   *     'A curvy four-sided slightly lopsided blob.'\n   *   );\n   * }\n   * </div>\n   * </code>\n   *\n   * <div>\n   * <code>\n   * // Note: A \"uniform\" is a global variable within a shader program.\n   *\n   * // Create a string with the vertex shader program.\n   * // The vertex shader is called for each vertex.\n   * let vertSrc = `#version 300 es\n   *\n   * precision mediump float;\n   *\n   * in vec3 aPosition;\n   * flat out int instanceID;\n   *\n   * uniform mat4 uModelViewMatrix;\n   * uniform mat4 uProjectionMatrix;\n   *\n   * void main() {\n   *\n   *   // Copy the instance ID to the fragment shader.\n   *   instanceID = gl_InstanceID;\n   *   vec4 positionVec4 = vec4(aPosition, 1.0);\n   *\n   *   // gl_InstanceID represents a numeric value for each instance.\n   *   // Using gl_InstanceID allows us to move each instance separately.\n   *   // Here we move each instance horizontally by ID * 23.\n   *   float xOffset = float(gl_InstanceID) * 23.0;\n   *\n   *   // Apply the offset to the final position.\n   *   gl_Position = uProjectionMatrix * uModelViewMatrix * (positionVec4 -\n   *     vec4(xOffset, 0.0, 0.0, 0.0));\n   * }\n   * `;\n   *\n   * // Create a string with the fragment shader program.\n   * // The fragment shader is called for each pixel.\n   * let fragSrc = `#version 300 es\n   *\n   * precision mediump float;\n   *\n   * out vec4 outColor;\n   * flat in int instanceID;\n   * uniform float numInstances;\n   *\n   * void main() {\n   *   vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n   *   vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n   *\n   *   // Normalize the instance ID.\n   *   float normId = float(instanceID) / numInstances;\n   *\n   *   // Mix between two colors using the normalized instance ID.\n   *   outColor = mix(red, blue, normId);\n   * }\n   * `;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Shader object.\n   *   let myShader = createShader(vertSrc, fragSrc);\n   *\n   *   background(220);\n   *\n   *   // Compile and apply the p5.Shader.\n   *   shader(myShader);\n   *\n   *   // Set the numInstances uniform.\n   *   myShader.setUniform('numInstances', 4);\n   *\n   *   // Translate the origin to help align the drawing.\n   *   translate(25, -10);\n   *\n   *   // Style the shapes.\n   *   noStroke();\n   *\n   *   // Draw the shapes.\n   *   beginShape();\n   *   vertex(0, 0);\n   *   vertex(0, 20);\n   *   vertex(20, 20);\n   *   vertex(20, 0);\n   *   vertex(0, 0);\n   *   endShape(CLOSE, 4);\n   *\n   *   describe('A row of four squares. Their colors transition from purple on the left to red on the right');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.endShape = function (mode, count = 1) {\n    // p5._validateParameters('endShape', arguments);\n    if (count < 1) {\n      console.log('🌸 p5.js says: You can not have less than one instance');\n      count = 1;\n    }\n    this._renderer.endShape(mode, count);\n  };\n\n  /**\n   * Sets the normal vector for vertices in a custom 3D shape.\n   *\n   * 3D shapes created with <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> are made by connecting sets of\n   * points called vertices. Each vertex added with\n   * <a href=\"#/p5/vertex\">vertex()</a> has a normal vector that points away\n   * from it. The normal vector controls how light reflects off the shape.\n   *\n   * `normal()` can be called two ways with different parameters to define the\n   * normal vector's components.\n   *\n   * The first way to call `normal()` has three parameters, `x`, `y`, and `z`.\n   * If `Number`s are passed, as in `normal(1, 2, 3)`, they set the x-, y-, and\n   * z-components of the normal vector.\n   *\n   * The second way to call `normal()` has one parameter, `vector`. If a\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object is passed, as in\n   * `normal(myVector)`, its components will be used to set the normal vector.\n   *\n   * `normal()` changes the normal vector of vertices added to a custom shape\n   * with <a href=\"#/p5/vertex\">vertex()</a>. `normal()` must be called between\n   * the <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions, just like\n   * <a href=\"#/p5/vertex\">vertex()</a>. The normal vector set by calling\n   * `normal()` will affect all following vertices until `normal()` is called\n   * again:\n   *\n   * ```js\n   * beginShape();\n   *\n   * // Set the vertex normal.\n   * normal(-0.4, -0.4, 0.8);\n   *\n   * // Add a vertex.\n   * vertex(-30, -30, 0);\n   *\n   * // Set the vertex normal.\n   * normal(0, 0, 1);\n   *\n   * // Add vertices.\n   * vertex(30, -30, 0);\n   * vertex(30, 30, 0);\n   *\n   * // Set the vertex normal.\n   * normal(0.4, -0.4, 0.8);\n   *\n   * // Add a vertex.\n   * vertex(-30, 30, 0);\n   *\n   * endShape();\n   * ```\n   *\n   * @method normal\n   * @param  {p5.Vector} vector vertex normal as a <a href=\"#/p5.Vector\">p5.Vector</a> object.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Draw the shape.\n   *   beginShape();\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Draw the shape.\n   *   // Use normal() to set vertex normals.\n   *   beginShape();\n   *   normal(-0.4, -0.4, 0.8);\n   *   vertex(-30, -30, 0);\n   *\n   *   normal(0, 0, 1);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *\n   *   normal(0.4, -0.4, 0.8);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div class='notest'>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Create p5.Vector objects.\n   *   let n1 = createVector(-0.4, -0.4, 0.8);\n   *   let n2 = createVector(0, 0, 1);\n   *   let n3 = createVector(0.4, -0.4, 0.8);\n   *\n   *   // Draw the shape.\n   *   // Use normal() to set vertex normals.\n   *   beginShape();\n   *   normal(n1);\n   *   vertex(-30, -30, 0);\n   *\n   *   normal(n2);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *\n   *   normal(n3);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method normal\n   * @param  {Number} x x-component of the vertex normal.\n   * @param  {Number} y y-component of the vertex normal.\n   * @param  {Number} z z-component of the vertex normal.\n   * @chainable\n   */\n  fn.normal = function (x, y, z) {\n    this._assert3d('normal');\n    // p5._validateParameters('normal', arguments);\n    this._renderer.normal(...arguments);\n    return this;\n  };\n\n  /**\n   * Sets the shader's vertex property or attribute variables.\n   *\n   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some\n   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are\n   * set using <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/normal\">normal()</a>\n   * and <a href=\"#/p5/fill\">fill()</a> respectively. Custom properties can also\n   * be defined within <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * The first parameter, `propertyName`, is a string with the property's name.\n   * This is the same variable name which should be declared in the shader, such as\n   * `in vec3 aProperty`, similar to .`setUniform()`.\n   *\n   * The second parameter, `data`, is the value assigned to the shader variable. This\n   * value will be applied to subsequent vertices created with\n   * <a href=\"#/p5/vertex\">vertex()</a>. It can be a Number or an array of numbers,\n   * and in the shader program the type can be declared according to the WebGL\n   * specification. Common types include `float`, `vec2`, `vec3`, `vec4` or matrices.\n   *\n   * See also the <a href=\"#/p5/vertexProperty\">vertexProperty()</a> method on\n   * <a href=\"#/p5/Geometry\">Geometry</a> objects.\n   *\n   * @method vertexProperty\n   * @for p5\n   * @param {String} attributeName the name of the vertex attribute.\n   * @param {Number|Number[]} data the data tied to the vertex attribute.\n   *\n   * @example\n   * <div>\n   * <code>\n   * const vertSrc = `#version 300 es\n   *  precision mediump float;\n   *  uniform mat4 uModelViewMatrix;\n   *  uniform mat4 uProjectionMatrix;\n   *\n   *  in vec3 aPosition;\n   *  in vec2 aOffset;\n   *\n   *  void main(){\n   *    vec4 positionVec4 = vec4(aPosition.xyz, 1.0);\n   *    positionVec4.xy += aOffset;\n   *    gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n   *  }\n   * `;\n   *\n   * const fragSrc = `#version 300 es\n   *  precision mediump float;\n   *  out vec4 outColor;\n   *  void main(){\n   *    outColor = vec4(0.0, 1.0, 1.0, 1.0);\n   *  }\n   * `;\n   *\n   * function setup(){\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create and use the custom shader.\n   *   const myShader = createShader(vertSrc, fragSrc);\n   *   shader(myShader);\n   *\n   *   describe('A wobbly, cyan circle on a gray background.');\n   * }\n   *\n   * function draw(){\n   *   // Set the styles\n   *   background(125);\n   *   noStroke();\n   *\n   *   // Draw the circle.\n   *   beginShape();\n   *   for (let i = 0; i < 30; i++){\n   *     const x = 40 * cos(i/30 * TWO_PI);\n   *     const y = 40 * sin(i/30 * TWO_PI);\n   *\n   *     // Apply some noise to the coordinates.\n   *     const xOff = 10 * noise(x + millis()/1000) - 5;\n   *     const yOff = 10 * noise(y + millis()/1000) - 5;\n   *\n   *     // Apply these noise values to the following vertex.\n   *     vertexProperty('aOffset', [xOff, yOff]);\n   *     vertex(x, y);\n   *   }\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let myShader;\n   * const cols = 10;\n   * const rows = 10;\n   * const cellSize = 6;\n   *\n   * const vertSrc = `#version 300 es\n   *   precision mediump float;\n   *   uniform mat4 uProjectionMatrix;\n   *   uniform mat4 uModelViewMatrix;\n   *\n   *   in vec3 aPosition;\n   *   in vec3 aNormal;\n   *   in vec3 aVertexColor;\n   *   in float aDistance;\n   *\n   *   out vec3 vVertexColor;\n   *\n   *   void main(){\n   *     vec4 positionVec4 = vec4(aPosition, 1.0);\n   *     positionVec4.xyz += aDistance * aNormal * 2.0;;\n   *     vVertexColor = aVertexColor;\n   *     gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n   *   }\n   * `;\n   *\n   * const fragSrc = `#version 300 es\n   *   precision mediump float;\n   *\n   *   in vec3 vVertexColor;\n   *   out vec4 outColor;\n   *\n   *   void main(){\n   *     outColor = vec4(vVertexColor, 1.0);\n   *   }\n   * `;\n   *\n   * function setup(){\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create and apply the custom shader.\n   *   myShader = createShader(vertSrc, fragSrc);\n   *   shader(myShader);\n   *   noStroke();\n   *   describe('A blue grid, which moves away from the mouse position, on a gray background.');\n   * }\n   *\n   * function draw(){\n   *   background(200);\n   *\n   *   // Draw the grid in the middle of the screen.\n   *   translate(-cols*cellSize/2, -rows*cellSize/2);\n   *   beginShape(QUADS);\n   *   for (let i = 0; i < cols; i++) {\n   *     for (let j = 0; j < rows; j++) {\n   *\n   *       // Calculate the cell position.\n   *       let x = i * cellSize;\n   *       let y = j * cellSize;\n   *\n   *       fill(j/rows*255, j/cols*255, 255);\n   *\n   *       // Calculate the distance from the corner of each cell to the mouse.\n   *       let distance = dist(x, y, mouseX, mouseY);\n   *\n   *       // Send the distance to the shader.\n   *       vertexProperty('aDistance', min(distance, 100));\n   *\n   *       vertex(x, y);\n   *       vertex(x + cellSize, y);\n   *       vertex(x + cellSize, y + cellSize);\n   *       vertex(x, y + cellSize);\n   *     }\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  fn.vertexProperty = function (attributeName, data) {\n    // this._assert3d('vertexProperty');\n    // p5._validateParameters('vertexProperty', arguments);\n    this._renderer.vertexProperty(attributeName, data);\n  };\n}\nif (typeof p5 !== 'undefined') {\n  vertex(p5, p5.prototype);\n}\nexport { vertex as default };","map":{"version":3,"names":["vertex","p5","fn","beginShape","kind","_renderer","arguments","bezierVertex","args","endShape","mode","count","console","log","normal","x","y","z","_assert3d","vertexProperty","attributeName","data","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/shape/vertex.js"],"sourcesContent":["/**\n * @module Shape\n * @submodule Custom Shapes\n * @for p5\n * @requires core\n * @requires constants\n */\n\n\nfunction vertex(p5, fn){\n  /**\n   * Begins adding vertices to a custom shape.\n   *\n   * The `beginShape()` and <a href=\"#/p5/endShape\">endShape()</a> functions\n   * allow for creating custom shapes in 2D or 3D. `beginShape()` begins adding\n   * vertices to a custom shape and <a href=\"#/p5/endShape\">endShape()</a> stops\n   * adding them.\n   *\n   * The parameter, `kind`, sets the kind of shape to make. The available kinds are:\n   *\n   * - `PATH` (the default) to draw shapes by tracing out the path along their edges.\n   * - `POINTS` to draw a series of points.\n   * - `LINES` to draw a series of unconnected line segments.\n   * - `TRIANGLES` to draw a series of separate triangles.\n   * - `TRIANGLE_FAN` to draw a series of connected triangles sharing the first vertex in a fan-like fashion.\n   * - `TRIANGLE_STRIP` to draw a series of connected triangles in strip fashion.\n   * - `QUADS` to draw a series of separate quadrilaterals (quads).\n   * - `QUAD_STRIP` to draw quad strip using adjacent edges to form the next quad.\n   *\n   * After calling `beginShape()`, shapes can be built by calling\n   * <a href=\"#/p5/vertex\">vertex()</a>,\n   * <a href=\"#/p5/bezierVertex\">bezierVertex()</a>, and/or\n   * <a href=\"#/p5/splineVertex\">splineVertex()</a>. Calling\n   * <a href=\"#/p5/endShape\">endShape()</a> will stop adding vertices to the\n   * shape. Each shape will be outlined with the current stroke color and filled\n   * with the current fill color.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and\n   * <a href=\"#/p5/scale\">scale()</a> don't work between `beginShape()` and\n   * <a href=\"#/p5/endShape\">endShape()</a>. It's also not possible to use\n   * other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between `beginShape()` and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * @method beginShape\n   * @param  {(POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH)} [kind=PATH] either POINTS, LINES, TRIANGLES, TRIANGLE_FAN\n   *                                TRIANGLE_STRIP, QUADS, QUAD_STRIP or PATH. Defaults to PATH.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw the vertices (points).\n   *   beginShape(POINTS);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four black dots that form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw lines between alternating pairs of vertices.\n   *   beginShape(LINES);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two horizontal black lines on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Three black lines form a sideways U shape on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   *\n   *   describe('A black outline of a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles.\n   *   beginShape(TRIANGLES);\n   *\n   *   // Left triangle.\n   *   vertex(30, 75);\n   *   vertex(40, 20);\n   *   vertex(50, 75);\n   *\n   *   // Right triangle.\n   *   vertex(60, 20);\n   *   vertex(70, 75);\n   *   vertex(80, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two white triangles drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles.\n   *   beginShape(TRIANGLE_STRIP);\n   *\n   *   // Add vertices.\n   *   vertex(30, 75);\n   *   vertex(40, 20);\n   *   vertex(50, 75);\n   *   vertex(60, 20);\n   *   vertex(70, 75);\n   *   vertex(80, 20);\n   *   vertex(90, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Five white triangles that are interleaved drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles that share their first vertex.\n   *   beginShape(TRIANGLE_FAN);\n   *\n   *   // Add vertices.\n   *   vertex(57.5, 50);\n   *   vertex(57.5, 15);\n   *   vertex(92, 50);\n   *   vertex(57.5, 85);\n   *   vertex(22, 50);\n   *   vertex(57.5, 15);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four white triangles form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(QUADS);\n   *\n   *   // Left rectangle.\n   *   vertex(30, 20);\n   *   vertex(30, 75);\n   *   vertex(50, 75);\n   *   vertex(50, 20);\n   *\n   *   // Right rectangle.\n   *   vertex(65, 20);\n   *   vertex(65, 75);\n   *   vertex(85, 75);\n   *   vertex(85, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two white rectangles drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(QUAD_STRIP);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(30, 75);\n   *   vertex(50, 20);\n   *   vertex(50, 75);\n   *   vertex(65, 20);\n   *   vertex(65, 75);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Three white rectangles that share edges are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(PATH);\n   *\n   *   // Add the vertices.\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, -10, 0);\n   *   vertex(-10, -10, 0);\n   *   vertex(-10, 10, 0);\n   *   vertex(30, 10, 0);\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   *\n   *   describe('A blocky C shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag with the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A blocky C shape drawn in red, blue, and green on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(PATH);\n   *\n   *   // Add the vertices.\n   *   fill('red');\n   *   stroke('red');\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, -10, 0);\n   *   fill('green');\n   *   stroke('green');\n   *   vertex(-10, -10, 0);\n   *   vertex(-10, 10, 0);\n   *   vertex(30, 10, 0);\n   *   fill('blue');\n   *   stroke('blue');\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.beginShape = function(kind) {\n    // p5._validateParameters('beginShape', arguments);\n    this._renderer.beginShape(...arguments);\n  };\n\n  /**\n   * Adds a Bézier curve segment to a custom shape.\n   *\n   * `bezierVertex()` adds a curved segment to custom shapes. The Bézier curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/bezier\">bezier()</a> function. `bezierVertex()` must be\n   * called between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   * Bézier need a starting point. Building a shape\n   * only with Bézier curves needs one initial\n   * call to <a href=\"#/p5/vertex\">bezierVertex()</a>, before\n   * a number of `bezierVertex()` calls that is a multiple of the parameter\n   * set by <a href=\"#/p5/bezierOrder\">bezierOrder(...)</a> (default 3).\n   * But shapes can mix different types of vertices, so if there\n   * are some previous vertices, then the initial anchor is not needed, \n   * only the multiples of 3 (or the Bézier order) calls to \n   *  `bezierVertex` for each curve.\n   * \n   * Each curve of order 3 requires three calls to `bezierVertex`, so\n   * 2 curves would need 7 calls to `bezierVertex()`:\n   * (1 one initial anchor point, two sets of 3 curves describing the curves)\n   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2. \n   *\n   * Bézier curves can also be drawn in 3D using WebGL mode.\n   *\n   * Note: `bezierVertex()` won’t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method bezierVertex\n   * @param  {Number} x x-coordinate of the first control point.\n   * @param  {Number} y y-coordinate of the first control point.\n   * @param  {Number} [u]\n   * @param  {Number} [v]\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertex.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A black C curve on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(30, 20);\n   *   point(30, 75);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(80, 0);\n   *   point(80, 75);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertex.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(30, 20, 80, 0);\n   *   line(30, 75, 80, 75);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the mouse near the red dot in the top-right corner\n   * // and drag to change the curve's shape.\n   *\n   * let x2 = 80;\n   * let y2 = 0;\n   * let isChanging = false;\n   *\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(30, 20);\n   *   point(30, 75);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(x2, y2);\n   *   point(80, 75);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertex.\n   *   bezierVertex(x2, y2);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(30, 20, x2, y2);\n   *   line(30, 75, 80, 75);\n   * }\n   *\n   * // Start changing the first control point if the user clicks near it.\n   * function mousePressed() {\n   *   if (dist(mouseX, mouseY, x2, y2) < 20) {\n   *     isChanging = true;\n   *   }\n   * }\n   *\n   * // Stop changing the first control point when the user releases the mouse.\n   * function mouseReleased() {\n   *   isChanging = false;\n   * }\n   *\n   * // Update the first control point while the user drags the mouse.\n   * function mouseDragged() {\n   *   if (isChanging === true) {\n   *     x2 = mouseX;\n   *     y2 = mouseY;\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the Bézier vertices.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   * \n   *   bezierVertex(50, 80);\n   *   bezierVertex(60, 25);\n   *   bezierVertex(30, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A crescent moon shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A crescent moon shape drawn in white on a blue background. When the user drags the mouse, the scene rotates and a second moon is revealed.');\n   * }\n   *\n   * function draw() {\n   *   background('midnightblue');\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the moons.\n   *   noStroke();\n   *   fill('lemonchiffon');\n   *\n   *   // Draw the first moon.\n   *   beginShape();\n   *   bezierVertex(-20, -30, 0);\n   * \n   *   bezierVertex(30, -50, 0);\n   *   bezierVertex(30, 25, 0);\n   *   bezierVertex(-20, 25, 0);\n   * \n   *   bezierVertex(0, 30, 0);\n   *   bezierVertex(10, -25, 0);\n   *   bezierVertex(-20, -30, 0);\n   *   endShape();\n   *\n   *   // Draw the second moon.\n   *   beginShape();\n   * \n   *   bezierVertex(-20, -30, -20);\n   * \n   *   bezierVertex(30, -50, -20);\n   *   bezierVertex(30, 25, -20);\n   *   bezierVertex(-20, 25, -20);\n   * \n   *   bezierVertex(0, 30, -20);\n   *   bezierVertex(10, -25, -20);\n   *   bezierVertex(-20, -30, -20);\n   * \n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method bezierVertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} z\n   * @param  {Number} [u]\n   * @param  {Number} [v]\n   */\n  fn.bezierVertex = function(...args) {\n    this._renderer.bezierVertex(...args);\n  };\n\n  /**\n   * Concludes the vertices of a custom shape. \n   * \n   * The <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()` functions\n   * allow for creating custom shapes in 2D or 3D.\n   * <a href=\"#/p5/beginShape\">beginShape()</a> begins adding vertices to a\n   * custom shape and `endShape()` stops adding them.\n   *\n   * The first parameter, `mode`, is optional. By default, the first and last\n   * vertices of a shape aren't connected. If the constant `CLOSE` is passed, as\n   * in `endShape(CLOSE)`, then the first and last vertices will be connected.\n   * When CLOSE mode is used for splines (with `splineVeertex()`), the shape is ended smoothly.\n   *\n   * \n   * The second parameter, `count`, is also optional. In WebGL mode, it’s more\n   * efficient to draw many copies of the same shape using a technique called\n   * <a href=\"https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html\" target=\"_blank\">instancing</a>.\n   * The `count` parameter tells WebGL mode how many copies to draw. For\n   * example, calling `endShape(CLOSE, 400)` after drawing a custom shape will\n   * make it efficient to draw 400 copies. This feature requires\n   * <a href=\"https://p5js.org/tutorials/intro-to-shaders/\" target=\"_blank\">writing a custom shader</a>.\n   *\n   * After calling <a href=\"#/p5/beginShape\">beginShape()</a>, shapes can be\n   * built by calling <a href=\"#/p5/vertex\">vertex()</a>,\n   * <a href=\"#/p5/bezierVertex\">bezierVertex()</a> and/or\n   * <a href=\"#/p5/splineVertex\">splineVertex()</a>. Calling\n   * `endShape()` will stop adding vertices to the\n   * shape. Each shape will be outlined with the current stroke color and filled\n   * with the current fill color.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and\n   * <a href=\"#/p5/scale\">scale()</a> don't work between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()`. It's also not\n   * possible to use other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()`.\n   *\n   * @method endShape\n   * @param  {CLOSE} [mode] use CLOSE to close the shape\n   * @param  {Integer} [count] number of times you want to draw/instance the shape (for WebGL mode).\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shapes.\n   *   noFill();\n   *\n   *   // Left triangle.\n   *   beginShape();\n   *   vertex(20, 20);\n   *   vertex(45, 20);\n   *   vertex(45, 80);\n   *   endShape(CLOSE);\n   *\n   *   // Right triangle.\n   *   beginShape();\n   *   vertex(50, 20);\n   *   vertex(75, 20);\n   *   vertex(75, 80);\n   *   endShape();\n   *\n   *   describe(\n   *     'Two sets of black lines drawn on a gray background. The three lines on the left form a right triangle. The two lines on the right form a right angle.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   * \n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   * \n   *   beginShape();\n   * \n   *   splineVertex(32, 91);\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *   splineVertex(82, 91);\n   * \n   *   endShape(CLOSE);\n   * \n   *   describe(\n   *     'A curvy four-sided slightly lopsided blob.'\n   *   );\n   * }\n   * </div>\n   * </code>\n   *\n   * <div>\n   * <code>\n   * // Note: A \"uniform\" is a global variable within a shader program.\n   *\n   * // Create a string with the vertex shader program.\n   * // The vertex shader is called for each vertex.\n   * let vertSrc = `#version 300 es\n   *\n   * precision mediump float;\n   *\n   * in vec3 aPosition;\n   * flat out int instanceID;\n   *\n   * uniform mat4 uModelViewMatrix;\n   * uniform mat4 uProjectionMatrix;\n   *\n   * void main() {\n   *\n   *   // Copy the instance ID to the fragment shader.\n   *   instanceID = gl_InstanceID;\n   *   vec4 positionVec4 = vec4(aPosition, 1.0);\n   *\n   *   // gl_InstanceID represents a numeric value for each instance.\n   *   // Using gl_InstanceID allows us to move each instance separately.\n   *   // Here we move each instance horizontally by ID * 23.\n   *   float xOffset = float(gl_InstanceID) * 23.0;\n   *\n   *   // Apply the offset to the final position.\n   *   gl_Position = uProjectionMatrix * uModelViewMatrix * (positionVec4 -\n   *     vec4(xOffset, 0.0, 0.0, 0.0));\n   * }\n   * `;\n   *\n   * // Create a string with the fragment shader program.\n   * // The fragment shader is called for each pixel.\n   * let fragSrc = `#version 300 es\n   *\n   * precision mediump float;\n   *\n   * out vec4 outColor;\n   * flat in int instanceID;\n   * uniform float numInstances;\n   *\n   * void main() {\n   *   vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n   *   vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n   *\n   *   // Normalize the instance ID.\n   *   float normId = float(instanceID) / numInstances;\n   *\n   *   // Mix between two colors using the normalized instance ID.\n   *   outColor = mix(red, blue, normId);\n   * }\n   * `;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Shader object.\n   *   let myShader = createShader(vertSrc, fragSrc);\n   *\n   *   background(220);\n   *\n   *   // Compile and apply the p5.Shader.\n   *   shader(myShader);\n   *\n   *   // Set the numInstances uniform.\n   *   myShader.setUniform('numInstances', 4);\n   *\n   *   // Translate the origin to help align the drawing.\n   *   translate(25, -10);\n   *\n   *   // Style the shapes.\n   *   noStroke();\n   *\n   *   // Draw the shapes.\n   *   beginShape();\n   *   vertex(0, 0);\n   *   vertex(0, 20);\n   *   vertex(20, 20);\n   *   vertex(20, 0);\n   *   vertex(0, 0);\n   *   endShape(CLOSE, 4);\n   *\n   *   describe('A row of four squares. Their colors transition from purple on the left to red on the right');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.endShape = function(mode, count = 1) {\n    // p5._validateParameters('endShape', arguments);\n    if (count < 1) {\n      console.log('🌸 p5.js says: You can not have less than one instance');\n      count = 1;\n    }\n\n    this._renderer.endShape(mode, count);\n  };\n\n  /**\n   * Sets the normal vector for vertices in a custom 3D shape.\n   *\n   * 3D shapes created with <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> are made by connecting sets of\n   * points called vertices. Each vertex added with\n   * <a href=\"#/p5/vertex\">vertex()</a> has a normal vector that points away\n   * from it. The normal vector controls how light reflects off the shape.\n   *\n   * `normal()` can be called two ways with different parameters to define the\n   * normal vector's components.\n   *\n   * The first way to call `normal()` has three parameters, `x`, `y`, and `z`.\n   * If `Number`s are passed, as in `normal(1, 2, 3)`, they set the x-, y-, and\n   * z-components of the normal vector.\n   *\n   * The second way to call `normal()` has one parameter, `vector`. If a\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object is passed, as in\n   * `normal(myVector)`, its components will be used to set the normal vector.\n   *\n   * `normal()` changes the normal vector of vertices added to a custom shape\n   * with <a href=\"#/p5/vertex\">vertex()</a>. `normal()` must be called between\n   * the <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions, just like\n   * <a href=\"#/p5/vertex\">vertex()</a>. The normal vector set by calling\n   * `normal()` will affect all following vertices until `normal()` is called\n   * again:\n   *\n   * ```js\n   * beginShape();\n   *\n   * // Set the vertex normal.\n   * normal(-0.4, -0.4, 0.8);\n   *\n   * // Add a vertex.\n   * vertex(-30, -30, 0);\n   *\n   * // Set the vertex normal.\n   * normal(0, 0, 1);\n   *\n   * // Add vertices.\n   * vertex(30, -30, 0);\n   * vertex(30, 30, 0);\n   *\n   * // Set the vertex normal.\n   * normal(0.4, -0.4, 0.8);\n   *\n   * // Add a vertex.\n   * vertex(-30, 30, 0);\n   *\n   * endShape();\n   * ```\n   *\n   * @method normal\n   * @param  {p5.Vector} vector vertex normal as a <a href=\"#/p5.Vector\">p5.Vector</a> object.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Draw the shape.\n   *   beginShape();\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Draw the shape.\n   *   // Use normal() to set vertex normals.\n   *   beginShape();\n   *   normal(-0.4, -0.4, 0.8);\n   *   vertex(-30, -30, 0);\n   *\n   *   normal(0, 0, 1);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *\n   *   normal(0.4, -0.4, 0.8);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div class='notest'>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Create p5.Vector objects.\n   *   let n1 = createVector(-0.4, -0.4, 0.8);\n   *   let n2 = createVector(0, 0, 1);\n   *   let n3 = createVector(0.4, -0.4, 0.8);\n   *\n   *   // Draw the shape.\n   *   // Use normal() to set vertex normals.\n   *   beginShape();\n   *   normal(n1);\n   *   vertex(-30, -30, 0);\n   *\n   *   normal(n2);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *\n   *   normal(n3);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method normal\n   * @param  {Number} x x-component of the vertex normal.\n   * @param  {Number} y y-component of the vertex normal.\n   * @param  {Number} z z-component of the vertex normal.\n   * @chainable\n   */\n  fn.normal = function(x, y, z) {\n    this._assert3d('normal');\n    // p5._validateParameters('normal', arguments);\n    this._renderer.normal(...arguments);\n\n    return this;\n  };\n\n  /**\n   * Sets the shader's vertex property or attribute variables.\n   *\n   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some\n   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are\n   * set using <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/normal\">normal()</a>\n   * and <a href=\"#/p5/fill\">fill()</a> respectively. Custom properties can also\n   * be defined within <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * The first parameter, `propertyName`, is a string with the property's name.\n   * This is the same variable name which should be declared in the shader, such as\n   * `in vec3 aProperty`, similar to .`setUniform()`.\n   *\n   * The second parameter, `data`, is the value assigned to the shader variable. This\n   * value will be applied to subsequent vertices created with\n   * <a href=\"#/p5/vertex\">vertex()</a>. It can be a Number or an array of numbers,\n   * and in the shader program the type can be declared according to the WebGL\n   * specification. Common types include `float`, `vec2`, `vec3`, `vec4` or matrices.\n   *\n   * See also the <a href=\"#/p5/vertexProperty\">vertexProperty()</a> method on\n   * <a href=\"#/p5/Geometry\">Geometry</a> objects.\n   *\n   * @method vertexProperty\n   * @for p5\n   * @param {String} attributeName the name of the vertex attribute.\n   * @param {Number|Number[]} data the data tied to the vertex attribute.\n   *\n   * @example\n   * <div>\n   * <code>\n   * const vertSrc = `#version 300 es\n   *  precision mediump float;\n   *  uniform mat4 uModelViewMatrix;\n   *  uniform mat4 uProjectionMatrix;\n   *\n   *  in vec3 aPosition;\n   *  in vec2 aOffset;\n   *\n   *  void main(){\n   *    vec4 positionVec4 = vec4(aPosition.xyz, 1.0);\n   *    positionVec4.xy += aOffset;\n   *    gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n   *  }\n   * `;\n   *\n   * const fragSrc = `#version 300 es\n   *  precision mediump float;\n   *  out vec4 outColor;\n   *  void main(){\n   *    outColor = vec4(0.0, 1.0, 1.0, 1.0);\n   *  }\n   * `;\n   *\n   * function setup(){\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create and use the custom shader.\n   *   const myShader = createShader(vertSrc, fragSrc);\n   *   shader(myShader);\n   *\n   *   describe('A wobbly, cyan circle on a gray background.');\n   * }\n   *\n   * function draw(){\n   *   // Set the styles\n   *   background(125);\n   *   noStroke();\n   *\n   *   // Draw the circle.\n   *   beginShape();\n   *   for (let i = 0; i < 30; i++){\n   *     const x = 40 * cos(i/30 * TWO_PI);\n   *     const y = 40 * sin(i/30 * TWO_PI);\n   *\n   *     // Apply some noise to the coordinates.\n   *     const xOff = 10 * noise(x + millis()/1000) - 5;\n   *     const yOff = 10 * noise(y + millis()/1000) - 5;\n   *\n   *     // Apply these noise values to the following vertex.\n   *     vertexProperty('aOffset', [xOff, yOff]);\n   *     vertex(x, y);\n   *   }\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let myShader;\n   * const cols = 10;\n   * const rows = 10;\n   * const cellSize = 6;\n   *\n   * const vertSrc = `#version 300 es\n   *   precision mediump float;\n   *   uniform mat4 uProjectionMatrix;\n   *   uniform mat4 uModelViewMatrix;\n   *\n   *   in vec3 aPosition;\n   *   in vec3 aNormal;\n   *   in vec3 aVertexColor;\n   *   in float aDistance;\n   *\n   *   out vec3 vVertexColor;\n   *\n   *   void main(){\n   *     vec4 positionVec4 = vec4(aPosition, 1.0);\n   *     positionVec4.xyz += aDistance * aNormal * 2.0;;\n   *     vVertexColor = aVertexColor;\n   *     gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n   *   }\n   * `;\n   *\n   * const fragSrc = `#version 300 es\n   *   precision mediump float;\n   *\n   *   in vec3 vVertexColor;\n   *   out vec4 outColor;\n   *\n   *   void main(){\n   *     outColor = vec4(vVertexColor, 1.0);\n   *   }\n   * `;\n   *\n   * function setup(){\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create and apply the custom shader.\n   *   myShader = createShader(vertSrc, fragSrc);\n   *   shader(myShader);\n   *   noStroke();\n   *   describe('A blue grid, which moves away from the mouse position, on a gray background.');\n   * }\n   *\n   * function draw(){\n   *   background(200);\n   *\n   *   // Draw the grid in the middle of the screen.\n   *   translate(-cols*cellSize/2, -rows*cellSize/2);\n   *   beginShape(QUADS);\n   *   for (let i = 0; i < cols; i++) {\n   *     for (let j = 0; j < rows; j++) {\n   *\n   *       // Calculate the cell position.\n   *       let x = i * cellSize;\n   *       let y = j * cellSize;\n   *\n   *       fill(j/rows*255, j/cols*255, 255);\n   *\n   *       // Calculate the distance from the corner of each cell to the mouse.\n   *       let distance = dist(x, y, mouseX, mouseY);\n   *\n   *       // Send the distance to the shader.\n   *       vertexProperty('aDistance', min(distance, 100));\n   *\n   *       vertex(x, y);\n   *       vertex(x + cellSize, y);\n   *       vertex(x + cellSize, y + cellSize);\n   *       vertex(x, y + cellSize);\n   *     }\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  fn.vertexProperty = function(attributeName, data){\n    // this._assert3d('vertexProperty');\n    // p5._validateParameters('vertexProperty', arguments);\n    this._renderer.vertexProperty(attributeName, data);\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  vertex(p5, p5.prototype);\n}\n\nexport { vertex as default };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASA,MAAMA,CAACC,EAAE,EAAEC,EAAE,EAAC;EACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEA,EAAE,CAACC,UAAU,GAAG,UAASC,IAAI,EAAE;IAC7B;IACA,IAAI,CAACC,SAAS,CAACF,UAAU,CAAC,GAAGG,SAAS,CAAC;EACzC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEJ,EAAE,CAACK,YAAY,GAAG,UAAS,GAAGC,IAAI,EAAE;IAClC,IAAI,CAACH,SAAS,CAACE,YAAY,CAAC,GAAGC,IAAI,CAAC;EACtC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEN,EAAE,CAACO,QAAQ,GAAG,UAASC,IAAI,EAAEC,KAAK,GAAG,CAAC,EAAE;IACtC;IACA,IAAIA,KAAK,GAAG,CAAC,EAAE;MACbC,OAAO,CAACC,GAAG,CAAC,wDAAwD,CAAC;MACrEF,KAAK,GAAG,CAAC;IACX;IAEA,IAAI,CAACN,SAAS,CAACI,QAAQ,CAACC,IAAI,EAAEC,KAAK,CAAC;EACtC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;EACET,EAAE,CAACY,MAAM,GAAG,UAASC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IAC5B,IAAI,CAACC,SAAS,CAAC,QAAQ,CAAC;IACxB;IACA,IAAI,CAACb,SAAS,CAACS,MAAM,CAAC,GAAGR,SAAS,CAAC;IAEnC,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEJ,EAAE,CAACiB,cAAc,GAAG,UAASC,aAAa,EAAEC,IAAI,EAAC;IAC/C;IACA;IACA,IAAI,CAAChB,SAAS,CAACc,cAAc,CAACC,aAAa,EAAEC,IAAI,CAAC;EACpD,CAAC;AACH;AAEA,IAAG,OAAOpB,EAAE,KAAK,WAAW,EAAC;EAC3BD,MAAM,CAACC,EAAE,EAAEA,EAAE,CAACqB,SAAS,CAAC;AAC1B;AAEA,SAAStB,MAAM,IAAIuB,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}