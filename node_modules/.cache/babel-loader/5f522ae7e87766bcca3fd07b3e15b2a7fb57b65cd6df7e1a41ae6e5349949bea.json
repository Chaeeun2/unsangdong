{"ast":null,"code":"import { C as Color } from './creating_reading-Cr8L2Jnm.js';\nimport { N as NORMAL, am as WORD, an as BASELINE, ao as LEFT, C as CENTER, e as CORNER, I as INCLUDE } from './constants-BRcElHU3.js';\nimport Filters from './image/filters.js';\nimport { Vector } from './math/p5.Vector.js';\nimport { Shape } from './shape/custom_shapes.js';\nimport { States } from './core/States.js';\nimport { _checkFileExtension, downloadFile } from './io/utilities.js';\n\n/**\n * @module Image\n * @submodule Image\n * @requires core\n * @requires constants\n * @requires filters\n */\n\nclass Image {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.drawingContext = this.canvas.getContext('2d');\n    this._pixelsState = this;\n    this._pixelDensity = 1;\n    //Object for working with GIFs, defaults to null\n    this.gifProperties = null;\n    //For WebGL Texturing only: used to determine whether to reupload texture to GPU\n    this._modified = false;\n    this.pixels = [];\n  }\n\n  /**\n   * Gets or sets the pixel density for high pixel density displays.\n   *\n   * By default, the density will be set to 1.\n   *\n   * Call this method with no arguments to get the default density, or pass\n   * in a number to set the density. If a non-positive number is provided,\n   * it defaults to 1.\n   *\n   * @param {Number} [density] A scaling factor for the number of pixels per\n   * side\n   * @returns {Number} The current density if called without arguments, or the instance for chaining if setting density.\n   */\n  pixelDensity(density) {\n    if (typeof density !== 'undefined') {\n      // Setter: set the density and handle resize\n      if (density <= 0) {\n        // p5._friendlyParamError(errorObj, 'pixelDensity');\n\n        // Default to 1 in case of an invalid value\n        density = 1;\n      }\n      this._pixelDensity = density;\n\n      // Adjust canvas dimensions based on pixel density\n      this.width /= density;\n      this.height /= density;\n      return this; // Return the image instance for chaining if needed\n    } else {\n      // Getter: return the default density\n      return this._pixelDensity;\n    }\n  }\n\n  /**\n   * Helper function for animating GIF-based images with time\n   */\n  _animateGif(pInst) {\n    const props = this.gifProperties;\n    const curTime = pInst._lastRealFrameTime || window.performance.now();\n    if (props.lastChangeTime === 0) {\n      props.lastChangeTime = curTime;\n    }\n    if (props.playing) {\n      props.timeDisplayed = curTime - props.lastChangeTime;\n      const curDelay = props.frames[props.displayIndex].delay;\n      if (props.timeDisplayed >= curDelay) {\n        //GIF is bound to 'realtime' so can skip frames\n        const skips = Math.floor(props.timeDisplayed / curDelay);\n        props.timeDisplayed = 0;\n        props.lastChangeTime = curTime;\n        props.displayIndex += skips;\n        props.loopCount = Math.floor(props.displayIndex / props.numFrames);\n        if (props.loopLimit !== null && props.loopCount >= props.loopLimit) {\n          props.playing = false;\n        } else {\n          const ind = props.displayIndex % props.numFrames;\n          this.drawingContext.putImageData(props.frames[ind].image, 0, 0);\n          props.displayIndex = ind;\n          this.setModified(true);\n        }\n      }\n    }\n  }\n\n  /**\n   * Loads the current value of each pixel in the image into the `img.pixels`\n   * array.\n   *\n   * `img.loadPixels()` must be called before reading or modifying pixel\n   * values.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       img.set(x, y, 0);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 0;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   */\n  loadPixels() {\n    // Renderer2D.prototype.loadPixels.call(this);\n    const pixelsState = this._pixelsState;\n    const pd = this._pixelDensity;\n    const w = this.width * pd;\n    const h = this.height * pd;\n    const imageData = this.drawingContext.getImageData(0, 0, w, h);\n    // @todo this should actually set pixels per object, so diff buffers can\n    // have diff pixel arrays.\n    pixelsState.imageData = imageData;\n    this.pixels = pixelsState.pixels = imageData.data;\n    this.setModified(true);\n  }\n\n  /**\n   * Updates the canvas with the RGBA values in the\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a> array.\n   *\n   * `img.updatePixels()` only needs to be called after changing values in\n   * the <a href=\"#/p5.Image/pixels\">img.pixels</a> array. Such changes can be\n   * made directly after calling\n   * <a href=\"#/p5.Image/loadPixels\">img.loadPixels()</a> or by calling\n   * <a href=\"#/p5.Image/set\">img.set()</a>.\n   *\n   * The optional parameters `x`, `y`, `width`, and `height` define a\n   * subsection of the image to update. Doing so can improve performance in\n   * some cases.\n   *\n   * If the image was loaded from a GIF, then calling `img.updatePixels()`\n   * will update the pixels in current frame.\n   *\n   * @param {Integer} x x-coordinate of the upper-left corner\n   *                    of the subsection to update.\n   * @param {Integer} y y-coordinate of the upper-left corner\n   *                    of the subsection to update.\n   * @param {Integer} w width of the subsection to update.\n   * @param {Integer} h height of the subsection to update.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       img.set(x, y, 0);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 0;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   */\n  updatePixels(x, y, w, h) {\n    // Renderer2D.prototype.updatePixels.call(this, x, y, w, h);\n    const pixelsState = this._pixelsState;\n    const pd = this._pixelDensity;\n    if (x === undefined && y === undefined && w === undefined && h === undefined) {\n      x = 0;\n      y = 0;\n      w = this.width;\n      h = this.height;\n    }\n    x *= pd;\n    y *= pd;\n    w *= pd;\n    h *= pd;\n    if (this.gifProperties) {\n      this.gifProperties.frames[this.gifProperties.displayIndex].image = pixelsState.imageData;\n    }\n    this.drawingContext.putImageData(pixelsState.imageData, x, y, 0, 0, w, h);\n    this.setModified(true);\n  }\n\n  /**\n   * Gets a pixel or a region of pixels from the image.\n   *\n   * `img.get()` is easy to use but it's not as fast as\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a>. Use\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a> to read many pixel values.\n   *\n   * The version of `img.get()` with no parameters returns the entire image.\n   *\n   * The version of `img.get()` with two parameters, as in `img.get(10, 20)`,\n   * interprets them as coordinates. It returns an array with the\n   * `[R, G, B, A]` values of the pixel at the given point.\n   *\n   * The version of `img.get()` with four parameters, as in\n   * `img,get(10, 20, 50, 90)`, interprets them as\n   * coordinates and dimensions. The first two parameters are the coordinates\n   * of the upper-left corner of the subsection. The last two parameters are\n   * the width and height of the subsection. It returns a subsection of the\n   * canvas in a new <a href=\"#/p5.Image\">p5.Image</a> object.\n   *\n   * Use `img.get()` instead of <a href=\"#/p5/get\">get()</a> to work directly\n   * with images.\n   *\n   * @param  {Number}               x x-coordinate of the pixel.\n   * @param  {Number}               y y-coordinate of the pixel.\n   * @param  {Number}               w width of the subsection to be returned.\n   * @param  {Number}               h height of the subsection to be returned.\n   * @return {p5.Image}             subsection as a <a href=\"#/p5.Image\">p5.Image</a> object.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Copy the image.\n   *   let img2 = get();\n   *\n   *   // Display the copied image on the right.\n   *   image(img2, 50, 0);\n   *\n   *   describe('Two identical mountain landscapes shown side-by-side.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get a pixel's color.\n   *   let c = img.get(50, 90);\n   *\n   *   // Style the square using the pixel's color.\n   *   fill(c);\n   *   noStroke();\n   *\n   *   // Draw the square.\n   *   square(25, 25, 50);\n   *\n   *   describe('A mountain landscape with an olive green square in its center.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Copy half of the image.\n   *   let img2 = img.get(0, 0, img.width / 2, img.height / 2);\n   *\n   *   // Display half of the image.\n   *   image(img2, 50, 50);\n   *\n   *   describe('A mountain landscape drawn on top of another mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @return {p5.Image}      whole <a href=\"#/p5.Image\">p5.Image</a>\n   */\n  /**\n   * @param  {Number}        x\n   * @param  {Number}        y\n   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.\n   */\n  get(x, y, w, h) {\n    // p5._validateParameters('p5.Image.get', arguments);\n    // return Renderer2D.prototype.get.apply(this, arguments);\n    const pixelsState = this._pixelsState;\n    const pd = this._pixelDensity;\n    const canvas = this.canvas;\n    if (typeof x === 'undefined' && typeof y === 'undefined') {\n      // get()\n      x = y = 0;\n      w = pixelsState.width;\n      h = pixelsState.height;\n    } else {\n      x *= pd;\n      y *= pd;\n      if (typeof w === 'undefined' && typeof h === 'undefined') {\n        // get(x,y)\n        if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {\n          return [0, 0, 0, 0];\n        }\n        return this._getPixel(x, y);\n      }\n      // get(x,y,w,h)\n    }\n    const region = new Image(w * pd, h * pd);\n    region.pixelDensity(pd);\n    region.canvas.getContext('2d').drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);\n    return region;\n  }\n  _getPixel(x, y) {\n    let imageData, index;\n    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;\n    index = 0;\n    return [imageData[index + 0], imageData[index + 1], imageData[index + 2], imageData[index + 3]];\n    // return Renderer2D.prototype._getPixel.apply(this, args);\n  }\n\n  /**\n   * Sets the color of one or more pixels within an image.\n   *\n   * `img.set()` is easy to use but it's not as fast as\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a>. Use\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a> to set many pixel values.\n   *\n   * `img.set()` interprets the first two parameters as x- and y-coordinates. It\n   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel\n   * array, a <a href=\"#/p5.Color\">p5.Color</a> object, or another\n   * <a href=\"#/p5.Image\">p5.Image</a> object.\n   *\n   * <a href=\"#/p5.Image/updatePixels\">img.updatePixels()</a> must be called\n   * after using `img.set()` for changes to appear.\n   *\n   * @param {Number}              x x-coordinate of the pixel.\n   * @param {Number}              y y-coordinate of the pixel.\n   * @param {Number|Number[]|Object}   a grayscale value | pixel array |\n   *                                   <a href=\"#/p5.Color\">p5.Color</a> object |\n   *                                   <a href=\"#/p5.Image\">p5.Image</a> to copy.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(100, 100);\n   *\n   *   // Set four pixels to black.\n   *   img.set(30, 20, 0);\n   *   img.set(85, 20, 0);\n   *   img.set(85, 75, 0);\n   *   img.set(30, 75, 0);\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(100, 100);\n   *\n   *   // Create a p5.Color object.\n   *   let black = color(0);\n   *\n   *   // Set four pixels to black.\n   *   img.set(30, 20, black);\n   *   img.set(85, 20, black);\n   *   img.set(85, 75, black);\n   *   img.set(30, 75, black);\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Draw a color gradient.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       let c = map(x, 0, img.width, 0, 255);\n   *       img.set(x, y, c);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A square with a horiztonal color gradient from black to white drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Create a p5.Image object.\n   *   let img2 = createImage(100, 100);\n   *\n   *   // Set the blank image's pixels using the landscape.\n   *   img2.set(0, 0, img);\n   *\n   *   // Display the second image.\n   *   image(img2, 0, 0);\n   *\n   *   describe('An image of a mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  set(x, y, imgOrCol) {\n    // Renderer2D.prototype.set.call(this, x, y, imgOrCol);\n    // round down to get integer numbers\n    x = Math.floor(x);\n    y = Math.floor(y);\n    const pixelsState = this._pixelsState;\n    if (imgOrCol instanceof Image) {\n      this.drawingContext.save();\n      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);\n      this.drawingContext.scale(this._pixelDensity, this._pixelDensity);\n      this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);\n      this.drawingContext.drawImage(imgOrCol.canvas, x, y);\n      this.drawingContext.restore();\n    } else {\n      let r = 0,\n        g = 0,\n        b = 0,\n        a = 0;\n      let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);\n      if (!pixelsState.imageData) {\n        pixelsState.loadPixels();\n      }\n      if (typeof imgOrCol === 'number') {\n        if (idx < pixelsState.pixels.length) {\n          r = imgOrCol;\n          g = imgOrCol;\n          b = imgOrCol;\n          a = 255;\n          //this.updatePixels.call(this);\n        }\n      } else if (Array.isArray(imgOrCol)) {\n        if (imgOrCol.length < 4) {\n          throw new Error('pixel array must be of the form [R, G, B, A]');\n        }\n        if (idx < pixelsState.pixels.length) {\n          r = imgOrCol[0];\n          g = imgOrCol[1];\n          b = imgOrCol[2];\n          a = imgOrCol[3];\n          //this.updatePixels.call(this);\n        }\n      } else if (imgOrCol instanceof p5.Color) {\n        if (idx < pixelsState.pixels.length) {\n          [r, g, b, a] = imgOrCol._getRGBA([255, 255, 255, 255]);\n          //this.updatePixels.call(this);\n        }\n      }\n      // loop over pixelDensity * pixelDensity\n      for (let i = 0; i < this._pixelDensity; i++) {\n        for (let j = 0; j < this._pixelDensity; j++) {\n          // loop over\n          idx = 4 * ((y * this._pixelDensity + j) * this.width * this._pixelDensity + (x * this._pixelDensity + i));\n          pixelsState.pixels[idx] = r;\n          pixelsState.pixels[idx + 1] = g;\n          pixelsState.pixels[idx + 2] = b;\n          pixelsState.pixels[idx + 3] = a;\n        }\n      }\n    }\n    this.setModified(true);\n  }\n\n  /**\n   * Resizes the image to a given width and height.\n   *\n   * The image's original aspect ratio can be kept by passing 0 for either\n   * `width` or `height`. For example, calling `img.resize(50, 0)` on an image\n   * that was 500 &times; 300 pixels will resize it to 50 &times; 30 pixels.\n   *\n   * @param {Number} width resized image width.\n   * @param {Number} height resized image height.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Resize the image.\n   *   img.resize(50, 100);\n   *\n   *   // Display the resized image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Two images of a mountain landscape. One copy of the image is squeezed horizontally.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Resize the image, keeping the aspect ratio.\n   *   img.resize(0, 30);\n   *\n   *   // Display the resized image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Resize the image, keeping the aspect ratio.\n   *   img.resize(60, 0);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');\n   * }\n   * </code>\n   * </div>\n   */\n  resize(width, height) {\n    // Copy contents to a temporary canvas, resize the original\n    // and then copy back.\n    //\n    // There is a faster approach that involves just one copy and swapping the\n    // this.canvas reference. We could switch to that approach if (as i think\n    // is the case) there an expectation that the user would not hold a\n    // reference to the backing canvas of a p5.Image. But since we do not\n    // enforce that at the moment, I am leaving in the slower, but safer\n    // implementation.\n\n    // auto-resize\n    if (width === 0 && height === 0) {\n      width = this.canvas.width;\n      height = this.canvas.height;\n    } else if (width === 0) {\n      width = this.canvas.width * height / this.canvas.height;\n    } else if (height === 0) {\n      height = this.canvas.height * width / this.canvas.width;\n    }\n    width = Math.floor(width);\n    height = Math.floor(height);\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = width;\n    tempCanvas.height = height;\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      //adapted from github.com/LinusU/resize-image-data\n      const nearestNeighbor = (src, dst) => {\n        let pos = 0;\n        for (let y = 0; y < dst.height; y++) {\n          for (let x = 0; x < dst.width; x++) {\n            const srcX = Math.floor(x * src.width / dst.width);\n            const srcY = Math.floor(y * src.height / dst.height);\n            let srcPos = (srcY * src.width + srcX) * 4;\n            dst.data[pos++] = src.data[srcPos++]; // R\n            dst.data[pos++] = src.data[srcPos++]; // G\n            dst.data[pos++] = src.data[srcPos++]; // B\n            dst.data[pos++] = src.data[srcPos++]; // A\n          }\n        }\n      };\n      for (let i = 0; i < props.numFrames; i++) {\n        const resizedImageData = this.drawingContext.createImageData(width, height);\n        nearestNeighbor(props.frames[i].image, resizedImageData);\n        props.frames[i].image = resizedImageData;\n      }\n    }\n    tempCanvas.getContext('2d').drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, tempCanvas.width, tempCanvas.height);\n\n    // Resize the original canvas, which will clear its contents\n    this.canvas.width = this.width = width;\n    this.canvas.height = this.height = height;\n\n    //Copy the image back\n    this.drawingContext.drawImage(tempCanvas, 0, 0, width, height, 0, 0, width, height);\n    if (this.pixels.length > 0) {\n      this.loadPixels();\n    }\n    this.setModified(true);\n  }\n\n  /**\n   * Copies pixels from a source image to this image.\n   *\n   * The first parameter, `srcImage`, is an optional\n   * <a href=\"#/p5.Image\">p5.Image</a> object to copy. If a source image isn't\n   * passed, then `img.copy()` can copy a region of this image to another\n   * region.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to copy from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the region's width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of this image to copy into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the region's width and height.\n   *\n   * Calling `img.copy()` will scale pixels from the source region if it isn't\n   * the same size as the destination region.\n   *\n   * @param  {p5.Image|p5.Element} srcImage source image.\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Copy one region of the image to another.\n   *   img.copy(7, 22, 10, 10, 35, 25, 50, 50);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Outline the copied region.\n   *   stroke(255);\n   *   noFill();\n   *   square(7, 22, 10);\n   *\n   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks.jpg');\n   *   createCanvas(100, 100);\n   *\n   *   // Calculate the center of the bricks image.\n   *   let x = bricks.width / 2;\n   *   let y = bricks.height / 2;\n   *\n   *   // Copy the bricks to the mountains image.\n   *   mountains.copy(bricks, 0, 0, x, y, 0, 0, x, y);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   describe('An image of a brick wall drawn at the top-left of an image of a mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   */\n  copy(...args) {\n    // NOTE: Duplicate implementation here and pixels.js\n    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;\n    if (args.length === 9) {\n      srcImage = args[0];\n      sx = args[1];\n      sy = args[2];\n      sw = args[3];\n      sh = args[4];\n      dx = args[5];\n      dy = args[6];\n      dw = args[7];\n      dh = args[8];\n    } else if (args.length === 8) {\n      srcImage = this;\n      sx = args[0];\n      sy = args[1];\n      sw = args[2];\n      sh = args[3];\n      dx = args[4];\n      dy = args[5];\n      dw = args[6];\n      dh = args[7];\n    } else {\n      throw new Error('Signature not supported');\n    }\n    this._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);\n  }\n  _copyHelper(dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {\n    const s = srcImage.canvas.width / srcImage.width;\n    // adjust coord system for 3D when renderer\n    // ie top-left = -width/2, -height/2\n    let sxMod = 0;\n    let syMod = 0;\n    if (srcImage._renderer && srcImage._renderer.isP3D) {\n      sxMod = srcImage.width / 2;\n      syMod = srcImage.height / 2;\n    }\n    if (dstImage._renderer && dstImage._renderer.isP3D) {\n      dstImage.push();\n      dstImage.resetMatrix();\n      dstImage.noLights();\n      dstImage.blendMode(dstImage.BLEND);\n      dstImage.imageMode(dstImage.CORNER);\n      dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);\n      dstImage.pop();\n    } else {\n      dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);\n    }\n  }\n\n  /**\n   * Masks part of the image with another.\n   *\n   * `img.mask()` uses another <a href=\"#/p5.Image\">p5.Image</a> object's\n   * alpha channel as the alpha channel for this image. Masks are cumulative\n   * and can't be removed once applied. If the mask has a different\n   * pixel density from this image, the mask will be scaled.\n   *\n   * @param {p5.Image} srcImage source image.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let photo;\n   * let maskImage;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   photo = await loadImage('assets/rockies.jpg');\n   *   maskImage = await loadImage('assets/mask2.png');\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the mask.\n   *   photo.mask(maskImage);\n   *\n   *   // Display the image.\n   *   image(photo, 0, 0);\n   *\n   *   describe('An image of a mountain landscape. The right side of the image has a faded patch of white.');\n   * }\n   * </code>\n   * </div>\n   */\n  // TODO: - Accept an array of alpha values.\n  mask(p5Image) {\n    if (p5Image === undefined) {\n      p5Image = this;\n    }\n    const currBlend = this.drawingContext.globalCompositeOperation;\n    let imgScaleFactor = this._pixelDensity;\n    let maskScaleFactor = 1;\n    if (p5Image instanceof Renderer) {\n      maskScaleFactor = p5Image._pInst._renderer._pixelDensity;\n    }\n    const copyArgs = [p5Image, 0, 0, maskScaleFactor * p5Image.width, maskScaleFactor * p5Image.height, 0, 0, imgScaleFactor * this.width, imgScaleFactor * this.height];\n    this.drawingContext.globalCompositeOperation = 'destination-in';\n    if (this.gifProperties) {\n      for (let i = 0; i < this.gifProperties.frames.length; i++) {\n        this.drawingContext.putImageData(this.gifProperties.frames[i].image, 0, 0);\n        this.copy(...copyArgs);\n        this.gifProperties.frames[i].image = this.drawingContext.getImageData(0, 0, imgScaleFactor * this.width, imgScaleFactor * this.height);\n      }\n      this.drawingContext.putImageData(this.gifProperties.frames[this.gifProperties.displayIndex].image, 0, 0);\n    } else {\n      this.copy(...copyArgs);\n    }\n    this.drawingContext.globalCompositeOperation = currBlend;\n    this.setModified(true);\n  }\n\n  /**\n   * Applies an image filter to the image.\n   *\n   * The preset options are:\n   *\n   * `INVERT`\n   * Inverts the colors in the image. No parameter is used.\n   *\n   * `GRAY`\n   * Converts the image to grayscale. No parameter is used.\n   *\n   * `THRESHOLD`\n   * Converts the image to black and white. Pixels with a grayscale value\n   * above a given threshold are converted to white. The rest are converted to\n   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no\n   * value is specified, 0.5 is used.\n   *\n   * `OPAQUE`\n   * Sets the alpha channel to be entirely opaque. No parameter is used.\n   *\n   * `POSTERIZE`\n   * Limits the number of colors in the image. Each color channel is limited to\n   * the number of colors specified. Values between 2 and 255 are valid, but\n   * results are most noticeable with lower values. The default value is 4.\n   *\n   * `BLUR`\n   * Blurs the image. The level of blurring is specified by a blur radius. Larger\n   * values increase the blur. The default value is 4. A gaussian blur is used\n   * in `P2D` mode. A box blur is used in `WEBGL` mode.\n   *\n   * `ERODE`\n   * Reduces the light areas. No parameter is used.\n   *\n   * `DILATE`\n   * Increases the light areas. No parameter is used.\n   *\n   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,\n   *                                POSTERIZE, ERODE, DILATE or BLUR.\n   * @param  {Number} [filterParam] parameter unique to each filter.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the INVERT filter.\n   *   img.filter(INVERT);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A blue brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the GRAY filter.\n   *   img.filter(GRAY);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A brick wall drawn in grayscale.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the THRESHOLD filter.\n   *   img.filter(THRESHOLD);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A brick wall drawn in black and white.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the OPAQUE filter.\n   *   img.filter(OPAQUE);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the POSTERIZE filter.\n   *   img.filter(POSTERIZE, 3);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('An image of a red brick wall drawn with a limited color palette.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the BLUR filter.\n   *   img.filter(BLUR, 3);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A blurry image of a red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the DILATE filter.\n   *   img.filter(DILATE);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A red brick wall with bright lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the ERODE filter.\n   *   img.filter(ERODE);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A red brick wall with faint lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   */\n  filter(operation, value) {\n    Filters.apply(this.canvas, Filters[operation], value);\n    this.setModified(true);\n  }\n\n  /**\n   * Copies a region of pixels from another image into this one.\n   *\n    * The first parameter, `srcImage`, is the\n   * <a href=\"#/p5.Image\">p5.Image</a> object to blend.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to blend from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the regions width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the regions width and height.\n   *\n   * The tenth parameter, `blendMode`, sets the effect used to blend the images'\n   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,\n   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,\n   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`.\n   *\n   * @param  {p5.Image} srcImage source image\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either\n   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,\n   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,\n   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.\n   *\n   * Available blend modes are: normal | multiply | screen | overlay |\n   *            darken | lighten | color-dodge | color-burn | hard-light |\n   *            soft-light | difference | exclusion | hue | saturation |\n   *            color | luminosity\n   *\n   * http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/\n   *\n   * @example\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks_third.jpg');\n   *   createCanvas(100, 100);\n   *\n   *   // Blend the bricks image into the mountains.\n   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, ADD);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   // Display the bricks image.\n   *   image(bricks, 0, 0);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Blend the bricks image into the mountains.\n   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   // Display the bricks image.\n   *   image(bricks, 0, 0);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Blend the bricks image into the mountains.\n   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   // Display the bricks image.\n   *   image(bricks, 0, 0);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode\n   */\n  blend(...args) {\n    const currBlend = this.drawingContext.globalCompositeOperation;\n    const blendMode = args[args.length - 1];\n    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);\n    this.drawingContext.globalCompositeOperation = blendMode;\n    this.copy(...copyArgs);\n    this.drawingContext.globalCompositeOperation = currBlend;\n    this.setModified(true);\n  }\n\n  /**\n   * helper method for web GL mode to indicate that an image has been\n   * changed or unchanged since last upload. gl texture upload will\n   * set this value to false after uploading the texture.\n   * @param {Boolean} val sets whether or not the image has been\n   * modified.\n   * @private\n   */\n  setModified(val) {\n    this._modified = val; //enforce boolean?\n  }\n\n  /**\n   * helper method for web GL mode to figure out if the image\n   * has been modified and might need to be re-uploaded to texture\n   * memory between frames.\n   * @private\n   * @return {boolean} a boolean indicating whether or not the\n   * image has been updated or modified since last texture upload.\n   */\n  isModified() {\n    return this._modified;\n  }\n\n  /**\n   * Saves the image to a file.\n   *\n   * By default, `img.save()` saves the image as a PNG image called\n   * `untitled.png`.\n   *\n   * The first parameter, `filename`, is optional. It's a string that sets the\n   * file's name. If a file extension is included, as in\n   * `img.save('drawing.png')`, then the image will be saved using that\n   * format.\n   *\n   * The second parameter, `extension`, is also optional. It sets the files format.\n   * Either `'png'` or `'jpg'` can be used. For example, `img.save('drawing', 'jpg')`\n   * saves the canvas to a file called `drawing.jpg`.\n   *\n   * Note: The browser will either save the file immediately or prompt the user\n   * with a dialogue window.\n   *\n   * The image will only be downloaded as an animated GIF if it was loaded\n   * from a GIF file. See <a href=\"#/p5/saveGif\">saveGif()</a> to create new\n   * GIFs.\n   *\n   * @param {String} filename filename. Defaults to 'untitled'.\n   * @param  {String} [extension] file extension, either 'png' or 'jpg'.\n   *                            Defaults to 'png'.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('An image of a mountain landscape. The image is downloaded when the user presses the \"s\", \"j\", or \"p\" key.');\n   * }\n   *\n   * // Save the image with different options when the user presses a key.\n   * function keyPressed() {\n   *   if (key === 's') {\n   *     img.save();\n   *   } else if (key === 'j') {\n   *     img.save('rockies.jpg');\n   *   } else if (key === 'p') {\n   *     img.save('rockies', 'png');\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n  save(filename, extension) {\n    if (this.gifProperties) {\n      encodeAndDownloadGif(this, filename);\n    } else {\n      let htmlCanvas = this.canvas;\n      extension = extension || _checkFileExtension(filename, extension)[1] || 'png';\n      let mimeType;\n      switch (extension) {\n        default:\n          //case 'png':\n          mimeType = 'image/png';\n          break;\n        case 'webp':\n          mimeType = 'image/webp';\n          break;\n        case 'jpeg':\n        case 'jpg':\n          mimeType = 'image/jpeg';\n          break;\n      }\n      htmlCanvas.toBlob(blob => {\n        downloadFile(blob, filename, extension);\n      }, mimeType);\n    }\n  }\n  async toBlob() {\n    return new Promise(resolve => {\n      this.canvas.toBlob(resolve);\n    });\n  }\n\n  // GIF Section\n  /**\n   * Restarts an animated GIF at its first frame.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-wink-loop-once.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A cartoon face winks once and then freezes. Clicking resets the face and makes it wink again.');\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   *\n   * // Reset the GIF when the user presses the mouse.\n   * function mousePressed() {\n   *   gif.reset();\n   * }\n   * </code>\n   * </div>\n   */\n  reset() {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      props.playing = true;\n      props.timeSinceStart = 0;\n      props.timeDisplayed = 0;\n      props.lastChangeTime = 0;\n      props.loopCount = 0;\n      props.displayIndex = 0;\n      this.drawingContext.putImageData(props.frames[0].image, 0, 0);\n    }\n  }\n\n  /**\n   * Gets the index of the current frame in an animated GIF.\n   *\n   * @return {Number}       index of the GIF's current frame.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A cartoon eye repeatedly looks around, then outwards. A number displayed in the bottom-left corner increases from 0 to 124, then repeats.');\n   * }\n   *\n   * function draw() {\n   *   // Get the index of the current GIF frame.\n   *   let index = gif.getCurrentFrame();\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   *\n   *   // Display the current frame.\n   *   text(index, 10, 90);\n   * }\n   * </code>\n   * </div>\n   */\n  getCurrentFrame() {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      return props.displayIndex % props.numFrames;\n    }\n  }\n\n  /**\n   * Sets the current frame in an animated GIF.\n   *\n   * @param {Number} index index of the frame to display.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   * let frameSlider;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Get the index of the last frame.\n   *   let maxFrame = gif.numFrames() - 1;\n   *\n   *   // Create a slider to control which frame is drawn.\n   *   frameSlider = createSlider(0, maxFrame);\n   *   frameSlider.position(10, 80);\n   *   frameSlider.size(80);\n   *\n   *   describe('A cartoon eye looks around when a slider is moved.');\n   * }\n   *\n   * function draw() {\n   *   // Get the slider's value.\n   *   let index = frameSlider.value();\n   *\n   *   // Set the GIF's frame.\n   *   gif.setFrame(index);\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   * </code>\n   * </div>\n   */\n  setFrame(index) {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      if (index < props.numFrames && index >= 0) {\n        props.timeDisplayed = 0;\n        props.lastChangeTime = 0;\n        props.displayIndex = index;\n        this.drawingContext.putImageData(props.frames[index].image, 0, 0);\n      } else {\n        console.log('Cannot set GIF to a frame number that is higher than total number of frames or below zero.');\n      }\n    }\n  }\n\n  /**\n   * Returns the number of frames in an animated GIF.\n   *\n   * @return {Number} number of frames in the GIF.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A cartoon eye looks around. The text \"n / 125\" is shown at the bottom of the canvas.');\n   * }\n   *\n   * function draw() {\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   *\n   *   // Display the current state of playback.\n   *   let total = gif.numFrames();\n   *   let index = gif.getCurrentFrame();\n   *   text(`${index} / ${total}`, 30, 90);\n   * }\n   * </code>\n   * </div>\n   */\n  numFrames() {\n    if (this.gifProperties) {\n      return this.gifProperties.numFrames;\n    }\n  }\n\n  /**\n   * Plays an animated GIF that was paused with\n   * <a href=\"#/p5.Image/pause\">img.pause()</a>.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *   image(gif, 0, 0);\n   * }\n   *\n   * // Pause the GIF when the user presses the mouse.\n   * function mousePressed() {\n   *   gif.pause();\n   * }\n   *\n   * // Play the GIF when the user releases the mouse.\n   * function mouseReleased() {\n   *   gif.play();\n   * }\n   * </code>\n   * </div>\n   */\n  play() {\n    if (this.gifProperties) {\n      this.gifProperties.playing = true;\n    }\n  }\n\n  /**\n   * Pauses an animated GIF.\n   *\n   * The GIF can be resumed by calling\n   * <a href=\"#/p5.Image/play\">img.play()</a>.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   *\n   * // Pause the GIF when the user presses the mouse.\n   * function mousePressed() {\n   *   gif.pause();\n   * }\n   *\n   * // Play the GIF when the user presses the mouse.\n   * function mouseReleased() {\n   *   gif.play();\n   * }\n   * </code>\n   * </div>\n   */\n  pause() {\n    if (this.gifProperties) {\n      this.gifProperties.playing = false;\n    }\n  }\n\n  /**\n   * Changes the delay between frames in an animated GIF.\n   *\n   * The first parameter, `delay`, is the length of the delay in milliseconds.\n   *\n   * The second parameter, `index`, is optional. If provided, only the frame\n   * at `index` will have its delay modified. All other frames will keep\n   * their default delay.\n   *\n   * @param {Number} d delay in milliseconds between switching frames.\n   * @param {Number} [index] index of the frame that will have its delay modified.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gifFast;\n   * let gifSlow;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   gifFast = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *   gifSlow = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Resize the images.\n   *   gifFast.resize(50, 50);\n   *   gifSlow.resize(50, 50);\n   *\n   *   // Set the delay lengths.\n   *   gifFast.delay(10);\n   *   gifSlow.delay(100);\n   *\n   *   describe('Two animated eyes looking around. The eye on the left moves faster than the eye on the right.');\n   * }\n   *\n   * function draw() {\n   *   // Display the images.\n   *   image(gifFast, 0, 0);\n   *   image(gifSlow, 50, 0);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Set the delay of frame 67.\n   *   gif.delay(3000, 67);\n   *\n   *   describe('An animated eye looking around. It pauses for three seconds while it looks down.');\n   * }\n   *\n   * function draw() {\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   * </code>\n   * </div>\n   */\n  delay(d, index) {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      if (index < props.numFrames && index >= 0) {\n        props.frames[index].delay = d;\n      } else {\n        // change all frames\n        for (const frame of props.frames) {\n          frame.delay = d;\n        }\n      }\n    }\n  }\n}\nfunction encodeAndDownloadGif(pImg, filename) {\n  const props = pImg.gifProperties;\n\n  //convert loopLimit back into Netscape Block formatting\n  let loopLimit = props.loopLimit;\n  if (loopLimit === 1) {\n    loopLimit = null;\n  } else if (loopLimit === null) {\n    loopLimit = 0;\n  }\n  const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);\n  const allFramesPixelColors = [];\n\n  // Used to determine the occurrence of unique palettes and the frames\n  // which use them\n  const paletteFreqsAndFrames = {};\n\n  // Pass 1:\n  //loop over frames and get the frequency of each palette\n  for (let i = 0; i < props.numFrames; i++) {\n    const paletteSet = new Set();\n    const data = props.frames[i].image.data;\n    const dataLength = data.length;\n    // The color for each pixel in this frame ( for easier lookup later )\n    const pixelColors = new Uint32Array(pImg.width * pImg.height);\n    for (let j = 0, k = 0; j < dataLength; j += 4, k++) {\n      const r = data[j + 0];\n      const g = data[j + 1];\n      const b = data[j + 2];\n      const color = r << 16 | g << 8 | b << 0;\n      paletteSet.add(color);\n\n      // What color does this pixel have in this frame ?\n      pixelColors[k] = color;\n    }\n\n    // A way to put use the entire palette as an object key\n    const paletteStr = [...paletteSet].sort().toString();\n    if (paletteFreqsAndFrames[paletteStr] === undefined) {\n      paletteFreqsAndFrames[paletteStr] = {\n        freq: 1,\n        frames: [i]\n      };\n    } else {\n      paletteFreqsAndFrames[paletteStr].freq += 1;\n      paletteFreqsAndFrames[paletteStr].frames.push(i);\n    }\n    allFramesPixelColors.push(pixelColors);\n  }\n  let framesUsingGlobalPalette = [];\n\n  // Now to build the global palette\n  // Sort all the unique palettes in descending order of their occurrence\n  const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function (a, b) {\n    return paletteFreqsAndFrames[b].freq - paletteFreqsAndFrames[a].freq;\n  });\n\n  // The initial global palette is the one with the most occurrence\n  const globalPalette = palettesSortedByFreq[0].split(',').map(a => parseInt(a));\n  framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[globalPalette].frames);\n  const globalPaletteSet = new Set(globalPalette);\n\n  // Build a more complete global palette\n  // Iterate over the remaining palettes in the order of\n  // their occurrence and see if the colors in this palette which are\n  // not in the global palette can be added there, while keeping the length\n  // of the global palette <= 256\n  for (let i = 1; i < palettesSortedByFreq.length; i++) {\n    const palette = palettesSortedByFreq[i].split(',').map(a => parseInt(a));\n    const difference = palette.filter(x => !globalPaletteSet.has(x));\n    if (globalPalette.length + difference.length <= 256) {\n      for (let j = 0; j < difference.length; j++) {\n        globalPalette.push(difference[j]);\n        globalPaletteSet.add(difference[j]);\n      }\n\n      // All frames using this palette now use the global palette\n      framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[palettesSortedByFreq[i]].frames);\n    }\n  }\n  framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);\n\n  // Build a lookup table of the index of each color in the global palette\n  // Maps a color to its index\n  const globalIndicesLookup = {};\n  for (let i = 0; i < globalPalette.length; i++) {\n    if (!globalIndicesLookup[globalPalette[i]]) {\n      globalIndicesLookup[globalPalette[i]] = i;\n    }\n  }\n\n  // force palette to be power of 2\n  let powof2 = 1;\n  while (powof2 < globalPalette.length) {\n    powof2 <<= 1;\n  }\n  globalPalette.length = powof2;\n\n  // global opts\n  const opts = {\n    loop: loopLimit,\n    palette: new Uint32Array(globalPalette)\n  };\n  const gifWriter = new omggif.GifWriter(buffer, pImg.width, pImg.height, opts);\n  let previousFrame = {};\n\n  // Pass 2\n  // Determine if the frame needs a local palette\n  // Also apply transparency optimization. This function will often blow up\n  // the size of a GIF if not for transparency. If a pixel in one frame has\n  // the same color in the previous frame, that pixel can be marked as\n  // transparent. We decide one particular color as transparent and make all\n  // transparent pixels take this color. This helps in later in compression.\n  for (let i = 0; i < props.numFrames; i++) {\n    const localPaletteRequired = !framesUsingGlobalPalette.has(i);\n    const palette = localPaletteRequired ? [] : globalPalette;\n    const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);\n\n    // Lookup table mapping color to its indices\n    const colorIndicesLookup = {};\n\n    // All the colors that cannot be marked transparent in this frame\n    const cannotBeTransparent = new Set();\n    allFramesPixelColors[i].forEach((color, k) => {\n      if (localPaletteRequired) {\n        if (colorIndicesLookup[color] === undefined) {\n          colorIndicesLookup[color] = palette.length;\n          palette.push(color);\n        }\n        pixelPaletteIndex[k] = colorIndicesLookup[color];\n      } else {\n        pixelPaletteIndex[k] = globalIndicesLookup[color];\n      }\n      if (i > 0) {\n        // If even one pixel of this color has changed in this frame\n        // from the previous frame, we cannot mark it as transparent\n        if (allFramesPixelColors[i - 1][k] !== color) {\n          cannotBeTransparent.add(color);\n        }\n      }\n    });\n    const frameOpts = {};\n\n    // Transparency optimization\n    const canBeTransparent = palette.filter(a => !cannotBeTransparent.has(a));\n    if (canBeTransparent.length > 0) {\n      // Select a color to mark as transparent\n      const transparent = canBeTransparent[0];\n      const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];\n      if (i > 0) {\n        for (let k = 0; k < allFramesPixelColors[i].length; k++) {\n          // If this pixel in this frame has the same color in previous frame\n          if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {\n            pixelPaletteIndex[k] = transparentIndex;\n          }\n        }\n        frameOpts.transparent = transparentIndex;\n        // If this frame has any transparency, do not dispose the previous frame\n        previousFrame.frameOpts.disposal = 1;\n      }\n    }\n    frameOpts.delay = props.frames[i].delay / 10; // Move timing back into GIF formatting\n    if (localPaletteRequired) {\n      // force palette to be power of 2\n      let powof2 = 1;\n      while (powof2 < palette.length) {\n        powof2 <<= 1;\n      }\n      palette.length = powof2;\n      frameOpts.palette = new Uint32Array(palette);\n    }\n    if (i > 0) {\n      // add the frame that came before the current one\n      gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);\n    }\n    // previous frame object should now have details of this frame\n    previousFrame = {\n      pixelPaletteIndex,\n      frameOpts\n    };\n  }\n  previousFrame.frameOpts.disposal = 1;\n  // add the last frame\n  gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);\n  const extension = 'gif';\n  const blob = new Blob([buffer.slice(0, gifWriter.end())], {\n    type: 'image/gif'\n  });\n  downloadFile(blob, filename, extension);\n}\nfunction image(p5, fn) {\n  /**\n   * A class to describe an image.\n   *\n   * Images are rectangular grids of pixels that can be displayed and modified.\n   *\n   * Existing images can be loaded by calling\n   * <a href=\"#/p5/loadImage\">loadImage()</a>. Blank images can be created by\n   * calling <a href=\"#/p5/createImage\">createImage()</a>. `p5.Image` objects\n   * have methods for common tasks such as applying filters and modifying\n   * pixel values.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('An image of a brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the GRAY filter.\n   *   img.filter(GRAY);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A grayscale image of a brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       img.set(x, y, 0);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @class p5.Image\n   * @param {Number} width\n   * @param {Number} height\n   */\n  p5.Image = Image;\n\n  /**\n   * The image's width in pixels.\n   *\n   * @type {Number}\n   * @property {Number} width\n   * @for p5.Image\n   * @name width\n   * @readOnly\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Calculate the center coordinates.\n   *   let x = img.width / 2;\n   *   let y = img.height / 2;\n   *\n   *   // Draw a circle at the image's center.\n   *   circle(x, y, 20);\n   *\n   *   describe('An image of a mountain landscape with a white circle drawn in the middle.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * The image's height in pixels.\n   *\n   * @type {Number}\n   * @property height\n   * @for p5.Image\n   * @name height\n   * @readOnly\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Calculate the center coordinates.\n   *   let x = img.width / 2;\n   *   let y = img.height / 2;\n   *\n   *   // Draw a circle at the image's center.\n   *   circle(x, y, 20);\n   *\n   *   describe('An image of a mountain landscape with a white circle drawn in the middle.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array containing the color of each pixel in the image.\n   *\n   * Colors are stored as numbers representing red, green, blue, and alpha\n   * (RGBA) values. `img.pixels` is a one-dimensional array for performance\n   * reasons.\n   *\n   * Each pixel occupies four elements in the pixels array, one for each\n   * RGBA value. For example, the pixel at coordinates (0, 0) stores its\n   * RGBA values at `img.pixels[0]`, `img.pixels[1]`, `img.pixels[2]`,\n   * and `img.pixels[3]`, respectively. The next pixel at coordinates (1, 0)\n   * stores its RGBA values at `img.pixels[4]`, `img.pixels[5]`,\n   * `img.pixels[6]`, and `img.pixels[7]`. And so on. The `img.pixels` array\n   * for a 100×100 <a href=\"#/p5.Image\">p5.Image</a> object has\n   * 100 × 100 × 4 = 40,000 elements.\n   *\n   * Accessing the RGBA values for a pixel in the image requires a little\n   * math as shown in the examples below. The\n   * <a href=\"#/p5.Image/loadPixels\">img.loadPixels()</a>\n   * method must be called before accessing the `img.pixels` array. The\n   * <a href=\"#/p5.Image/updatePixels\">img.updatePixels()</a> method must be\n   * called after any changes are made.\n   *\n   * @property {Number[]} pixels\n   * @for p5.Image\n   * @name pixels\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 0;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to red.\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 255;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A red square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   */\n}\nif (typeof p5 !== 'undefined') {\n  image(p5, p5.prototype);\n}\n\n/**\n * @module Rendering\n * @submodule Rendering\n * @for p5\n */\n\nclass ClonableObject {\n  constructor(obj = {}) {\n    for (const key in obj) {\n      this[key] = obj[key];\n    }\n  }\n  clone() {\n    return new ClonableObject(this);\n  }\n}\nclass Renderer {\n  static states = {\n    strokeColor: null,\n    strokeSet: false,\n    fillColor: null,\n    fillSet: false,\n    tint: null,\n    imageMode: CORNER,\n    rectMode: CORNER,\n    ellipseMode: CENTER,\n    strokeWeight: 1,\n    textFont: {\n      family: 'sans-serif'\n    },\n    textLeading: 15,\n    leadingSet: false,\n    textSize: 12,\n    textAlign: LEFT,\n    textBaseline: BASELINE,\n    bezierOrder: 3,\n    splineProperties: new ClonableObject({\n      ends: INCLUDE,\n      tightness: 0\n    }),\n    textWrap: WORD,\n    // added v2.0\n    fontStyle: NORMAL,\n    // v1: textStyle\n    fontStretch: NORMAL,\n    fontWeight: NORMAL,\n    lineHeight: NORMAL,\n    fontVariant: NORMAL,\n    direction: 'inherit'\n  };\n  constructor(pInst, w, h, isMainCanvas) {\n    this._pInst = pInst;\n    this._isMainCanvas = isMainCanvas;\n    this.pixels = [];\n    this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;\n    this.width = w;\n    this.height = h;\n    this._events = {};\n    if (isMainCanvas) {\n      this._isMainCanvas = true;\n    }\n\n    // Renderer state machine\n    this.states = new States(Renderer.states);\n    this.states.strokeColor = new Color([0, 0, 0]);\n    this.states.fillColor = new Color([1, 1, 1]);\n    this._pushPopStack = [];\n    // NOTE: can use the length of the push pop stack instead\n    this._pushPopDepth = 0;\n    this._clipping = false;\n    this._clipInvert = false;\n    this._currentShape = undefined; // Lazily generate current shape\n  }\n  get currentShape() {\n    if (!this._currentShape) {\n      this._currentShape = new Shape(this.getCommonVertexProperties());\n    }\n    return this._currentShape;\n  }\n  remove() {}\n  pixelDensity(val) {\n    let returnValue;\n    if (typeof val === 'number') {\n      if (val !== this._pixelDensity) {\n        this._pixelDensity = val;\n      }\n      returnValue = this;\n      this.resize(this.width, this.height);\n    } else {\n      returnValue = this._pixelDensity;\n    }\n    return returnValue;\n  }\n\n  // Makes a shallow copy of the current states\n  // and push it into the push pop stack\n  push() {\n    this._pushPopDepth++;\n    this._pushPopStack.push(this.states.getDiff());\n  }\n\n  // Pop the previous states out of the push pop stack and\n  // assign it back to the current state\n  pop() {\n    this._pushPopDepth--;\n    const diff = this._pushPopStack.pop() || {};\n    const modified = this.states.getModified();\n    this.states.applyDiff(diff);\n    this.updateShapeVertexProperties(modified);\n    this.updateShapeProperties(modified);\n  }\n  bezierOrder(order) {\n    if (order === undefined) {\n      return this.states.bezierOrder;\n    } else {\n      this.states.setValue('bezierOrder', order);\n      this.updateShapeProperties();\n    }\n  }\n  bezierVertex(x, y, z = 0, u = 0, v = 0) {\n    const position = new Vector(x, y, z);\n    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : undefined;\n    this.currentShape.bezierVertex(position, textureCoordinates);\n  }\n  splineProperty(key, value) {\n    if (value === undefined) {\n      return this.states.splineProperties[key];\n    } else {\n      this.states.setValue('splineProperties', this.states.splineProperties.clone());\n      this.states.splineProperties[key] = value;\n    }\n    this.updateShapeProperties();\n  }\n  splineProperties(values) {\n    if (values) {\n      for (const key in values) {\n        this.splineProperty(key, values[key]);\n      }\n    } else {\n      return {\n        ...this.states.splineProperties\n      };\n    }\n  }\n  splineVertex(x, y, z = 0, u = 0, v = 0) {\n    const position = new Vector(x, y, z);\n    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : undefined;\n    this.currentShape.splineVertex(position, textureCoordinates);\n  }\n  curveDetail(d) {\n    if (d === undefined) {\n      return this.states.curveDetail;\n    } else {\n      this.states.setValue('curveDetail', d);\n    }\n  }\n  beginShape(...args) {\n    this.currentShape.reset();\n    this.updateShapeVertexProperties();\n    this.currentShape.beginShape(...args);\n  }\n  endShape(...args) {\n    this.currentShape.endShape(...args);\n    this.drawShape(this.currentShape);\n  }\n  beginContour(shapeKind) {\n    this.currentShape.beginContour(shapeKind);\n  }\n  endContour(mode) {\n    this.currentShape.endContour(mode);\n  }\n  drawShape(shape, count) {\n    throw new Error('Unimplemented');\n  }\n  vertex(x, y, z = 0, u = 0, v = 0) {\n    const position = new Vector(x, y, z);\n    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : undefined;\n    this.currentShape.vertex(position, textureCoordinates);\n  }\n  bezier(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const oldOrder = this._pInst.bezierOrder();\n    this._pInst.bezierOrder(oldOrder);\n    this._pInst.beginShape();\n    this._pInst.bezierVertex(x1, y1);\n    this._pInst.bezierVertex(x2, y2);\n    this._pInst.bezierVertex(x3, y3);\n    this._pInst.bezierVertex(x4, y4);\n    this._pInst.endShape();\n    return this;\n  }\n  spline(...args) {\n    if (args.length === 2 * 4) {\n      const [x1, y1, x2, y2, x3, y3, x4, y4] = args;\n      this._pInst.beginShape();\n      this._pInst.splineVertex(x1, y1);\n      this._pInst.splineVertex(x2, y2);\n      this._pInst.splineVertex(x3, y3);\n      this._pInst.splineVertex(x4, y4);\n      this._pInst.endShape();\n    } else if (args.length === 3 * 4) {\n      const [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = args;\n      this._pInst.beginShape();\n      this._pInst.splineVertex(x1, y1, z1);\n      this._pInst.splineVertex(x2, y2, z2);\n      this._pInst.splineVertex(x3, y3, z3);\n      this._pInst.splineVertex(x4, y4, z4);\n      this._pInst.endShape();\n    }\n    return this;\n  }\n  beginClip(options = {}) {\n    if (this._clipping) {\n      throw new Error(\"It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?\");\n    }\n    this._clipping = true;\n    this._clipInvert = options.invert;\n  }\n  endClip() {\n    if (!this._clipping) {\n      throw new Error(\"It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?\");\n    }\n    this._clipping = false;\n  }\n\n  /**\n   * Resize our canvas element.\n   */\n  resize(w, h) {\n    this.width = w;\n    this.height = h;\n  }\n  get(x, y, w, h) {\n    const pd = this._pixelDensity;\n    const canvas = this.canvas;\n    if (typeof x === 'undefined' && typeof y === 'undefined') {\n      // get()\n      x = y = 0;\n      w = this.width;\n      h = this.height;\n    } else {\n      x *= pd;\n      y *= pd;\n      if (typeof w === 'undefined' && typeof h === 'undefined') {\n        // get(x,y)\n        if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {\n          return [0, 0, 0, 0];\n        }\n        return this._getPixel(x, y);\n      }\n      // get(x,y,w,h)\n    }\n    const region = new Image(w * pd, h * pd);\n    region.pixelDensity(pd);\n    region.canvas.getContext('2d').drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);\n    return region;\n  }\n  scale(x, y) {}\n  fill(...args) {\n    this.states.setValue('fillSet', true);\n    this.states.setValue('fillColor', this._pInst.color(...args));\n    this.updateShapeVertexProperties();\n  }\n  noFill() {\n    this.states.setValue('fillColor', null);\n  }\n  strokeWeight(w) {\n    if (w === undefined) {\n      return this.states.strokeWeight;\n    } else {\n      this.states.setValue('strokeWeight', w);\n    }\n  }\n  stroke(...args) {\n    this.states.setValue('strokeSet', true);\n    this.states.setValue('strokeColor', this._pInst.color(...args));\n    this.updateShapeVertexProperties();\n  }\n  noStroke() {\n    this.states.setValue('strokeColor', null);\n  }\n  getCommonVertexProperties() {\n    return {};\n  }\n  getSupportedIndividualVertexProperties() {\n    return {\n      textureCoordinates: false\n    };\n  }\n  updateShapeProperties(modified) {\n    if (!modified || modified.bezierOrder || modified.splineProperties) {\n      const shape = this.currentShape;\n      shape.bezierOrder(this.states.bezierOrder);\n      shape.splineProperty('ends', this.states.splineProperties.ends);\n      shape.splineProperty('tightness', this.states.splineProperties.tightness);\n    }\n  }\n  updateShapeVertexProperties(modified) {\n    const props = this.getCommonVertexProperties();\n    if (!modified || Object.keys(modified).some(k => k in props)) {\n      const shape = this.currentShape;\n      for (const key in props) {\n        shape[key](props[key]);\n      }\n    }\n  }\n  _applyDefaults() {\n    return this;\n  }\n}\nfunction renderer(p5, fn) {\n  /**\n   * Main graphics and rendering context, as well as the base API\n   * implementation for p5.js \"core\". To be used as the superclass for\n   * Renderer2D and Renderer3D classes, respectively.\n   *\n   * @class p5.Renderer\n   * @param {HTMLElement} elt DOM node that is wrapped\n   * @param {p5} [pInst] pointer to p5 instance\n   * @param {Boolean} [isMainCanvas] whether we're using it as main canvas\n   * @private\n   */\n  p5.Renderer = Renderer;\n}\nexport { Image as I, Renderer as R, image as i, renderer as r };","map":{"version":3,"names":["C","Color","N","NORMAL","am","WORD","an","BASELINE","ao","LEFT","CENTER","e","CORNER","I","INCLUDE","Filters","Vector","Shape","States","_checkFileExtension","downloadFile","Image","constructor","width","height","canvas","document","createElement","drawingContext","getContext","_pixelsState","_pixelDensity","gifProperties","_modified","pixels","pixelDensity","density","_animateGif","pInst","props","curTime","_lastRealFrameTime","window","performance","now","lastChangeTime","playing","timeDisplayed","curDelay","frames","displayIndex","delay","skips","Math","floor","loopCount","numFrames","loopLimit","ind","putImageData","image","setModified","loadPixels","pixelsState","pd","w","h","imageData","getImageData","data","updatePixels","x","y","undefined","get","_getPixel","region","drawImage","index","set","imgOrCol","save","setTransform","scale","clearRect","restore","r","g","b","a","idx","length","Array","isArray","Error","p5","_getRGBA","i","j","resize","tempCanvas","nearestNeighbor","src","dst","pos","srcX","srcY","srcPos","resizedImageData","createImageData","copy","args","srcImage","sx","sy","sw","sh","dx","dy","dw","dh","_copyHelper","dstImage","s","sxMod","syMod","_renderer","isP3D","push","resetMatrix","noLights","blendMode","BLEND","imageMode","pop","mask","p5Image","currBlend","globalCompositeOperation","imgScaleFactor","maskScaleFactor","Renderer","_pInst","copyArgs","filter","operation","value","apply","blend","prototype","slice","call","val","isModified","filename","extension","encodeAndDownloadGif","htmlCanvas","mimeType","toBlob","blob","Promise","resolve","reset","timeSinceStart","getCurrentFrame","setFrame","console","log","play","pause","d","frame","pImg","buffer","Uint8Array","allFramesPixelColors","paletteFreqsAndFrames","paletteSet","Set","dataLength","pixelColors","Uint32Array","k","color","add","paletteStr","sort","toString","freq","framesUsingGlobalPalette","palettesSortedByFreq","Object","keys","globalPalette","split","map","parseInt","concat","globalPaletteSet","palette","difference","has","globalIndicesLookup","powof2","opts","loop","gifWriter","omggif","GifWriter","previousFrame","localPaletteRequired","pixelPaletteIndex","colorIndicesLookup","cannotBeTransparent","forEach","frameOpts","canBeTransparent","transparent","transparentIndex","disposal","addFrame","Blob","end","type","fn","ClonableObject","obj","key","clone","states","strokeColor","strokeSet","fillColor","fillSet","tint","rectMode","ellipseMode","strokeWeight","textFont","family","textLeading","leadingSet","textSize","textAlign","textBaseline","bezierOrder","splineProperties","ends","tightness","textWrap","fontStyle","fontStretch","fontWeight","lineHeight","fontVariant","direction","isMainCanvas","_isMainCanvas","ceil","devicePixelRatio","_events","_pushPopStack","_pushPopDepth","_clipping","_clipInvert","_currentShape","currentShape","getCommonVertexProperties","remove","returnValue","getDiff","diff","modified","getModified","applyDiff","updateShapeVertexProperties","updateShapeProperties","order","setValue","bezierVertex","z","u","v","position","textureCoordinates","getSupportedIndividualVertexProperties","splineProperty","values","splineVertex","curveDetail","beginShape","endShape","drawShape","beginContour","shapeKind","endContour","mode","shape","count","vertex","bezier","x1","y1","x2","y2","x3","y3","x4","y4","oldOrder","spline","z1","z2","z3","z4","beginClip","options","invert","endClip","fill","noFill","stroke","noStroke","some","_applyDefaults","renderer","R"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/p5.Renderer-R23xoC7s.js"],"sourcesContent":["import { C as Color } from './creating_reading-Cr8L2Jnm.js';\nimport { N as NORMAL, am as WORD, an as BASELINE, ao as LEFT, C as CENTER, e as CORNER, I as INCLUDE } from './constants-BRcElHU3.js';\nimport Filters from './image/filters.js';\nimport { Vector } from './math/p5.Vector.js';\nimport { Shape } from './shape/custom_shapes.js';\nimport { States } from './core/States.js';\nimport { _checkFileExtension, downloadFile } from './io/utilities.js';\n\n/**\n * @module Image\n * @submodule Image\n * @requires core\n * @requires constants\n * @requires filters\n */\n\n\nclass Image {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.drawingContext = this.canvas.getContext('2d');\n    this._pixelsState = this;\n    this._pixelDensity = 1;\n    //Object for working with GIFs, defaults to null\n    this.gifProperties = null;\n    //For WebGL Texturing only: used to determine whether to reupload texture to GPU\n    this._modified = false;\n    this.pixels = [];\n  }\n\n  /**\n   * Gets or sets the pixel density for high pixel density displays.\n   *\n   * By default, the density will be set to 1.\n   *\n   * Call this method with no arguments to get the default density, or pass\n   * in a number to set the density. If a non-positive number is provided,\n   * it defaults to 1.\n   *\n   * @param {Number} [density] A scaling factor for the number of pixels per\n   * side\n   * @returns {Number} The current density if called without arguments, or the instance for chaining if setting density.\n   */\n  pixelDensity(density) {\n    if (typeof density !== 'undefined') {\n    // Setter: set the density and handle resize\n      if (density <= 0) {\n\n        // p5._friendlyParamError(errorObj, 'pixelDensity');\n\n        // Default to 1 in case of an invalid value\n        density = 1;\n      }\n\n      this._pixelDensity = density;\n\n      // Adjust canvas dimensions based on pixel density\n      this.width /= density;\n      this.height /= density;\n\n      return this; // Return the image instance for chaining if needed\n    } else {\n    // Getter: return the default density\n      return this._pixelDensity;\n    }\n  }\n\n  /**\n   * Helper function for animating GIF-based images with time\n   */\n  _animateGif(pInst) {\n    const props = this.gifProperties;\n    const curTime = pInst._lastRealFrameTime || window.performance.now();\n    if (props.lastChangeTime === 0) {\n      props.lastChangeTime = curTime;\n    }\n    if (props.playing) {\n      props.timeDisplayed = curTime - props.lastChangeTime;\n      const curDelay = props.frames[props.displayIndex].delay;\n      if (props.timeDisplayed >= curDelay) {\n        //GIF is bound to 'realtime' so can skip frames\n        const skips = Math.floor(props.timeDisplayed / curDelay);\n        props.timeDisplayed = 0;\n        props.lastChangeTime = curTime;\n        props.displayIndex += skips;\n        props.loopCount = Math.floor(props.displayIndex / props.numFrames);\n        if (props.loopLimit !== null && props.loopCount >= props.loopLimit) {\n          props.playing = false;\n        } else {\n          const ind = props.displayIndex % props.numFrames;\n          this.drawingContext.putImageData(props.frames[ind].image, 0, 0);\n          props.displayIndex = ind;\n          this.setModified(true);\n        }\n      }\n    }\n  }\n\n  /**\n   * Loads the current value of each pixel in the image into the `img.pixels`\n   * array.\n   *\n   * `img.loadPixels()` must be called before reading or modifying pixel\n   * values.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       img.set(x, y, 0);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 0;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   */\n  loadPixels() {\n    // Renderer2D.prototype.loadPixels.call(this);\n    const pixelsState = this._pixelsState;\n    const pd = this._pixelDensity;\n    const w = this.width * pd;\n    const h = this.height * pd;\n    const imageData = this.drawingContext.getImageData(0, 0, w, h);\n    // @todo this should actually set pixels per object, so diff buffers can\n    // have diff pixel arrays.\n    pixelsState.imageData = imageData;\n    this.pixels = pixelsState.pixels = imageData.data;\n    this.setModified(true);\n  }\n\n  /**\n   * Updates the canvas with the RGBA values in the\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a> array.\n   *\n   * `img.updatePixels()` only needs to be called after changing values in\n   * the <a href=\"#/p5.Image/pixels\">img.pixels</a> array. Such changes can be\n   * made directly after calling\n   * <a href=\"#/p5.Image/loadPixels\">img.loadPixels()</a> or by calling\n   * <a href=\"#/p5.Image/set\">img.set()</a>.\n   *\n   * The optional parameters `x`, `y`, `width`, and `height` define a\n   * subsection of the image to update. Doing so can improve performance in\n   * some cases.\n   *\n   * If the image was loaded from a GIF, then calling `img.updatePixels()`\n   * will update the pixels in current frame.\n   *\n   * @param {Integer} x x-coordinate of the upper-left corner\n   *                    of the subsection to update.\n   * @param {Integer} y y-coordinate of the upper-left corner\n   *                    of the subsection to update.\n   * @param {Integer} w width of the subsection to update.\n   * @param {Integer} h height of the subsection to update.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       img.set(x, y, 0);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 0;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   */\n  updatePixels(x, y, w, h) {\n    // Renderer2D.prototype.updatePixels.call(this, x, y, w, h);\n    const pixelsState = this._pixelsState;\n    const pd = this._pixelDensity;\n    if (\n      x === undefined &&\n      y === undefined &&\n      w === undefined &&\n      h === undefined\n    ) {\n      x = 0;\n      y = 0;\n      w = this.width;\n      h = this.height;\n    }\n    x *= pd;\n    y *= pd;\n    w *= pd;\n    h *= pd;\n\n    if (this.gifProperties) {\n      this.gifProperties.frames[this.gifProperties.displayIndex].image =\n        pixelsState.imageData;\n    }\n\n    this.drawingContext.putImageData(pixelsState.imageData, x, y, 0, 0, w, h);\n    this.setModified(true);\n  }\n\n  /**\n   * Gets a pixel or a region of pixels from the image.\n   *\n   * `img.get()` is easy to use but it's not as fast as\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a>. Use\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a> to read many pixel values.\n   *\n   * The version of `img.get()` with no parameters returns the entire image.\n   *\n   * The version of `img.get()` with two parameters, as in `img.get(10, 20)`,\n   * interprets them as coordinates. It returns an array with the\n   * `[R, G, B, A]` values of the pixel at the given point.\n   *\n   * The version of `img.get()` with four parameters, as in\n   * `img,get(10, 20, 50, 90)`, interprets them as\n   * coordinates and dimensions. The first two parameters are the coordinates\n   * of the upper-left corner of the subsection. The last two parameters are\n   * the width and height of the subsection. It returns a subsection of the\n   * canvas in a new <a href=\"#/p5.Image\">p5.Image</a> object.\n   *\n   * Use `img.get()` instead of <a href=\"#/p5/get\">get()</a> to work directly\n   * with images.\n   *\n   * @param  {Number}               x x-coordinate of the pixel.\n   * @param  {Number}               y y-coordinate of the pixel.\n   * @param  {Number}               w width of the subsection to be returned.\n   * @param  {Number}               h height of the subsection to be returned.\n   * @return {p5.Image}             subsection as a <a href=\"#/p5.Image\">p5.Image</a> object.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Copy the image.\n   *   let img2 = get();\n   *\n   *   // Display the copied image on the right.\n   *   image(img2, 50, 0);\n   *\n   *   describe('Two identical mountain landscapes shown side-by-side.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Get a pixel's color.\n   *   let c = img.get(50, 90);\n   *\n   *   // Style the square using the pixel's color.\n   *   fill(c);\n   *   noStroke();\n   *\n   *   // Draw the square.\n   *   square(25, 25, 50);\n   *\n   *   describe('A mountain landscape with an olive green square in its center.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Copy half of the image.\n   *   let img2 = img.get(0, 0, img.width / 2, img.height / 2);\n   *\n   *   // Display half of the image.\n   *   image(img2, 50, 50);\n   *\n   *   describe('A mountain landscape drawn on top of another mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @return {p5.Image}      whole <a href=\"#/p5.Image\">p5.Image</a>\n   */\n  /**\n   * @param  {Number}        x\n   * @param  {Number}        y\n   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.\n   */\n  get(x, y, w, h) {\n    // p5._validateParameters('p5.Image.get', arguments);\n    // return Renderer2D.prototype.get.apply(this, arguments);\n    const pixelsState = this._pixelsState;\n    const pd = this._pixelDensity;\n    const canvas = this.canvas;\n\n    if (typeof x === 'undefined' && typeof y === 'undefined') {\n    // get()\n      x = y = 0;\n      w = pixelsState.width;\n      h = pixelsState.height;\n    } else {\n      x *= pd;\n      y *= pd;\n\n      if (typeof w === 'undefined' && typeof h === 'undefined') {\n      // get(x,y)\n        if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {\n          return [0, 0, 0, 0];\n        }\n\n        return this._getPixel(x, y);\n      }\n    // get(x,y,w,h)\n    }\n\n    const region = new Image(w*pd, h*pd);\n    region.pixelDensity(pd);\n    region.canvas\n      .getContext('2d')\n      .drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w*pd, h*pd);\n\n    return region;\n  }\n\n  _getPixel(x, y) {\n    let imageData, index;\n    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;\n    index = 0;\n    return [\n      imageData[index + 0],\n      imageData[index + 1],\n      imageData[index + 2],\n      imageData[index + 3]\n    ];\n    // return Renderer2D.prototype._getPixel.apply(this, args);\n  }\n\n  /**\n   * Sets the color of one or more pixels within an image.\n   *\n   * `img.set()` is easy to use but it's not as fast as\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a>. Use\n   * <a href=\"#/p5.Image/pixels\">img.pixels</a> to set many pixel values.\n   *\n   * `img.set()` interprets the first two parameters as x- and y-coordinates. It\n   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel\n   * array, a <a href=\"#/p5.Color\">p5.Color</a> object, or another\n   * <a href=\"#/p5.Image\">p5.Image</a> object.\n   *\n   * <a href=\"#/p5.Image/updatePixels\">img.updatePixels()</a> must be called\n   * after using `img.set()` for changes to appear.\n   *\n   * @param {Number}              x x-coordinate of the pixel.\n   * @param {Number}              y y-coordinate of the pixel.\n   * @param {Number|Number[]|Object}   a grayscale value | pixel array |\n   *                                   <a href=\"#/p5.Color\">p5.Color</a> object |\n   *                                   <a href=\"#/p5.Image\">p5.Image</a> to copy.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(100, 100);\n   *\n   *   // Set four pixels to black.\n   *   img.set(30, 20, 0);\n   *   img.set(85, 20, 0);\n   *   img.set(85, 75, 0);\n   *   img.set(30, 75, 0);\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(100, 100);\n   *\n   *   // Create a p5.Color object.\n   *   let black = color(0);\n   *\n   *   // Set four pixels to black.\n   *   img.set(30, 20, black);\n   *   img.set(85, 20, black);\n   *   img.set(85, 75, black);\n   *   img.set(30, 75, black);\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Four black dots arranged in a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Draw a color gradient.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       let c = map(x, 0, img.width, 0, 255);\n   *       img.set(x, y, c);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A square with a horiztonal color gradient from black to white drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Create a p5.Image object.\n   *   let img2 = createImage(100, 100);\n   *\n   *   // Set the blank image's pixels using the landscape.\n   *   img2.set(0, 0, img);\n   *\n   *   // Display the second image.\n   *   image(img2, 0, 0);\n   *\n   *   describe('An image of a mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  set(x, y, imgOrCol) {\n    // Renderer2D.prototype.set.call(this, x, y, imgOrCol);\n    // round down to get integer numbers\n    x = Math.floor(x);\n    y = Math.floor(y);\n    const pixelsState = this._pixelsState;\n    if (imgOrCol instanceof Image) {\n      this.drawingContext.save();\n      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);\n      this.drawingContext.scale(\n        this._pixelDensity,\n        this._pixelDensity\n      );\n      this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);\n      this.drawingContext.drawImage(imgOrCol.canvas, x, y);\n      this.drawingContext.restore();\n    } else {\n      let r = 0,\n        g = 0,\n        b = 0,\n        a = 0;\n      let idx =\n        4 *\n        (y *\n          this._pixelDensity *\n          (this.width * this._pixelDensity) +\n          x * this._pixelDensity);\n      if (!pixelsState.imageData) {\n        pixelsState.loadPixels();\n      }\n      if (typeof imgOrCol === 'number') {\n        if (idx < pixelsState.pixels.length) {\n          r = imgOrCol;\n          g = imgOrCol;\n          b = imgOrCol;\n          a = 255;\n          //this.updatePixels.call(this);\n        }\n      } else if (Array.isArray(imgOrCol)) {\n        if (imgOrCol.length < 4) {\n          throw new Error('pixel array must be of the form [R, G, B, A]');\n        }\n        if (idx < pixelsState.pixels.length) {\n          r = imgOrCol[0];\n          g = imgOrCol[1];\n          b = imgOrCol[2];\n          a = imgOrCol[3];\n          //this.updatePixels.call(this);\n        }\n      } else if (imgOrCol instanceof p5.Color) {\n        if (idx < pixelsState.pixels.length) {\n          [r, g, b, a] = imgOrCol._getRGBA([255, 255, 255, 255]);\n          //this.updatePixels.call(this);\n        }\n      }\n      // loop over pixelDensity * pixelDensity\n      for (let i = 0; i < this._pixelDensity; i++) {\n        for (let j = 0; j < this._pixelDensity; j++) {\n          // loop over\n          idx =\n            4 *\n            ((y * this._pixelDensity + j) *\n              this.width *\n              this._pixelDensity +\n              (x * this._pixelDensity + i));\n          pixelsState.pixels[idx] = r;\n          pixelsState.pixels[idx + 1] = g;\n          pixelsState.pixels[idx + 2] = b;\n          pixelsState.pixels[idx + 3] = a;\n        }\n      }\n    }\n    this.setModified(true);\n  }\n\n  /**\n   * Resizes the image to a given width and height.\n   *\n   * The image's original aspect ratio can be kept by passing 0 for either\n   * `width` or `height`. For example, calling `img.resize(50, 0)` on an image\n   * that was 500 &times; 300 pixels will resize it to 50 &times; 30 pixels.\n   *\n   * @param {Number} width resized image width.\n   * @param {Number} height resized image height.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Resize the image.\n   *   img.resize(50, 100);\n   *\n   *   // Display the resized image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Two images of a mountain landscape. One copy of the image is squeezed horizontally.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Resize the image, keeping the aspect ratio.\n   *   img.resize(0, 30);\n   *\n   *   // Display the resized image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Resize the image, keeping the aspect ratio.\n   *   img.resize(60, 0);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');\n   * }\n   * </code>\n   * </div>\n   */\n  resize(width, height) {\n    // Copy contents to a temporary canvas, resize the original\n    // and then copy back.\n    //\n    // There is a faster approach that involves just one copy and swapping the\n    // this.canvas reference. We could switch to that approach if (as i think\n    // is the case) there an expectation that the user would not hold a\n    // reference to the backing canvas of a p5.Image. But since we do not\n    // enforce that at the moment, I am leaving in the slower, but safer\n    // implementation.\n\n    // auto-resize\n    if (width === 0 && height === 0) {\n      width = this.canvas.width;\n      height = this.canvas.height;\n    } else if (width === 0) {\n      width = this.canvas.width * height / this.canvas.height;\n    } else if (height === 0) {\n      height = this.canvas.height * width / this.canvas.width;\n    }\n\n    width = Math.floor(width);\n    height = Math.floor(height);\n\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = width;\n    tempCanvas.height = height;\n\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      //adapted from github.com/LinusU/resize-image-data\n      const nearestNeighbor = (src, dst) => {\n        let pos = 0;\n        for (let y = 0; y < dst.height; y++) {\n          for (let x = 0; x < dst.width; x++) {\n            const srcX = Math.floor(x * src.width / dst.width);\n            const srcY = Math.floor(y * src.height / dst.height);\n            let srcPos = (srcY * src.width + srcX) * 4;\n            dst.data[pos++] = src.data[srcPos++]; // R\n            dst.data[pos++] = src.data[srcPos++]; // G\n            dst.data[pos++] = src.data[srcPos++]; // B\n            dst.data[pos++] = src.data[srcPos++]; // A\n          }\n        }\n      };\n      for (let i = 0; i < props.numFrames; i++) {\n        const resizedImageData = this.drawingContext.createImageData(\n          width,\n          height\n        );\n        nearestNeighbor(props.frames[i].image, resizedImageData);\n        props.frames[i].image = resizedImageData;\n      }\n    }\n\n    tempCanvas.getContext('2d').drawImage(\n      this.canvas,\n      0, 0, this.canvas.width, this.canvas.height,\n      0, 0, tempCanvas.width, tempCanvas.height\n    );\n\n    // Resize the original canvas, which will clear its contents\n    this.canvas.width = this.width = width;\n    this.canvas.height = this.height = height;\n\n    //Copy the image back\n    this.drawingContext.drawImage(\n      tempCanvas,\n      0, 0, width, height,\n      0, 0, width, height\n    );\n\n    if (this.pixels.length > 0) {\n      this.loadPixels();\n    }\n\n    this.setModified(true);\n  }\n\n  /**\n   * Copies pixels from a source image to this image.\n   *\n   * The first parameter, `srcImage`, is an optional\n   * <a href=\"#/p5.Image\">p5.Image</a> object to copy. If a source image isn't\n   * passed, then `img.copy()` can copy a region of this image to another\n   * region.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to copy from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the region's width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of this image to copy into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the region's width and height.\n   *\n   * Calling `img.copy()` will scale pixels from the source region if it isn't\n   * the same size as the destination region.\n   *\n   * @param  {p5.Image|p5.Element} srcImage source image.\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Copy one region of the image to another.\n   *   img.copy(7, 22, 10, 10, 35, 25, 50, 50);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Outline the copied region.\n   *   stroke(255);\n   *   noFill();\n   *   square(7, 22, 10);\n   *\n   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks.jpg');\n   *   createCanvas(100, 100);\n   *\n   *   // Calculate the center of the bricks image.\n   *   let x = bricks.width / 2;\n   *   let y = bricks.height / 2;\n   *\n   *   // Copy the bricks to the mountains image.\n   *   mountains.copy(bricks, 0, 0, x, y, 0, 0, x, y);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   describe('An image of a brick wall drawn at the top-left of an image of a mountain landscape.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   */\n  copy(...args) {\n    // NOTE: Duplicate implementation here and pixels.js\n    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;\n    if (args.length === 9) {\n      srcImage = args[0];\n      sx = args[1];\n      sy = args[2];\n      sw = args[3];\n      sh = args[4];\n      dx = args[5];\n      dy = args[6];\n      dw = args[7];\n      dh = args[8];\n    } else if (args.length === 8) {\n      srcImage = this;\n      sx = args[0];\n      sy = args[1];\n      sw = args[2];\n      sh = args[3];\n      dx = args[4];\n      dy = args[5];\n      dw = args[6];\n      dh = args[7];\n    } else {\n      throw new Error('Signature not supported');\n    }\n\n    this._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);\n  }\n\n  _copyHelper(\n    dstImage,\n    srcImage,\n    sx,\n    sy,\n    sw,\n    sh,\n    dx,\n    dy,\n    dw,\n    dh\n  ){\n    const s = srcImage.canvas.width / srcImage.width;\n    // adjust coord system for 3D when renderer\n    // ie top-left = -width/2, -height/2\n    let sxMod = 0;\n    let syMod = 0;\n    if (srcImage._renderer && srcImage._renderer.isP3D) {\n      sxMod = srcImage.width / 2;\n      syMod = srcImage.height / 2;\n    }\n    if (dstImage._renderer && dstImage._renderer.isP3D) {\n      dstImage.push();\n      dstImage.resetMatrix();\n      dstImage.noLights();\n      dstImage.blendMode(dstImage.BLEND);\n      dstImage.imageMode(dstImage.CORNER);\n      dstImage._renderer.image(\n        srcImage,\n        sx + sxMod,\n        sy + syMod,\n        sw,\n        sh,\n        dx,\n        dy,\n        dw,\n        dh\n      );\n      dstImage.pop();\n    } else {\n      dstImage.drawingContext.drawImage(\n        srcImage.canvas,\n        s * (sx + sxMod),\n        s * (sy + syMod),\n        s * sw,\n        s * sh,\n        dx,\n        dy,\n        dw,\n        dh\n      );\n    }\n  }\n\n  /**\n   * Masks part of the image with another.\n   *\n   * `img.mask()` uses another <a href=\"#/p5.Image\">p5.Image</a> object's\n   * alpha channel as the alpha channel for this image. Masks are cumulative\n   * and can't be removed once applied. If the mask has a different\n   * pixel density from this image, the mask will be scaled.\n   *\n   * @param {p5.Image} srcImage source image.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let photo;\n   * let maskImage;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   photo = await loadImage('assets/rockies.jpg');\n   *   maskImage = await loadImage('assets/mask2.png');\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the mask.\n   *   photo.mask(maskImage);\n   *\n   *   // Display the image.\n   *   image(photo, 0, 0);\n   *\n   *   describe('An image of a mountain landscape. The right side of the image has a faded patch of white.');\n   * }\n   * </code>\n   * </div>\n   */\n  // TODO: - Accept an array of alpha values.\n  mask(p5Image) {\n    if (p5Image === undefined) {\n      p5Image = this;\n    }\n    const currBlend = this.drawingContext.globalCompositeOperation;\n\n    let imgScaleFactor = this._pixelDensity;\n    let maskScaleFactor = 1;\n    if (p5Image instanceof Renderer) {\n      maskScaleFactor = p5Image._pInst._renderer._pixelDensity;\n    }\n\n    const copyArgs = [\n      p5Image,\n      0,\n      0,\n      maskScaleFactor * p5Image.width,\n      maskScaleFactor * p5Image.height,\n      0,\n      0,\n      imgScaleFactor * this.width,\n      imgScaleFactor * this.height\n    ];\n\n    this.drawingContext.globalCompositeOperation = 'destination-in';\n    if (this.gifProperties) {\n      for (let i = 0; i < this.gifProperties.frames.length; i++) {\n        this.drawingContext.putImageData(\n          this.gifProperties.frames[i].image,\n          0,\n          0\n        );\n        this.copy(...copyArgs);\n        this.gifProperties.frames[i].image = this.drawingContext.getImageData(\n          0,\n          0,\n          imgScaleFactor * this.width,\n          imgScaleFactor * this.height\n        );\n      }\n      this.drawingContext.putImageData(\n        this.gifProperties.frames[this.gifProperties.displayIndex].image,\n        0,\n        0\n      );\n    } else {\n      this.copy(...copyArgs);\n    }\n    this.drawingContext.globalCompositeOperation = currBlend;\n    this.setModified(true);\n  }\n\n  /**\n   * Applies an image filter to the image.\n   *\n   * The preset options are:\n   *\n   * `INVERT`\n   * Inverts the colors in the image. No parameter is used.\n   *\n   * `GRAY`\n   * Converts the image to grayscale. No parameter is used.\n   *\n   * `THRESHOLD`\n   * Converts the image to black and white. Pixels with a grayscale value\n   * above a given threshold are converted to white. The rest are converted to\n   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no\n   * value is specified, 0.5 is used.\n   *\n   * `OPAQUE`\n   * Sets the alpha channel to be entirely opaque. No parameter is used.\n   *\n   * `POSTERIZE`\n   * Limits the number of colors in the image. Each color channel is limited to\n   * the number of colors specified. Values between 2 and 255 are valid, but\n   * results are most noticeable with lower values. The default value is 4.\n   *\n   * `BLUR`\n   * Blurs the image. The level of blurring is specified by a blur radius. Larger\n   * values increase the blur. The default value is 4. A gaussian blur is used\n   * in `P2D` mode. A box blur is used in `WEBGL` mode.\n   *\n   * `ERODE`\n   * Reduces the light areas. No parameter is used.\n   *\n   * `DILATE`\n   * Increases the light areas. No parameter is used.\n   *\n   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,\n   *                                POSTERIZE, ERODE, DILATE or BLUR.\n   * @param  {Number} [filterParam] parameter unique to each filter.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the INVERT filter.\n   *   img.filter(INVERT);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A blue brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the GRAY filter.\n   *   img.filter(GRAY);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A brick wall drawn in grayscale.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the THRESHOLD filter.\n   *   img.filter(THRESHOLD);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A brick wall drawn in black and white.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the OPAQUE filter.\n   *   img.filter(OPAQUE);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the POSTERIZE filter.\n   *   img.filter(POSTERIZE, 3);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('An image of a red brick wall drawn with a limited color palette.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the BLUR filter.\n   *   img.filter(BLUR, 3);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A blurry image of a red brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the DILATE filter.\n   *   img.filter(DILATE);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A red brick wall with bright lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the ERODE filter.\n   *   img.filter(ERODE);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A red brick wall with faint lines between each brick.');\n   * }\n   * </code>\n   * </div>\n   */\n  filter(operation, value) {\n    Filters.apply(this.canvas, Filters[operation], value);\n    this.setModified(true);\n  }\n\n  /**\n   * Copies a region of pixels from another image into this one.\n   *\n    * The first parameter, `srcImage`, is the\n   * <a href=\"#/p5.Image\">p5.Image</a> object to blend.\n   *\n   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region\n   * to blend from the source image. `(sx, sy)` is the top-left corner of the\n   * region. `sw` and `sh` are the regions width and height.\n   *\n   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region\n   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the\n   * region. `dw` and `dh` are the regions width and height.\n   *\n   * The tenth parameter, `blendMode`, sets the effect used to blend the images'\n   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,\n   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,\n   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`.\n   *\n   * @param  {p5.Image} srcImage source image\n   * @param  {Integer} sx x-coordinate of the source's upper-left corner.\n   * @param  {Integer} sy y-coordinate of the source's upper-left corner.\n   * @param  {Integer} sw source image width.\n   * @param  {Integer} sh source image height.\n   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.\n   * @param  {Integer} dw destination image width.\n   * @param  {Integer} dh destination image height.\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either\n   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,\n   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,\n   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.\n   *\n   * Available blend modes are: normal | multiply | screen | overlay |\n   *            darken | lighten | color-dodge | color-burn | hard-light |\n   *            soft-light | difference | exclusion | hue | saturation |\n   *            color | luminosity\n   *\n   * http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/\n   *\n   * @example\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks_third.jpg');\n   *   createCanvas(100, 100);\n   *\n   *   // Blend the bricks image into the mountains.\n   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, ADD);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   // Display the bricks image.\n   *   image(bricks, 0, 0);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Blend the bricks image into the mountains.\n   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   // Display the bricks image.\n   *   image(bricks, 0, 0);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let mountains;\n   * let bricks;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   mountains = await loadImage('assets/rockies.jpg');\n   *   bricks = await loadImage('assets/bricks_third.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Blend the bricks image into the mountains.\n   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);\n   *\n   *   // Display the mountains image.\n   *   image(mountains, 0, 0);\n   *\n   *   // Display the bricks image.\n   *   image(bricks, 0, 0);\n   *\n   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @param  {Integer} sx\n   * @param  {Integer} sy\n   * @param  {Integer} sw\n   * @param  {Integer} sh\n   * @param  {Integer} dx\n   * @param  {Integer} dy\n   * @param  {Integer} dw\n   * @param  {Integer} dh\n   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode\n   */\n  blend(...args) {\n    const currBlend = this.drawingContext.globalCompositeOperation;\n    const blendMode = args[args.length - 1];\n    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);\n\n    this.drawingContext.globalCompositeOperation = blendMode;\n    this.copy(...copyArgs);\n    this.drawingContext.globalCompositeOperation = currBlend;\n    this.setModified(true);\n  }\n\n  /**\n   * helper method for web GL mode to indicate that an image has been\n   * changed or unchanged since last upload. gl texture upload will\n   * set this value to false after uploading the texture.\n   * @param {Boolean} val sets whether or not the image has been\n   * modified.\n   * @private\n   */\n  setModified(val) {\n    this._modified = val; //enforce boolean?\n  }\n\n  /**\n   * helper method for web GL mode to figure out if the image\n   * has been modified and might need to be re-uploaded to texture\n   * memory between frames.\n   * @private\n   * @return {boolean} a boolean indicating whether or not the\n   * image has been updated or modified since last texture upload.\n   */\n  isModified() {\n    return this._modified;\n  }\n\n  /**\n   * Saves the image to a file.\n   *\n   * By default, `img.save()` saves the image as a PNG image called\n   * `untitled.png`.\n   *\n   * The first parameter, `filename`, is optional. It's a string that sets the\n   * file's name. If a file extension is included, as in\n   * `img.save('drawing.png')`, then the image will be saved using that\n   * format.\n   *\n   * The second parameter, `extension`, is also optional. It sets the files format.\n   * Either `'png'` or `'jpg'` can be used. For example, `img.save('drawing', 'jpg')`\n   * saves the canvas to a file called `drawing.jpg`.\n   *\n   * Note: The browser will either save the file immediately or prompt the user\n   * with a dialogue window.\n   *\n   * The image will only be downloaded as an animated GIF if it was loaded\n   * from a GIF file. See <a href=\"#/p5/saveGif\">saveGif()</a> to create new\n   * GIFs.\n   *\n   * @param {String} filename filename. Defaults to 'untitled'.\n   * @param  {String} [extension] file extension, either 'png' or 'jpg'.\n   *                            Defaults to 'png'.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('An image of a mountain landscape. The image is downloaded when the user presses the \"s\", \"j\", or \"p\" key.');\n   * }\n   *\n   * // Save the image with different options when the user presses a key.\n   * function keyPressed() {\n   *   if (key === 's') {\n   *     img.save();\n   *   } else if (key === 'j') {\n   *     img.save('rockies.jpg');\n   *   } else if (key === 'p') {\n   *     img.save('rockies', 'png');\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n  save(filename, extension) {\n    if (this.gifProperties) {\n      encodeAndDownloadGif(this, filename);\n    } else {\n      let htmlCanvas = this.canvas;\n      extension =\n        extension ||\n        _checkFileExtension(filename, extension)[1] ||\n        'png';\n\n      let mimeType;\n      switch (extension) {\n        default:\n          //case 'png':\n          mimeType = 'image/png';\n          break;\n        case 'webp':\n          mimeType = 'image/webp';\n          break;\n        case 'jpeg':\n        case 'jpg':\n          mimeType = 'image/jpeg';\n          break;\n      }\n\n      htmlCanvas.toBlob(blob => {\n        downloadFile(blob, filename, extension);\n      }, mimeType);\n    }\n  }\n\n  async toBlob() {\n    return new Promise(resolve => {\n      this.canvas.toBlob(resolve);\n    });\n  }\n\n  // GIF Section\n  /**\n   * Restarts an animated GIF at its first frame.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-wink-loop-once.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A cartoon face winks once and then freezes. Clicking resets the face and makes it wink again.');\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   *\n   * // Reset the GIF when the user presses the mouse.\n   * function mousePressed() {\n   *   gif.reset();\n   * }\n   * </code>\n   * </div>\n   */\n  reset() {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      props.playing = true;\n      props.timeSinceStart = 0;\n      props.timeDisplayed = 0;\n      props.lastChangeTime = 0;\n      props.loopCount = 0;\n      props.displayIndex = 0;\n      this.drawingContext.putImageData(props.frames[0].image, 0, 0);\n    }\n  }\n\n  /**\n   * Gets the index of the current frame in an animated GIF.\n   *\n   * @return {Number}       index of the GIF's current frame.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A cartoon eye repeatedly looks around, then outwards. A number displayed in the bottom-left corner increases from 0 to 124, then repeats.');\n   * }\n   *\n   * function draw() {\n   *   // Get the index of the current GIF frame.\n   *   let index = gif.getCurrentFrame();\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   *\n   *   // Display the current frame.\n   *   text(index, 10, 90);\n   * }\n   * </code>\n   * </div>\n   */\n  getCurrentFrame() {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      return props.displayIndex % props.numFrames;\n    }\n  }\n\n  /**\n   * Sets the current frame in an animated GIF.\n   *\n   * @param {Number} index index of the frame to display.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   * let frameSlider;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Get the index of the last frame.\n   *   let maxFrame = gif.numFrames() - 1;\n   *\n   *   // Create a slider to control which frame is drawn.\n   *   frameSlider = createSlider(0, maxFrame);\n   *   frameSlider.position(10, 80);\n   *   frameSlider.size(80);\n   *\n   *   describe('A cartoon eye looks around when a slider is moved.');\n   * }\n   *\n   * function draw() {\n   *   // Get the slider's value.\n   *   let index = frameSlider.value();\n   *\n   *   // Set the GIF's frame.\n   *   gif.setFrame(index);\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   * </code>\n   * </div>\n   */\n  setFrame(index) {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      if (index < props.numFrames && index >= 0) {\n        props.timeDisplayed = 0;\n        props.lastChangeTime = 0;\n        props.displayIndex = index;\n        this.drawingContext.putImageData(props.frames[index].image, 0, 0);\n      } else {\n        console.log(\n          'Cannot set GIF to a frame number that is higher than total number of frames or below zero.'\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns the number of frames in an animated GIF.\n   *\n   * @return {Number} number of frames in the GIF.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A cartoon eye looks around. The text \"n / 125\" is shown at the bottom of the canvas.');\n   * }\n   *\n   * function draw() {\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   *\n   *   // Display the current state of playback.\n   *   let total = gif.numFrames();\n   *   let index = gif.getCurrentFrame();\n   *   text(`${index} / ${total}`, 30, 90);\n   * }\n   * </code>\n   * </div>\n   */\n  numFrames() {\n    if (this.gifProperties) {\n      return this.gifProperties.numFrames;\n    }\n  }\n\n  /**\n   * Plays an animated GIF that was paused with\n   * <a href=\"#/p5.Image/pause\">img.pause()</a>.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *   image(gif, 0, 0);\n   * }\n   *\n   * // Pause the GIF when the user presses the mouse.\n   * function mousePressed() {\n   *   gif.pause();\n   * }\n   *\n   * // Play the GIF when the user releases the mouse.\n   * function mouseReleased() {\n   *   gif.play();\n   * }\n   * </code>\n   * </div>\n   */\n  play() {\n    if (this.gifProperties) {\n      this.gifProperties.playing = true;\n    }\n  }\n\n  /**\n   * Pauses an animated GIF.\n   *\n   * The GIF can be resumed by calling\n   * <a href=\"#/p5.Image/play\">img.play()</a>.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');\n   * }\n   *\n   * function draw() {\n   *   background(255);\n   *\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   *\n   * // Pause the GIF when the user presses the mouse.\n   * function mousePressed() {\n   *   gif.pause();\n   * }\n   *\n   * // Play the GIF when the user presses the mouse.\n   * function mouseReleased() {\n   *   gif.play();\n   * }\n   * </code>\n   * </div>\n   */\n  pause() {\n    if (this.gifProperties) {\n      this.gifProperties.playing = false;\n    }\n  }\n\n  /**\n   * Changes the delay between frames in an animated GIF.\n   *\n   * The first parameter, `delay`, is the length of the delay in milliseconds.\n   *\n   * The second parameter, `index`, is optional. If provided, only the frame\n   * at `index` will have its delay modified. All other frames will keep\n   * their default delay.\n   *\n   * @param {Number} d delay in milliseconds between switching frames.\n   * @param {Number} [index] index of the frame that will have its delay modified.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let gifFast;\n   * let gifSlow;\n   *\n   * async function setup() {\n   *   // Load the images.\n   *   gifFast = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *   gifSlow = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Resize the images.\n   *   gifFast.resize(50, 50);\n   *   gifSlow.resize(50, 50);\n   *\n   *   // Set the delay lengths.\n   *   gifFast.delay(10);\n   *   gifSlow.delay(100);\n   *\n   *   describe('Two animated eyes looking around. The eye on the left moves faster than the eye on the right.');\n   * }\n   *\n   * function draw() {\n   *   // Display the images.\n   *   image(gifFast, 0, 0);\n   *   image(gifSlow, 50, 0);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let gif;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Set the delay of frame 67.\n   *   gif.delay(3000, 67);\n   *\n   *   describe('An animated eye looking around. It pauses for three seconds while it looks down.');\n   * }\n   *\n   * function draw() {\n   *   // Display the image.\n   *   image(gif, 0, 0);\n   * }\n   * </code>\n   * </div>\n   */\n  delay(d, index) {\n    if (this.gifProperties) {\n      const props = this.gifProperties;\n      if (index < props.numFrames && index >= 0) {\n        props.frames[index].delay = d;\n      } else {\n        // change all frames\n        for (const frame of props.frames) {\n          frame.delay = d;\n        }\n      }\n    }\n  }\n}\nfunction encodeAndDownloadGif(pImg, filename) {\n  const props = pImg.gifProperties;\n\n  //convert loopLimit back into Netscape Block formatting\n  let loopLimit = props.loopLimit;\n  if (loopLimit === 1) {\n    loopLimit = null;\n  } else if (loopLimit === null) {\n    loopLimit = 0;\n  }\n  const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);\n\n  const allFramesPixelColors = [];\n\n  // Used to determine the occurrence of unique palettes and the frames\n  // which use them\n  const paletteFreqsAndFrames = {};\n\n  // Pass 1:\n  //loop over frames and get the frequency of each palette\n  for (let i = 0; i < props.numFrames; i++) {\n    const paletteSet = new Set();\n    const data = props.frames[i].image.data;\n    const dataLength = data.length;\n    // The color for each pixel in this frame ( for easier lookup later )\n    const pixelColors = new Uint32Array(pImg.width * pImg.height);\n    for (let j = 0, k = 0; j < dataLength; j += 4, k++) {\n      const r = data[j + 0];\n      const g = data[j + 1];\n      const b = data[j + 2];\n      const color = (r << 16) | (g << 8) | (b << 0);\n      paletteSet.add(color);\n\n      // What color does this pixel have in this frame ?\n      pixelColors[k] = color;\n    }\n\n    // A way to put use the entire palette as an object key\n    const paletteStr = [...paletteSet].sort().toString();\n    if (paletteFreqsAndFrames[paletteStr] === undefined) {\n      paletteFreqsAndFrames[paletteStr] = { freq: 1, frames: [i] };\n    } else {\n      paletteFreqsAndFrames[paletteStr].freq += 1;\n      paletteFreqsAndFrames[paletteStr].frames.push(i);\n    }\n\n    allFramesPixelColors.push(pixelColors);\n  }\n\n  let framesUsingGlobalPalette = [];\n\n  // Now to build the global palette\n  // Sort all the unique palettes in descending order of their occurrence\n  const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(\n    a,\n    b\n  ) {\n    return paletteFreqsAndFrames[b].freq - paletteFreqsAndFrames[a].freq;\n  });\n\n  // The initial global palette is the one with the most occurrence\n  const globalPalette = palettesSortedByFreq[0]\n    .split(',')\n    .map(a => parseInt(a));\n\n  framesUsingGlobalPalette = framesUsingGlobalPalette.concat(\n    paletteFreqsAndFrames[globalPalette].frames\n  );\n\n  const globalPaletteSet = new Set(globalPalette);\n\n  // Build a more complete global palette\n  // Iterate over the remaining palettes in the order of\n  // their occurrence and see if the colors in this palette which are\n  // not in the global palette can be added there, while keeping the length\n  // of the global palette <= 256\n  for (let i = 1; i < palettesSortedByFreq.length; i++) {\n    const palette = palettesSortedByFreq[i].split(',').map(a => parseInt(a));\n\n    const difference = palette.filter(x => !globalPaletteSet.has(x));\n    if (globalPalette.length + difference.length <= 256) {\n      for (let j = 0; j < difference.length; j++) {\n        globalPalette.push(difference[j]);\n        globalPaletteSet.add(difference[j]);\n      }\n\n      // All frames using this palette now use the global palette\n      framesUsingGlobalPalette = framesUsingGlobalPalette.concat(\n        paletteFreqsAndFrames[palettesSortedByFreq[i]].frames\n      );\n    }\n  }\n\n  framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);\n\n  // Build a lookup table of the index of each color in the global palette\n  // Maps a color to its index\n  const globalIndicesLookup = {};\n  for (let i = 0; i < globalPalette.length; i++) {\n    if (!globalIndicesLookup[globalPalette[i]]) {\n      globalIndicesLookup[globalPalette[i]] = i;\n    }\n  }\n\n  // force palette to be power of 2\n  let powof2 = 1;\n  while (powof2 < globalPalette.length) {\n    powof2 <<= 1;\n  }\n  globalPalette.length = powof2;\n\n  // global opts\n  const opts = {\n    loop: loopLimit,\n    palette: new Uint32Array(globalPalette)\n  };\n  const gifWriter = new omggif.GifWriter(buffer, pImg.width, pImg.height, opts);\n  let previousFrame = {};\n\n  // Pass 2\n  // Determine if the frame needs a local palette\n  // Also apply transparency optimization. This function will often blow up\n  // the size of a GIF if not for transparency. If a pixel in one frame has\n  // the same color in the previous frame, that pixel can be marked as\n  // transparent. We decide one particular color as transparent and make all\n  // transparent pixels take this color. This helps in later in compression.\n  for (let i = 0; i < props.numFrames; i++) {\n    const localPaletteRequired = !framesUsingGlobalPalette.has(i);\n    const palette = localPaletteRequired ? [] : globalPalette;\n    const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);\n\n    // Lookup table mapping color to its indices\n    const colorIndicesLookup = {};\n\n    // All the colors that cannot be marked transparent in this frame\n    const cannotBeTransparent = new Set();\n\n    allFramesPixelColors[i].forEach((color, k) => {\n      if (localPaletteRequired) {\n        if (colorIndicesLookup[color] === undefined) {\n          colorIndicesLookup[color] = palette.length;\n          palette.push(color);\n        }\n        pixelPaletteIndex[k] = colorIndicesLookup[color];\n      } else {\n        pixelPaletteIndex[k] = globalIndicesLookup[color];\n      }\n\n      if (i > 0) {\n        // If even one pixel of this color has changed in this frame\n        // from the previous frame, we cannot mark it as transparent\n        if (allFramesPixelColors[i - 1][k] !== color) {\n          cannotBeTransparent.add(color);\n        }\n      }\n    });\n\n    const frameOpts = {};\n\n    // Transparency optimization\n    const canBeTransparent = palette.filter(a => !cannotBeTransparent.has(a));\n    if (canBeTransparent.length > 0) {\n      // Select a color to mark as transparent\n      const transparent = canBeTransparent[0];\n      const transparentIndex = localPaletteRequired\n        ? colorIndicesLookup[transparent]\n        : globalIndicesLookup[transparent];\n      if (i > 0) {\n        for (let k = 0; k < allFramesPixelColors[i].length; k++) {\n          // If this pixel in this frame has the same color in previous frame\n          if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {\n            pixelPaletteIndex[k] = transparentIndex;\n          }\n        }\n        frameOpts.transparent = transparentIndex;\n        // If this frame has any transparency, do not dispose the previous frame\n        previousFrame.frameOpts.disposal = 1;\n      }\n    }\n    frameOpts.delay = props.frames[i].delay / 10; // Move timing back into GIF formatting\n    if (localPaletteRequired) {\n      // force palette to be power of 2\n      let powof2 = 1;\n      while (powof2 < palette.length) {\n        powof2 <<= 1;\n      }\n      palette.length = powof2;\n      frameOpts.palette = new Uint32Array(palette);\n    }\n    if (i > 0) {\n      // add the frame that came before the current one\n      gifWriter.addFrame(\n        0,\n        0,\n        pImg.width,\n        pImg.height,\n        previousFrame.pixelPaletteIndex,\n        previousFrame.frameOpts\n      );\n    }\n    // previous frame object should now have details of this frame\n    previousFrame = {\n      pixelPaletteIndex,\n      frameOpts\n    };\n  }\n\n  previousFrame.frameOpts.disposal = 1;\n  // add the last frame\n  gifWriter.addFrame(\n    0,\n    0,\n    pImg.width,\n    pImg.height,\n    previousFrame.pixelPaletteIndex,\n    previousFrame.frameOpts\n  );\n\n  const extension = 'gif';\n  const blob = new Blob([buffer.slice(0, gifWriter.end())], {\n    type: 'image/gif'\n  });\n  downloadFile(blob, filename, extension);\n}\nfunction image(p5, fn){\n  /**\n   * A class to describe an image.\n   *\n   * Images are rectangular grids of pixels that can be displayed and modified.\n   *\n   * Existing images can be loaded by calling\n   * <a href=\"#/p5/loadImage\">loadImage()</a>. Blank images can be created by\n   * calling <a href=\"#/p5/createImage\">createImage()</a>. `p5.Image` objects\n   * have methods for common tasks such as applying filters and modifying\n   * pixel values.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('An image of a brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/bricks.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Apply the GRAY filter.\n   *   img.filter(GRAY);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   describe('A grayscale image of a brick wall.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to black.\n   *   for (let x = 0; x < img.width; x += 1) {\n   *     for (let y = 0; y < img.height; y += 1) {\n   *       img.set(x, y, 0);\n   *     }\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @class p5.Image\n   * @param {Number} width\n   * @param {Number} height\n   */\n  p5.Image = Image;\n\n  /**\n   * The image's width in pixels.\n   *\n   * @type {Number}\n   * @property {Number} width\n   * @for p5.Image\n   * @name width\n   * @readOnly\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Calculate the center coordinates.\n   *   let x = img.width / 2;\n   *   let y = img.height / 2;\n   *\n   *   // Draw a circle at the image's center.\n   *   circle(x, y, 20);\n   *\n   *   describe('An image of a mountain landscape with a white circle drawn in the middle.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * The image's height in pixels.\n   *\n   * @type {Number}\n   * @property height\n   * @for p5.Image\n   * @name height\n   * @readOnly\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load the image.\n   *   img = await loadImage('assets/rockies.jpg');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   // Display the image.\n   *   image(img, 0, 0);\n   *\n   *   // Calculate the center coordinates.\n   *   let x = img.width / 2;\n   *   let y = img.height / 2;\n   *\n   *   // Draw a circle at the image's center.\n   *   circle(x, y, 20);\n   *\n   *   describe('An image of a mountain landscape with a white circle drawn in the middle.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array containing the color of each pixel in the image.\n   *\n   * Colors are stored as numbers representing red, green, blue, and alpha\n   * (RGBA) values. `img.pixels` is a one-dimensional array for performance\n   * reasons.\n   *\n   * Each pixel occupies four elements in the pixels array, one for each\n   * RGBA value. For example, the pixel at coordinates (0, 0) stores its\n   * RGBA values at `img.pixels[0]`, `img.pixels[1]`, `img.pixels[2]`,\n   * and `img.pixels[3]`, respectively. The next pixel at coordinates (1, 0)\n   * stores its RGBA values at `img.pixels[4]`, `img.pixels[5]`,\n   * `img.pixels[6]`, and `img.pixels[7]`. And so on. The `img.pixels` array\n   * for a 100×100 <a href=\"#/p5.Image\">p5.Image</a> object has\n   * 100 × 100 × 4 = 40,000 elements.\n   *\n   * Accessing the RGBA values for a pixel in the image requires a little\n   * math as shown in the examples below. The\n   * <a href=\"#/p5.Image/loadPixels\">img.loadPixels()</a>\n   * method must be called before accessing the `img.pixels` array. The\n   * <a href=\"#/p5.Image/updatePixels\">img.updatePixels()</a> method must be\n   * called after any changes are made.\n   *\n   * @property {Number[]} pixels\n   * @for p5.Image\n   * @name pixels\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 0;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A black square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Image object.\n   *   let img = createImage(66, 66);\n   *\n   *   // Load the image's pixels.\n   *   img.loadPixels();\n   *\n   *   // Set the pixels to red.\n   *   for (let i = 0; i < img.pixels.length; i += 4) {\n   *     // Red.\n   *     img.pixels[i] = 255;\n   *     // Green.\n   *     img.pixels[i + 1] = 0;\n   *     // Blue.\n   *     img.pixels[i + 2] = 0;\n   *     // Alpha.\n   *     img.pixels[i + 3] = 255;\n   *   }\n   *\n   *   // Update the image.\n   *   img.updatePixels();\n   *\n   *   // Display the image.\n   *   image(img, 17, 17);\n   *\n   *   describe('A red square drawn in the middle of a gray square.');\n   * }\n   * </code>\n   * </div>\n   */\n}\n\nif(typeof p5 !== 'undefined'){\n  image(p5, p5.prototype);\n}\n\n/**\n * @module Rendering\n * @submodule Rendering\n * @for p5\n */\n\n\nclass ClonableObject {\n  constructor(obj = {}) {\n    for (const key in obj) {\n      this[key] = obj[key];\n    }\n  }\n\n  clone() {\n    return new ClonableObject(this);\n  }\n}\nclass Renderer {\n  static states = {\n    strokeColor: null,\n    strokeSet: false,\n    fillColor: null,\n    fillSet: false,\n    tint: null,\n\n    imageMode: CORNER,\n    rectMode: CORNER,\n    ellipseMode: CENTER,\n    strokeWeight: 1,\n\n    textFont: { family: 'sans-serif' },\n    textLeading: 15,\n    leadingSet: false,\n    textSize: 12,\n    textAlign: LEFT,\n    textBaseline: BASELINE,\n    bezierOrder: 3,\n    splineProperties: new ClonableObject({ ends: INCLUDE, tightness: 0 }),\n    textWrap: WORD,\n\n    // added v2.0\n    fontStyle: NORMAL, // v1: textStyle\n    fontStretch: NORMAL,\n    fontWeight: NORMAL,\n    lineHeight: NORMAL,\n    fontVariant: NORMAL,\n    direction: 'inherit'\n  }\n\n  constructor(pInst, w, h, isMainCanvas) {\n    this._pInst = pInst;\n    this._isMainCanvas = isMainCanvas;\n    this.pixels = [];\n    this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;\n\n    this.width = w;\n    this.height = h;\n\n    this._events = {};\n\n    if (isMainCanvas) {\n      this._isMainCanvas = true;\n    }\n\n    // Renderer state machine\n    this.states = new States(Renderer.states);\n\n    this.states.strokeColor = new Color([0, 0, 0]);\n    this.states.fillColor = new Color([1, 1, 1]);\n\n    this._pushPopStack = [];\n    // NOTE: can use the length of the push pop stack instead\n    this._pushPopDepth = 0;\n\n    this._clipping = false;\n    this._clipInvert = false;\n\n    this._currentShape = undefined; // Lazily generate current shape\n  }\n\n  get currentShape() {\n    if (!this._currentShape) {\n      this._currentShape = new Shape(this.getCommonVertexProperties());\n    }\n    return this._currentShape;\n  }\n\n  remove() {\n\n  }\n\n  pixelDensity(val){\n    let returnValue;\n    if (typeof val === 'number') {\n      if (val !== this._pixelDensity) {\n        this._pixelDensity = val;\n      }\n      returnValue = this;\n      this.resize(this.width, this.height);\n    } else {\n      returnValue = this._pixelDensity;\n    }\n    return returnValue;\n  }\n\n  // Makes a shallow copy of the current states\n  // and push it into the push pop stack\n  push() {\n    this._pushPopDepth++;\n    this._pushPopStack.push(this.states.getDiff());\n  }\n\n  // Pop the previous states out of the push pop stack and\n  // assign it back to the current state\n  pop() {\n    this._pushPopDepth--;\n    const diff = this._pushPopStack.pop() || {};\n    const modified = this.states.getModified();\n    this.states.applyDiff(diff);\n    this.updateShapeVertexProperties(modified);\n    this.updateShapeProperties(modified);\n  }\n\n  bezierOrder(order) {\n    if (order === undefined) {\n      return this.states.bezierOrder;\n    } else {\n      this.states.setValue('bezierOrder', order);\n      this.updateShapeProperties();\n    }\n  }\n\n  bezierVertex(x, y, z = 0, u = 0, v = 0) {\n    const position = new Vector(x, y, z);\n    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates\n      ? new Vector(u, v)\n      : undefined;\n    this.currentShape.bezierVertex(position, textureCoordinates);\n  }\n\n  splineProperty(key, value) {\n    if (value === undefined) {\n      return this.states.splineProperties[key];\n    } else {\n      this.states.setValue('splineProperties', this.states.splineProperties.clone());\n      this.states.splineProperties[key] = value;\n    }\n    this.updateShapeProperties();\n  }\n\n  splineProperties(values) {\n    if (values) {\n      for (const key in values) {\n        this.splineProperty(key, values[key]);\n      }\n    } else {\n      return { ...this.states.splineProperties };\n    }\n  }\n\n  splineVertex(x, y, z = 0, u = 0, v = 0) {\n    const position = new Vector(x, y, z);\n    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates\n      ? new Vector(u, v)\n      : undefined;\n    this.currentShape.splineVertex(position, textureCoordinates);\n  }\n\n  curveDetail(d) {\n    if (d === undefined) {\n      return this.states.curveDetail;\n    } else {\n      this.states.setValue('curveDetail', d);\n    }\n  }\n\n  beginShape(...args) {\n    this.currentShape.reset();\n    this.updateShapeVertexProperties();\n    this.currentShape.beginShape(...args);\n  }\n\n  endShape(...args) {\n    this.currentShape.endShape(...args);\n    this.drawShape(this.currentShape);\n  }\n\n  beginContour(shapeKind) {\n    this.currentShape.beginContour(shapeKind);\n  }\n\n  endContour(mode) {\n    this.currentShape.endContour(mode);\n  }\n\n  drawShape(shape, count) {\n    throw new Error('Unimplemented')\n  }\n\n  vertex(x, y, z = 0, u = 0, v = 0) {\n    const position = new Vector(x, y, z);\n    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates\n      ? new Vector(u, v)\n      : undefined;\n    this.currentShape.vertex(position, textureCoordinates);\n  }\n\n  bezier(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const oldOrder = this._pInst.bezierOrder();\n    this._pInst.bezierOrder(oldOrder);\n    this._pInst.beginShape();\n    this._pInst.bezierVertex(x1, y1);\n    this._pInst.bezierVertex(x2, y2);\n    this._pInst.bezierVertex(x3, y3);\n    this._pInst.bezierVertex(x4, y4);\n    this._pInst.endShape();\n    return this;\n  }\n\n  spline(...args) {\n    if (args.length === 2 * 4) {\n      const [x1, y1, x2, y2, x3, y3, x4, y4] = args;\n      this._pInst.beginShape();\n      this._pInst.splineVertex(x1, y1);\n      this._pInst.splineVertex(x2, y2);\n      this._pInst.splineVertex(x3, y3);\n      this._pInst.splineVertex(x4, y4);\n      this._pInst.endShape();\n    } else if (args.length === 3 * 4) {\n      const [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = args;\n      this._pInst.beginShape();\n      this._pInst.splineVertex(x1, y1, z1);\n      this._pInst.splineVertex(x2, y2, z2);\n      this._pInst.splineVertex(x3, y3, z3);\n      this._pInst.splineVertex(x4, y4, z4);\n      this._pInst.endShape();\n    }\n    return this;\n  }\n\n  beginClip(options = {}) {\n    if (this._clipping) {\n      throw new Error(\"It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?\");\n    }\n    this._clipping = true;\n    this._clipInvert = options.invert;\n  }\n\n  endClip() {\n    if (!this._clipping) {\n      throw new Error(\"It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?\");\n    }\n    this._clipping = false;\n  }\n\n  /**\n   * Resize our canvas element.\n   */\n  resize(w, h) {\n    this.width = w;\n    this.height = h;\n  }\n\n  get(x, y, w, h) {\n    const pd = this._pixelDensity;\n    const canvas = this.canvas;\n\n    if (typeof x === 'undefined' && typeof y === 'undefined') {\n    // get()\n      x = y = 0;\n      w = this.width;\n      h = this.height;\n    } else {\n      x *= pd;\n      y *= pd;\n\n      if (typeof w === 'undefined' && typeof h === 'undefined') {\n      // get(x,y)\n        if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {\n          return [0, 0, 0, 0];\n        }\n\n        return this._getPixel(x, y);\n      }\n    // get(x,y,w,h)\n    }\n\n    const region = new Image(w*pd, h*pd);\n    region.pixelDensity(pd);\n    region.canvas\n      .getContext('2d')\n      .drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w*pd, h*pd);\n\n    return region;\n  }\n\n  scale(x, y){\n\n  }\n\n  fill(...args) {\n    this.states.setValue('fillSet', true);\n    this.states.setValue('fillColor', this._pInst.color(...args));\n    this.updateShapeVertexProperties();\n  }\n\n  noFill() {\n    this.states.setValue('fillColor', null);\n  }\n\n  strokeWeight(w) {\n    if (w === undefined) {\n      return this.states.strokeWeight;\n    } else {\n      this.states.setValue('strokeWeight', w);\n    }\n  }\n\n  stroke(...args) {\n    this.states.setValue('strokeSet', true);\n    this.states.setValue('strokeColor', this._pInst.color(...args));\n    this.updateShapeVertexProperties();\n  }\n\n  noStroke() {\n    this.states.setValue('strokeColor', null);\n  }\n\n  getCommonVertexProperties() {\n    return {}\n  }\n\n  getSupportedIndividualVertexProperties() {\n    return {\n      textureCoordinates: false,\n    }\n  }\n\n  updateShapeProperties(modified) {\n    if (!modified || modified.bezierOrder || modified.splineProperties) {\n      const shape = this.currentShape;\n      shape.bezierOrder(this.states.bezierOrder);\n      shape.splineProperty('ends', this.states.splineProperties.ends);\n      shape.splineProperty('tightness', this.states.splineProperties.tightness);\n    }\n  }\n\n  updateShapeVertexProperties(modified) {\n    const props = this.getCommonVertexProperties();\n    if (!modified || Object.keys(modified).some((k) => k in props)) {\n      const shape = this.currentShape;\n      for (const key in props) {\n        shape[key](props[key]);\n      }\n    }\n  }\n\n  _applyDefaults() {\n    return this;\n  }\n\n}\nfunction renderer(p5, fn){\n  /**\n   * Main graphics and rendering context, as well as the base API\n   * implementation for p5.js \"core\". To be used as the superclass for\n   * Renderer2D and Renderer3D classes, respectively.\n   *\n   * @class p5.Renderer\n   * @param {HTMLElement} elt DOM node that is wrapped\n   * @param {p5} [pInst] pointer to p5 instance\n   * @param {Boolean} [isMainCanvas] whether we're using it as main canvas\n   * @private\n   */\n  p5.Renderer = Renderer;\n}\n\nexport { Image as I, Renderer as R, image as i, renderer as r };\n"],"mappings":"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AK,CAACW,YAAY,GAAGQ,GAAG;UACxB,IAAI,CAACG,WAAW,CAAC,IAAI,CAAC;QACxB;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAAA,EAAG;IACX;IACA,MAAMC,WAAW,GAAG,IAAI,CAACjC,YAAY;IACrC,MAAMkC,EAAE,GAAG,IAAI,CAACjC,aAAa;IAC7B,MAAMkC,CAAC,GAAG,IAAI,CAAC1C,KAAK,GAAGyC,EAAE;IACzB,MAAME,CAAC,GAAG,IAAI,CAAC1C,MAAM,GAAGwC,EAAE;IAC1B,MAAMG,SAAS,GAAG,IAAI,CAACvC,cAAc,CAACwC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAEH,CAAC,EAAEC,CAAC,CAAC;IAC9D;IACA;IACAH,WAAW,CAACI,SAAS,GAAGA,SAAS;IACjC,IAAI,CAACjC,MAAM,GAAG6B,WAAW,CAAC7B,MAAM,GAAGiC,SAAS,CAACE,IAAI;IACjD,IAAI,CAACR,WAAW,CAAC,IAAI,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,YAAYA,CAACC,CAAC,EAAEC,CAAC,EAAEP,CAAC,EAAEC,CAAC,EAAE;IACvB;IACA,MAAMH,WAAW,GAAG,IAAI,CAACjC,YAAY;IACrC,MAAMkC,EAAE,GAAG,IAAI,CAACjC,aAAa;IAC7B,IACEwC,CAAC,KAAKE,SAAS,IACfD,CAAC,KAAKC,SAAS,IACfR,CAAC,KAAKQ,SAAS,IACfP,CAAC,KAAKO,SAAS,EACf;MACAF,CAAC,GAAG,CAAC;MACLC,CAAC,GAAG,CAAC;MACLP,CAAC,GAAG,IAAI,CAAC1C,KAAK;MACd2C,CAAC,GAAG,IAAI,CAAC1C,MAAM;IACjB;IACA+C,CAAC,IAAIP,EAAE;IACPQ,CAAC,IAAIR,EAAE;IACPC,CAAC,IAAID,EAAE;IACPE,CAAC,IAAIF,EAAE;IAEP,IAAI,IAAI,CAAChC,aAAa,EAAE;MACtB,IAAI,CAACA,aAAa,CAACiB,MAAM,CAAC,IAAI,CAACjB,aAAa,CAACkB,YAAY,CAAC,CAACU,KAAK,GAC9DG,WAAW,CAACI,SAAS;IACzB;IAEA,IAAI,CAACvC,cAAc,CAAC+B,YAAY,CAACI,WAAW,CAACI,SAAS,EAAEI,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEP,CAAC,EAAEC,CAAC,CAAC;IACzE,IAAI,CAACL,WAAW,CAAC,IAAI,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;EACE;AACF;AACA;AACA;AACA;EACEa,GAAGA,CAACH,CAAC,EAAEC,CAAC,EAAEP,CAAC,EAAEC,CAAC,EAAE;IACd;IACA;IACA,MAAMH,WAAW,GAAG,IAAI,CAACjC,YAAY;IACrC,MAAMkC,EAAE,GAAG,IAAI,CAACjC,aAAa;IAC7B,MAAMN,MAAM,GAAG,IAAI,CAACA,MAAM;IAE1B,IAAI,OAAO8C,CAAC,KAAK,WAAW,IAAI,OAAOC,CAAC,KAAK,WAAW,EAAE;MAC1D;MACED,CAAC,GAAGC,CAAC,GAAG,CAAC;MACTP,CAAC,GAAGF,WAAW,CAACxC,KAAK;MACrB2C,CAAC,GAAGH,WAAW,CAACvC,MAAM;IACxB,CAAC,MAAM;MACL+C,CAAC,IAAIP,EAAE;MACPQ,CAAC,IAAIR,EAAE;MAEP,IAAI,OAAOC,CAAC,KAAK,WAAW,IAAI,OAAOC,CAAC,KAAK,WAAW,EAAE;QAC1D;QACE,IAAIK,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,IAAID,CAAC,IAAI9C,MAAM,CAACF,KAAK,IAAIiD,CAAC,IAAI/C,MAAM,CAACD,MAAM,EAAE;UAC7D,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACrB;QAEA,OAAO,IAAI,CAACmD,SAAS,CAACJ,CAAC,EAAEC,CAAC,CAAC;MAC7B;MACF;IACA;IAEA,MAAMI,MAAM,GAAG,IAAIvD,KAAK,CAAC4C,CAAC,GAACD,EAAE,EAAEE,CAAC,GAACF,EAAE,CAAC;IACpCY,MAAM,CAACzC,YAAY,CAAC6B,EAAE,CAAC;IACvBY,MAAM,CAACnD,MAAM,CACVI,UAAU,CAAC,IAAI,CAAC,CAChBgD,SAAS,CAACpD,MAAM,EAAE8C,CAAC,EAAEC,CAAC,EAAEP,CAAC,GAAGD,EAAE,EAAEE,CAAC,GAAGF,EAAE,EAAE,CAAC,EAAE,CAAC,EAAEC,CAAC,GAACD,EAAE,EAAEE,CAAC,GAACF,EAAE,CAAC;IAE5D,OAAOY,MAAM;EACf;EAEAD,SAASA,CAACJ,CAAC,EAAEC,CAAC,EAAE;IACd,IAAIL,SAAS,EAAEW,KAAK;IACpBX,SAAS,GAAG,IAAI,CAACvC,cAAc,CAACwC,YAAY,CAACG,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACH,IAAI;IAC7DS,KAAK,GAAG,CAAC;IACT,OAAO,CACLX,SAAS,CAACW,KAAK,GAAG,CAAC,CAAC,EACpBX,SAAS,CAACW,KAAK,GAAG,CAAC,CAAC,EACpBX,SAAS,CAACW,KAAK,GAAG,CAAC,CAAC,EACpBX,SAAS,CAACW,KAAK,GAAG,CAAC,CAAC,CACrB;IACD;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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AACwD,GAAG,GAAG,CAAC,CAAC,GAAGF,CAAC;UAC/BzB,WAAW,CAAC7B,MAAM,CAACwD,GAAG,GAAG,CAAC,CAAC,GAAGD,CAAC;QACjC;MACF;IACF;IACA,IAAI,CAAC5B,WAAW,CAAC,IAAI,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEsC,MAAMA,CAAC5E,KAAK,EAAEC,MAAM,EAAE;IACpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA,IAAID,KAAK,KAAK,CAAC,IAAIC,MAAM,KAAK,CAAC,EAAE;MAC/BD,KAAK,GAAG,IAAI,CAACE,MAAM,CAACF,KAAK;MACzBC,MAAM,GAAG,IAAI,CAACC,MAAM,CAACD,MAAM;IAC7B,CAAC,MAAM,IAAID,KAAK,KAAK,CAAC,EAAE;MACtBA,KAAK,GAAG,IAAI,CAACE,MAAM,CAACF,KAAK,GAAGC,MAAM,GAAG,IAAI,CAACC,MAAM,CAACD,MAAM;IACzD,CAAC,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;MACvBA,MAAM,GAAG,IAAI,CAACC,MAAM,CAACD,MAAM,GAAGD,KAAK,GAAG,IAAI,CAACE,MAAM,CAACF,KAAK;IACzD;IAEAA,KAAK,GAAG8B,IAAI,CAACC,KAAK,CAAC/B,KAAK,CAAC;IACzBC,MAAM,GAAG6B,IAAI,CAACC,KAAK,CAAC9B,MAAM,CAAC;IAE3B,MAAM4E,UAAU,GAAG1E,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CAAC,EACDuE,cAAc,GAAG,IAAI,CAACpH,KAAK,EAC3BoH,cAAc,GAAG,IAAI,CAACnH,MACxB,CAAC;MACH;MACA,IAAI,CAACI,cAAc,CAAC+B,YAAY,CAC9B,IAAI,CAAC3B,aAAa,CAACiB,MAAM,CAAC,IAAI,CAACjB,aAAa,CAACkB,YAAY,CAAC,CAACU,KAAK,EAChE,CAAC,EACD,CACF,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACkD,IAAI,CAAC,GAAGiC,QAAQ,CAAC;IACxB;IACA,IAAI,CAACnH,cAAc,CAAC8G,wBAAwB,GAAGD,SAAS;IACxD,IAAI,CAAC5E,WAAW,CAAC,IAAI,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEmF,MAAMA,CAACC,SAAS,EAAEC,KAAK,EAAE;IACvBnI,OAAO,CAACoI,KAAK,CAAC,IAAI,CAAC1H,MAAM,EAAEV,OAAO,CAACkI,SAAS,CAAC,EAAEC,KAAK,CAAC;IACrD,IAAI,CAACrF,WAAW,CAAC,IAAI,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuF,KAAKA,CAAC,GAAGrC,IAAI,EAAE;IACb,MAAM0B,SAAS,GAAG,IAAI,CAAC7G,cAAc,CAAC8G,wBAAwB;IAC9D,MAAMP,SAAS,GAAGpB,IAAI,CAACA,IAAI,CAACpB,MAAM,GAAG,CAA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F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE8G,QAAQA,CAACxF,KAAK,EAAE;IACd,IAAI,IAAI,CAAC9C,aAAa,EAAE;MACtB,MAAMO,KAAK,GAAG,IAAI,CAACP,aAAa;MAChC,IAAI8C,KAAK,GAAGvC,KAAK,CAACiB,SAAS,IAAIsB,KAAK,IAAI,CAAC,EAAE;QACzCvC,KAAK,CAACQ,aAAa,GAAG,CAAC;QACvBR,KAAK,CAACM,cAAc,GAAG,CAAC;QACxBN,KAAK,CAACW,YAAY,GAAG4B,KAAK;QAC1B,IAAI,CAAClD,cAAc,CAAC+B,YAAY,CAACpB,KAAK,CAACU,MAAM,CAAC6B,KAAK,CAAC,CAAClB,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;MACnE,CAAC,MAAM;QACL2G,OAAO,CAACC,GAAG,CACT,4FACF,CAAC;MACH;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEhH,SAASA,CAAA,EAAG;IACV,IAAI,IAAI,CAACxB,aAAa,EAAE;MACtB,OAAO,IAAI,CAACA,aAAa,CAACwB,SAAS;IACrC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEiH,IAAIA,CAAA,EAAG;IACL,IAAI,IAAI,CAACzI,aAAa,EAAE;MACtB,IAAI,CAACA,aAAa,CAACc,OAAO,GAAG,IAAI;IACnC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4H,KAAKA,CAAA,EAAG;IACN,IAAI,IAAI,CAAC1I,aAAa,EAAE;MACtB,IAAI,CAACA,aAAa,CAACc,OAAO,GAAG,KAAK;IACpC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,KAAKA,CAACwH,CAAC,EAAE7F,KAAK,EAAE;IACd,IAAI,IAAI,CAAC9C,aAAa,EAAE;MACtB,MAAMO,KAAK,GAAG,IAAI,CAACP,aAAa;MAChC,IAAI8C,KAAK,GAAGvC,KAAK,CAACiB,SAAS,IAAIsB,KAAK,IAAI,CAAC,EAAE;QACzCvC,KAAK,CAACU,MAAM,CAAC6B,KAAK,CAAC,CAAC3B,KAAK,GAAGwH,CAAC;MAC/B,CAAC,MAAM;QACL;QACA,KAAK,MAAMC,KAAK,IAAIrI,KAAK,CAACU,MAAM,EAAE;UAChC2H,KAAK,CAACzH,KAAK,GAAGwH,CAAC;QACjB;MACF;IACF;EACF;AACF;AACA,SAASf,oBAAoBA,CAACiB,IAAI,EAAEnB,QAAQ,EAAE;EAC5C,MAAMnH,KAAK,GAAGsI,IAAI,CAAC7I,aAAa;;EAEhC;EACA,IAAIyB,SAAS,GAAGlB,KAAK,CAACkB,SAAS;EAC/B,IAAIA,SAAS,KAAK,CAAC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EACX0L,aAAa,CAACE,iBAAiB,EAC/BF,aAAa,CAACM,SAChB,CAAC;EAED,MAAM7D,SAAS,GAAG,KAAK;EACvB,MAAMK,IAAI,GAAG,IAAI8D,IAAI,CAAC,CAAChD,MAAM,CAACxB,KAAK,CAAC,CAAC,EAAEyD,SAAS,CAACgB,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;IACxDC,IAAI,EAAE;EACR,CAAC,CAAC;EACF5M,YAAY,CAAC4I,IAAI,EAAEN,QAAQ,EAAEC,SAAS,CAAC;AACzC;AACA,SAAS/F,KAAKA,CAACmC,EAAE,EAAEkI,EAAE,EAAC;EACpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACElI,EAAE,CAAC1E,KAAK,GAAGA,KAAK;;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAG,OAAO0E,EAAE,KAAK,WAAW,EAAC;EAC3BnC,KAAK,CAACmC,EAAE,EAAEA,EAAE,CAACsD,SAAS,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAGA,MAAM6E,cAAc,CAAC;EACnB5M,WAAWA,CAAC6M,GAAG,GAAG,CAAC,CAAC,EAAE;IACpB,KAAK,MAAMC,GAAG,IAAID,GAAG,EAAE;MACrB,IAAI,CAACC,GAAG,CAAC,GAAGD,GAAG,CAACC,GAAG,CAAC;IACtB;EACF;EAEAC,KAAKA,CAAA,EAAG;IACN,OAAO,IAAIH,cAAc,CAAC,IAAI,CAAC;EACjC;AACF;AACA,MAAMrF,QAAQ,CAAC;EACb,OAAOyF,MAAM,GAAG;IACdC,WAAW,EAAE,IAAI;IACjBC,SAAS,EAAE,KAAK;IAChBC,SAAS,EAAE,IAAI;IACfC,OAAO,EAAE,KAAK;IACdC,IAAI,EAAE,IAAI;IAEVtG,SAAS,EAAEzH,MAAM;IACjBgO,QAAQ,EAAEhO,MAAM;IAChBiO,WAAW,EAAEnO,MAAM;IACnBoO,YAAY,EAAE,CAAC;IAEfC,QAAQ,EAAE;MAAEC,MAAM,EAAE;IAAa,CAAC;IAClCC,WAAW,EAAE,EAAE;IACfC,UAAU,EAAE,KAAK;IACjBC,QAAQ,EAAE,EAAE;IACZC,SAAS,EAAE3O,IAAI;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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}