{"ast":null,"code":"import ColorSpace from \"../space.js\";\nimport { constrain } from \"../angles.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport { fromCam16, toCam16, environment } from \"./cam16.js\";\nimport { WHITES } from \"../adapt.js\";\nconst white = WHITES.D65;\nconst ε = 216 / 24389; // 6^3/29^3 == (24/116)^3\nconst κ = 24389 / 27; // 29^3/3^3\n\nfunction toLstar(y) {\n  // Convert XYZ Y to L*\n\n  const fy = y > ε ? Math.cbrt(y) : (κ * y + 16) / 116;\n  return 116.0 * fy - 16.0;\n}\nfunction fromLstar(lstar) {\n  // Convert L* back to XYZ Y\n\n  return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / κ;\n}\nfunction fromHct(coords, env) {\n  // Use Newton's method to try and converge as quick as possible or\n  // converge as close as we can. While the requested precision is achieved\n  // most of the time, it may not always be achievable. Especially past the\n  // visible spectrum, the algorithm will likely struggle to get the same\n  // precision. If, for whatever reason, we cannot achieve the accuracy we\n  // seek in the allotted iterations, just return the closest we were able to\n  // get.\n\n  let [h, c, t] = coords;\n  let xyz = [];\n  let j = 0;\n\n  // Shortcut out for black\n  if (t === 0) {\n    return [0.0, 0.0, 0.0];\n  }\n\n  // Calculate the Y we need to target\n  let y = fromLstar(t);\n\n  // A better initial guess yields better results. Polynomials come from\n  // curve fitting the T vs J response.\n  if (t > 0) {\n    j = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;\n  } else {\n    j = 9.514440756550361e-06 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;\n  }\n\n  // Threshold of how close is close enough, and max number of attempts.\n  // More precision and more attempts means more time spent iterating. Higher\n  // required precision gives more accuracy but also increases the chance of\n  // not hitting the goal. 2e-12 allows us to convert round trip with\n  // reasonable accuracy of six decimal places or more.\n  const threshold = 2e-12;\n  const max_attempts = 15;\n  let attempt = 0;\n  let last = Infinity;\n  let best = j;\n\n  // Try to find a J such that the returned y matches the returned y of the L*\n  while (attempt <= max_attempts) {\n    xyz = fromCam16({\n      J: j,\n      C: c,\n      h: h\n    }, env);\n\n    // If we are within range, return XYZ\n    // If we are closer than last time, save the values\n    const delta = Math.abs(xyz[1] - y);\n    if (delta < last) {\n      if (delta <= threshold) {\n        return xyz;\n      }\n      best = j;\n      last = delta;\n    }\n\n    // f(j_root) = (j ** (1 / 2)) * 0.1\n    // f(j) = ((f(j_root) * 100) ** 2) / j - 1 = 0\n    // f(j_root) = Y = y / 100\n    // f(j) = (y ** 2) / j - 1\n    // f'(j) = (2 * y) / j\n    j = j - (xyz[1] - y) * j / (2 * xyz[1]);\n    attempt += 1;\n  }\n\n  // We could not acquire the precision we desired,\n  // return our closest attempt.\n  return fromCam16({\n    J: j,\n    C: c,\n    h: h\n  }, env);\n}\nfunction toHct(xyz, env) {\n  // Calculate HCT by taking the L* of CIE LCh D65 and CAM16 chroma and hue.\n\n  const t = toLstar(xyz[1]);\n  if (t === 0.0) {\n    return [0.0, 0.0, 0.0];\n  }\n  const cam16 = toCam16(xyz, viewingConditions);\n  return [constrain(cam16.h), cam16.C, t];\n}\n\n// Pre-calculate everything we can with the viewing conditions\nexport const viewingConditions = environment(white, 200 / Math.PI * fromLstar(50.0), fromLstar(50.0) * 100, \"average\", false);\n\n// https://material.io/blog/science-of-color-design\n// This is not a port of the material-color-utilities,\n// but instead implements the full color space as described,\n// combining CAM16 JCh and Lab D65. This does not clamp conversion\n// to HCT to specific chroma bands and provides support for wider\n// gamuts than Google currently supports and does so at a greater\n// precision (> 8 bits back to sRGB).\n// This implementation comes from https://github.com/facelessuser/coloraide\n// which is licensed under MIT.\nexport default new ColorSpace({\n  id: \"hct\",\n  name: \"HCT\",\n  coords: {\n    h: {\n      refRange: [0, 360],\n      type: \"angle\",\n      name: \"Hue\"\n    },\n    c: {\n      refRange: [0, 145],\n      name: \"Colorfulness\"\n    },\n    t: {\n      refRange: [0, 100],\n      name: \"Tone\"\n    }\n  },\n  base: xyz_d65,\n  fromBase(xyz) {\n    return toHct(xyz, viewingConditions);\n  },\n  toBase(hct) {\n    return fromHct(hct, viewingConditions);\n  },\n  formats: {\n    color: {\n      id: \"--hct\",\n      coords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"]\n    }\n  }\n});","map":{"version":3,"names":["ColorSpace","constrain","xyz_d65","fromCam16","toCam16","environment","WHITES","white","D65","ε","κ","toLstar","y","fy","Math","cbrt","fromLstar","lstar","pow","fromHct","coords","env","h","c","t","xyz","j","threshold","max_attempts","attempt","last","Infinity","best","J","C","delta","abs","toHct","cam16","viewingConditions","PI","id","name","refRange","type","base","fromBase","toBase","hct","formats","color"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/spaces/hct.js"],"sourcesContent":["import ColorSpace from \"../space.js\";\nimport {constrain} from \"../angles.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport {fromCam16, toCam16, environment} from \"./cam16.js\";\nimport {WHITES} from \"../adapt.js\";\n\nconst white = WHITES.D65;\nconst ε = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst κ = 24389 / 27;   // 29^3/3^3\n\nfunction toLstar (y) {\n\t// Convert XYZ Y to L*\n\n\tconst fy = (y > ε) ? Math.cbrt(y) : (κ * y + 16) / 116;\n\treturn (116.0 * fy) - 16.0;\n}\n\nfunction fromLstar (lstar) {\n\t// Convert L* back to XYZ Y\n\n\treturn (lstar > 8) ?  Math.pow((lstar + 16) / 116, 3) : lstar / κ;\n}\n\nfunction fromHct (coords, env) {\n\t// Use Newton's method to try and converge as quick as possible or\n\t// converge as close as we can. While the requested precision is achieved\n\t// most of the time, it may not always be achievable. Especially past the\n\t// visible spectrum, the algorithm will likely struggle to get the same\n\t// precision. If, for whatever reason, we cannot achieve the accuracy we\n\t// seek in the allotted iterations, just return the closest we were able to\n\t// get.\n\n\tlet [h, c, t] = coords;\n\tlet xyz = [];\n\tlet j = 0;\n\n\t// Shortcut out for black\n\tif (t === 0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\n\t// Calculate the Y we need to target\n\tlet y = fromLstar(t);\n\n\t// A better initial guess yields better results. Polynomials come from\n\t// curve fitting the T vs J response.\n\tif (t > 0) {\n\t\tj = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;\n\t}\n\telse {\n\t\tj = 9.514440756550361e-06 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;\n\t}\n\n\t// Threshold of how close is close enough, and max number of attempts.\n\t// More precision and more attempts means more time spent iterating. Higher\n\t// required precision gives more accuracy but also increases the chance of\n\t// not hitting the goal. 2e-12 allows us to convert round trip with\n\t// reasonable accuracy of six decimal places or more.\n\tconst threshold = 2e-12;\n\tconst max_attempts = 15;\n\n\tlet attempt = 0;\n\tlet last = Infinity;\n\tlet best = j;\n\n\t// Try to find a J such that the returned y matches the returned y of the L*\n\twhile (attempt <= max_attempts) {\n\t\txyz = fromCam16({J: j, C: c, h: h}, env);\n\n\t\t// If we are within range, return XYZ\n\t\t// If we are closer than last time, save the values\n\t\tconst delta = Math.abs(xyz[1] - y);\n\t\tif (delta < last) {\n\t\t\tif (delta <= threshold) {\n\t\t\t\treturn xyz;\n\t\t\t}\n\t\t\tbest = j;\n\t\t\tlast = delta;\n\t\t}\n\n\t\t// f(j_root) = (j ** (1 / 2)) * 0.1\n\t\t// f(j) = ((f(j_root) * 100) ** 2) / j - 1 = 0\n\t\t// f(j_root) = Y = y / 100\n\t\t// f(j) = (y ** 2) / j - 1\n\t\t// f'(j) = (2 * y) / j\n\t\tj = j - (xyz[1] - y) * j / (2 * xyz[1]);\n\n\t\tattempt += 1;\n\t}\n\n\t// We could not acquire the precision we desired,\n\t// return our closest attempt.\n\treturn fromCam16({J: j, C: c, h: h}, env);\n}\n\nfunction toHct (xyz, env) {\n\t// Calculate HCT by taking the L* of CIE LCh D65 and CAM16 chroma and hue.\n\n\tconst t = toLstar(xyz[1]);\n\tif (t === 0.0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\tconst cam16 = toCam16(xyz, viewingConditions);\n\treturn [constrain(cam16.h), cam16.C, t];\n}\n\n// Pre-calculate everything we can with the viewing conditions\nexport const viewingConditions = environment(\n\twhite, 200 / Math.PI * fromLstar(50.0),\n\tfromLstar(50.0) * 100,\n\t\"average\",\n\tfalse,\n);\n\n// https://material.io/blog/science-of-color-design\n// This is not a port of the material-color-utilities,\n// but instead implements the full color space as described,\n// combining CAM16 JCh and Lab D65. This does not clamp conversion\n// to HCT to specific chroma bands and provides support for wider\n// gamuts than Google currently supports and does so at a greater\n// precision (> 8 bits back to sRGB).\n// This implementation comes from https://github.com/facelessuser/coloraide\n// which is licensed under MIT.\nexport default new ColorSpace({\n\tid: \"hct\",\n\tname: \"HCT\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 145],\n\t\t\tname: \"Colorfulness\",\n\t\t},\n\t\tt: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Tone\",\n\t\t},\n\t},\n\n\tbase: xyz_d65,\n\n\tfromBase (xyz) {\n\t\treturn toHct(xyz, viewingConditions);\n\t},\n\ttoBase (hct) {\n\t\treturn fromHct(hct, viewingConditions);\n\t},\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hct\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}