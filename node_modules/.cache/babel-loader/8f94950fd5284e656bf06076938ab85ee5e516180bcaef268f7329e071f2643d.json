{"ast":null,"code":"import { m as PATH, Q as QUADS, s as QUAD_STRIP, r as TRIANGLE_STRIP, p as TRIANGLES, a1 as IMAGE, L as LINES, q as TRIANGLE_FAN } from '../constants-BRcElHU3.js';\nimport { Geometry } from './p5.Geometry.js';\nimport libtess from 'libtess';\nimport { Vector } from '../math/p5.Vector.js';\nimport { RenderBuffer } from './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\nconst INITIAL_BUFFER_STRIDES = {\n  vertices: 1,\n  vertexNormals: 1,\n  vertexColors: 4,\n  vertexStrokeColors: 4,\n  uvs: 2\n};\n\n// The total number of properties per vertex, before additional\n// user attributes are added.\nconst INITIAL_VERTEX_SIZE = Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);\nclass ShapeBuilder {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.shapeMode = PATH;\n    this.geometry = new Geometry(undefined, undefined, undefined, this.renderer);\n    this.geometry.gid = '__IMMEDIATE_MODE_GEOMETRY__';\n    this.contourIndices = [];\n    this._useUserVertexProperties = undefined;\n    this._bezierVertex = [];\n    this._quadraticVertex = [];\n    this._curveVertex = [];\n\n    // Used to distinguish between user calls to vertex() and internal calls\n    this.isProcessingVertices = false;\n\n    // Used for converting shape outlines into triangles for rendering\n    this._tessy = this._initTessy();\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.bufferStrides = {\n      ...INITIAL_BUFFER_STRIDES\n    };\n  }\n  constructFromContours(shape, contours) {\n    if (this._useUserVertexProperties) {\n      this._resetUserVertexProperties();\n    }\n    this.geometry.reset();\n    this.contourIndices = [];\n    // TODO: handle just some contours having non-PATH mode\n    this.shapeMode = shape.contours[0].kind;\n    const shouldProcessEdges = !!this.renderer.states.strokeColor;\n    const userVertexPropertyHelpers = {};\n    if (shape.userVertexProperties) {\n      this._useUserVertexProperties = true;\n      for (const key in shape.userVertexProperties) {\n        const name = shape.vertexPropertyName(key);\n        const prop = this.geometry._userVertexPropertyHelper(name, [], shape.userVertexProperties[key]);\n        userVertexPropertyHelpers[key] = prop;\n        this.tessyVertexSize += prop.getDataSize();\n        this.bufferStrides[prop.getSrcName()] = prop.getDataSize();\n        this.renderer.buffers.user.push(new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer));\n      }\n    } else {\n      this._useUserVertexProperties = false;\n    }\n    for (const contour of contours) {\n      this.contourIndices.push(this.geometry.vertices.length);\n      for (const vertex of contour) {\n        // WebGL doesn't support QUADS or QUAD_STRIP, so we duplicate data to turn\n        // QUADS into TRIANGLES and QUAD_STRIP into TRIANGLE_STRIP. (There is no extra\n        // work to convert QUAD_STRIP here, since the only difference is in how edges\n        // are rendered.)\n        if (this.shapeMode === QUADS) {\n          // A finished quad turned into triangles should leave 6 vertices in the\n          // buffer:\n          // 0--3     0   3--5\n          // |  | --> | \\  \\ |\n          // 1--2     1--2   4\n          // When vertex index 3 is being added, add the necessary duplicates.\n          if (this.geometry.vertices.length % 6 === 3) {\n            for (const key in this.bufferStrides) {\n              const stride = this.bufferStrides[key];\n              const buffer = this.geometry[key];\n              buffer.push(...buffer.slice(buffer.length - 3 * stride, buffer.length - 2 * stride), ...buffer.slice(buffer.length - stride, buffer.length));\n            }\n          }\n        }\n        this.geometry.vertices.push(vertex.position);\n        this.geometry.vertexNormals.push(vertex.normal || new Vector(0, 0, 0));\n        this.geometry.uvs.push(vertex.textureCoordinates.x, vertex.textureCoordinates.y);\n        if (this.renderer.states.fillColor) {\n          this.geometry.vertexColors.push(...vertex.fill.array());\n        } else {\n          this.geometry.vertexColors.push(0, 0, 0, 0);\n        }\n        if (this.renderer.states.strokeColor) {\n          this.geometry.vertexStrokeColors.push(...vertex.stroke.array());\n        } else {\n          this.geometry.vertexStrokeColors.push(0, 0, 0, 0);\n        }\n        for (const key in userVertexPropertyHelpers) {\n          const prop = userVertexPropertyHelpers[key];\n          if (key in vertex) {\n            prop.setCurrentData(vertex[key]);\n          }\n          prop.pushCurrentData();\n        }\n      }\n    }\n    if (shouldProcessEdges) {\n      this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);\n    }\n    if (shouldProcessEdges && !this.renderer.geometryBuilder) {\n      this.geometry._edgesToVertices();\n    }\n    if (this.shapeMode === PATH) {\n      this.isProcessingVertices = true;\n      this._tesselateShape();\n      this.isProcessingVertices = false;\n    } else if (this.shapeMode === QUAD_STRIP) {\n      // The only difference between these two modes is which edges are\n      // displayed, so after we've updated the edges, we switch the mode\n      // to one that native WebGL knows how to render.\n      this.shapeMode = TRIANGLE_STRIP;\n    } else if (this.shapeMode === QUADS) {\n      // We translate QUADS to TRIANGLES when vertices are being added,\n      // since QUADS is just a p5 mode, whereas TRIANGLES is also a mode\n      // that native WebGL knows how to render. Once we've processed edges,\n      // everything should be set up for TRIANGLES mode.\n      this.shapeMode = TRIANGLES;\n    }\n    if (this.renderer.states.textureMode === IMAGE && this.renderer.states._tex !== null && this.renderer.states._tex.width > 0 && this.renderer.states._tex.height > 0) {\n      this.geometry.uvs = this.geometry.uvs.map((val, i) => {\n        if (i % 2 === 0) {\n          return val / this.renderer.states._tex.width;\n        } else {\n          return val / this.renderer.states._tex.height;\n        }\n      });\n    }\n  }\n  _resetUserVertexProperties() {\n    const properties = this.geometry.userVertexProperties;\n    for (const propName in properties) {\n      const prop = properties[propName];\n      delete this.bufferStrides[propName];\n      prop.delete();\n    }\n    this._useUserVertexProperties = false;\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.geometry.userVertexProperties = {};\n  }\n\n  /**\n   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and\n   * tesselates shapes when applicable.\n   * @private\n   * @returns  {Number[]} indices for custom shape vertices indicating edges.\n   */\n  _calculateEdges(shapeMode, verts) {\n    const res = [];\n    let i = 0;\n    const contourIndices = this.contourIndices.slice();\n    let contourStart = -1;\n    switch (shapeMode) {\n      case TRIANGLE_STRIP:\n        for (i = 0; i < verts.length - 2; i++) {\n          res.push([i, i + 1]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      case TRIANGLE_FAN:\n        for (i = 1; i < verts.length - 1; i++) {\n          res.push([0, i]);\n          res.push([i, i + 1]);\n        }\n        res.push([0, verts.length - 1]);\n        break;\n      case TRIANGLES:\n        for (i = 0; i < verts.length - 2; i = i + 3) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i]);\n        }\n        break;\n      case LINES:\n        for (i = 0; i < verts.length - 1; i = i + 2) {\n          res.push([i, i + 1]);\n        }\n        break;\n      case QUADS:\n        // Quads have been broken up into two triangles by `vertex()`:\n        // 0   3--5\n        // | \\  \\ |\n        // 1--2   4\n        for (i = 0; i < verts.length - 5; i += 6) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i + 5]);\n          res.push([i + 5, i]);\n        }\n        break;\n      case QUAD_STRIP:\n        // 0---2---4\n        // |   |   |\n        // 1---3---5\n        for (i = 0; i < verts.length - 2; i += 2) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 3]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      default:\n        // TODO: handle contours in other modes too\n        for (i = 0; i < verts.length; i++) {\n          if (i === contourIndices[0]) {\n            contourStart = contourIndices.shift();\n          } else if (verts[contourStart] && verts[i].equals(verts[contourStart])) {\n            res.push([i - 1, contourStart]);\n          } else {\n            res.push([i - 1, i]);\n          }\n        }\n        break;\n    }\n    return res;\n  }\n\n  /**\n   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.\n   * @private\n   */\n  _tesselateShape() {\n    // TODO: handle non-PATH shape modes that have contours\n    this.shapeMode = TRIANGLES;\n    // const contours = [[]];\n    const contours = [];\n    for (let i = 0; i < this.geometry.vertices.length; i++) {\n      if (this.contourIndices.length > 0 && this.contourIndices[0] === i) {\n        this.contourIndices.shift();\n        contours.push([]);\n      }\n      contours[contours.length - 1].push(this.geometry.vertices[i].x, this.geometry.vertices[i].y, this.geometry.vertices[i].z, this.geometry.uvs[i * 2], this.geometry.uvs[i * 2 + 1], this.geometry.vertexColors[i * 4], this.geometry.vertexColors[i * 4 + 1], this.geometry.vertexColors[i * 4 + 2], this.geometry.vertexColors[i * 4 + 3], this.geometry.vertexNormals[i].x, this.geometry.vertexNormals[i].y, this.geometry.vertexNormals[i].z);\n      for (const propName in this.geometry.userVertexProperties) {\n        const prop = this.geometry.userVertexProperties[propName];\n        const start = i * prop.getDataSize();\n        const end = start + prop.getDataSize();\n        const vals = prop.getSrcArray().slice(start, end);\n        contours[contours.length - 1].push(...vals);\n      }\n    }\n    const polyTriangles = this._triangulate(contours);\n    const originalVertices = this.geometry.vertices;\n    this.geometry.vertices = [];\n    this.geometry.vertexNormals = [];\n    this.geometry.uvs = [];\n    for (const propName in this.geometry.userVertexProperties) {\n      const prop = this.geometry.userVertexProperties[propName];\n      prop.resetSrcArray();\n    }\n    const colors = [];\n    for (let j = 0, polyTriLength = polyTriangles.length; j < polyTriLength; j = j + this.tessyVertexSize) {\n      colors.push(...polyTriangles.slice(j + 5, j + 9));\n      this.geometry.vertexNormals.push(new Vector(...polyTriangles.slice(j + 9, j + 12)));\n      {\n        let offset = 12;\n        for (const propName in this.geometry.userVertexProperties) {\n          const prop = this.geometry.userVertexProperties[propName];\n          const size = prop.getDataSize();\n          const start = j + offset;\n          const end = start + size;\n          prop.setCurrentData(polyTriangles.slice(start, end));\n          prop.pushCurrentData();\n          offset += size;\n        }\n      }\n      this.geometry.vertices.push(new Vector(...polyTriangles.slice(j, j + 3)));\n      this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));\n    }\n    if (this.renderer.geometryBuilder) {\n      // Tesselating the face causes the indices of edge vertices to stop being\n      // correct. When rendering, this is not a problem, since _edgesToVertices\n      // will have been called before this, and edge vertex indices are no longer\n      // needed. However, the geometry builder still needs this information, so\n      // when one is active, we need to update the indices.\n      //\n      // We record index mappings in a Map so that once we have found a\n      // corresponding vertex, we don't need to loop to find it again.\n      const newIndex = new Map();\n      this.geometry.edges = this.geometry.edges.map(edge => edge.map(origIdx => {\n        if (!newIndex.has(origIdx)) {\n          const orig = originalVertices[origIdx];\n          let newVertIndex = this.geometry.vertices.findIndex(v => orig.x === v.x && orig.y === v.y && orig.z === v.z);\n          if (newVertIndex === -1) {\n            // The tesselation process didn't output a vertex with the exact\n            // coordinate as before, potentially due to numerical issues. This\n            // doesn't happen often, but in this case, pick the closest point\n            let closestDist = Infinity;\n            let closestIndex = 0;\n            for (let i = 0; i < this.geometry.vertices.length; i++) {\n              const vert = this.geometry.vertices[i];\n              const dX = orig.x - vert.x;\n              const dY = orig.y - vert.y;\n              const dZ = orig.z - vert.z;\n              const dist = dX * dX + dY * dY + dZ * dZ;\n              if (dist < closestDist) {\n                closestDist = dist;\n                closestIndex = i;\n              }\n            }\n            newVertIndex = closestIndex;\n          }\n          newIndex.set(origIdx, newVertIndex);\n        }\n        return newIndex.get(origIdx);\n      }));\n    }\n    this.geometry.vertexColors = colors;\n  }\n  _initTessy() {\n    // function called for each vertex of tesselator output\n    function vertexCallback(data, polyVertArray) {\n      for (const element of data) {\n        polyVertArray.push(element);\n      }\n    }\n    function begincallback(type) {\n      if (type !== libtess.primitiveType.GL_TRIANGLES) {\n        console.log(`expected TRIANGLES but got type: ${type}`);\n      }\n    }\n    function errorcallback(errno) {\n      console.log('error callback');\n      console.log(`error number: ${errno}`);\n    }\n\n    // callback for when segments intersect and must be split\n    const combinecallback = (coords, data, weight) => {\n      const result = new Array(this.tessyVertexSize).fill(0);\n      for (let i = 0; i < weight.length; i++) {\n        for (let j = 0; j < result.length; j++) {\n          if (weight[i] === 0 || !data[i]) continue;\n          result[j] += data[i][j] * weight[i];\n        }\n      }\n      return result;\n    };\n    function edgeCallback(flag) {\n      // don't really care about the flag, but need no-strip/no-fan behavior\n    }\n    const tessy = new libtess.GluTesselator();\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);\n    tessy.gluTessProperty(libtess.gluEnum.GLU_TESS_WINDING_RULE, libtess.windingRule.GLU_TESS_WINDING_NONZERO);\n    return tessy;\n  }\n\n  /**\n   * Runs vertices through libtess to convert them into triangles\n   * @private\n   */\n  _triangulate(contours) {\n    // libtess will take 3d verts and flatten to a plane for tesselation.\n    // libtess is capable of calculating a plane to tesselate on, but\n    // if all of the vertices have the same z values, we'll just\n    // assume the face is facing the camera, letting us skip any performance\n    // issues or bugs in libtess's automatic calculation.\n    const z = contours[0] ? contours[0][2] : undefined;\n    let allSameZ = true;\n    for (const contour of contours) {\n      for (let j = 0; j < contour.length; j += this.tessyVertexSize) {\n        if (contour[j + 2] !== z) {\n          allSameZ = false;\n          break;\n        }\n      }\n    }\n    if (allSameZ) {\n      this._tessy.gluTessNormal(0, 0, 1);\n    } else {\n      // Let libtess pick a plane for us\n      this._tessy.gluTessNormal(0, 0, 0);\n    }\n    const triangleVerts = [];\n    this._tessy.gluTessBeginPolygon(triangleVerts);\n    for (const contour of contours) {\n      this._tessy.gluTessBeginContour();\n      for (let j = 0; j < contour.length; j += this.tessyVertexSize) {\n        const coords = contour.slice(j, j + this.tessyVertexSize);\n        this._tessy.gluTessVertex(coords, coords);\n      }\n      this._tessy.gluTessEndContour();\n    }\n\n    // finish polygon\n    this._tessy.gluTessEndPolygon();\n    return triangleVerts;\n  }\n}\nexport { ShapeBuilder };","map":{"version":3,"names":["m","PATH","Q","QUADS","s","QUAD_STRIP","r","TRIANGLE_STRIP","p","TRIANGLES","a1","IMAGE","L","LINES","q","TRIANGLE_FAN","Geometry","libtess","Vector","RenderBuffer","INITIAL_BUFFER_STRIDES","vertices","vertexNormals","vertexColors","vertexStrokeColors","uvs","INITIAL_VERTEX_SIZE","Object","values","reduce","acc","next","ShapeBuilder","constructor","renderer","shapeMode","geometry","undefined","gid","contourIndices","_useUserVertexProperties","_bezierVertex","_quadraticVertex","_curveVertex","isProcessingVertices","_tessy","_initTessy","tessyVertexSize","bufferStrides","constructFromContours","shape","contours","_resetUserVertexProperties","reset","kind","shouldProcessEdges","states","strokeColor","userVertexPropertyHelpers","userVertexProperties","key","name","vertexPropertyName","prop","_userVertexPropertyHelper","getDataSize","getSrcName","buffers","user","push","getDstName","contour","length","vertex","stride","buffer","slice","position","normal","textureCoordinates","x","y","fillColor","fill","array","stroke","setCurrentData","pushCurrentData","edges","_calculateEdges","geometryBuilder","_edgesToVertices","_tesselateShape","textureMode","_tex","width","height","map","val","i","properties","propName","delete","verts","res","contourStart","shift","equals","z","start","end","vals","getSrcArray","polyTriangles","_triangulate","originalVertices","resetSrcArray","colors","j","polyTriLength","offset","size","newIndex","Map","edge","origIdx","has","orig","newVertIndex","findIndex","v","closestDist","Infinity","closestIndex","vert","dX","dY","dZ","dist","set","get","vertexCallback","data","polyVertArray","element","begincallback","type","primitiveType","GL_TRIANGLES","console","log","errorcallback","errno","combinecallback","coords","weight","result","Array","edgeCallback","flag","tessy","GluTesselator","gluTessCallback","gluEnum","GLU_TESS_VERTEX_DATA","GLU_TESS_BEGIN","GLU_TESS_ERROR","GLU_TESS_COMBINE","GLU_TESS_EDGE_FLAG","gluTessProperty","GLU_TESS_WINDING_RULE","windingRule","GLU_TESS_WINDING_NONZERO","allSameZ","gluTessNormal","triangleVerts","gluTessBeginPolygon","gluTessBeginContour","gluTessVertex","gluTessEndContour","gluTessEndPolygon"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/webgl/ShapeBuilder.js"],"sourcesContent":["import { m as PATH, Q as QUADS, s as QUAD_STRIP, r as TRIANGLE_STRIP, p as TRIANGLES, a1 as IMAGE, L as LINES, q as TRIANGLE_FAN } from '../constants-BRcElHU3.js';\nimport { Geometry } from './p5.Geometry.js';\nimport libtess from 'libtess';\nimport { Vector } from '../math/p5.Vector.js';\nimport { RenderBuffer } from './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\n\nconst INITIAL_BUFFER_STRIDES = {\n  vertices: 1,\n  vertexNormals: 1,\n  vertexColors: 4,\n  vertexStrokeColors: 4,\n  uvs: 2\n};\n\n// The total number of properties per vertex, before additional\n// user attributes are added.\nconst INITIAL_VERTEX_SIZE =\n  Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);\n\nclass ShapeBuilder {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.shapeMode = PATH;\n    this.geometry = new Geometry(undefined, undefined, undefined, this.renderer);\n    this.geometry.gid = '__IMMEDIATE_MODE_GEOMETRY__';\n\n    this.contourIndices = [];\n    this._useUserVertexProperties = undefined;\n\n    this._bezierVertex = [];\n    this._quadraticVertex = [];\n    this._curveVertex = [];\n\n    // Used to distinguish between user calls to vertex() and internal calls\n    this.isProcessingVertices = false;\n\n    // Used for converting shape outlines into triangles for rendering\n    this._tessy = this._initTessy();\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.bufferStrides = { ...INITIAL_BUFFER_STRIDES };\n  }\n\n  constructFromContours(shape, contours) {\n    if (this._useUserVertexProperties){\n      this._resetUserVertexProperties();\n    }\n    this.geometry.reset();\n    this.contourIndices = [];\n    // TODO: handle just some contours having non-PATH mode\n    this.shapeMode = shape.contours[0].kind;\n    const shouldProcessEdges = !!this.renderer.states.strokeColor;\n\n    const userVertexPropertyHelpers = {};\n    if (shape.userVertexProperties) {\n      this._useUserVertexProperties = true;\n      for (const key in shape.userVertexProperties) {\n        const name = shape.vertexPropertyName(key);\n        const prop = this.geometry._userVertexPropertyHelper(name, [], shape.userVertexProperties[key]);\n        userVertexPropertyHelpers[key] = prop;\n        this.tessyVertexSize += prop.getDataSize();\n        this.bufferStrides[prop.getSrcName()] = prop.getDataSize();\n        this.renderer.buffers.user.push(\n          new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer)\n        );\n      }\n    } else {\n      this._useUserVertexProperties = false;\n    }\n\n    for (const contour of contours) {\n      this.contourIndices.push(this.geometry.vertices.length);\n      for (const vertex of contour) {\n        // WebGL doesn't support QUADS or QUAD_STRIP, so we duplicate data to turn\n        // QUADS into TRIANGLES and QUAD_STRIP into TRIANGLE_STRIP. (There is no extra\n        // work to convert QUAD_STRIP here, since the only difference is in how edges\n        // are rendered.)\n        if (this.shapeMode === QUADS) {\n          // A finished quad turned into triangles should leave 6 vertices in the\n          // buffer:\n          // 0--3     0   3--5\n          // |  | --> | \\  \\ |\n          // 1--2     1--2   4\n          // When vertex index 3 is being added, add the necessary duplicates.\n          if (this.geometry.vertices.length % 6 === 3) {\n            for (const key in this.bufferStrides) {\n              const stride = this.bufferStrides[key];\n              const buffer = this.geometry[key];\n              buffer.push(\n                ...buffer.slice(\n                  buffer.length - 3 * stride,\n                  buffer.length - 2 * stride\n                ),\n                ...buffer.slice(buffer.length - stride, buffer.length),\n              );\n            }\n          }\n        }\n\n        this.geometry.vertices.push(vertex.position);\n        this.geometry.vertexNormals.push(vertex.normal || new Vector(0, 0, 0));\n        this.geometry.uvs.push(vertex.textureCoordinates.x, vertex.textureCoordinates.y);\n        if (this.renderer.states.fillColor) {\n          this.geometry.vertexColors.push(...vertex.fill.array());\n        } else {\n          this.geometry.vertexColors.push(0, 0, 0, 0);\n        }\n        if (this.renderer.states.strokeColor) {\n          this.geometry.vertexStrokeColors.push(...vertex.stroke.array());\n        } else {\n          this.geometry.vertexStrokeColors.push(0, 0, 0, 0);\n        }\n        for (const key in userVertexPropertyHelpers) {\n          const prop = userVertexPropertyHelpers[key];\n          if (key in vertex) {\n            prop.setCurrentData(vertex[key]);\n          }\n          prop.pushCurrentData();\n        }\n      }\n    }\n\n    if (shouldProcessEdges) {\n      this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);\n    }\n    if (shouldProcessEdges && !this.renderer.geometryBuilder) {\n      this.geometry._edgesToVertices();\n    }\n\n    if (this.shapeMode === PATH) {\n      this.isProcessingVertices = true;\n      this._tesselateShape();\n      this.isProcessingVertices = false;\n    } else if (this.shapeMode === QUAD_STRIP) {\n      // The only difference between these two modes is which edges are\n      // displayed, so after we've updated the edges, we switch the mode\n      // to one that native WebGL knows how to render.\n      this.shapeMode = TRIANGLE_STRIP;\n    } else if (this.shapeMode === QUADS) {\n      // We translate QUADS to TRIANGLES when vertices are being added,\n      // since QUADS is just a p5 mode, whereas TRIANGLES is also a mode\n      // that native WebGL knows how to render. Once we've processed edges,\n      // everything should be set up for TRIANGLES mode.\n      this.shapeMode = TRIANGLES;\n    }\n\n    if (\n      this.renderer.states.textureMode === IMAGE &&\n      this.renderer.states._tex !== null &&\n      this.renderer.states._tex.width > 0 &&\n      this.renderer.states._tex.height > 0\n    ) {\n      this.geometry.uvs = this.geometry.uvs.map((val, i) => {\n        if (i % 2 === 0) {\n          return val / this.renderer.states._tex.width;\n        } else {\n          return val / this.renderer.states._tex.height;\n        }\n      });\n    }\n  }\n\n  _resetUserVertexProperties() {\n    const properties = this.geometry.userVertexProperties;\n    for (const propName in properties){\n      const prop = properties[propName];\n      delete this.bufferStrides[propName];\n      prop.delete();\n    }\n    this._useUserVertexProperties = false;\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.geometry.userVertexProperties = {};\n  }\n\n  /**\n   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and\n   * tesselates shapes when applicable.\n   * @private\n   * @returns  {Number[]} indices for custom shape vertices indicating edges.\n   */\n  _calculateEdges(\n    shapeMode,\n    verts,\n  ) {\n    const res = [];\n    let i = 0;\n    const contourIndices = this.contourIndices.slice();\n    let contourStart = -1;\n    switch (shapeMode) {\n      case TRIANGLE_STRIP:\n        for (i = 0; i < verts.length - 2; i++) {\n          res.push([i, i + 1]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      case TRIANGLE_FAN:\n        for (i = 1; i < verts.length - 1; i++) {\n          res.push([0, i]);\n          res.push([i, i + 1]);\n        }\n        res.push([0, verts.length - 1]);\n        break;\n      case TRIANGLES:\n        for (i = 0; i < verts.length - 2; i = i + 3) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i]);\n        }\n        break;\n      case LINES:\n        for (i = 0; i < verts.length - 1; i = i + 2) {\n          res.push([i, i + 1]);\n        }\n        break;\n      case QUADS:\n        // Quads have been broken up into two triangles by `vertex()`:\n        // 0   3--5\n        // | \\  \\ |\n        // 1--2   4\n        for (i = 0; i < verts.length - 5; i += 6) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i + 5]);\n          res.push([i + 5, i]);\n        }\n        break;\n      case QUAD_STRIP:\n        // 0---2---4\n        // |   |   |\n        // 1---3---5\n        for (i = 0; i < verts.length - 2; i += 2) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 3]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      default:\n        // TODO: handle contours in other modes too\n        for (i = 0; i < verts.length; i++) {\n          if (i === contourIndices[0]) {\n            contourStart = contourIndices.shift();\n          } else if (\n            verts[contourStart] &&\n            verts[i].equals(verts[contourStart])\n          ) {\n            res.push([i - 1, contourStart]);\n          } else {\n            res.push([i - 1, i]);\n          }\n        }\n        break;\n    }\n    return res;\n  }\n\n  /**\n   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.\n   * @private\n   */\n  _tesselateShape() {\n    // TODO: handle non-PATH shape modes that have contours\n    this.shapeMode = TRIANGLES;\n    // const contours = [[]];\n    const contours = [];\n    for (let i = 0; i < this.geometry.vertices.length; i++) {\n      if (\n        this.contourIndices.length > 0 &&\n        this.contourIndices[0] === i\n      ) {\n        this.contourIndices.shift();\n        contours.push([]);\n      }\n      contours[contours.length-1].push(\n        this.geometry.vertices[i].x,\n        this.geometry.vertices[i].y,\n        this.geometry.vertices[i].z,\n        this.geometry.uvs[i * 2],\n        this.geometry.uvs[i * 2 + 1],\n        this.geometry.vertexColors[i * 4],\n        this.geometry.vertexColors[i * 4 + 1],\n        this.geometry.vertexColors[i * 4 + 2],\n        this.geometry.vertexColors[i * 4 + 3],\n        this.geometry.vertexNormals[i].x,\n        this.geometry.vertexNormals[i].y,\n        this.geometry.vertexNormals[i].z\n      );\n      for (const propName in this.geometry.userVertexProperties) {\n        const prop = this.geometry.userVertexProperties[propName];\n        const start = i * prop.getDataSize();\n        const end = start + prop.getDataSize();\n        const vals = prop.getSrcArray().slice(start, end);\n        contours[contours.length-1].push(...vals);\n      }\n    }\n\n    const polyTriangles = this._triangulate(contours);\n    const originalVertices = this.geometry.vertices;\n    this.geometry.vertices = [];\n    this.geometry.vertexNormals = [];\n    this.geometry.uvs = [];\n    for (const propName in this.geometry.userVertexProperties){\n      const prop = this.geometry.userVertexProperties[propName];\n      prop.resetSrcArray();\n    }\n    const colors = [];\n    for (\n      let j = 0, polyTriLength = polyTriangles.length;\n      j < polyTriLength;\n      j = j + this.tessyVertexSize\n    ) {\n      colors.push(...polyTriangles.slice(j + 5, j + 9));\n      this.geometry.vertexNormals.push(new Vector(...polyTriangles.slice(j + 9, j + 12)));\n      {\n        let offset = 12;\n        for (const propName in this.geometry.userVertexProperties){\n          const prop = this.geometry.userVertexProperties[propName];\n          const size = prop.getDataSize();\n          const start = j + offset;\n          const end = start + size;\n          prop.setCurrentData(polyTriangles.slice(start, end));\n          prop.pushCurrentData();\n          offset += size;\n        }\n      }\n      this.geometry.vertices.push(new Vector(...polyTriangles.slice(j, j + 3)));\n      this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));\n    }\n    if (this.renderer.geometryBuilder) {\n      // Tesselating the face causes the indices of edge vertices to stop being\n      // correct. When rendering, this is not a problem, since _edgesToVertices\n      // will have been called before this, and edge vertex indices are no longer\n      // needed. However, the geometry builder still needs this information, so\n      // when one is active, we need to update the indices.\n      //\n      // We record index mappings in a Map so that once we have found a\n      // corresponding vertex, we don't need to loop to find it again.\n      const newIndex = new Map();\n      this.geometry.edges =\n        this.geometry.edges.map(edge => edge.map(origIdx => {\n          if (!newIndex.has(origIdx)) {\n            const orig = originalVertices[origIdx];\n            let newVertIndex = this.geometry.vertices.findIndex(\n              v =>\n                orig.x === v.x &&\n                orig.y === v.y &&\n                orig.z === v.z\n            );\n            if (newVertIndex === -1) {\n              // The tesselation process didn't output a vertex with the exact\n              // coordinate as before, potentially due to numerical issues. This\n              // doesn't happen often, but in this case, pick the closest point\n              let closestDist = Infinity;\n              let closestIndex = 0;\n              for (\n                let i = 0;\n                i < this.geometry.vertices.length;\n                i++\n              ) {\n                const vert = this.geometry.vertices[i];\n                const dX = orig.x - vert.x;\n                const dY = orig.y - vert.y;\n                const dZ = orig.z - vert.z;\n                const dist = dX*dX + dY*dY + dZ*dZ;\n                if (dist < closestDist) {\n                  closestDist = dist;\n                  closestIndex = i;\n                }\n              }\n              newVertIndex = closestIndex;\n            }\n            newIndex.set(origIdx, newVertIndex);\n          }\n          return newIndex.get(origIdx);\n        }));\n    }\n    this.geometry.vertexColors = colors;\n  }\n\n  _initTessy() {\n    // function called for each vertex of tesselator output\n    function vertexCallback(data, polyVertArray) {\n      for (const element of data) {\n        polyVertArray.push(element);\n      }\n    }\n\n    function begincallback(type) {\n      if (type !== libtess.primitiveType.GL_TRIANGLES) {\n        console.log(`expected TRIANGLES but got type: ${type}`);\n      }\n    }\n\n    function errorcallback(errno) {\n      console.log('error callback');\n      console.log(`error number: ${errno}`);\n    }\n\n    // callback for when segments intersect and must be split\n    const combinecallback = (coords, data, weight) => {\n      const result = new Array(this.tessyVertexSize).fill(0);\n      for (let i = 0; i < weight.length; i++) {\n        for (let j = 0; j < result.length; j++) {\n          if (weight[i] === 0 || !data[i]) continue;\n          result[j] += data[i][j] * weight[i];\n        }\n      }\n      return result;\n    };\n\n    function edgeCallback(flag) {\n      // don't really care about the flag, but need no-strip/no-fan behavior\n    }\n\n    const tessy = new libtess.GluTesselator();\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);\n    tessy.gluTessProperty(\n      libtess.gluEnum.GLU_TESS_WINDING_RULE,\n      libtess.windingRule.GLU_TESS_WINDING_NONZERO\n    );\n\n    return tessy;\n  }\n\n  /**\n   * Runs vertices through libtess to convert them into triangles\n   * @private\n   */\n  _triangulate(contours) {\n    // libtess will take 3d verts and flatten to a plane for tesselation.\n    // libtess is capable of calculating a plane to tesselate on, but\n    // if all of the vertices have the same z values, we'll just\n    // assume the face is facing the camera, letting us skip any performance\n    // issues or bugs in libtess's automatic calculation.\n    const z = contours[0] ? contours[0][2] : undefined;\n    let allSameZ = true;\n    for (const contour of contours) {\n      for (\n        let j = 0;\n        j < contour.length;\n        j += this.tessyVertexSize\n      ) {\n        if (contour[j + 2] !== z) {\n          allSameZ = false;\n          break;\n        }\n      }\n    }\n    if (allSameZ) {\n      this._tessy.gluTessNormal(0, 0, 1);\n    } else {\n      // Let libtess pick a plane for us\n      this._tessy.gluTessNormal(0, 0, 0);\n    }\n\n    const triangleVerts = [];\n    this._tessy.gluTessBeginPolygon(triangleVerts);\n\n    for (const contour of contours) {\n      this._tessy.gluTessBeginContour();\n      for (\n        let j = 0;\n        j < contour.length;\n        j += this.tessyVertexSize\n      ) {\n        const coords = contour.slice(\n          j,\n          j + this.tessyVertexSize\n        );\n        this._tessy.gluTessVertex(coords, coords);\n      }\n      this._tessy.gluTessEndContour();\n    }\n\n    // finish polygon\n    this._tessy.gluTessEndPolygon();\n\n    return triangleVerts;\n  }\n}\n\nexport { ShapeBuilder };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}