{"ast":null,"code":"import hct from \"../spaces/hct.js\";\nimport { viewingConditions } from \"../spaces/hct.js\";\nimport getColor from \"../getColor.js\";\nconst rad2deg = 180 / Math.PI;\nconst deg2rad = Math.PI / 180;\nconst ucsCoeff = [1.00, 0.007, 0.0228];\n\n/**\n* Convert HCT chroma and hue (CAM16 JMh colorfulness and hue) using UCS logic for a and b.\n* @param {number[]} coords - HCT coordinates.\n* @return {number[]}\n*/\nfunction convertUcsAb(coords) {\n  // We want the distance between the actual color.\n  // If chroma is negative, it will throw off our calculations.\n  // Normally, converting back to the base and forward will correct it.\n  // If we have a negative chroma after this, then we have a color that\n  // cannot resolve to positive chroma.\n  if (coords[1] < 0) {\n    coords = hct.fromBase(hct.toBase(coords));\n  }\n\n  // Only in extreme cases (usually outside the visible spectrum)\n  // can the input value for log become negative.\n  // Avoid domain error by forcing a zero result via \"max\" if necessary.\n  const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1.0)) / ucsCoeff[2];\n  const hrad = coords[0] * deg2rad;\n  const a = M * Math.cos(hrad);\n  const b = M * Math.sin(hrad);\n  return [coords[2], a, b];\n}\n\n/**\n* Color distance using HCT.\n* @param {Color} color - Color to compare.\n* @param {Color} sample - Color to compare.\n* @return {number[]}\n*/\nexport default function (color, sample) {\n  [color, sample] = getColor([color, sample]);\n  let [t1, a1, b1] = convertUcsAb(hct.from(color));\n  let [t2, a2, b2] = convertUcsAb(hct.from(sample));\n\n  // Use simple euclidean distance with a and b using UCS conversion\n  // and LCh lightness (HCT tone).\n  return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);\n}","map":{"version":3,"names":["hct","viewingConditions","getColor","rad2deg","Math","PI","deg2rad","ucsCoeff","convertUcsAb","coords","fromBase","toBase","M","log","max","flRoot","hrad","a","cos","b","sin","color","sample","t1","a1","b1","from","t2","a2","b2","sqrt"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/deltaE/deltaEHCT.js"],"sourcesContent":["import hct from \"../spaces/hct.js\";\nimport {viewingConditions} from \"../spaces/hct.js\";\nimport getColor from \"../getColor.js\";\n\nconst rad2deg = 180 / Math.PI;\nconst deg2rad = Math.PI / 180;\nconst ucsCoeff = [1.00, 0.007, 0.0228];\n\n/**\n* Convert HCT chroma and hue (CAM16 JMh colorfulness and hue) using UCS logic for a and b.\n* @param {number[]} coords - HCT coordinates.\n* @return {number[]}\n*/\nfunction convertUcsAb (coords) {\n\t// We want the distance between the actual color.\n\t// If chroma is negative, it will throw off our calculations.\n\t// Normally, converting back to the base and forward will correct it.\n\t// If we have a negative chroma after this, then we have a color that\n\t// cannot resolve to positive chroma.\n\tif (coords[1] < 0) {\n\t\tcoords = hct.fromBase(hct.toBase(coords));\n\t}\n\n\t// Only in extreme cases (usually outside the visible spectrum)\n\t// can the input value for log become negative.\n\t// Avoid domain error by forcing a zero result via \"max\" if necessary.\n\tconst M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1.0)) / ucsCoeff[2];\n\tconst hrad = coords[0] * deg2rad;\n\tconst a = M * Math.cos(hrad);\n\tconst b = M * Math.sin(hrad);\n\n\treturn [coords[2], a, b];\n}\n\n\n/**\n* Color distance using HCT.\n* @param {Color} color - Color to compare.\n* @param {Color} sample - Color to compare.\n* @return {number[]}\n*/\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\tlet [ t1, a1, b1 ] = convertUcsAb(hct.from(color));\n\tlet [ t2, a2, b2 ] = convertUcsAb(hct.from(sample));\n\n\t// Use simple euclidean distance with a and b using UCS conversion\n\t// and LCh lightness (HCT tone).\n\treturn Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);\n}\n"],"mappings":"AAAA,OAAOA,GAAG,MAAM,kBAAkB;AAClC,SAAQC,iBAAiB,QAAO,kBAAkB;AAClD,OAAOC,QAAQ,MAAM,gBAAgB;AAErC,MAAMC,OAAO,GAAG,GAAG,GAAGC,IAAI,CAACC,EAAE;AAC7B,MAAMC,OAAO,GAAGF,IAAI,CAACC,EAAE,GAAG,GAAG;AAC7B,MAAME,QAAQ,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAAEC,MAAM,EAAE;EAC9B;EACA;EACA;EACA;EACA;EACA,IAAIA,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;IAClBA,MAAM,GAAGT,GAAG,CAACU,QAAQ,CAACV,GAAG,CAACW,MAAM,CAACF,MAAM,CAAC,CAAC;EAC1C;;EAEA;EACA;EACA;EACA,MAAMG,CAAC,GAAGR,IAAI,CAACS,GAAG,CAACT,IAAI,CAACU,GAAG,CAAC,CAAC,GAAGP,QAAQ,CAAC,CAAC,CAAC,GAAGE,MAAM,CAAC,CAAC,CAAC,GAAGR,iBAAiB,CAACc,MAAM,EAAE,GAAG,CAAC,CAAC,GAAGR,QAAQ,CAAC,CAAC,CAAC;EACvG,MAAMS,IAAI,GAAGP,MAAM,CAAC,CAAC,CAAC,GAAGH,OAAO;EAChC,MAAMW,CAAC,GAAGL,CAAC,GAAGR,IAAI,CAACc,GAAG,CAACF,IAAI,CAAC;EAC5B,MAAMG,CAAC,GAAGP,CAAC,GAAGR,IAAI,CAACgB,GAAG,CAACJ,IAAI,CAAC;EAE5B,OAAO,CAACP,MAAM,CAAC,CAAC,CAAC,EAAEQ,CAAC,EAAEE,CAAC,CAAC;AACzB;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAUE,KAAK,EAAEC,MAAM,EAAE;EACvC,CAACD,KAAK,EAAEC,MAAM,CAAC,GAAGpB,QAAQ,CAAC,CAACmB,KAAK,EAAEC,MAAM,CAAC,CAAC;EAE3C,IAAI,CAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAE,GAAGjB,YAAY,CAACR,GAAG,CAAC0B,IAAI,CAACL,KAAK,CAAC,CAAC;EAClD,IAAI,CAAEM,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAE,GAAGrB,YAAY,CAACR,GAAG,CAAC0B,IAAI,CAACJ,MAAM,CAAC,CAAC;;EAEnD;EACA;EACA,OAAOlB,IAAI,CAAC0B,IAAI,CAAC,CAACP,EAAE,GAAGI,EAAE,KAAK,CAAC,GAAG,CAACH,EAAE,GAAGI,EAAE,KAAK,CAAC,GAAG,CAACH,EAAE,GAAGI,EAAE,KAAK,CAAC,CAAC;AACnE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}