{"ast":null,"code":"/**\n * @for p5\n * @requires core\n */\n// Borrow from stacktracejs https://github.com/stacktracejs/stacktrace.js with\n// minor modifications. The license for the same and the code is included below\n\n// Copyright (c) 2017 Eric Wendelin and other contributors\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction ErrorStackParser() {\n  let FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n  let CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  let SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     * @private\n     * @param {Error} error object\n     * @return {Array} of stack frames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else ;\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n      let regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      let parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      let filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n        }\n        let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n        // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n        let location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n        // remove the parenthesized location from the line, if it was matched\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        let tokens = sanitizedLine.split(/\\s+/).slice(1);\n        // if a location was matched, pass it to extractLocation() otherwise pop the last token\n        let locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        let functionName = tokens.join(' ') || undefined;\n        let fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return {\n          functionName,\n          fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        };\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      let filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n        }\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return {\n            functionName: line\n          };\n        } else {\n          let functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          let matches = line.match(functionNameRegex);\n          let functionName = matches && matches[1] ? matches[1] : undefined;\n          let locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return {\n            functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          };\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      let lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      let lines = e.message.split('\\n');\n      let result = [];\n      for (let i = 2, len = lines.length; i < len; i += 2) {\n        let match = lineRE.exec(lines[i]);\n        if (match) {\n          result.push({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          });\n        }\n      }\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      let lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      let lines = e.stacktrace.split('\\n');\n      let result = [];\n      for (let i = 0, len = lines.length; i < len; i += 2) {\n        let match = lineRE.exec(lines[i]);\n        if (match) {\n          result.push({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          });\n        }\n      }\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      let filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        let tokens = line.split('@');\n        let locationParts = this.extractLocation(tokens.pop());\n        let functionCall = tokens.shift() || '';\n        let functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n        let argsRaw;\n        if (functionCall.match(/\\(([^)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n        }\n        let args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return {\n          functionName,\n          args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        };\n      }, this);\n    }\n  };\n}\n\n// End borrow\n\n// wrapper exposing ErrorStackParser\nfunction stacktrace(p5, fn) {\n  p5._getErrorStackParser = function getErrorStackParser() {\n    return new ErrorStackParser();\n  };\n}\nif (typeof p5 !== 'undefined') {\n  stacktrace(p5, p5.prototype);\n}\nexport { stacktrace as default };","map":{"version":3,"names":["ErrorStackParser","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","parse","ErrorStackParser$$parse","error","stacktrace","parseOpera","stack","match","parseV8OrIE","parseFFOrSafari","extractLocation","ErrorStackParser$$extractLocation","urlLike","indexOf","regExp","parts","exec","replace","undefined","ErrorStackParser$$parseV8OrIE","filtered","split","filter","line","map","sanitizedLine","location","tokens","slice","locationParts","pop","functionName","join","fileName","lineNumber","columnNumber","source","ErrorStackParser$$parseFFOrSafari","functionNameRegex","matches","ErrorStackParser$$parseOpera","e","message","length","parseOpera9","parseOpera10","parseOpera11","ErrorStackParser$$parseOpera9","lineRE","lines","result","i","len","push","ErrorStackParser$$parseOpera10","ErrorStackParser$$parseOpera11","functionCall","shift","argsRaw","args","p5","fn","_getErrorStackParser","getErrorStackParser","prototype","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/core/friendly_errors/stacktrace.js"],"sourcesContent":["/**\n * @for p5\n * @requires core\n */\n// Borrow from stacktracejs https://github.com/stacktracejs/stacktrace.js with\n// minor modifications. The license for the same and the code is included below\n\n// Copyright (c) 2017 Eric Wendelin and other contributors\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction ErrorStackParser() {\n  let FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n  let CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  let SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     * @private\n     * @param {Error} error object\n     * @return {Array} of stack frames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (\n        typeof error.stacktrace !== 'undefined' ||\n        typeof error['opera#sourceloc'] !== 'undefined'\n      ) {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else ;\n    },\n\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      let regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      let parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      let filtered = error.stack.split('\\n').filter(function(line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n\n      return filtered.map(function(line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line\n            .replace(/eval code/g, 'eval')\n            .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n        }\n        let sanitizedLine = line\n          .replace(/^\\s+/, '')\n          .replace(/\\(eval code/g, '(');\n\n        // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n        let location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n        // remove the parenthesized location from the line, if it was matched\n        sanitizedLine = location\n          ? sanitizedLine.replace(location[0], '')\n          : sanitizedLine;\n\n        let tokens = sanitizedLine.split(/\\s+/).slice(1);\n        // if a location was matched, pass it to extractLocation() otherwise pop the last token\n        let locationParts = this.extractLocation(\n          location ? location[1] : tokens.pop()\n        );\n        let functionName = tokens.join(' ') || undefined;\n        let fileName =\n          ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n            ? undefined\n            : locationParts[0];\n\n        return {\n          functionName,\n          fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        };\n      }, this);\n    },\n\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      let filtered = error.stack.split('\\n').filter(function(line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n\n      return filtered.map(function(line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(\n            / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n            ':$1'\n          );\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return {\n            functionName: line\n          };\n        } else {\n          let functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          let matches = line.match(functionNameRegex);\n          let functionName = matches && matches[1] ? matches[1] : undefined;\n          let locationParts = this.extractLocation(\n            line.replace(functionNameRegex, '')\n          );\n\n          return {\n            functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          };\n        }\n      }, this);\n    },\n\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (\n        !e.stacktrace ||\n        (e.message.indexOf('\\n') > -1 &&\n          e.message.split('\\n').length > e.stacktrace.split('\\n').length)\n      ) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      let lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      let lines = e.message.split('\\n');\n      let result = [];\n\n      for (let i = 2, len = lines.length; i < len; i += 2) {\n        let match = lineRE.exec(lines[i]);\n        if (match) {\n          result.push({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          });\n        }\n      }\n\n      return result;\n    },\n\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      let lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      let lines = e.stacktrace.split('\\n');\n      let result = [];\n\n      for (let i = 0, len = lines.length; i < len; i += 2) {\n        let match = lineRE.exec(lines[i]);\n        if (match) {\n          result.push({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          });\n        }\n      }\n\n      return result;\n    },\n\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      let filtered = error.stack.split('\\n').filter(function(line) {\n        return (\n          !!line.match(FIREFOX_SAFARI_STACK_REGEXP) &&\n          !line.match(/^Error created at/)\n        );\n      }, this);\n\n      return filtered.map(function(line) {\n        let tokens = line.split('@');\n        let locationParts = this.extractLocation(tokens.pop());\n        let functionCall = tokens.shift() || '';\n        let functionName =\n          functionCall\n            .replace(/<anonymous function(: (\\w+))?>/, '$2')\n            .replace(/\\([^)]*\\)/g, '') || undefined;\n        let argsRaw;\n        if (functionCall.match(/\\(([^)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n        }\n        let args =\n          argsRaw === undefined || argsRaw === '[arguments not available]'\n            ? undefined\n            : argsRaw.split(',');\n\n        return {\n          functionName,\n          args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        };\n      }, this);\n    }\n  };\n}\n\n// End borrow\n\n// wrapper exposing ErrorStackParser\nfunction stacktrace(p5, fn){\n  p5._getErrorStackParser = function getErrorStackParser() {\n    return new ErrorStackParser();\n  };\n}\n\nif (typeof p5 !== 'undefined') {\n  stacktrace(p5, p5.prototype);\n}\n\nexport { stacktrace as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}