{"ast":null,"code":"/*\n * This module defines the filters for use with image buffers.\n *\n * This module is basically a collection of functions stored in an object\n * as opposed to modules. The functions are destructive, modifying\n * the passed in canvas rather than creating a copy.\n *\n * Generally speaking users of this module will use the Filters.apply method\n * on a canvas to create an effect.\n *\n * A number of functions are borrowed/adapted from\n * http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\n * or the java processing implementation.\n *\n * @private\n */\n\nconst Filters = {\n  /*\n   * Helper functions\n   */\n\n  /**\n   * Returns the pixel buffer for a canvas.\n   *\n   * @private\n   *\n   * @param  {Canvas|ImageData} canvas the canvas to get pixels from\n   * @return {Uint8ClampedArray}       a one-dimensional array containing\n   *                                   the data in the RGBA order, with integer\n   *                                   values between 0 and 255.\n   */\n  _toPixels(canvas) {\n    // Return pixel data if 'canvas' is an ImageData object.\n    if (canvas instanceof ImageData) {\n      return canvas.data;\n    } else {\n      // Check 2D context support.\n      if (canvas.getContext('2d')) {\n        // Retrieve pixel data.\n        return canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height).data;\n      } else if (canvas.getContext('webgl')) {\n        //Check WebGL context support\n        const gl = canvas.getContext('webgl');\n        // Calculate the size of pixel data\n        // (4 bytes per pixel - one byte for each RGBA channel).\n        const len = gl.drawingBufferWidth * gl.drawingBufferHeight * 4;\n        const data = new Uint8Array(len);\n        // Use gl.readPixels to fetch pixel data from the WebGL\n        // canvas, storing it in the data array as UNSIGNED_BYTE integers.\n        gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        return data;\n      }\n    }\n  },\n  /**\n   * Returns a 32-bit number containing ARGB data at the ith pixel in the\n   * 1D array containing pixels data.\n   *\n   * @private\n   *\n   * @param  {Uint8ClampedArray} data array returned by _toPixels()\n   * @param  {Integer}           i    index of a 1D Image Array\n   * @return {Integer}                32-bit integer value representing\n   *                                  ARGB value.\n   */\n  _getARGB(data, i) {\n    // Determine the starting position in the 'data' array for the 'i'-th pixel.\n    const offset = i * 4;\n    return (\n      // Combining the extracted components using bitwise OR operations to form the final ARGB value.\n      data[offset + 3] << 24 & 0xff000000 |\n      //Extract alpha component\n      data[offset] << 16 & 0x00ff0000 |\n      //Extract Red component\n      data[offset + 1] << 8 & 0x0000ff00 |\n      //Extract green component\n      data[offset + 2] & 0x000000ff //Extract blue component\n    );\n  },\n  /**\n   * Modifies pixels RGBA values to values contained in the data object.\n   *\n   * @private\n   *\n   * @param {Uint8ClampedArray} pixels array returned by _toPixels()\n   * @param {Int32Array}        data   source 1D array where each value\n   *                                   represents ARGB values\n   */\n  _setPixels(pixels, data) {\n    let offset = 0;\n    for (let i = 0, al = pixels.length; i < al; i++) {\n      offset = i * 4;\n      pixels[offset + 0] = (data[i] & 0x00ff0000) >>> 16;\n      pixels[offset + 1] = (data[i] & 0x0000ff00) >>> 8;\n      pixels[offset + 2] = data[i] & 0x000000ff;\n      pixels[offset + 3] = (data[i] & 0xff000000) >>> 24;\n    }\n  },\n  /**\n   * Returns the ImageData object for a canvas.\n   * https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n   *\n   * @private\n   *\n   * @param  {Canvas|ImageData} canvas canvas to get image data from\n   * @return {ImageData}               Holder of pixel data (and width and\n   *                                   height) for a canvas\n   */\n  _toImageData(canvas) {\n    if (canvas instanceof ImageData) {\n      return canvas;\n    } else {\n      return canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n    }\n  },\n  /**\n   * Returns a blank ImageData object.\n   *\n   * @private\n   *\n   * @param  {Integer} width\n   * @param  {Integer} height\n   * @return {ImageData}\n   */\n  _createImageData(width, height) {\n    Filters._tmpCanvas = document.createElement('canvas');\n    Filters._tmpCtx = Filters._tmpCanvas.getContext('2d');\n    return this._tmpCtx.createImageData(width, height);\n  },\n  /**\n   * Applys a filter function to a canvas.\n   *\n   * The difference between this and the actual filter functions defined below\n   * is that the filter functions generally modify the pixel buffer but do\n   * not actually put that data back to the canvas (where it would actually\n   * update what is visible). By contrast this method does make the changes\n   * actually visible in the canvas.\n   *\n   * The apply method is the method that callers of this module would generally\n   * use. It has been separated from the actual filters to support an advanced\n   * use case of creating a filter chain that executes without actually updating\n   * the canvas in between everystep.\n   *\n   * @private\n   * @param  {HTMLCanvasElement} canvas The input canvas to apply the filter on.\n   * @param  {function(ImageData,Object)} func The filter function to apply to the canvas's pixel data.\n   * @param  {Object} filterParam An optional parameter to pass to the filter function.\n   */\n  apply(canvas, func, filterParam) {\n    const pixelsState = canvas.getContext('2d');\n    const imageData = pixelsState.getImageData(0, 0, canvas.width, canvas.height);\n\n    //Filters can either return a new ImageData object, or just modify\n    //the one they received.\n    const newImageData = func(imageData, filterParam);\n    //If new ImageData is returned, replace the canvas's pixel data with it.\n    if (newImageData instanceof ImageData) {\n      pixelsState.putImageData(newImageData, 0, 0, 0, 0, canvas.width, canvas.height);\n    } else {\n      //Restore the original pixel.\n      pixelsState.putImageData(imageData, 0, 0, 0, 0, canvas.width, canvas.height);\n    }\n  },\n  /*\n   * Filters\n   */\n\n  /**\n   * Converts the image to black and white pixels depending if they are above or\n   * below the threshold defined by the level parameter. The parameter must be\n   * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.\n   *\n   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\n   *\n   * @private\n   * @param  {Canvas} canvas Canvas to apply thershold filter on.\n   * @param  {Float} level Threshold level (0-1).\n   */\n  threshold(canvas, level = 0.5) {\n    const pixels = Filters._toPixels(canvas);\n\n    // Calculate threshold value on a (0-255) scale.\n    const thresh = Math.floor(level * 255);\n    for (let i = 0; i < pixels.length; i += 4) {\n      const r = pixels[i];\n      const g = pixels[i + 1];\n      const b = pixels[i + 2];\n      // CIE luminance for RGB\n      const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n      let val;\n      if (gray >= thresh) {\n        val = 255;\n      } else {\n        val = 0;\n      }\n      pixels[i] = pixels[i + 1] = pixels[i + 2] = val; //set pixel to val.\n    }\n  },\n  /**\n   * Converts any colors in the image to grayscale equivalents.\n   * No parameter is used.\n   *\n   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\n   *\n   * @private\n   * @param {Canvas} canvas Canvas to apply gray filter on.\n   */\n  gray(canvas) {\n    const pixels = Filters._toPixels(canvas);\n    for (let i = 0; i < pixels.length; i += 4) {\n      const r = pixels[i];\n      const g = pixels[i + 1];\n      const b = pixels[i + 2];\n\n      // CIE luminance for RGB\n      const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n      pixels[i] = pixels[i + 1] = pixels[i + 2] = gray; // set pixel to gray.\n    }\n  },\n  /**\n   * Sets the alpha channel to entirely opaque. No parameter is used.\n   *\n   * @private\n   * @param {Canvas} canvas\n   */\n  opaque(canvas) {\n    const pixels = Filters._toPixels(canvas);\n    for (let i = 0; i < pixels.length; i += 4) {\n      pixels[i + 3] = 255;\n    }\n    return pixels;\n  },\n  /**\n   * Sets each pixel to its inverse value. No parameter is used.\n   * @private\n   * @param  {Canvas} canvas\n   */\n  invert(canvas) {\n    const pixels = Filters._toPixels(canvas);\n    for (let i = 0; i < pixels.length; i += 4) {\n      pixels[i] = 255 - pixels[i];\n      pixels[i + 1] = 255 - pixels[i + 1];\n      pixels[i + 2] = 255 - pixels[i + 2];\n    }\n  },\n  /**\n   * Limits each channel of the image to the number of colors specified as\n   * the parameter. The parameter can be set to values between 2 and 255, but\n   * results are most noticeable in the lower ranges.\n   *\n   * Adapted from java based processing implementation\n   *\n   * @private\n   * @param  {Canvas} canvas\n   * @param  {Integer} level\n   */\n  posterize(canvas, level = 4) {\n    const pixels = Filters._toPixels(canvas);\n    if (level < 2 || level > 255) {\n      throw new Error('Level must be greater than 2 and less than 255 for posterize');\n    }\n    const levels1 = level - 1;\n    for (let i = 0; i < pixels.length; i += 4) {\n      const rlevel = pixels[i];\n      const glevel = pixels[i + 1];\n      const blevel = pixels[i + 2];\n\n      // New pixel value by posterizing each color.\n      pixels[i] = (rlevel * level >> 8) * 255 / levels1;\n      pixels[i + 1] = (glevel * level >> 8) * 255 / levels1;\n      pixels[i + 2] = (blevel * level >> 8) * 255 / levels1;\n    }\n  },\n  /**\n   * Increases the bright areas in an image.\n   * @private\n   * @param  {Canvas} canvas\n   */\n  dilate(canvas) {\n    const pixels = Filters._toPixels(canvas);\n    let currIdx = 0;\n    const maxIdx = pixels.length ? pixels.length / 4 : 0;\n    const out = new Int32Array(maxIdx);\n    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n    let idxRight, idxLeft, idxUp, idxDown;\n    let colRight, colLeft, colUp, colDown;\n    let lumRight, lumLeft, lumUp, lumDown;\n    // Iterates through rows of pixels.\n    while (currIdx < maxIdx) {\n      currRowIdx = currIdx;\n      maxRowIdx = currIdx + canvas.width;\n      // Iterates through pixels within the current row.\n      while (currIdx < maxRowIdx) {\n        // Get original color of current pixel.\n        colOrig = colOut = Filters._getARGB(pixels, currIdx);\n        idxLeft = currIdx - 1;\n        idxRight = currIdx + 1;\n        idxUp = currIdx - canvas.width;\n        idxDown = currIdx + canvas.width;\n\n        // Adjust the indices to avoid going out of bounds.\n        if (idxLeft < currRowIdx) {\n          idxLeft = currIdx;\n        }\n        if (idxRight >= maxRowIdx) {\n          idxRight = currIdx;\n        }\n        if (idxUp < 0) {\n          idxUp = 0;\n        }\n        if (idxDown >= maxIdx) {\n          idxDown = currIdx;\n        }\n        colUp = Filters._getARGB(pixels, idxUp);\n        colLeft = Filters._getARGB(pixels, idxLeft);\n        colDown = Filters._getARGB(pixels, idxDown);\n        colRight = Filters._getARGB(pixels, idxRight);\n\n        // Compute luminance\n        currLum = 77 * (colOrig >> 16 & 0xff) + 151 * (colOrig >> 8 & 0xff) + 28 * (colOrig & 0xff);\n        lumLeft = 77 * (colLeft >> 16 & 0xff) + 151 * (colLeft >> 8 & 0xff) + 28 * (colLeft & 0xff);\n        lumRight = 77 * (colRight >> 16 & 0xff) + 151 * (colRight >> 8 & 0xff) + 28 * (colRight & 0xff);\n        lumUp = 77 * (colUp >> 16 & 0xff) + 151 * (colUp >> 8 & 0xff) + 28 * (colUp & 0xff);\n        lumDown = 77 * (colDown >> 16 & 0xff) + 151 * (colDown >> 8 & 0xff) + 28 * (colDown & 0xff);\n\n        // Update the output color based on the highest luminance value\n        if (lumLeft > currLum) {\n          colOut = colLeft;\n          currLum = lumLeft;\n        }\n        if (lumRight > currLum) {\n          colOut = colRight;\n          currLum = lumRight;\n        }\n        if (lumUp > currLum) {\n          colOut = colUp;\n          currLum = lumUp;\n        }\n        if (lumDown > currLum) {\n          colOut = colDown;\n          currLum = lumDown;\n        }\n        // Store the updated color.\n        out[currIdx++] = colOut;\n      }\n    }\n    Filters._setPixels(pixels, out);\n  },\n  /**\n   * Reduces the bright areas in an image.\n   * Similar to `dilate()`, but updates the output color based on the lowest luminance value.\n   * @private\n   * @param  {Canvas} canvas\n   */\n  erode(canvas) {\n    const pixels = Filters._toPixels(canvas);\n    let currIdx = 0;\n    const maxIdx = pixels.length ? pixels.length / 4 : 0;\n    const out = new Int32Array(maxIdx);\n    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n    let idxRight, idxLeft, idxUp, idxDown;\n    let colRight, colLeft, colUp, colDown;\n    let lumRight, lumLeft, lumUp, lumDown;\n    while (currIdx < maxIdx) {\n      currRowIdx = currIdx;\n      maxRowIdx = currIdx + canvas.width;\n      while (currIdx < maxRowIdx) {\n        colOrig = colOut = Filters._getARGB(pixels, currIdx);\n        idxLeft = currIdx - 1;\n        idxRight = currIdx + 1;\n        idxUp = currIdx - canvas.width;\n        idxDown = currIdx + canvas.width;\n        if (idxLeft < currRowIdx) {\n          idxLeft = currIdx;\n        }\n        if (idxRight >= maxRowIdx) {\n          idxRight = currIdx;\n        }\n        if (idxUp < 0) {\n          idxUp = 0;\n        }\n        if (idxDown >= maxIdx) {\n          idxDown = currIdx;\n        }\n        colUp = Filters._getARGB(pixels, idxUp);\n        colLeft = Filters._getARGB(pixels, idxLeft);\n        colDown = Filters._getARGB(pixels, idxDown);\n        colRight = Filters._getARGB(pixels, idxRight);\n\n        //compute luminance\n        currLum = 77 * (colOrig >> 16 & 0xff) + 151 * (colOrig >> 8 & 0xff) + 28 * (colOrig & 0xff);\n        lumLeft = 77 * (colLeft >> 16 & 0xff) + 151 * (colLeft >> 8 & 0xff) + 28 * (colLeft & 0xff);\n        lumRight = 77 * (colRight >> 16 & 0xff) + 151 * (colRight >> 8 & 0xff) + 28 * (colRight & 0xff);\n        lumUp = 77 * (colUp >> 16 & 0xff) + 151 * (colUp >> 8 & 0xff) + 28 * (colUp & 0xff);\n        lumDown = 77 * (colDown >> 16 & 0xff) + 151 * (colDown >> 8 & 0xff) + 28 * (colDown & 0xff);\n        if (lumLeft < currLum) {\n          colOut = colLeft;\n          currLum = lumLeft;\n        }\n        if (lumRight < currLum) {\n          colOut = colRight;\n          currLum = lumRight;\n        }\n        if (lumUp < currLum) {\n          colOut = colUp;\n          currLum = lumUp;\n        }\n        if (lumDown < currLum) {\n          colOut = colDown;\n          currLum = lumDown;\n        }\n        // Store the updated color.\n        out[currIdx++] = colOut;\n      }\n    }\n    Filters._setPixels(pixels, out);\n  },\n  blur(canvas, radius) {\n    blurARGB(canvas, radius);\n  }\n};\n\n// BLUR\n\n// Internal kernel stuff for the gaussian blur filter.\nlet blurRadius;\nlet blurKernelSize;\nlet blurKernel;\nlet blurMult;\n\n/*\n * Port of https://github.com/processing/processing/blob/\n * main/core/src/processing/core/PImage.java#L1250\n *\n * Optimized code for building the blur kernel.\n * further optimized blur code (approx. 15% for radius=20)\n * bigger speed gains for larger radii (~30%)\n * added support for various image types (ALPHA, RGB, ARGB)\n * [toxi 050728]\n */\nfunction buildBlurKernel(r) {\n  let radius = r * 3.5 | 0;\n  radius = radius < 1 ? 1 : radius < 248 ? radius : 248;\n  if (blurRadius !== radius) {\n    blurRadius = radius;\n    // Calculating the size of the blur kernel\n    blurKernelSize = 1 + blurRadius << 1;\n    blurKernel = new Int32Array(blurKernelSize);\n    blurMult = new Array(blurKernelSize);\n    for (let l = 0; l < blurKernelSize; l++) {\n      blurMult[l] = new Int32Array(256);\n    }\n    let bk, bki;\n    let bm, bmi;\n    // Generating blur kernel values.\n    for (let i = 1, radiusi = radius - 1; i < radius; i++) {\n      blurKernel[radius + i] = blurKernel[radiusi] = bki = radiusi * radiusi;\n      bm = blurMult[radius + i];\n      bmi = blurMult[radiusi--];\n      for (let j = 0; j < 256; j++) {\n        bm[j] = bmi[j] = bki * j;\n      }\n    }\n    bk = blurKernel[radius] = radius * radius;\n    bm = blurMult[radius];\n    for (let k = 0; k < 256; k++) {\n      bm[k] = bk * k;\n    }\n  }\n}\n\n// Port of https://github.com/processing/processing/blob/\n// main/core/src/processing/core/PImage.java#L1433\nfunction blurARGB(canvas, radius) {\n  // Get pixel data.\n  const pixels = Filters._toPixels(canvas);\n  const width = canvas.width;\n  const height = canvas.height;\n  const numPackedPixels = width * height;\n  const argb = new Int32Array(numPackedPixels);\n  for (let j = 0; j < numPackedPixels; j++) {\n    argb[j] = Filters._getARGB(pixels, j);\n  }\n  let sum, cr, cg, cb, ca;\n  let read, ri, ym, ymi, bk0;\n  const a2 = new Int32Array(numPackedPixels);\n  const r2 = new Int32Array(numPackedPixels);\n  const g2 = new Int32Array(numPackedPixels);\n  const b2 = new Int32Array(numPackedPixels);\n  let yi = 0;\n  buildBlurKernel(radius);\n  let x, y, i;\n  let bm;\n  // Horizontal pass.\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      cb = cg = cr = ca = sum = 0;\n      read = x - blurRadius;\n      // Handle edge cases.\n      if (read < 0) {\n        bk0 = -read;\n        read = 0;\n      } else {\n        if (read >= width) {\n          break;\n        }\n        bk0 = 0;\n      }\n      for (i = bk0; i < blurKernelSize; i++) {\n        if (read >= width) {\n          break;\n        }\n        const c = argb[read + yi];\n        bm = blurMult[i];\n        ca += bm[(c & -16777216) >>> 24];\n        cr += bm[(c & 16711680) >> 16];\n        cg += bm[(c & 65280) >> 8];\n        cb += bm[c & 255];\n        sum += blurKernel[i];\n        read++;\n      }\n      ri = yi + x;\n      a2[ri] = ca / sum;\n      r2[ri] = cr / sum;\n      g2[ri] = cg / sum;\n      b2[ri] = cb / sum;\n    }\n    yi += width;\n  }\n  yi = 0;\n  ym = -blurRadius;\n  ymi = ym * width;\n  //  Vertical pass.\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      cb = cg = cr = ca = sum = 0;\n      // Handle edge cases.\n      if (ym < 0) {\n        bk0 = ri = -ym;\n        read = x;\n      } else {\n        if (ym >= height) {\n          break;\n        }\n        bk0 = 0;\n        ri = ym;\n        read = x + ymi;\n      }\n      for (i = bk0; i < blurKernelSize; i++) {\n        if (ri >= height) {\n          break;\n        }\n        bm = blurMult[i];\n        ca += bm[a2[read]];\n        cr += bm[r2[read]];\n        cg += bm[g2[read]];\n        cb += bm[b2[read]];\n        sum += blurKernel[i];\n        ri++;\n        read += width;\n      }\n      // Set final ARGB value\n      argb[x + yi] = ca / sum << 24 | cr / sum << 16 | cg / sum << 8 | cb / sum;\n    }\n    yi += width;\n    ymi += width;\n    ym++;\n  }\n  Filters._setPixels(pixels, argb);\n}\nexport { Filters as default };","map":{"version":3,"names":["Filters","_toPixels","canvas","ImageData","data","getContext","getImageData","width","height","gl","len","drawingBufferWidth","drawingBufferHeight","Uint8Array","readPixels","RGBA","UNSIGNED_BYTE","_getARGB","i","offset","_setPixels","pixels","al","length","_toImageData","_createImageData","_tmpCanvas","document","createElement","_tmpCtx","createImageData","apply","func","filterParam","pixelsState","imageData","newImageData","putImageData","threshold","level","thresh","Math","floor","r","g","b","gray","val","opaque","invert","posterize","Error","levels1","rlevel","glevel","blevel","dilate","currIdx","maxIdx","out","Int32Array","currRowIdx","maxRowIdx","colOrig","colOut","currLum","idxRight","idxLeft","idxUp","idxDown","colRight","colLeft","colUp","colDown","lumRight","lumLeft","lumUp","lumDown","erode","blur","radius","blurARGB","blurRadius","blurKernelSize","blurKernel","blurMult","buildBlurKernel","Array","l","bk","bki","bm","bmi","radiusi","j","k","numPackedPixels","argb","sum","cr","cg","cb","ca","read","ri","ym","ymi","bk0","a2","r2","g2","b2","yi","x","y","c","default"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/p5/dist/image/filters.js"],"sourcesContent":["/*\n * This module defines the filters for use with image buffers.\n *\n * This module is basically a collection of functions stored in an object\n * as opposed to modules. The functions are destructive, modifying\n * the passed in canvas rather than creating a copy.\n *\n * Generally speaking users of this module will use the Filters.apply method\n * on a canvas to create an effect.\n *\n * A number of functions are borrowed/adapted from\n * http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\n * or the java processing implementation.\n *\n * @private\n */\n\nconst Filters = {\n\n  /*\n   * Helper functions\n   */\n\n  /**\n   * Returns the pixel buffer for a canvas.\n   *\n   * @private\n   *\n   * @param  {Canvas|ImageData} canvas the canvas to get pixels from\n   * @return {Uint8ClampedArray}       a one-dimensional array containing\n   *                                   the data in the RGBA order, with integer\n   *                                   values between 0 and 255.\n   */\n  _toPixels(canvas) {\n    // Return pixel data if 'canvas' is an ImageData object.\n    if (canvas instanceof ImageData) {\n      return canvas.data;\n    } else {\n      // Check 2D context support.\n      if (canvas.getContext('2d')) {\n        // Retrieve pixel data.\n        return canvas\n          .getContext('2d')\n          .getImageData(0, 0, canvas.width, canvas.height).data;\n      } else if (canvas.getContext('webgl')) { //Check WebGL context support\n        const gl = canvas.getContext('webgl');\n        // Calculate the size of pixel data\n        // (4 bytes per pixel - one byte for each RGBA channel).\n        const len = gl.drawingBufferWidth * gl.drawingBufferHeight * 4;\n        const data = new Uint8Array(len);\n        // Use gl.readPixels to fetch pixel data from the WebGL\n        // canvas, storing it in the data array as UNSIGNED_BYTE integers.\n        gl.readPixels(\n          0,\n          0,\n          canvas.width,\n          canvas.height,\n          gl.RGBA,\n          gl.UNSIGNED_BYTE,\n          data\n        );\n        return data;\n      }\n    }\n  },\n\n  /**\n   * Returns a 32-bit number containing ARGB data at the ith pixel in the\n   * 1D array containing pixels data.\n   *\n   * @private\n   *\n   * @param  {Uint8ClampedArray} data array returned by _toPixels()\n   * @param  {Integer}           i    index of a 1D Image Array\n   * @return {Integer}                32-bit integer value representing\n   *                                  ARGB value.\n   */\n  _getARGB(data, i) {\n    // Determine the starting position in the 'data' array for the 'i'-th pixel.\n    const offset = i * 4;\n    return (\n      // Combining the extracted components using bitwise OR operations to form the final ARGB value.\n      ((data[offset + 3] << 24) & 0xff000000) | //Extract alpha component\n      ((data[offset] << 16) & 0x00ff0000) | //Extract Red component\n      ((data[offset + 1] << 8) & 0x0000ff00) | //Extract green component\n      (data[offset + 2] & 0x000000ff) //Extract blue component\n    );\n  },\n\n  /**\n   * Modifies pixels RGBA values to values contained in the data object.\n   *\n   * @private\n   *\n   * @param {Uint8ClampedArray} pixels array returned by _toPixels()\n   * @param {Int32Array}        data   source 1D array where each value\n   *                                   represents ARGB values\n   */\n  _setPixels(pixels, data) {\n    let offset = 0;\n    for (let i = 0, al = pixels.length; i < al; i++) {\n      offset = i * 4;\n      pixels[offset + 0] = (data[i] & 0x00ff0000) >>> 16;\n      pixels[offset + 1] = (data[i] & 0x0000ff00) >>> 8;\n      pixels[offset + 2] = data[i] & 0x000000ff;\n      pixels[offset + 3] = (data[i] & 0xff000000) >>> 24;\n    }\n  },\n\n\n  /**\n   * Returns the ImageData object for a canvas.\n   * https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n   *\n   * @private\n   *\n   * @param  {Canvas|ImageData} canvas canvas to get image data from\n   * @return {ImageData}               Holder of pixel data (and width and\n   *                                   height) for a canvas\n   */\n  _toImageData(canvas) {\n    if (canvas instanceof ImageData) {\n      return canvas;\n    } else {\n      return canvas\n        .getContext('2d')\n        .getImageData(0, 0, canvas.width, canvas.height);\n    }\n  },\n\n\n  /**\n   * Returns a blank ImageData object.\n   *\n   * @private\n   *\n   * @param  {Integer} width\n   * @param  {Integer} height\n   * @return {ImageData}\n   */\n  _createImageData(width, height) {\n    Filters._tmpCanvas = document.createElement('canvas');\n    Filters._tmpCtx = Filters._tmpCanvas.getContext('2d');\n    return this._tmpCtx.createImageData(width, height);\n  },\n\n  /**\n   * Applys a filter function to a canvas.\n   *\n   * The difference between this and the actual filter functions defined below\n   * is that the filter functions generally modify the pixel buffer but do\n   * not actually put that data back to the canvas (where it would actually\n   * update what is visible). By contrast this method does make the changes\n   * actually visible in the canvas.\n   *\n   * The apply method is the method that callers of this module would generally\n   * use. It has been separated from the actual filters to support an advanced\n   * use case of creating a filter chain that executes without actually updating\n   * the canvas in between everystep.\n   *\n   * @private\n   * @param  {HTMLCanvasElement} canvas The input canvas to apply the filter on.\n   * @param  {function(ImageData,Object)} func The filter function to apply to the canvas's pixel data.\n   * @param  {Object} filterParam An optional parameter to pass to the filter function.\n   */\n  apply(canvas, func, filterParam) {\n    const pixelsState = canvas.getContext('2d');\n    const imageData = pixelsState.getImageData(\n      0, 0, canvas.width, canvas.height);\n\n    //Filters can either return a new ImageData object, or just modify\n    //the one they received.\n    const newImageData = func(imageData, filterParam);\n    //If new ImageData is returned, replace the canvas's pixel data with it.\n    if (newImageData instanceof ImageData) {\n      pixelsState.putImageData(\n        newImageData,\n        0,\n        0,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n    } else {  //Restore the original pixel.\n      pixelsState.putImageData(\n        imageData,\n        0,\n        0,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n    }\n  },\n\n  /*\n   * Filters\n   */\n\n  /**\n   * Converts the image to black and white pixels depending if they are above or\n   * below the threshold defined by the level parameter. The parameter must be\n   * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.\n   *\n   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\n   *\n   * @private\n   * @param  {Canvas} canvas Canvas to apply thershold filter on.\n   * @param  {Float} level Threshold level (0-1).\n   */\n  threshold(canvas, level = 0.5) {\n    const pixels = Filters._toPixels(canvas);\n\n    // Calculate threshold value on a (0-255) scale.\n    const thresh = Math.floor(level * 255);\n\n    for (let i = 0; i < pixels.length; i += 4) {\n      const r = pixels[i];\n      const g = pixels[i + 1];\n      const b = pixels[i + 2];\n      // CIE luminance for RGB\n      const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n      let val;\n      if (gray >= thresh) {\n        val = 255;\n      } else {\n        val = 0;\n      }\n      pixels[i] = pixels[i + 1] = pixels[i + 2] = val; //set pixel to val.\n    }\n  },\n\n  /**\n   * Converts any colors in the image to grayscale equivalents.\n   * No parameter is used.\n   *\n   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\n   *\n   * @private\n   * @param {Canvas} canvas Canvas to apply gray filter on.\n   */\n  gray(canvas) {\n    const pixels = Filters._toPixels(canvas);\n\n    for (let i = 0; i < pixels.length; i += 4) {\n      const r = pixels[i];\n      const g = pixels[i + 1];\n      const b = pixels[i + 2];\n\n      // CIE luminance for RGB\n      const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n      pixels[i] = pixels[i + 1] = pixels[i + 2] = gray; // set pixel to gray.\n    }\n  },\n\n  /**\n   * Sets the alpha channel to entirely opaque. No parameter is used.\n   *\n   * @private\n   * @param {Canvas} canvas\n   */\n  opaque(canvas) {\n    const pixels = Filters._toPixels(canvas);\n\n    for (let i = 0; i < pixels.length; i += 4) {\n      pixels[i + 3] = 255;\n    }\n\n    return pixels;\n  },\n\n  /**\n   * Sets each pixel to its inverse value. No parameter is used.\n   * @private\n   * @param  {Canvas} canvas\n   */\n  invert(canvas) {\n    const pixels = Filters._toPixels(canvas);\n\n    for (let i = 0; i < pixels.length; i += 4) {\n      pixels[i] = 255 - pixels[i];\n      pixels[i + 1] = 255 - pixels[i + 1];\n      pixels[i + 2] = 255 - pixels[i + 2];\n    }\n  },\n\n  /**\n   * Limits each channel of the image to the number of colors specified as\n   * the parameter. The parameter can be set to values between 2 and 255, but\n   * results are most noticeable in the lower ranges.\n   *\n   * Adapted from java based processing implementation\n   *\n   * @private\n   * @param  {Canvas} canvas\n   * @param  {Integer} level\n   */\n  posterize(canvas, level = 4) {\n    const pixels = Filters._toPixels(canvas);\n    if (level < 2 || level > 255) {\n      throw new Error(\n        'Level must be greater than 2 and less than 255 for posterize'\n      );\n    }\n\n    const levels1 = level - 1;\n    for (let i = 0; i < pixels.length; i += 4) {\n      const rlevel = pixels[i];\n      const glevel = pixels[i + 1];\n      const blevel = pixels[i + 2];\n\n      // New pixel value by posterizing each color.\n      pixels[i] = ((rlevel * level) >> 8) * 255 / levels1;\n      pixels[i + 1] = ((glevel * level) >> 8) * 255 / levels1;\n      pixels[i + 2] = ((blevel * level) >> 8) * 255 / levels1;\n    }\n  },\n\n  /**\n   * Increases the bright areas in an image.\n   * @private\n   * @param  {Canvas} canvas\n   */\n  dilate(canvas) {\n    const pixels = Filters._toPixels(canvas);\n    let currIdx = 0;\n    const maxIdx = pixels.length ? pixels.length / 4 : 0;\n    const out = new Int32Array(maxIdx);\n    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n\n    let idxRight, idxLeft, idxUp, idxDown;\n    let colRight, colLeft, colUp, colDown;\n    let lumRight, lumLeft, lumUp, lumDown;\n    // Iterates through rows of pixels.\n    while (currIdx < maxIdx) {\n      currRowIdx = currIdx;\n      maxRowIdx = currIdx + canvas.width;\n      // Iterates through pixels within the current row.\n      while (currIdx < maxRowIdx) {\n        // Get original color of current pixel.\n        colOrig = colOut = Filters._getARGB(pixels, currIdx);\n        idxLeft = currIdx - 1;\n        idxRight = currIdx + 1;\n        idxUp = currIdx - canvas.width;\n        idxDown = currIdx + canvas.width;\n\n        // Adjust the indices to avoid going out of bounds.\n        if (idxLeft < currRowIdx) {\n          idxLeft = currIdx;\n        }\n        if (idxRight >= maxRowIdx) {\n          idxRight = currIdx;\n        }\n        if (idxUp < 0) {\n          idxUp = 0;\n        }\n        if (idxDown >= maxIdx) {\n          idxDown = currIdx;\n        }\n        colUp = Filters._getARGB(pixels, idxUp);\n        colLeft = Filters._getARGB(pixels, idxLeft);\n        colDown = Filters._getARGB(pixels, idxDown);\n        colRight = Filters._getARGB(pixels, idxRight);\n\n        // Compute luminance\n        currLum =\n          77 * ((colOrig >> 16) & 0xff) +\n          151 * ((colOrig >> 8) & 0xff) +\n          28 * (colOrig & 0xff);\n        lumLeft =\n          77 * ((colLeft >> 16) & 0xff) +\n          151 * ((colLeft >> 8) & 0xff) +\n          28 * (colLeft & 0xff);\n        lumRight =\n          77 * ((colRight >> 16) & 0xff) +\n          151 * ((colRight >> 8) & 0xff) +\n          28 * (colRight & 0xff);\n        lumUp =\n          77 * ((colUp >> 16) & 0xff) +\n          151 * ((colUp >> 8) & 0xff) +\n          28 * (colUp & 0xff);\n        lumDown =\n          77 * ((colDown >> 16) & 0xff) +\n          151 * ((colDown >> 8) & 0xff) +\n          28 * (colDown & 0xff);\n\n        // Update the output color based on the highest luminance value\n        if (lumLeft > currLum) {\n          colOut = colLeft;\n          currLum = lumLeft;\n        }\n        if (lumRight > currLum) {\n          colOut = colRight;\n          currLum = lumRight;\n        }\n        if (lumUp > currLum) {\n          colOut = colUp;\n          currLum = lumUp;\n        }\n        if (lumDown > currLum) {\n          colOut = colDown;\n          currLum = lumDown;\n        }\n        // Store the updated color.\n        out[currIdx++] = colOut;\n      }\n    }\n    Filters._setPixels(pixels, out);\n  },\n\n  /**\n   * Reduces the bright areas in an image.\n   * Similar to `dilate()`, but updates the output color based on the lowest luminance value.\n   * @private\n   * @param  {Canvas} canvas\n   */\n  erode(canvas) {\n    const pixels = Filters._toPixels(canvas);\n    let currIdx = 0;\n    const maxIdx = pixels.length ? pixels.length / 4 : 0;\n    const out = new Int32Array(maxIdx);\n    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n    let idxRight, idxLeft, idxUp, idxDown;\n    let colRight, colLeft, colUp, colDown;\n    let lumRight, lumLeft, lumUp, lumDown;\n\n    while (currIdx < maxIdx) {\n      currRowIdx = currIdx;\n      maxRowIdx = currIdx + canvas.width;\n      while (currIdx < maxRowIdx) {\n        colOrig = colOut = Filters._getARGB(pixels, currIdx);\n        idxLeft = currIdx - 1;\n        idxRight = currIdx + 1;\n        idxUp = currIdx - canvas.width;\n        idxDown = currIdx + canvas.width;\n\n        if (idxLeft < currRowIdx) {\n          idxLeft = currIdx;\n        }\n        if (idxRight >= maxRowIdx) {\n          idxRight = currIdx;\n        }\n        if (idxUp < 0) {\n          idxUp = 0;\n        }\n        if (idxDown >= maxIdx) {\n          idxDown = currIdx;\n        }\n        colUp = Filters._getARGB(pixels, idxUp);\n        colLeft = Filters._getARGB(pixels, idxLeft);\n        colDown = Filters._getARGB(pixels, idxDown);\n        colRight = Filters._getARGB(pixels, idxRight);\n\n        //compute luminance\n        currLum =\n          77 * ((colOrig >> 16) & 0xff) +\n          151 * ((colOrig >> 8) & 0xff) +\n          28 * (colOrig & 0xff);\n        lumLeft =\n          77 * ((colLeft >> 16) & 0xff) +\n          151 * ((colLeft >> 8) & 0xff) +\n          28 * (colLeft & 0xff);\n        lumRight =\n          77 * ((colRight >> 16) & 0xff) +\n          151 * ((colRight >> 8) & 0xff) +\n          28 * (colRight & 0xff);\n        lumUp =\n          77 * ((colUp >> 16) & 0xff) +\n          151 * ((colUp >> 8) & 0xff) +\n          28 * (colUp & 0xff);\n        lumDown =\n          77 * ((colDown >> 16) & 0xff) +\n          151 * ((colDown >> 8) & 0xff) +\n          28 * (colDown & 0xff);\n\n        if (lumLeft < currLum) {\n          colOut = colLeft;\n          currLum = lumLeft;\n        }\n        if (lumRight < currLum) {\n          colOut = colRight;\n          currLum = lumRight;\n        }\n        if (lumUp < currLum) {\n          colOut = colUp;\n          currLum = lumUp;\n        }\n        if (lumDown < currLum) {\n          colOut = colDown;\n          currLum = lumDown;\n        }\n        // Store the updated color.\n        out[currIdx++] = colOut;\n      }\n    }\n    Filters._setPixels(pixels, out);\n  },\n\n  blur(canvas, radius) {\n    blurARGB(canvas, radius);\n  }\n};\n\n// BLUR\n\n// Internal kernel stuff for the gaussian blur filter.\nlet blurRadius;\nlet blurKernelSize;\nlet blurKernel;\nlet blurMult;\n\n/*\n * Port of https://github.com/processing/processing/blob/\n * main/core/src/processing/core/PImage.java#L1250\n *\n * Optimized code for building the blur kernel.\n * further optimized blur code (approx. 15% for radius=20)\n * bigger speed gains for larger radii (~30%)\n * added support for various image types (ALPHA, RGB, ARGB)\n * [toxi 050728]\n */\nfunction buildBlurKernel(r) {\n  let radius = (r * 3.5) | 0;\n  radius = radius < 1 ? 1 : radius < 248 ? radius : 248;\n\n  if (blurRadius !== radius) {\n    blurRadius = radius;\n    // Calculating the size of the blur kernel\n    blurKernelSize = (1 + blurRadius) << 1;\n    blurKernel = new Int32Array(blurKernelSize);\n    blurMult = new Array(blurKernelSize);\n    for (let l = 0; l < blurKernelSize; l++) {\n      blurMult[l] = new Int32Array(256);\n    }\n\n    let bk, bki;\n    let bm, bmi;\n    // Generating blur kernel values.\n    for (let i = 1, radiusi = radius - 1; i < radius; i++) {\n      blurKernel[radius + i] = blurKernel[radiusi] = bki = radiusi * radiusi;\n      bm = blurMult[radius + i];\n      bmi = blurMult[radiusi--];\n      for (let j = 0; j < 256; j++) {\n        bm[j] = bmi[j] = bki * j;\n      }\n    }\n    bk = blurKernel[radius] = radius * radius;\n    bm = blurMult[radius];\n\n    for (let k = 0; k < 256; k++) {\n      bm[k] = bk * k;\n    }\n  }\n}\n\n// Port of https://github.com/processing/processing/blob/\n// main/core/src/processing/core/PImage.java#L1433\nfunction blurARGB(canvas, radius) {\n  // Get pixel data.\n  const pixels = Filters._toPixels(canvas);\n  const width = canvas.width;\n  const height = canvas.height;\n  const numPackedPixels = width * height;\n  const argb = new Int32Array(numPackedPixels);\n  for (let j = 0; j < numPackedPixels; j++) {\n    argb[j] = Filters._getARGB(pixels, j);\n  }\n  let sum, cr, cg, cb, ca;\n  let read, ri, ym, ymi, bk0;\n  const a2 = new Int32Array(numPackedPixels);\n  const r2 = new Int32Array(numPackedPixels);\n  const g2 = new Int32Array(numPackedPixels);\n  const b2 = new Int32Array(numPackedPixels);\n  let yi = 0;\n  buildBlurKernel(radius);\n  let x, y, i;\n  let bm;\n  // Horizontal pass.\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      cb = cg = cr = ca = sum = 0;\n      read = x - blurRadius;\n      // Handle edge cases.\n      if (read < 0) {\n        bk0 = -read;\n        read = 0;\n      } else {\n        if (read >= width) {\n          break;\n        }\n        bk0 = 0;\n      }\n      for (i = bk0; i < blurKernelSize; i++) {\n        if (read >= width) {\n          break;\n        }\n        const c = argb[read + yi];\n        bm = blurMult[i];\n        ca += bm[(c & -16777216) >>> 24];\n        cr += bm[(c & 16711680) >> 16];\n        cg += bm[(c & 65280) >> 8];\n        cb += bm[c & 255];\n        sum += blurKernel[i];\n        read++;\n      }\n      ri = yi + x;\n      a2[ri] = ca / sum;\n      r2[ri] = cr / sum;\n      g2[ri] = cg / sum;\n      b2[ri] = cb / sum;\n    }\n    yi += width;\n  }\n  yi = 0;\n  ym = -blurRadius;\n  ymi = ym * width;\n  //  Vertical pass.\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      cb = cg = cr = ca = sum = 0;\n      // Handle edge cases.\n      if (ym < 0) {\n        bk0 = ri = -ym;\n        read = x;\n      } else {\n        if (ym >= height) {\n          break;\n        }\n        bk0 = 0;\n        ri = ym;\n        read = x + ymi;\n      }\n      for (i = bk0; i < blurKernelSize; i++) {\n        if (ri >= height) {\n          break;\n        }\n        bm = blurMult[i];\n        ca += bm[a2[read]];\n        cr += bm[r2[read]];\n        cg += bm[g2[read]];\n        cb += bm[b2[read]];\n        sum += blurKernel[i];\n        ri++;\n        read += width;\n      }\n      // Set final ARGB value\n      argb[x + yi] =\n        ((ca / sum) << 24) |\n        ((cr / sum) << 16) |\n        ((cg / sum) << 8) |\n        (cb / sum);\n    }\n    yi += width;\n    ymi += width;\n    ym++;\n  }\n  Filters._setPixels(pixels, argb);\n}\n\nexport { Filters as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}