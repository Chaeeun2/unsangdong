{"ast":null,"code":"/**\n * Functions related to color interpolation\n */\nimport ColorSpace from \"./space.js\";\nimport { type, interpolate } from \"./util.js\";\nimport getColor from \"./getColor.js\";\nimport clone from \"./clone.js\";\nimport to from \"./to.js\";\nimport toGamut from \"./toGamut.js\";\nimport get from \"./get.js\";\nimport set from \"./set.js\";\nimport defaults from \"./defaults.js\";\nimport * as angles from \"./angles.js\";\nimport deltaE from \"./deltaE.js\";\n\n/**\n * Return an intermediate color between two colors\n * Signatures: mix(c1, c2, p, options)\n *             mix(c1, c2, options)\n *             mix(color)\n * @param {Color | string} c1 The first color\n * @param {Color | string} [c2] The second color\n * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2\n * @param {Object} [o={}]\n * @return {Color}\n */\nexport function mix(c1, c2, p = .5, o = {}) {\n  [c1, c2] = [getColor(c1), getColor(c2)];\n  if (type(p) === \"object\") {\n    [p, o] = [.5, p];\n  }\n  let r = range(c1, c2, o);\n  return r(p);\n}\n\n/**\n *\n * @param {Color | string | Function} c1 The first color or a range\n * @param {Color | string} [c2] The second color if c1 is not a range\n * @param {Object} [options={}]\n * @return {Color[]}\n */\nexport function steps(c1, c2, options = {}) {\n  let colorRange;\n  if (isRange(c1)) {\n    // Tweaking existing range\n    [colorRange, options] = [c1, c2];\n    [c1, c2] = colorRange.rangeArgs.colors;\n  }\n  let {\n    maxDeltaE,\n    deltaEMethod,\n    steps = 2,\n    maxSteps = 1000,\n    ...rangeOptions\n  } = options;\n  if (!colorRange) {\n    [c1, c2] = [getColor(c1), getColor(c2)];\n    colorRange = range(c1, c2, rangeOptions);\n  }\n  let totalDelta = deltaE(c1, c2);\n  let actualSteps = maxDeltaE > 0 ? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;\n  let ret = [];\n  if (maxSteps !== undefined) {\n    actualSteps = Math.min(actualSteps, maxSteps);\n  }\n  if (actualSteps === 1) {\n    ret = [{\n      p: .5,\n      color: colorRange(.5)\n    }];\n  } else {\n    let step = 1 / (actualSteps - 1);\n    ret = Array.from({\n      length: actualSteps\n    }, (_, i) => {\n      let p = i * step;\n      return {\n        p,\n        color: colorRange(p)\n      };\n    });\n  }\n  if (maxDeltaE > 0) {\n    // Iterate over all stops and find max deltaE\n    let maxDelta = ret.reduce((acc, cur, i) => {\n      if (i === 0) {\n        return 0;\n      }\n      let ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);\n      return Math.max(acc, ΔΕ);\n    }, 0);\n    while (maxDelta > maxDeltaE) {\n      // Insert intermediate stops and measure maxDelta again\n      // We need to do this for all pairs, otherwise the midpoint shifts\n      maxDelta = 0;\n      for (let i = 1; i < ret.length && ret.length < maxSteps; i++) {\n        let prev = ret[i - 1];\n        let cur = ret[i];\n        let p = (cur.p + prev.p) / 2;\n        let color = colorRange(p);\n        maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));\n        ret.splice(i, 0, {\n          p,\n          color: colorRange(p)\n        });\n        i++;\n      }\n    }\n  }\n  ret = ret.map(a => a.color);\n  return ret;\n}\n\n/**\n * Interpolate to color2 and return a function that takes a 0-1 percentage\n * @param {Color | string | Function} color1 The first color or an existing range\n * @param {Color | string} [color2] If color1 is a color, this is the second color\n * @param {Object} [options={}]\n * @returns {Function} A function that takes a 0-1 percentage and returns a color\n */\nexport function range(color1, color2, options = {}) {\n  if (isRange(color1)) {\n    // Tweaking existing range\n    let [r, options] = [color1, color2];\n    return range(...r.rangeArgs.colors, {\n      ...r.rangeArgs.options,\n      ...options\n    });\n  }\n  let {\n    space,\n    outputSpace,\n    progression,\n    premultiplied\n  } = options;\n  color1 = getColor(color1);\n  color2 = getColor(color2);\n\n  // Make sure we're working on copies of these colors\n  color1 = clone(color1);\n  color2 = clone(color2);\n  let rangeArgs = {\n    colors: [color1, color2],\n    options\n  };\n  if (space) {\n    space = ColorSpace.get(space);\n  } else {\n    space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;\n  }\n  outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;\n  color1 = to(color1, space);\n  color2 = to(color2, space);\n\n  // Gamut map to avoid areas of flat color\n  color1 = toGamut(color1);\n  color2 = toGamut(color2);\n\n  // Handle hue interpolation\n  // See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840\n  if (space.coords.h && space.coords.h.type === \"angle\") {\n    let arc = options.hue = options.hue || \"shorter\";\n    let hue = [space, \"h\"];\n    let [θ1, θ2] = [get(color1, hue), get(color2, hue)];\n    // Undefined hues must be evaluated before hue fix-up to properly\n    // calculate hue arcs between undefined and defined hues.\n    // See https://github.com/w3c/csswg-drafts/issues/9436#issuecomment-1746957545\n    if (isNaN(θ1) && !isNaN(θ2)) {\n      θ1 = θ2;\n    } else if (isNaN(θ2) && !isNaN(θ1)) {\n      θ2 = θ1;\n    }\n    [θ1, θ2] = angles.adjust(arc, [θ1, θ2]);\n    set(color1, hue, θ1);\n    set(color2, hue, θ2);\n  }\n  if (premultiplied) {\n    // not coping with polar spaces yet\n    color1.coords = color1.coords.map(c => c * color1.alpha);\n    color2.coords = color2.coords.map(c => c * color2.alpha);\n  }\n  return Object.assign(p => {\n    p = progression ? progression(p) : p;\n    let coords = color1.coords.map((start, i) => {\n      let end = color2.coords[i];\n      return interpolate(start, end, p);\n    });\n    let alpha = interpolate(color1.alpha, color2.alpha, p);\n    let ret = {\n      space,\n      coords,\n      alpha\n    };\n    if (premultiplied) {\n      // undo premultiplication\n      ret.coords = ret.coords.map(c => c / alpha);\n    }\n    if (outputSpace !== space) {\n      ret = to(ret, outputSpace);\n    }\n    return ret;\n  }, {\n    rangeArgs\n  });\n}\nexport function isRange(val) {\n  return type(val) === \"function\" && !!val.rangeArgs;\n}\ndefaults.interpolationSpace = \"lab\";\nexport function register(Color) {\n  Color.defineFunction(\"mix\", mix, {\n    returns: \"color\"\n  });\n  Color.defineFunction(\"range\", range, {\n    returns: \"function<color>\"\n  });\n  Color.defineFunction(\"steps\", steps, {\n    returns: \"array<color>\"\n  });\n}","map":{"version":3,"names":["ColorSpace","type","interpolate","getColor","clone","to","toGamut","get","set","defaults","angles","deltaE","mix","c1","c2","p","o","r","range","steps","options","colorRange","isRange","rangeArgs","colors","maxDeltaE","deltaEMethod","maxSteps","rangeOptions","totalDelta","actualSteps","Math","max","ceil","ret","undefined","min","color","step","Array","from","length","_","i","maxDelta","reduce","acc","cur","ΔΕ","prev","splice","map","a","color1","color2","space","outputSpace","progression","premultiplied","registry","interpolationSpace","coords","h","arc","hue","θ1","θ2","isNaN","adjust","c","alpha","Object","assign","start","end","val","register","Color","defineFunction","returns"],"sources":["/Users/lyuchaeeun/Desktop/unsaengdong/node_modules/colorjs.io/src/interpolation.js"],"sourcesContent":["/**\n * Functions related to color interpolation\n */\nimport ColorSpace from \"./space.js\";\nimport {type, interpolate} from \"./util.js\";\nimport getColor from \"./getColor.js\";\nimport clone from \"./clone.js\";\nimport to from \"./to.js\";\nimport toGamut from \"./toGamut.js\";\nimport get from \"./get.js\";\nimport set from \"./set.js\";\nimport defaults from \"./defaults.js\";\nimport * as angles from \"./angles.js\";\nimport deltaE from \"./deltaE.js\";\n\n/**\n * Return an intermediate color between two colors\n * Signatures: mix(c1, c2, p, options)\n *             mix(c1, c2, options)\n *             mix(color)\n * @param {Color | string} c1 The first color\n * @param {Color | string} [c2] The second color\n * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2\n * @param {Object} [o={}]\n * @return {Color}\n */\nexport function mix (c1, c2, p = .5, o = {}) {\n\t[c1, c2] = [getColor(c1), getColor(c2)];\n\n\tif (type(p) === \"object\") {\n\t\t[p, o] = [.5, p];\n\t}\n\n\tlet r = range(c1, c2, o);\n\treturn r(p);\n}\n\n/**\n *\n * @param {Color | string | Function} c1 The first color or a range\n * @param {Color | string} [c2] The second color if c1 is not a range\n * @param {Object} [options={}]\n * @return {Color[]}\n */\nexport function steps (c1, c2, options = {}) {\n\tlet colorRange;\n\n\tif (isRange(c1)) {\n\t\t// Tweaking existing range\n\t\t[colorRange, options] = [c1, c2];\n\t\t[c1, c2] = colorRange.rangeArgs.colors;\n\t}\n\n\tlet {\n\t\tmaxDeltaE, deltaEMethod,\n\t\tsteps = 2, maxSteps = 1000,\n\t\t...rangeOptions\n\t} = options;\n\n\tif (!colorRange) {\n\t\t[c1, c2] = [getColor(c1), getColor(c2)];\n\t\tcolorRange = range(c1, c2, rangeOptions);\n\t}\n\n\tlet totalDelta = deltaE(c1, c2);\n\tlet actualSteps = maxDeltaE > 0 ? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;\n\tlet ret = [];\n\n\tif (maxSteps !== undefined) {\n\t\tactualSteps = Math.min(actualSteps, maxSteps);\n\t}\n\n\tif (actualSteps === 1) {\n\t\tret = [{p: .5, color: colorRange(.5)}];\n\t}\n\telse {\n\t\tlet step = 1 / (actualSteps - 1);\n\t\tret = Array.from({length: actualSteps}, (_, i) => {\n\t\t\tlet p = i * step;\n\t\t\treturn {p, color: colorRange(p)};\n\t\t});\n\t}\n\n\tif (maxDeltaE > 0) {\n\t\t// Iterate over all stops and find max deltaE\n\t\tlet maxDelta = ret.reduce((acc, cur, i) => {\n\t\t\tif (i === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlet ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);\n\t\t\treturn Math.max(acc, ΔΕ);\n\t\t}, 0);\n\n\t\twhile (maxDelta > maxDeltaE) {\n\t\t\t// Insert intermediate stops and measure maxDelta again\n\t\t\t// We need to do this for all pairs, otherwise the midpoint shifts\n\t\t\tmaxDelta = 0;\n\n\t\t\tfor (let i = 1; (i < ret.length) && (ret.length < maxSteps); i++) {\n\t\t\t\tlet prev = ret[i - 1];\n\t\t\t\tlet cur = ret[i];\n\n\t\t\t\tlet p = (cur.p + prev.p) / 2;\n\t\t\t\tlet color = colorRange(p);\n\t\t\t\tmaxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));\n\t\t\t\tret.splice(i, 0, {p, color: colorRange(p)});\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ret.map(a => a.color);\n\n\treturn ret;\n}\n\n/**\n * Interpolate to color2 and return a function that takes a 0-1 percentage\n * @param {Color | string | Function} color1 The first color or an existing range\n * @param {Color | string} [color2] If color1 is a color, this is the second color\n * @param {Object} [options={}]\n * @returns {Function} A function that takes a 0-1 percentage and returns a color\n */\nexport function range (color1, color2, options = {}) {\n\tif (isRange(color1)) {\n\t\t// Tweaking existing range\n\t\tlet [r, options] = [color1, color2];\n\n\t\treturn range(...r.rangeArgs.colors, {...r.rangeArgs.options, ...options});\n\t}\n\n\tlet {space, outputSpace, progression, premultiplied} = options;\n\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\t// Make sure we're working on copies of these colors\n\tcolor1 = clone(color1);\n\tcolor2 = clone(color2);\n\n\tlet rangeArgs = {colors: [color1, color2], options};\n\n\tif (space) {\n\t\tspace = ColorSpace.get(space);\n\t}\n\telse {\n\t\tspace = ColorSpace.registry[defaults.interpolationSpace] || color1.space;\n\t}\n\n\toutputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;\n\n\tcolor1 = to(color1, space);\n\tcolor2 = to(color2, space);\n\n\t// Gamut map to avoid areas of flat color\n\tcolor1 = toGamut(color1);\n\tcolor2 = toGamut(color2);\n\n\t// Handle hue interpolation\n\t// See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840\n\tif (space.coords.h && space.coords.h.type === \"angle\") {\n\t\tlet arc = options.hue = options.hue || \"shorter\";\n\n\t\tlet hue = [space, \"h\"];\n\t\tlet [θ1, θ2] = [get(color1, hue), get(color2, hue)];\n\t\t// Undefined hues must be evaluated before hue fix-up to properly\n\t\t// calculate hue arcs between undefined and defined hues.\n\t\t// See https://github.com/w3c/csswg-drafts/issues/9436#issuecomment-1746957545\n\t\tif (isNaN(θ1) && !isNaN(θ2)) {\n\t\t\tθ1 = θ2;\n\t\t}\n\t\telse if (isNaN(θ2) && !isNaN(θ1)) {\n\t\t\tθ2 = θ1;\n\t\t}\n\t\t[θ1, θ2] = angles.adjust(arc, [θ1, θ2]);\n\t\tset(color1, hue, θ1);\n\t\tset(color2, hue, θ2);\n\t}\n\n\tif (premultiplied) {\n\t\t// not coping with polar spaces yet\n\t\tcolor1.coords = color1.coords.map(c => c * color1.alpha);\n\t\tcolor2.coords = color2.coords.map(c => c * color2.alpha);\n\t}\n\n\treturn Object.assign(p => {\n\t\tp = progression ? progression(p) : p;\n\t\tlet coords = color1.coords.map((start, i) => {\n\t\t\tlet end = color2.coords[i];\n\t\t\treturn interpolate(start, end, p);\n\t\t});\n\n\t\tlet alpha = interpolate(color1.alpha, color2.alpha, p);\n\t\tlet ret = {space, coords, alpha};\n\n\t\tif (premultiplied) {\n\t\t\t// undo premultiplication\n\t\t\tret.coords = ret.coords.map(c => c / alpha);\n\t\t}\n\n\t\tif (outputSpace !== space) {\n\t\t\tret = to(ret, outputSpace);\n\t\t}\n\n\t\treturn ret;\n\t}, {\n\t\trangeArgs,\n\t});\n}\n\nexport function isRange (val) {\n\treturn type(val) === \"function\" && !!val.rangeArgs;\n}\n\ndefaults.interpolationSpace = \"lab\";\n\nexport function register (Color) {\n\tColor.defineFunction(\"mix\", mix, {returns: \"color\"});\n\tColor.defineFunction(\"range\", range, {returns: \"function<color>\"});\n\tColor.defineFunction(\"steps\", steps, {returns: \"array<color>\"});\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}